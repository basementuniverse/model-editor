/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/camera-3d/build/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@basementuniverse/camera-3d/build/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://Camera3d/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nclass Camera3d {\n    constructor(position, target, options = {}) {\n        const actualOptions = Object.assign({}, Camera3d.DEFAULT_OPTIONS, options);\n        this.mode = actualOptions.mode;\n        this.up = vec_1.vec3.nor(actualOptions.up);\n        this.fov = actualOptions.fov;\n        this.aspect = actualOptions.aspect;\n        this.near = actualOptions.near;\n        this.far = actualOptions.far;\n        this.positionEaseAmount = actualOptions.positionEaseAmount;\n        this.targetEaseAmount = actualOptions.targetEaseAmount;\n        this._actualPosition = position;\n        this._targetPosition = position;\n        this._actualTarget = target;\n        this._targetTarget = target;\n    }\n    get position() {\n        return this._targetPosition;\n    }\n    set position(value) {\n        this._targetPosition = value;\n    }\n    set positionImmediate(value) {\n        this._actualPosition = value;\n        this._targetPosition = value;\n    }\n    get actualPosition() {\n        return this._actualPosition;\n    }\n    get target() {\n        return this._targetTarget;\n    }\n    set target(value) {\n        this._targetTarget = value;\n    }\n    set targetImmediate(value) {\n        this._actualTarget = value;\n        this._targetTarget = value;\n    }\n    get actualTarget() {\n        return this._actualTarget;\n    }\n    /**\n     * Update the camera\n     */\n    update() {\n        this._actualPosition = vec_1.vec3.add(this._targetPosition, vec_1.vec3.mul(vec_1.vec3.sub(this._actualPosition, this._targetPosition), this.positionEaseAmount));\n        this._actualTarget = vec_1.vec3.add(this._targetTarget, vec_1.vec3.mul(vec_1.vec3.sub(this._actualTarget, this._targetTarget), this.targetEaseAmount));\n    }\n    /**\n     * Get the view matrix for the camera\n     *\n     * The view matrix transforms world coordinates into camera coordinates\n     */\n    getViewMatrix() {\n        const forward = vec_1.vec3.nor(vec_1.vec3.sub(this._actualTarget, this._actualPosition));\n        const right = vec_1.vec3.nor(vec_1.vec3.cross(forward, this.up));\n        const up = vec_1.vec3.cross(right, forward);\n        const rotation = (0, vec_1.mat)(4, 4, [\n            right.x, right.y, right.z, 0,\n            up.x, up.y, up.z, 0,\n            -forward.x, -forward.y, -forward.z, 0,\n            0, 0, 0, 1,\n        ]);\n        const translation = (0, vec_1.mat)(4, 4, [\n            1, 0, 0, -this._actualPosition.x,\n            0, 1, 0, -this._actualPosition.y,\n            0, 0, 1, -this._actualPosition.z,\n            0, 0, 0, 1,\n        ]);\n        const viewMatrix = vec_1.mat.mul(rotation, translation);\n        if (!viewMatrix) {\n            throw new Error('Failed to create view matrix');\n        }\n        return viewMatrix;\n    }\n    /**\n     * Get a perspective projection matrix for the camera\n     */\n    getPerspectiveProjectionMatrix() {\n        const f = 1.0 / Math.tan(this.fov / 2);\n        const nf = 1 / (this.near - this.far);\n        return (0, vec_1.mat)(4, 4, [\n            f / this.aspect, 0, 0, 0,\n            0, f, 0, 0,\n            0, 0, (this.far + this.near) * nf, -1,\n            0, 0, 2 * this.far * this.near * nf, 0,\n        ]);\n    }\n    /**\n     * Get an orthographic projection matrix for the camera\n     */\n    getOrthographicProjectionMatrix() {\n        const l = -this.aspect * this.fov;\n        const r = this.aspect * this.fov;\n        const b = -this.aspect * this.fov;\n        const t = this.aspect * this.fov;\n        const n = this.near;\n        const f = this.far;\n        return (0, vec_1.mat)(4, 4, [\n            2 / (r - l), 0, 0, -(r + l) / (r - l),\n            0, 2 / (t - b), 0, -(t + b) / (t - b),\n            0, 0, -2 / (f - n), -(f + n) / (f - n),\n            0, 0, 0, 1,\n        ]);\n    }\n    /**\n     * Project a 3D point into 2D screen coordinates\n     * @param v The 3D point to project\n     * @param screenSize The size of the screen in pixels\n     * @returns The projected 2D coordinates, or null if projection fails\n     */\n    project(v, screenSize) {\n        const viewMatrix = this.getViewMatrix();\n        let projectionMatrix;\n        switch (this.mode) {\n            case 'perspective':\n                projectionMatrix = this.getPerspectiveProjectionMatrix();\n                break;\n            case 'orthographic':\n                projectionMatrix = this.getOrthographicProjectionMatrix();\n                break;\n        }\n        // Transform the 3D point into view space\n        const viewPos = vec_1.mat.mulv(viewMatrix, [...vec_1.vec3.components(v), 1]);\n        if (!viewPos) {\n            return null;\n        }\n        viewPos[3] = 1; // Homogeneous coordinates\n        // Transform the point from view space to clip space\n        const clipPos = vec_1.mat.mulv(projectionMatrix, viewPos);\n        if (clipPos === false) {\n            return null;\n        }\n        const clipPosVec = vec_1.vec3.fromComponents(clipPos);\n        // Perform perspective division to get normalized device coordinates (NDC)\n        const ndc = (0, vec_1.vec2)(clipPosVec.x / clipPosVec.z, clipPosVec.y / clipPosVec.z);\n        return (0, vec_1.vec2)((ndc.x * 0.5 + 0.5) * screenSize.x, (1 - (ndc.y * 0.5 + 0.5)) * screenSize.y);\n    }\n    /**\n     * Convert a screen position to a world position\n     * @param screenPosition The 2D screen coordinates to convert\n     * @param screenSize The size of the screen in pixels\n     * @param depth The depth (distance from the camera) to use for conversion\n     * @returns The corresponding 3D world coordinates, or null if conversion fails\n     */\n    screenToWorld(screenPosition, screenSize, depth) {\n        // If depth is not provided, use the near plane\n        if (depth === undefined) {\n            depth = this.near;\n        }\n        // Convert screen position to normalized device coordinates (NDC)\n        const ndc = (0, vec_1.vec2)(1 - (screenPosition.x / screenSize.x) * 2, 1 - (screenPosition.y / screenSize.y) * 2);\n        // Transform NDC from view space to clip space\n        const viewMatrix = this.getViewMatrix();\n        let projectionMatrix;\n        switch (this.mode) {\n            case 'perspective':\n                projectionMatrix = this.getPerspectiveProjectionMatrix();\n                break;\n            case 'orthographic':\n                projectionMatrix = this.getOrthographicProjectionMatrix();\n                break;\n        }\n        const invProjectionMatrix = vec_1.mat.inv(projectionMatrix);\n        if (!invProjectionMatrix) {\n            return null;\n        }\n        const invViewMatrix = vec_1.mat.inv(viewMatrix);\n        if (!invViewMatrix) {\n            return null;\n        }\n        let clipPos = (0, vec_1.vec3)();\n        switch (this.mode) {\n            case 'perspective':\n                // For perspective projection, we need to calculate the clip space\n                // position and scale by tan(fov/2) to account for the field of view\n                const tanHalfFov = Math.tan(this.fov / 2);\n                clipPos = (0, vec_1.vec3)(ndc.x * depth * tanHalfFov * this.aspect, ndc.y * depth * tanHalfFov, depth);\n                break;\n            case 'orthographic':\n                // For orthographic projection, we can directly use the depth value\n                clipPos = (0, vec_1.vec3)(ndc.x * (this.far - this.near) / 2, ndc.y * (this.far - this.near) / 2, (this.far + this.near) / 2 + depth);\n                break;\n        }\n        // Transform clip space coordinates to world space\n        const worldPos = vec_1.mat.mulv(invViewMatrix, [...vec_1.vec3.components(clipPos), 1]);\n        if (!worldPos) {\n            return null;\n        }\n        return (0, vec_1.vec3)(worldPos[0] / worldPos[3], worldPos[1] / worldPos[3], worldPos[2] / worldPos[3]);\n    }\n    /**\n     * Cast a ray from the camera through a screen position\n     * @param screenPosition The 2D screen coordinates to cast the ray from\n     * @param screenSize The size of the screen in pixels\n     * @returns A ray with origin and direction, or null if raycasting fails\n     */\n    raycast(screenPosition, screenSize) {\n        const nearPlanePoint = this.screenToWorld(screenPosition, screenSize, this.near);\n        const farPlanePoint = this.screenToWorld(screenPosition, screenSize, this.far);\n        if (!nearPlanePoint || !farPlanePoint) {\n            return null;\n        }\n        const direction = vec_1.vec3.nor(vec_1.vec3.sub(farPlanePoint, nearPlanePoint));\n        return {\n            origin: this._actualPosition,\n            direction: direction,\n        };\n    }\n}\nexports[\"default\"] = Camera3d;\nCamera3d.DEFAULT_OPTIONS = {\n    mode: 'perspective',\n    up: (0, vec_1.vec3)(0, 1, 0),\n    fov: Math.PI / 2,\n    aspect: 1,\n    near: 0.1,\n    far: 1000,\n    positionEaseAmount: 0.1,\n    targetEaseAmount: 0.1,\n};\n\n\n//# sourceURL=webpack://Camera3d/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_37205__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_37205__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_37205__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/camera/build/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@basementuniverse/camera/build/index.js ***!
  \**************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback interpolationCallback\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {interpolationCallback} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst permutation = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst combination = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * A function for generating array values\n * @callback timesCallback\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {timesCallback} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    permutation,\n    combination,\n    times,\n    range,\n    zip,\n    at,\n    chunk,\n    shuffle,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : (a > max ? max : a);\n}\nclass Camera {\n    constructor(position, options) {\n        this.size = (0, vec_1.vec)();\n        this._actualPosition = (0, vec_1.vec)();\n        this.targetPosition = (0, vec_1.vec)();\n        this._actualScale = 1;\n        this.targetScale = 1;\n        this._actualPosition = position;\n        this.targetPosition = position;\n        this.options = Object.assign({}, Camera.defaultOptions, options !== null && options !== void 0 ? options : {});\n    }\n    get position() {\n        return this.targetPosition;\n    }\n    set position(value) {\n        this.targetPosition = value;\n    }\n    set positionImmediate(value) {\n        this._actualPosition = value;\n        this.targetPosition = value;\n    }\n    get actualPosition() {\n        return this._actualPosition;\n    }\n    get scale() {\n        return this.targetScale;\n    }\n    get actualScale() {\n        return this._actualScale;\n    }\n    set scale(value) {\n        this.targetScale = clamp(value, this.options.minScale, this.options.maxScale);\n    }\n    set scaleImmediate(value) {\n        this._actualScale = clamp(value, this.options.minScale, this.options.maxScale);\n        this.targetScale = this._actualScale;\n    }\n    /**\n     * Get screen bounds based on the current camera position and scale\n     */\n    get bounds() {\n        return {\n            top: this._actualPosition.y - (this.size.y / 2) / this._actualScale,\n            bottom: this._actualPosition.y + (this.size.y / 2) / this._actualScale,\n            left: this._actualPosition.x - (this.size.x / 2) / this._actualScale,\n            right: this._actualPosition.x + (this.size.x / 2) / this._actualScale\n        };\n    }\n    /**\n     * Convert a screen position to a world position\n     */\n    screenToWorld(position) {\n        const bounds = this.bounds;\n        return vec_1.vec.add({ x: bounds.left, y: bounds.top }, vec_1.vec.mul(position, 1 / this.actualScale));\n    }\n    /**\n     * Convert a world position to a screen position\n     */\n    worldToScreen(position) {\n        const bounds = this.bounds;\n        return vec_1.vec.mul(vec_1.vec.sub(position, { x: bounds.left, y: bounds.top }), this.actualScale);\n    }\n    /**\n     * Update the camera\n     */\n    update(screen) {\n        this.size = (0, vec_1.vec)(screen);\n        // Maybe clamp position to bounds\n        if (this.options.bounds) {\n            const screenScaled = vec_1.vec.map(vec_1.vec.mul(this.size, 1 / this._actualScale), Math.ceil);\n            // If the scaled screen size is larger than allowed bounds, we resize\n            // the bounds to prevent jittering\n            const actualBounds = {\n                ...this.options.bounds,\n            };\n            if (screenScaled.x > actualBounds.right - actualBounds.left) {\n                const boundsWidth = actualBounds.right - actualBounds.left;\n                const halfDiff = (screenScaled.x - boundsWidth) / 2;\n                actualBounds.left -= halfDiff;\n                actualBounds.right += halfDiff;\n            }\n            if (screenScaled.y > actualBounds.bottom - actualBounds.top) {\n                const boundsHeight = actualBounds.bottom - actualBounds.top;\n                const halfDiff = (screenScaled.y - boundsHeight) / 2;\n                actualBounds.top -= halfDiff;\n                actualBounds.bottom += halfDiff;\n            }\n            const halfScreenScaled = vec_1.vec.map(vec_1.vec.mul(screenScaled, 1 / 2), Math.ceil);\n            const minPosition = (0, vec_1.vec)(actualBounds.left + halfScreenScaled.x, actualBounds.top + halfScreenScaled.y);\n            const maxPosition = (0, vec_1.vec)(actualBounds.right - halfScreenScaled.x, actualBounds.bottom - halfScreenScaled.y);\n            this.targetPosition.x = clamp(this.targetPosition.x, minPosition.x, maxPosition.x);\n            this.targetPosition.y = clamp(this.targetPosition.y, minPosition.y, maxPosition.y);\n        }\n        const d = vec_1.vec.sub(this._actualPosition, this.targetPosition);\n        this._actualPosition = vec_1.vec.add(this.position, vec_1.vec.mul(d, this.options.moveEaseAmount));\n        const s = clamp(this.targetScale, this.options.minScale, this.options.maxScale);\n        this._actualScale = s + (this._actualScale - s) * this.options.scaleEaseAmount;\n    }\n    /**\n     * Set the camera transforms on a canvas context\n     */\n    setTransforms(context) {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.translate((this.size.x / 2) - this._actualPosition.x * this._actualScale, (this.size.y / 2) - this._actualPosition.y * this._actualScale);\n        context.scale(this._actualScale, this._actualScale);\n    }\n    /**\n     * Update the camera and then set transforms on a canvas context\n     */\n    draw(context, screen) {\n        this.update(screen);\n        this.setTransforms(context);\n    }\n}\nexports[\"default\"] = Camera;\nCamera.defaultOptions = {\n    allowScale: true,\n    minScale: 0.5,\n    maxScale: 4,\n    moveEaseAmount: 0.1,\n    scaleEaseAmount: 0.1,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_26909__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_26909__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_26909__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/canvas-helpers/build/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@basementuniverse/canvas-helpers/build/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Memoize a function\n * @param {Function} f The function to memoize\n * @returns {Function} A memoized version of the function\n */\nconst memoize = f => {\n  var cache = {};\n  return function(...args) {\n    return cache[args] ?? (cache[args] = f.apply(this, args));\n  };\n};\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Round n to d decimal places\n * @param {number} n The number to round\n * @param {number} [d=0] The number of decimal places to round to\n * @return {number} A rounded number\n */\nconst round = (n, d = 0) => {\n  const p = Math.pow(10, d);\n  return Math.round(n * p + Number.EPSILON) / p;\n}\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback InterpolationFunction\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst npr = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * Generate all permutations of r elements from an array\n *\n * @example\n * ```js\n * permutations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 1],\n *   [2, 3],\n *   [3, 1],\n *   [3, 2]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each permutation\n * @return {Array<Array<*>>} An array of permutation arrays\n */\nconst permutations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n}\n\n/**\n * Generate all combinations of r elements from an array\n *\n * @example\n * ```js\n * combinations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 3]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each combination\n * @return {Array<Array<*>>} An array of combination arrays\n */\nconst combinations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n};\n\n/**\n * Get a cartesian product of arrays\n *\n * @example\n * ```js\n * cartesian([1, 2, 3], ['a', 'b']);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, \"a\"],\n *   [1, \"b\"],\n *   [2, \"a\"],\n *   [2, \"b\"],\n *   [3, \"a\"],\n *   [3, \"b\"]\n * ]\n * ```\n */\nconst cartesian = (...arr) =>\n  arr.reduce(\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\n    [[]]\n  );\n\n/**\n * A function for generating array values\n * @callback TimesFunction\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {TimesFunction} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {...Array<*>} a The arrays to zip\n * @return {Array<Array<*>>}\n */\nconst zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a The array to access\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Return the last element of an array without removing it\n * @param {Array<*>} a\n * @return {*} The last element from the array\n */\nconst peek = (a) => {\n  if (!a.length) {\n    return undefined;\n  }\n\n  return a[a.length - 1];\n};\n\n/**\n * Return the index for a given position in an unrolled 2d array\n * @param {number} x The x position\n * @param {number} y The y position\n * @param {number} w The width of the 2d array\n * @returns {number} The index in the unrolled array\n */\nconst ind = (x, y, w) => x + y * w;\n\n/**\n * Return the position for a given index in an unrolled 2d array\n * @param {number} i The index\n * @param {number} w The width of the 2d array\n * @returns {Array<number>} The position as a 2-tuple\n */\nconst pos = (i, w) => [i % w, Math.floor(i / w)];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\n/**\n * Flatten an object\n * @param {object} o\n * @param {string} concatenator The string to use for concatenating keys\n * @return {object} A flattened object\n */\nconst flat = (o, concatenator = '.') => {\n  return Object.keys(o).reduce((acc, key) => {\n    if (o[key] instanceof Date) {\n      return {\n        ...acc,\n        [key]: o[key].toISOString(),\n      };\n    }\n\n    if (typeof o[key] !== 'object' || !o[key]) {\n      return {\n        ...acc,\n        [key]: o[key],\n      };\n    }\n    const flattened = flat(o[key], concatenator);\n\n    return {\n      ...acc,\n      ...Object.keys(flattened).reduce(\n        (childAcc, childKey) => ({\n          ...childAcc,\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\n        }),\n        {}\n      ),\n    };\n  }, {});\n};\n\n/**\n * Unflatten an object\n * @param {object} o\n * @param {string} concatenator The string to check for in concatenated keys\n * @return {object} An un-flattened object\n */\nconst unflat = (o, concatenator = '.') => {\n  let result = {}, temp, substrings, property, i;\n\n  for (property in o) {\n    substrings = property.split(concatenator);\n    temp = result;\n    for (i = 0; i < substrings.length - 1; i++) {\n      if (!(substrings[i] in temp)) {\n        if (isFinite(substrings[i + 1])) {\n          temp[substrings[i]] = [];\n        } else {\n          temp[substrings[i]] = {};\n        }\n      }\n      temp = temp[substrings[i]];\n    }\n    temp[substrings[substrings.length - 1]] = o[property];\n  }\n\n  return result;\n};\n\n/**\n * A split predicate\n * @callback SplitPredicate\n * @param {any} value The current value\n * @return {boolean} True if the array should split at this index\n */\n\n/**\n * Split an array into sub-arrays based on a predicate\n * @param {Array<*>} array\n * @param {SplitPredicate} predicate\n * @return {Array<Array<*>>} An array of arrays\n */\nconst split = (array, predicate) => {\n  const result = [];\n  let current = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      if (current.length) {\n        result.push(current);\n      }\n      current = [value];\n    } else {\n      current.push(value);\n    }\n  }\n  result.push(current);\n\n  return result;\n};\n\n/**\n * Pluck keys from an object\n * @param {object} o\n * @param {...string} keys The keys to pluck from the object\n * @return {object} An object containing the plucked keys\n */\nconst pluck = (o, ...keys) => {\n  return keys.reduce(\n    (result, key) => Object.assign(result, { [key]: o[key] }),\n    {}\n  );\n};\n\n/**\n * Exclude keys from an object\n * @param {object} o\n * @param {...string} keys The keys to exclude from the object\n * @return {object} An object containing all keys except excluded keys\n */\nconst exclude = (o, ...keys) => {\n  return Object.fromEntries(\n    Object.entries(o).filter(([key]) => !keys.includes(key))\n  );\n};\n\nif (true) {\n  module.exports = {\n    memoize,\n    floatEquals,\n    clamp,\n    frac,\n    round,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    npr,\n    ncr,\n    permutations,\n    combinations,\n    cartesian,\n    times,\n    range,\n    zip,\n    at,\n    peek,\n    ind,\n    pos,\n    chunk,\n    shuffle,\n    flat,\n    unflat,\n    split,\n    pluck,\n    exclude,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.withContext = withContext;\nexports.line = line;\nexports.cross = cross;\nexports.arrow = arrow;\nexports.circle = circle;\nexports.rectangle = rectangle;\nexports.polygon = polygon;\nexports.path = path;\nconst utils_1 = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nconst DEFAULT_STYLE_OPTIONS = {\n    batch: false,\n    fill: false,\n    fillColor: null,\n    gradient: null,\n    stroke: true,\n    strokeColor: null,\n    lineWidth: 1,\n    lineStyle: 'solid',\n    lineDash: null,\n    crossStyle: 'x',\n    rounded: false,\n    arrow: {\n        type: 'caret',\n        size: 5,\n    },\n};\nconst DEFAULT_LINE_DASHES = {\n    solid: [],\n    dashed: [5, 5],\n    dotted: [1, 3],\n};\nconst BEZIER_MATRICES = {\n    1: (0, vec_1.mat)(2, 2, [-1, 1, 1, 0]),\n    2: (0, vec_1.mat)(3, 3, [1, -2, 1, -2, 2, 0, 1, 0, 0]),\n    3: (0, vec_1.mat)(4, 4, [-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0]),\n};\nconst BEZIER_COEFFICIENTS = (t, order) => ({\n    1: [t, 1],\n    2: [t * t, t, 1],\n    3: [t * t * t, t * t, t, 1],\n}[order]);\nconst CATMULL_ROM_BASIS_FUNCTIONS = [\n    (t, tension) => -tension * Math.pow(t, 3) + 2 * tension * Math.pow(t, 2) - tension * t,\n    (t, tension) => (2 - tension) * Math.pow(t, 3) + (tension - 3) * Math.pow(t, 2) + 1,\n    (t, tension) => (tension - 2) * Math.pow(t, 3) +\n        (3 - 2 * tension) * Math.pow(t, 2) +\n        tension * t,\n    (t, tension) => tension * Math.pow(t, 3) - tension * Math.pow(t, 2),\n];\nconst CATMULL_ROM_BASIS_VECTOR = (t, tension) => CATMULL_ROM_BASIS_FUNCTIONS.map(f => f(t, tension));\n/**\n * Type guard to check if a value is a Color object\n */\nfunction isColorObject(color) {\n    return (typeof color === 'object' &&\n        'r' in color &&\n        'g' in color &&\n        'b' in color &&\n        (typeof color.a === 'number' || !('a' in color)));\n}\n/**\n * Convert a color object to a string in the format \"rgba(r, g, b, a)\"\n */\nfunction colourToString(color) {\n    var _a;\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${(_a = color.a) !== null && _a !== void 0 ? _a : 1})`;\n}\n/**\n * Prepare a color value (string or Color object) for use in styles\n */\nfunction prepareColor(color) {\n    if (typeof color === 'string') {\n        // Assume it's already a valid CSS color string\n        return color;\n    }\n    else if (isColorObject(color)) {\n        // Convert Color object to CSS color string\n        return colourToString(color);\n    }\n    // If it's neither, default to black\n    return 'black';\n}\n/**\n * Prepare a gradient for use in styles\n *\n * Returns a CanvasGradient object or null if no gradient is specified\n */\nfunction prepareGradient(context, style) {\n    if (!style) {\n        return null;\n    }\n    let gradient;\n    if (style.type === 'linear') {\n        gradient = context.createLinearGradient(style.start.x, style.start.y, style.end.x, style.end.y);\n    }\n    else {\n        gradient = context.createRadialGradient(style.start.x, style.start.y, 0, style.start.x, style.start.y, vec_1.vec2.len(vec_1.vec2.sub(style.end, style.start)) / 2);\n    }\n    for (const stop of style.colorStops) {\n        gradient.addColorStop(stop.position, prepareColor(stop.color));\n    }\n    return gradient;\n}\n/**\n * Get a complete style object with default values filled in\n */\nfunction getStyle(style) {\n    var _a;\n    return Object.assign({}, DEFAULT_STYLE_OPTIONS, {\n        ...(style !== null && style !== void 0 ? style : {}),\n        lineDash: style && style.lineDash !== undefined\n            ? style.lineDash\n            : (style === null || style === void 0 ? void 0 : style.lineStyle) === undefined\n                ? []\n                : DEFAULT_LINE_DASHES[(_a = style.lineStyle) !== null && _a !== void 0 ? _a : 'solid'],\n    });\n}\n/**\n * Pass in a context and some number of functions that take a context as their\n * first argument, and return an array of functions that don't require the\n * context argument\n *\n * If only one function is passed, this will return a single function\n */\nfunction withContext(context, ...functions) {\n    const result = functions.map(f => {\n        return (...args) => {\n            f(context, ...args);\n        };\n    });\n    return result.length === 1 ? result[0] : result;\n}\n/**\n * Draw a straight line segment between two points\n */\nfunction line(context, start, end, style) {\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple lines in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    context.moveTo(start.x, start.y);\n    context.lineTo(end.x, end.y);\n    // Stroke the path if required\n    // Additionally, if this is a batch operation, we don't stroke right away so\n    // that we can add more lines to the same path if we want\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a cross at a given position with a specified size\n */\nfunction cross(context, position, size, style) {\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple lines in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the cross\n    const halfSize = size / 2;\n    if (actualStyle.crossStyle === '+') {\n        // Plus sign cross\n        context.moveTo(position.x - halfSize, position.y);\n        context.lineTo(position.x + halfSize, position.y);\n        context.moveTo(position.x, position.y - halfSize);\n        context.lineTo(position.x, position.y + halfSize);\n    }\n    else if (actualStyle.crossStyle === 'x') {\n        // X cross\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n    }\n    // Stroke the path if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw an arrow from a start point to an end point with an optional arrowhead\n * at the end\n *\n * This function does not support batch drawing since it requires\n * beginning a new path for the arrowhead\n */\nfunction arrow(context, start, end, style) {\n    var _a;\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // Arrows don't support batch drawing since we have to begin a new path\n    // when drawing the arrowhead\n    context.beginPath();\n    // Draw the line segment\n    context.moveTo(start.x, start.y);\n    context.lineTo(end.x, end.y);\n    context.stroke();\n    // Draw the arrowhead if specified\n    if (actualStyle.arrow) {\n        const arrowSize = (_a = actualStyle.arrow.size) !== null && _a !== void 0 ? _a : 10;\n        const halfSize = arrowSize / 2;\n        const angle = vec_1.vec2.rad(vec_1.vec2.sub(end, start));\n        const arrowType = actualStyle.arrow.type;\n        context.save();\n        context.translate(end.x, end.y);\n        context.rotate(angle);\n        if (typeof arrowType === 'function') {\n            arrowType(context, arrowSize);\n        }\n        else if (arrowType === 'caret') {\n            if (actualStyle.strokeColor !== null) {\n                context.fillStyle = prepareColor(actualStyle.strokeColor);\n            }\n            context.beginPath();\n            context.moveTo(0, -halfSize);\n            context.lineTo(arrowSize, 0);\n            context.lineTo(0, halfSize);\n            context.closePath();\n            context.fill();\n        }\n        else if (arrowType === 'chevron') {\n            context.beginPath();\n            context.moveTo(-halfSize, -halfSize);\n            context.lineTo(0, 0);\n            context.lineTo(-halfSize, halfSize);\n            context.stroke();\n        }\n        context.restore();\n    }\n    context.restore();\n}\n/**\n * Draw a circle at a specified center point with a given radius\n */\nfunction circle(context, center, radius, style) {\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.fillColor !== null) {\n        context.fillStyle = prepareColor(actualStyle.fillColor);\n    }\n    if (actualStyle.gradient) {\n        const gradient = prepareGradient(context, actualStyle.gradient);\n        if (gradient) {\n            context.fillStyle = gradient;\n        }\n    }\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple shapes in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the circle\n    context.arc(center.x, center.y, radius, 0, Math.PI * 2);\n    // Fill the circle if required\n    if (actualStyle.fill && !actualStyle.batch) {\n        context.fill();\n    }\n    // Stroke the circle if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a rectangle at a specified position with a given size\n */\nfunction rectangle(context, position, size, style) {\n    var _a;\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.fillColor !== null) {\n        context.fillStyle = prepareColor(actualStyle.fillColor);\n    }\n    if (actualStyle.gradient) {\n        const gradient = prepareGradient(context, actualStyle.gradient);\n        if (gradient) {\n            context.fillStyle = gradient;\n        }\n    }\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple shapes in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the rectangle\n    if (actualStyle.rounded) {\n        context.roundRect(position.x, position.y, size.x, size.y, (_a = actualStyle.borderRadius) !== null && _a !== void 0 ? _a : 1);\n    }\n    else {\n        context.rect(position.x, position.y, size.x, size.y);\n    }\n    // Fill the rectangle if required\n    if (actualStyle.fill && !actualStyle.batch) {\n        context.fill();\n    }\n    // Stroke the rectangle if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a polygon defined by an array of vertices\n */\nfunction polygon(context, vertices, style) {\n    if (vertices.length < 3) {\n        return;\n    }\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.fillColor !== null) {\n        context.fillStyle = prepareColor(actualStyle.fillColor);\n    }\n    if (actualStyle.gradient) {\n        const gradient = prepareGradient(context, actualStyle.gradient);\n        if (gradient) {\n            context.fillStyle = gradient;\n        }\n    }\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple shapes in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the polygon path\n    context.moveTo(vertices[0].x, vertices[0].y);\n    for (let i = 1; i < vertices.length; i++) {\n        context.lineTo(vertices[i].x, vertices[i].y);\n    }\n    context.closePath();\n    // Fill the rectangle if required\n    if (actualStyle.fill && !actualStyle.batch) {\n        context.fill();\n    }\n    // Stroke the rectangle if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a path defined by an array of vertices\n */\nfunction path(context, vertices, style) {\n    var _a, _b, _c;\n    if (vertices.length < 2)\n        return;\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Handle different path types\n    const pathType = (_a = actualStyle.pathType) !== null && _a !== void 0 ? _a : 'linear';\n    if (pathType === 'linear') {\n        // Simple linear path\n        context.moveTo(vertices[0].x, vertices[0].y);\n        for (let i = 1; i < vertices.length; i++) {\n            context.lineTo(vertices[i].x, vertices[i].y);\n        }\n    }\n    else if (pathType === 'bezier') {\n        const order = (0, utils_1.clamp)((_b = actualStyle.bezierOrder) !== null && _b !== void 0 ? _b : 3, 1, 3);\n        // Draw bezier curve segments\n        const segmentSize = order + 1;\n        for (let i = 0; i + segmentSize <= vertices.length; i += order) {\n            const segmentPoints = vertices.slice(i, i + segmentSize);\n            // Draw first point of segment\n            if (i === 0) {\n                context.moveTo(segmentPoints[0].x, segmentPoints[0].y);\n            }\n            // Draw bezier curve through points\n            for (let t = 0; t <= 1; t += 0.01) {\n                const q = vec_1.mat.mulv(BEZIER_MATRICES[order], BEZIER_COEFFICIENTS(t, order));\n                if (q === false) {\n                    context.restore();\n                    return;\n                }\n                let p = (0, vec_1.vec2)();\n                for (let j = 0; j < segmentSize; j++) {\n                    p.x += segmentPoints[j].x * q[j];\n                    p.y += segmentPoints[j].y * q[j];\n                }\n                context.lineTo(p.x, p.y);\n            }\n        }\n    }\n    else if (pathType === 'catmull-rom') {\n        const tension = (_c = actualStyle.catmullRomTension) !== null && _c !== void 0 ? _c : 0.5;\n        // Need at least 4 points for Catmull-Rom\n        if (vertices.length >= 4) {\n            context.moveTo(vertices[1].x, vertices[1].y);\n            // Draw curve segments\n            for (let i = 1; i < vertices.length - 2; i++) {\n                const points = [\n                    vertices[i - 1],\n                    vertices[i],\n                    vertices[i + 1],\n                    vertices[i + 2],\n                ];\n                for (let t = 0; t <= 1; t += 0.01) {\n                    const x = (0, utils_1.dot)(points.map(p => p.x), CATMULL_ROM_BASIS_VECTOR(t, tension));\n                    const y = (0, utils_1.dot)(points.map(p => p.y), CATMULL_ROM_BASIS_VECTOR(t, tension));\n                    context.lineTo(x, y);\n                }\n            }\n        }\n        else {\n            // Fall back to linear if not enough points\n            context.moveTo(vertices[0].x, vertices[0].y);\n            for (let i = 1; i < vertices.length; i++) {\n                context.lineTo(vertices[i].x, vertices[i].y);\n            }\n        }\n    }\n    // Stroke the path if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n\n\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_60904__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_60904__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_60904__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/debug/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@basementuniverse/debug/build/index.js ***!
  \*************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback interpolationCallback\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {interpolationCallback} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst permutation = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst combination = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * A function for generating array values\n * @callback timesCallback\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {timesCallback} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    permutation,\n    combination,\n    times,\n    range,\n    zip,\n    at,\n    chunk,\n    shuffle,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nclass Debug {\n    constructor(options) {\n        if (options === null || options === void 0 ? void 0 : options.defaultValue) {\n            options.defaultValue = Object.assign({}, Debug.defaultOptions.defaultValue, options.defaultValue);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultChart) {\n            options.defaultChart = Object.assign({}, Debug.defaultOptions.defaultChart, options.defaultChart);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultMarker) {\n            options.defaultMarker = Object.assign({}, Debug.defaultOptions.defaultMarker, options.defaultMarker);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultBorder) {\n            options.defaultBorder = Object.assign({}, Debug.defaultOptions.defaultBorder, options.defaultBorder);\n        }\n        this.options = Object.assign({}, Debug.defaultOptions, options !== null && options !== void 0 ? options : {});\n        this.values = new Map();\n        this.charts = new Map();\n        this.markers = new Map();\n        this.borders = new Map();\n    }\n    /**\n     * Initialise the debug renderer for displaying values and markers\n     */\n    static initialise(options = {}) {\n        if (Debug.instance !== undefined) {\n            throw new Error('Debug has already been initialised');\n        }\n        Debug.instance = new Debug(options);\n    }\n    static getInstance() {\n        if (Debug.instance === undefined) {\n            throw new Error('Debug not properly initialised');\n        }\n        return Debug.instance;\n    }\n    /**\n     * Show a debug value\n     */\n    static value(label, value, options) {\n        var _a;\n        const instance = Debug.getInstance();\n        instance.values.set(label, Object.assign({}, instance.options.defaultValue, (_a = instance.values.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value }));\n    }\n    /**\n     * Show a debug chart\n     */\n    static chart(label, value, options) {\n        var _a, _b;\n        const instance = Debug.getInstance();\n        const currentChart = instance.charts.get(label);\n        instance.charts.set(label, Object.assign({}, instance.options.defaultChart, currentChart !== null && currentChart !== void 0 ? currentChart : {}, options !== null && options !== void 0 ? options : {}, {\n            label,\n            values: [...(_a = currentChart === null || currentChart === void 0 ? void 0 : currentChart.values) !== null && _a !== void 0 ? _a : [], value].slice(-((_b = options === null || options === void 0 ? void 0 : options.valueBufferSize) !== null && _b !== void 0 ? _b : instance.options.defaultChart.valueBufferSize)),\n        }));\n    }\n    /**\n     * Remove a debug chart\n     */\n    static removeChart(label) {\n        const instance = Debug.getInstance();\n        instance.charts.delete(label);\n    }\n    /**\n     * Show a marker in world or screen space\n     */\n    static marker(label, value, position, options) {\n        var _a;\n        const instance = Debug.getInstance();\n        instance.markers.set(label, Object.assign({}, instance.options.defaultMarker, (_a = instance.markers.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value, position }));\n    }\n    /**\n     * Show a border in world or screen space\n     */\n    static border(label, value, position, options) {\n        var _a;\n        if ((options === null || options === void 0 ? void 0 : options.borderShape) === 'circle' && (options === null || options === void 0 ? void 0 : options.radius) === undefined) {\n            // Don't add the border if it's circular but we don't have a radius\n            return;\n        }\n        if ((options === null || options === void 0 ? void 0 : options.borderShape) !== 'circle' && (options === null || options === void 0 ? void 0 : options.size) === undefined) {\n            // Don't add the border if it's rectangular (default is rectangular) but\n            // we don't have a size\n            return;\n        }\n        const instance = Debug.getInstance();\n        instance.borders.set(label, Object.assign({}, instance.options.defaultBorder, (_a = instance.borders.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value, position }));\n    }\n    /**\n     * Render the debug values and markers onto a canvas\n     */\n    static draw(context, tags, clear = true) {\n        const instance = Debug.getInstance();\n        // Draw world-space markers & borders\n        context.save();\n        instance.markers.forEach(marker => {\n            var _a;\n            if (tags && !((_a = marker.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (marker.space === 'world') {\n                instance.drawMarker(context, marker);\n            }\n        });\n        instance.borders.forEach(border => {\n            var _a;\n            if (tags && !((_a = border.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (border.space === 'world') {\n                instance.drawBorder(context, border);\n            }\n        });\n        context.restore();\n        // Draw values, charts and screen-space markers & borders\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        let position;\n        let leftY = instance.options.margin;\n        let rightY = instance.options.margin;\n        const lineHeight = (instance.options.lineHeight +\n            instance.options.padding * 2);\n        instance.values.forEach(value => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (tags && !((_a = value.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            switch (value.align) {\n                case 'left':\n                    position = (0, vec_1.vec)(instance.options.margin, leftY);\n                    leftY += lineHeight + instance.options.lineMargin;\n                    break;\n                case 'right':\n                    position = (0, vec_1.vec)(context.canvas.clientWidth - instance.options.margin, rightY);\n                    rightY += lineHeight + instance.options.lineMargin;\n                    break;\n            }\n            instance.drawLabel(context, Debug.prepareLabel((_b = value.label) !== null && _b !== void 0 ? _b : '', (_c = value.value) !== null && _c !== void 0 ? _c : '', value.showLabel, true), position, value.align, (_d = value.padding) !== null && _d !== void 0 ? _d : instance.options.padding, (_e = value.font) !== null && _e !== void 0 ? _e : instance.options.font, (_f = value.foregroundColour) !== null && _f !== void 0 ? _f : instance.options.foregroundColour, (_g = value.backgroundColour) !== null && _g !== void 0 ? _g : instance.options.backgroundColour);\n        });\n        instance.charts.forEach(chart => {\n            var _a, _b, _c, _d, _e, _f;\n            if (tags && !((_a = chart.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            switch (chart.align) {\n                case 'left':\n                    position = (0, vec_1.vec)(instance.options.margin, leftY);\n                    leftY += lineHeight + instance.options.lineMargin;\n                    break;\n                case 'right':\n                    position = (0, vec_1.vec)(context.canvas.clientWidth - instance.options.margin, rightY);\n                    rightY += lineHeight + instance.options.lineMargin;\n                    break;\n            }\n            instance.drawChart(context, Debug.prepareLabel((_b = chart.label) !== null && _b !== void 0 ? _b : '', '', chart.showLabel, false), position, chart.align, (_c = chart.padding) !== null && _c !== void 0 ? _c : instance.options.padding, (_d = chart.font) !== null && _d !== void 0 ? _d : instance.options.font, (_e = chart.foregroundColour) !== null && _e !== void 0 ? _e : instance.options.foregroundColour, (_f = chart.backgroundColour) !== null && _f !== void 0 ? _f : instance.options.backgroundColour, chart.chartBackgroundColour, chart.values, chart.valueBufferSize, chart.valueBufferStride, chart.minValue, chart.maxValue, chart.barWidth, chart.barColours);\n        });\n        instance.markers.forEach(marker => {\n            var _a;\n            if (tags && !((_a = marker.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (marker.space === 'screen') {\n                instance.drawMarker(context, marker);\n            }\n        });\n        instance.borders.forEach(border => {\n            var _a;\n            if (tags && !((_a = border.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (border.space === 'screen') {\n                instance.drawBorder(context, border);\n            }\n        });\n        context.restore();\n        // Clear values, markers & borders ready for next frame\n        if (clear) {\n            instance.values.clear();\n            instance.markers.clear();\n            instance.borders.clear();\n        }\n    }\n    static clear(clearCharts = false) {\n        const instance = Debug.getInstance();\n        instance.values.clear();\n        instance.markers.clear();\n        if (clearCharts) {\n            instance.charts.clear();\n        }\n        instance.borders.clear();\n    }\n    static prepareLabel(label, value, showLabel, showValue) {\n        const actualLabel = (showLabel && label) ? label : '';\n        const actualValue = (!!showValue && value !== '') ? value.toString() : '';\n        const separator = (actualLabel && actualValue) ? ': ' : '';\n        return `${actualLabel}${separator}${actualValue}`;\n    }\n    drawLabel(context, text, position, align, padding, font, foregroundColour, backgroundColour) {\n        context.save();\n        context.font = font;\n        context.textBaseline = 'top';\n        const backgroundSize = {\n            width: context.measureText(text).width + padding * 2,\n            height: this.options.lineHeight + padding * 2,\n        };\n        const x = align === 'right'\n            ? (position.x - backgroundSize.width)\n            : position.x;\n        // Draw background\n        context.fillStyle = backgroundColour;\n        context.fillRect(x - padding, position.y - padding, backgroundSize.width, backgroundSize.height);\n        // Draw text\n        context.fillStyle = foregroundColour;\n        context.fillText(text, x, position.y);\n        context.restore();\n    }\n    drawChart(context, label, position, align, padding, font, foregroundColour, backgroundColour, chartBackgroundColour, values, valueBufferSize, valueBufferStride, minValue, maxValue, barWidth, barColours) {\n        var _a, _b;\n        context.save();\n        context.font = font;\n        context.textBaseline = 'top';\n        const chartSize = {\n            width: barWidth * Math.ceil(valueBufferSize / Math.max(valueBufferStride, 1)),\n            height: this.options.lineHeight + padding * 2,\n        };\n        const labelSize = {\n            width: context.measureText(label).width,\n            height: this.options.lineHeight,\n        };\n        const backgroundSize = {\n            width: (labelSize.width +\n                padding +\n                chartSize.width) + padding * 2,\n            height: this.options.lineHeight + padding * 2,\n        };\n        const x = align === 'right'\n            ? (position.x - backgroundSize.width)\n            : position.x;\n        // Draw background\n        context.fillStyle = backgroundColour;\n        context.fillRect(x - padding, position.y - padding, backgroundSize.width, backgroundSize.height);\n        // Draw label\n        if (label) {\n            context.fillStyle = foregroundColour;\n            context.fillText(label, x, position.y);\n        }\n        // Draw chart\n        if (chartBackgroundColour) {\n            context.fillStyle = chartBackgroundColour;\n            context.fillRect(x + padding + labelSize.width + padding, position.y - padding, chartSize.width, chartSize.height);\n        }\n        const range = maxValue - minValue;\n        const barOffset = (0, vec_1.vec)(x + padding + labelSize.width + padding, position.y - padding);\n        for (let i = 0; i < Math.ceil(values.length / Math.max(valueBufferStride, 1)); i++) {\n            let value;\n            if (valueBufferStride <= 1) {\n                value = values[i];\n            }\n            else {\n                value = values\n                    .slice(i * valueBufferStride, (i + 1) * valueBufferStride)\n                    .reduce((a, b) => a + b, 0) / valueBufferStride;\n            }\n            const barSize = (0, vec_1.vec)(barWidth, Math.round(chartSize.height * (value - minValue) / range));\n            const barPosition = vec_1.vec.add(barOffset, (0, vec_1.vec)((values.length < valueBufferSize\n                ? Math.ceil((valueBufferSize - values.length) / valueBufferStride) * barWidth\n                : 0) + i * barWidth, chartSize.height - barSize.y));\n            const barColour = (_b = (barColours\n                ? (_a = [...barColours].reverse().find(c => values[i] >= c.offset)) === null || _a === void 0 ? void 0 : _a.colour\n                : undefined)) !== null && _b !== void 0 ? _b : foregroundColour;\n            context.fillStyle = barColour;\n            context.fillRect(barPosition.x, barPosition.y, barSize.x, barSize.y);\n        }\n        context.restore();\n    }\n    drawMarker(context, marker) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        context.save();\n        const position = (_a = marker.position) !== null && _a !== void 0 ? _a : (0, vec_1.vec)();\n        if (marker.showLabel || marker.showValue) {\n            this.drawLabel(context, Debug.prepareLabel((_b = marker.label) !== null && _b !== void 0 ? _b : '', (_c = marker.value) !== null && _c !== void 0 ? _c : '', marker.showLabel, marker.showValue), vec_1.vec.add(position !== null && position !== void 0 ? position : (0, vec_1.vec)(), marker.labelOffset), 'left', (_d = marker.padding) !== null && _d !== void 0 ? _d : this.options.padding, (_e = marker.font) !== null && _e !== void 0 ? _e : this.options.font, (_f = marker.foregroundColour) !== null && _f !== void 0 ? _f : this.options.foregroundColour, (_g = marker.backgroundColour) !== null && _g !== void 0 ? _g : this.options.backgroundColour);\n        }\n        if (marker.showMarker) {\n            if (marker.markerImage) {\n                context.drawImage(marker.markerImage, position.x - marker.markerImage.width / 2, position.y - marker.markerImage.height / 2);\n            }\n            else {\n                context.lineWidth = marker.markerLineWidth;\n                context.strokeStyle = context.fillStyle = marker.markerColour;\n                switch (marker.markerStyle) {\n                    case 'x':\n                        this.drawCross(context, position, marker.markerSize);\n                        break;\n                    case '+':\n                        this.drawPlus(context, position, marker.markerSize);\n                        break;\n                    case '.':\n                        this.drawDot(context, position, marker.markerSize);\n                        break;\n                }\n            }\n        }\n        context.restore();\n    }\n    drawCross(context, position, size) {\n        context.beginPath();\n        const halfSize = size / 2;\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n    }\n    drawPlus(context, position, size) {\n        context.beginPath();\n        const halfSize = size / 2;\n        context.moveTo(position.x, position.y - halfSize);\n        context.lineTo(position.x, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y);\n        context.lineTo(position.x + halfSize, position.y);\n        context.stroke();\n    }\n    drawDot(context, position, size) {\n        context.beginPath();\n        context.arc(position.x, position.y, size / 2, 0, Math.PI * 2);\n        context.fill();\n    }\n    drawBorder(context, border) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        context.save();\n        const position = (_a = border.position) !== null && _a !== void 0 ? _a : (0, vec_1.vec)();\n        if (border.showLabel || border.showValue) {\n            this.drawLabel(context, Debug.prepareLabel((_b = border.label) !== null && _b !== void 0 ? _b : '', (_c = border.value) !== null && _c !== void 0 ? _c : '', border.showLabel, border.showValue), vec_1.vec.add(position !== null && position !== void 0 ? position : (0, vec_1.vec)(), border.labelOffset), 'left', (_d = border.padding) !== null && _d !== void 0 ? _d : this.options.padding, (_e = border.font) !== null && _e !== void 0 ? _e : this.options.font, (_f = border.foregroundColour) !== null && _f !== void 0 ? _f : this.options.foregroundColour, (_g = border.backgroundColour) !== null && _g !== void 0 ? _g : this.options.backgroundColour);\n        }\n        if (border.showBorder) {\n            context.lineWidth = border.borderWidth;\n            context.strokeStyle = context.fillStyle = border.borderColour;\n            switch (border.borderStyle) {\n                case 'solid':\n                    context.setLineDash([]);\n                    break;\n                case 'dashed':\n                    context.setLineDash([border.borderDashSize, border.borderDashSize]);\n                    break;\n                case 'dotted':\n                    context.setLineDash([border.borderWidth, border.borderWidth]);\n                    break;\n            }\n            switch (border.borderShape) {\n                case 'rectangle':\n                    if (border.size) {\n                        this.drawRectangle(context, position, border.size);\n                    }\n                    break;\n                case 'circle':\n                    if (border.radius) {\n                        this.drawCircle(context, position, border.radius);\n                    }\n                    break;\n            }\n        }\n        context.restore();\n    }\n    drawRectangle(context, position, size) {\n        context.beginPath();\n        context.rect(position.x, position.y, size.x, size.y);\n        context.stroke();\n    }\n    drawCircle(context, position, radius) {\n        context.beginPath();\n        context.arc(position.x, position.y, radius, 0, Math.PI * 2);\n        context.stroke();\n    }\n}\nexports[\"default\"] = Debug;\nDebug.defaultOptions = {\n    margin: 10,\n    padding: 4,\n    font: '10pt Lucida Console, monospace',\n    lineHeight: 12,\n    lineMargin: 0,\n    foregroundColour: '#fff',\n    backgroundColour: '#333',\n    defaultValue: {\n        align: 'left',\n        showLabel: true,\n    },\n    defaultChart: {\n        values: [],\n        valueBufferSize: 60,\n        valueBufferStride: 1,\n        minValue: 0,\n        maxValue: 100,\n        barWidth: 2,\n        align: 'left',\n        showLabel: true,\n        chartBackgroundColour: '#222',\n    },\n    defaultMarker: {\n        showLabel: true,\n        showValue: true,\n        showMarker: true,\n        markerSize: 6,\n        markerLineWidth: 2,\n        markerStyle: 'x',\n        markerColour: '#ccc',\n        space: 'world',\n        labelOffset: (0, vec_1.vec)(10),\n    },\n    defaultBorder: {\n        showLabel: true,\n        showValue: true,\n        showBorder: true,\n        borderWidth: 1,\n        borderStyle: 'solid',\n        borderShape: 'rectangle',\n        borderColour: '#ccc',\n        borderDashSize: 5,\n        space: 'world',\n        labelOffset: (0, vec_1.vec)(10),\n    },\n};\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_42206__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_42206__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_42206__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/input-manager/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/input-manager/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback interpolationCallback\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {interpolationCallback} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst permutation = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst combination = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * A function for generating array values\n * @callback timesCallback\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {timesCallback} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    permutation,\n    combination,\n    times,\n    range,\n    zip,\n    at,\n    chunk,\n    shuffle,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MouseButton = void 0;\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nvar MouseButton;\n(function (MouseButton) {\n    MouseButton[MouseButton[\"Left\"] = 0] = \"Left\";\n    MouseButton[MouseButton[\"Middle\"] = 1] = \"Middle\";\n    MouseButton[MouseButton[\"Right\"] = 2] = \"Right\";\n})(MouseButton = exports.MouseButton || (exports.MouseButton = {}));\nclass InputManager {\n    constructor(options) {\n        this.keyboardState = InputManager.initialKeyboardState();\n        this.previousKeyboardState = InputManager.initialKeyboardState();\n        this.mouseState = InputManager.initialMouseState();\n        this.previousMouseState = InputManager.initialMouseState();\n        this.options = Object.assign({}, InputManager.defaultOptions, options !== null && options !== void 0 ? options : {});\n        // Set up event handlers\n        if (this.options.mouse) {\n            this.options.element.addEventListener('mousedown', e => {\n                this.mouseState.buttons[e.button] = true;\n            });\n            this.options.element.addEventListener('mouseup', e => {\n                this.mouseState.buttons[e.button] = false;\n            });\n            this.options.element.addEventListener('touchstart', () => {\n                this.mouseState.buttons[0] = true;\n            });\n            this.options.element.addEventListener('touchend', () => {\n                this.mouseState.buttons[0] = false;\n            });\n            this.options.element.addEventListener('mousemove', e => {\n                this.mouseState.position.x = e.offsetX;\n                this.mouseState.position.y = e.offsetY;\n                this.mouseState.hoveredElement = e.target;\n            });\n            if (this.options.mouseWheel) {\n                window.addEventListener('wheel', e => {\n                    this.mouseState.wheel = e.deltaY > 0 ? 1 : -1;\n                });\n            }\n        }\n        if (this.options.keyboard) {\n            window.addEventListener('keydown', e => {\n                this.keyboardState[e.code] = true;\n            });\n            window.addEventListener('keyup', e => {\n                this.keyboardState[e.code] = false;\n            });\n        }\n        // Prevent the context menu from appearing on right-click\n        if (this.options.preventContextMenu) {\n            this.options.element.addEventListener('contextmenu', e => {\n                e.preventDefault();\n            });\n        }\n    }\n    /**\n     * Initialise the input manager for managing mouse and keyboard input\n     */\n    static initialise(options) {\n        if (InputManager.instance !== undefined) {\n            throw new Error('Input manager already initialised');\n        }\n        InputManager.instance = new InputManager(options);\n    }\n    static getInstance() {\n        if (InputManager.instance === undefined) {\n            throw new Error('Input manager not properly initialised');\n        }\n        return InputManager.instance;\n    }\n    static initialKeyboardState() {\n        return {};\n    }\n    static initialMouseState() {\n        return {\n            buttons: {\n                [MouseButton.Left]: false,\n                [MouseButton.Middle]: false,\n                [MouseButton.Right]: false,\n            },\n            position: (0, vec_1.vec)(),\n            wheel: 0,\n            hoveredElement: null,\n        };\n    }\n    static copyKeyboardState(state) {\n        return Object.assign({}, state);\n    }\n    static copyMouseState(state) {\n        return {\n            buttons: Object.assign({}, state.buttons),\n            position: vec_1.vec.cpy(state.position),\n            wheel: state.wheel,\n            hoveredElement: state.hoveredElement,\n        };\n    }\n    /**\n     * Update the state of the input devices\n     */\n    static update() {\n        const instance = InputManager.getInstance();\n        instance.previousKeyboardState = this.copyKeyboardState(instance.keyboardState);\n        instance.previousMouseState = this.copyMouseState(instance.mouseState);\n        instance.mouseState.wheel = 0;\n    }\n    /**\n     * Check if a key is currently pressed down\n     */\n    static keyDown(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key is down\n        if (code === undefined) {\n            for (const k in instance.keyboardState) {\n                if (instance.keyboardState[k]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return !!instance.keyboardState[code];\n    }\n    /**\n     * Check if a key has been pressed since the last frame\n     */\n    static keyPressed(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key was pressed\n        if (code === undefined) {\n            for (const k in instance.keyboardState) {\n                if (instance.keyboardState[k] &&\n                    (!(k in instance.previousKeyboardState) ||\n                        !instance.previousKeyboardState[k])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!!instance.keyboardState[code] &&\n            !instance.previousKeyboardState[code]);\n    }\n    /**\n     * Check if a key has been released since the last frame\n     */\n    static keyReleased(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key was released\n        if (code === undefined) {\n            for (const k in instance.keyboardState) {\n                if (!instance.keyboardState[k] &&\n                    !!instance.previousKeyboardState[k]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!instance.keyboardState[code] &&\n            !!instance.previousKeyboardState[code]);\n    }\n    /**\n     * Check if a mouse button is currently pressed down\n     */\n    static mouseDown(button) {\n        const instance = InputManager.getInstance();\n        // Check if any button is down\n        if (button === undefined) {\n            for (const b in instance.mouseState.buttons) {\n                const currentButton = +b;\n                if (instance.mouseState.buttons[currentButton]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return !!instance.mouseState.buttons[button];\n    }\n    /**\n     * Check if a mouse button has been pressed since the last frame\n     */\n    static mousePressed(button) {\n        const instance = InputManager.getInstance();\n        // Check if any button was pressed\n        if (button === undefined) {\n            for (const b in instance.mouseState.buttons) {\n                const currentButton = +b;\n                if (instance.mouseState.buttons[currentButton] &&\n                    (!(b in instance.previousMouseState.buttons) ||\n                        !instance.previousMouseState.buttons[currentButton])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!!instance.mouseState.buttons[button] &&\n            !instance.previousMouseState.buttons[button]);\n    }\n    /**\n     * Check if a mouse button has been released since the last frame\n     */\n    static mouseReleased(button) {\n        const instance = InputManager.getInstance();\n        // Check if any button was released\n        if (button === undefined) {\n            for (const b in instance.mouseState.buttons) {\n                const currentButton = +b;\n                if (!instance.mouseState.buttons[currentButton] &&\n                    !!instance.previousMouseState.buttons[currentButton]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!instance.mouseState.buttons[button] &&\n            !!instance.previousMouseState.buttons[button]);\n    }\n    /**\n     * Check if the mousewheel is scrolling up\n     */\n    static mouseWheelUp() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.wheel > 0;\n    }\n    /**\n     * Check if the mousewheel is scrolling down\n     */\n    static mouseWheelDown() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.wheel < 0;\n    }\n    /**\n     * Get the current mouse position in screen-space\n     */\n    static get mousePosition() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.position;\n    }\n    /**\n     * Get the currently hovered element\n     */\n    static get hoveredElement() {\n        var _a;\n        const instance = InputManager.getInstance();\n        return (_a = instance.mouseState.hoveredElement) !== null && _a !== void 0 ? _a : null;\n    }\n}\nexports[\"default\"] = InputManager;\nInputManager.defaultOptions = {\n    element: window,\n    mouse: true,\n    mouseWheel: true,\n    keyboard: true,\n    preventContextMenu: false,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_30860__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_30860__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_30860__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/intersection-helpers/build/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@basementuniverse/intersection-helpers/build/index.js ***!
  \****************************************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * @overview A library of useful functions
 * @author Gordon Larrigan
 */

/**
 * Memoize a function
 * @param {Function} f The function to memoize
 * @returns {Function} A memoized version of the function
 */
const memoize = f => {
  var cache = {};
  return function(...args) {
    return cache[args] ?? (cache[args] = f.apply(this, args));
  };
};

/**
 * Check if two numbers are approximately equal
 * @param {number} a Number a
 * @param {number} b Number b
 * @param {number} [p=Number.EPSILON] The precision value
 * @return {boolean} True if numbers a and b are approximately equal
 */
const floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;

/**
 * Clamp a number between min and max
 * @param {number} a The number to clamp
 * @param {number} [min=0] The minimum value
 * @param {number} [max=1] The maximum value
 * @return {number} A clamped number
 */
const clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);

/**
 * Get the fractional part of a number
 * @param {number} a The number from which to get the fractional part
 * @return {number} The fractional part of the number
 */
const frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);

/**
 * Round n to d decimal places
 * @param {number} n The number to round
 * @param {number} [d=0] The number of decimal places to round to
 * @return {number} A rounded number
 */
const round = (n, d = 0) => {
  const p = Math.pow(10, d);
  return Math.round(n * p + Number.EPSILON) / p;
}

/**
 * Do a linear interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} An interpolated value in the interval [a, b]
 */
const lerp = (a, b, i) => a + (b - a) * i;

/**
 * Get the position of i between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolated value in the interval [a, b]
 * @return {number} The position of i between a and b
 */
const unlerp = (a, b, i) => (i - a) / (b - a);

/**
 * Do a bilinear interpolation
 * @param {number} c00 Top-left value
 * @param {number} c10 Top-right value
 * @param {number} c01 Bottom-left value
 * @param {number} c11 Bottom-right value
 * @param {number} ix Interpolation value along x
 * @param {number} iy Interpolation value along y
 * @return {number} A bilinear interpolated value
 */
const blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);

/**
 * Re-map a number i from range a1...a2 to b1...b2
 * @param {number} i The number to re-map
 * @param {number} a1
 * @param {number} a2
 * @param {number} b1
 * @param {number} b2
 * @return {number}
 */
const remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);

/**
 * Do a smooth interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value
 * @return {number} An interpolated value in the interval [a, b]
 */
const smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));

/**
 * Get an angle in radians
 * @param {number} degrees The angle in degrees
 * @return {number} The angle in radians
 */
const radians = degrees => (Math.PI / 180) * degrees;

/**
 * Get an angle in degrees
 * @param {number} radians The angle in radians
 * @return {number} The angle in degrees
 */
const degrees = radians => (180 / Math.PI) * radians;

/**
 * Get a random float in the interval [min, max)
 * @param {number} min Inclusive min
 * @param {number} max Exclusive max
 * @return {number} A random float in the interval [min, max)
 */
const randomBetween = (min, max) => Math.random() * (max - min) + min;

/**
 * Get a random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A random integer in the interval [min, max]
 */
const randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

/**
 * Get a normally-distributed random number
 * @param {number} [mu=0.5] The mean value
 * @param {number} [sigma=0.5] The standard deviation
 * @param {number} [samples=2] The number of samples
 * @return {number} A normally-distributed random number
 */
const cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {
  let total = 0;
  for (let i = samples; i--;) {
    total += Math.random();
  }
  return mu + (total - samples / 2) / (samples / 2) * sigma;
};

/**
 * Get a normally-distributed random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A normally-distributed random integer
 */
const cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));

/**
 * Return a weighted random integer
 * @param {Array<number>} w An array of weights
 * @return {number} An index from w
 */
const weightedRandom = w => {
  let total = w.reduce((a, i) => a + i, 0), n = 0;
  const r = Math.random() * total;
  while (total > r) {
    total -= w[n++];
  }
  return n - 1;
};

/**
 * An interpolation function
 * @callback InterpolationFunction
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} The interpolated value in the interval [a, b]
 */

/**
 * Return an interpolated value from an array
 * @param {Array<number>} a An array of values interpolate
 * @param {number} i A number in the interval [0, 1]
 * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use
 * @return {number} An interpolated value in the interval [min(a), max(a)]
 */
const lerpArray = (a, i, f = lerp) => {
  const s = i * (a.length - 1);
  const p = clamp(Math.trunc(s), 0, a.length - 1);
  return f(a[p] || 0, a[p + 1] || 0, frac(s));
};

/**
 * Get the dot product of two vectors
 * @param {Array<number>} a Vector a
 * @param {Array<number>} b Vector b
 * @return {number} a ∙ b
 */
const dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);

/**
 * Get the factorial of a number
 * @param {number} a
 * @return {number} a!
 */
const factorial = a => {
  let result = 1;
  for (let i = 2; i <= a; i++) {
    result *= i;
  }
  return result;
};

/**
 * Get the number of permutations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nPr
 */
const npr = (n, r) => factorial(n) / factorial(n - r);

/**
 * Get the number of combinations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nCr
 */
const ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));

/**
 * Generate all permutations of r elements from an array
 *
 * @example
 * ```js
 * permutations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 1],
 *   [2, 3],
 *   [3, 1],
 *   [3, 2]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each permutation
 * @return {Array<Array<*>>} An array of permutation arrays
 */
const permutations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),
    ],
    []
  );
}

/**
 * Generate all combinations of r elements from an array
 *
 * @example
 * ```js
 * combinations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 3]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each combination
 * @return {Array<Array<*>>} An array of combination arrays
 */
const combinations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),
    ],
    []
  );
};

/**
 * Get a cartesian product of arrays
 *
 * @example
 * ```js
 * cartesian([1, 2, 3], ['a', 'b']);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, "a"],
 *   [1, "b"],
 *   [2, "a"],
 *   [2, "b"],
 *   [3, "a"],
 *   [3, "b"]
 * ]
 * ```
 */
const cartesian = (...arr) =>
  arr.reduce(
    (a, b) => a.flatMap(c => b.map(d => [...c, d])),
    [[]]
  );

/**
 * A function for generating array values
 * @callback TimesFunction
 * @param {number} i The array index
 * @return {*} The array value
 */

/**
 * Return a new array with length n by calling function f(i) on each element
 * @param {TimesFunction} f
 * @param {number} n The size of the array
 * @return {Array<*>}
 */
const times = (f, n) => Array(n).fill(0).map((_, i) => f(i));

/**
 * Return an array containing numbers 0->(n - 1)
 * @param {number} n The size of the array
 * @return {Array<number>} An array of integers 0->(n - 1)
 */
const range = n => times(i => i, n);

/**
 * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]
 * @param {...Array<*>} a The arrays to zip
 * @return {Array<Array<*>>}
 */
const zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));

/**
 * Return array[i] with positive and negative wrapping
 * @param {Array<*>} a The array to access
 * @param {number} i The positively/negatively wrapped array index
 * @return {*} An element from the array
 */
const at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];

/**
 * Return the last element of an array without removing it
 * @param {Array<*>} a
 * @return {*} The last element from the array
 */
const peek = (a) => {
  if (!a.length) {
    return undefined;
  }

  return a[a.length - 1];
};

/**
 * Return the index for a given position in an unrolled 2d array
 * @param {number} x The x position
 * @param {number} y The y position
 * @param {number} w The width of the 2d array
 * @returns {number} The index in the unrolled array
 */
const ind = (x, y, w) => x + y * w;

/**
 * Return the position for a given index in an unrolled 2d array
 * @param {number} i The index
 * @param {number} w The width of the 2d array
 * @returns {Array<number>} The position as a 2-tuple
 */
const pos = (i, w) => [i % w, Math.floor(i / w)];

/**
 * Chop an array into chunks of size n
 * @param {Array<*>} a
 * @param {number} n The chunk size
 * @return {Array<Array<*>>} An array of array chunks
 */
const chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));

/**
 * Randomly shuffle a shallow copy of an array
 * @param {Array<*>} a
 * @return {Array<*>} The shuffled array
 */
const shuffle = a => a.slice().sort(() => Math.random() - 0.5);

/**
 * Flatten an object
 * @param {object} o
 * @param {string} concatenator The string to use for concatenating keys
 * @return {object} A flattened object
 */
const flat = (o, concatenator = '.') => {
  return Object.keys(o).reduce((acc, key) => {
    if (o[key] instanceof Date) {
      return {
        ...acc,
        [key]: o[key].toISOString(),
      };
    }

    if (typeof o[key] !== 'object' || !o[key]) {
      return {
        ...acc,
        [key]: o[key],
      };
    }
    const flattened = flat(o[key], concatenator);

    return {
      ...acc,
      ...Object.keys(flattened).reduce(
        (childAcc, childKey) => ({
          ...childAcc,
          [`${key}${concatenator}${childKey}`]: flattened[childKey],
        }),
        {}
      ),
    };
  }, {});
};

/**
 * Unflatten an object
 * @param {object} o
 * @param {string} concatenator The string to check for in concatenated keys
 * @return {object} An un-flattened object
 */
const unflat = (o, concatenator = '.') => {
  let result = {}, temp, substrings, property, i;

  for (property in o) {
    substrings = property.split(concatenator);
    temp = result;
    for (i = 0; i < substrings.length - 1; i++) {
      if (!(substrings[i] in temp)) {
        if (isFinite(substrings[i + 1])) {
          temp[substrings[i]] = [];
        } else {
          temp[substrings[i]] = {};
        }
      }
      temp = temp[substrings[i]];
    }
    temp[substrings[substrings.length - 1]] = o[property];
  }

  return result;
};

/**
 * A split predicate
 * @callback SplitPredicate
 * @param {any} value The current value
 * @return {boolean} True if the array should split at this index
 */

/**
 * Split an array into sub-arrays based on a predicate
 * @param {Array<*>} array
 * @param {SplitPredicate} predicate
 * @return {Array<Array<*>>} An array of arrays
 */
const split = (array, predicate) => {
  const result = [];
  let current = [];
  for (const value of array) {
    if (predicate(value)) {
      if (current.length) {
        result.push(current);
      }
      current = [value];
    } else {
      current.push(value);
    }
  }
  result.push(current);

  return result;
};

/**
 * Pluck keys from an object
 * @param {object} o
 * @param {...string} keys The keys to pluck from the object
 * @return {object} An object containing the plucked keys
 */
const pluck = (o, ...keys) => {
  return keys.reduce(
    (result, key) => Object.assign(result, { [key]: o[key] }),
    {}
  );
};

/**
 * Exclude keys from an object
 * @param {object} o
 * @param {...string} keys The keys to exclude from the object
 * @return {object} An object containing all keys except excluded keys
 */
const exclude = (o, ...keys) => {
  return Object.fromEntries(
    Object.entries(o).filter(([key]) => !keys.includes(key))
  );
};

if (true) {
  module.exports = {
    memoize,
    floatEquals,
    clamp,
    frac,
    round,
    lerp,
    unlerp,
    blerp,
    remap,
    smoothstep,
    radians,
    degrees,
    randomBetween,
    randomIntBetween,
    cltRandom,
    cltRandomInt,
    weightedRandom,
    lerpArray,
    dot,
    factorial,
    npr,
    ncr,
    permutations,
    combinations,
    cartesian,
    times,
    range,
    zip,
    at,
    peek,
    ind,
    pos,
    chunk,
    shuffle,
    flat,
    unflat,
    split,
    pluck,
    exclude,
  };
}


/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * @overview A small vector and matrix library
 * @author Gordon Larrigan
 */

const _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));
const _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));
const _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);
const _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;
const _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;

/**
 * A 2d vector
 * @typedef {Object} vec2
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 */

/**
 * Create a new 2d vector
 * @param {number|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector
 * @return {vec2} A new 2d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec2(3, 2); // (3, 2)
 * let b = vec2(4);    // (4, 4)
 * let c = vec2(a);    // (3, 2)
 * let d = vec2();     // (0, 0)
 */
const vec2 = (x, y) => {
  if (!x && !y) {
    return { x: 0, y: 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0 };
  }
  return { x: x, y: y ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec2} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec2.components = a => [a.x, a.y];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec2} A new vector
 */
vec2.fromComponents = components => vec2(...components.slice(0, 2));

/**
 * Return a unit vector (1, 0)
 * @return {vec2} A unit vector (1, 0)
 */
vec2.ux = () => vec2(1, 0);

/**
 * Return a unit vector (0, 1)
 * @return {vec2} A unit vector (0, 1)
 */
vec2.uy = () => vec2(0, 1);

/**
 * Add vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a + b
 */
vec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });

/**
 * Subtract vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a - b
 */
vec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });

/**
 * Scale a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a * b
 */
vec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });

/**
 * Scale a vector by a scalar, alias for vec2.mul
 * @param {vec2} a Vector a
 * @param {number} b Scalar b
 * @return {vec2} a * b
 */
vec2.scale = (a, b) => vec2.mul(a, b);

/**
 * Divide a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a / b
 */
vec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });

/**
 * Get the length of a vector
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);

/**
 * Normalise a vector
 * @param {vec2} a The vector to normalise
 * @return {vec2} ^a
 */
vec2.nor = a => {
  let len = vec2.len(a);
  return len ? { x: a.x / len, y: a.y / len } : vec2();
};

/**
 * Get a dot product of vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a ∙ b
 */
vec2.dot = (a, b) => a.x * b.x + a.y * b.y;

/**
 * Rotate a vector by r radians
 * @param {vec2} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec2} A rotated vector
 */
vec2.rot = (a, r) => {
  let s = Math.sin(r),
    c = Math.cos(r);
  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };
};

/**
 * Fast method to rotate a vector by -90, 90 or 180 degrees
 * @param {vec2} a The vector to rotate
 * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees
 * @return {vec2} A rotated vector
 */
vec2.rotf = (a, r) => {
  switch (r) {
    case 1: return vec2(a.y, -a.x);
    case -1: return vec2(-a.y, a.x);
    case 2: case -2: return vec2(-a.x, -a.y);
    default: return a;
  }
};

/**
 * Scalar cross product of two vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a × b
 */
vec2.cross = (a, b) => {
  return a.x * b.y - a.y * b.x;
};

/**
 * Check if two vectors are equal
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec2.eq = (a, b) => a.x === b.x && a.y === b.y;

/**
 * Get the angle of a vector
 * @param {vec2} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec2.rad = a => Math.atan2(a.y, a.x);

/**
 * Copy a vector
 * @param {vec2} a The vector to copy
 * @return {vec2} A copy of vector a
 */
vec2.cpy = a => vec2(a);

/**
 * A function to call on each component of a 2d vector
 * @callback vec2MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y'} label The component label (x or y)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec2} a Vector a
 * @param {vec2MapCallback} f The function to call on each component of the vector
 * @return {vec2} Vector a mapped through f
 */
vec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });

/**
 * Convert a vector into a string
 * @param {vec2} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x` or `y`
 * - `u` or `v` (aliases for `x` and `y`, respectively)
 * - `X`, `Y`, `U`, `V` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec2} a The vector to swizzle
 * @param {string} [s='..'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec2(3, -2);
 * vec2.swiz(a, 'x');    // [3]
 * vec2.swiz(a, 'yx');   // [-2, 3]
 * vec2.swiz(a, 'xY');   // [3, 2]
 * vec2.swiz(a, 'Yy');   // [2, -2]
 * vec2.swiz(a, 'x.x');  // [3, -2, 3]
 * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]
 */
vec2.swiz = (a, s = '..') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': result.push(a.x); break;
      case 'y': case 'v': result.push(a.y); break;
      case 'X': case 'U': result.push(-a.x); break;
      case 'Y': case 'V': result.push(-a.y); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 2d vector
 * @typedef {Object} polarCoordinates2d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec2} a The vector to convert
 * @return {polarCoordinates2d} The magnitude and angle of the vector
 */
vec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The angle of the vector
 * @return {vec2} A vector with the given angle and magnitude
 */
vec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));

/**
 * A 3d vector
 * @typedef {Object} vec3
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 * @property {number} z The z component of the vector
 */

/**
 * Create a new 3d vector
 * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector, or the z component if x is a vec2
 * @param {number} [z] The z component of the vector
 * @return {vec3} A new 3d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec3(3, 2, 1);       // (3, 2, 1)
 * let b = vec3(4, 5);          // (4, 5, 0)
 * let c = vec3(6);             // (6, 6, 6)
 * let d = vec3(a);             // (3, 2, 1)
 * let e = vec3();              // (0, 0, 0)
 * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)
 * let g = vec3(vec2(4, 5));    // (4, 5, 0)
 */
const vec3 = (x, y, z) => {
  if (!x && !y && !z) {
    return { x: 0, y: 0, z: 0 };
  }
  if (_vec_is_vec3(x)) {
    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0, z: y || 0 };
  }
  return { x: x, y: y ?? x, z: z ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec3} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec3.components = a => [a.x, a.y, a.z];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec3} A new vector
 */
vec3.fromComponents = components => vec3(...components.slice(0, 3));

/**
 * Return a unit vector (1, 0, 0)
 * @return {vec3} A unit vector (1, 0, 0)
 */
vec3.ux = () => vec3(1, 0, 0);

/**
 * Return a unit vector (0, 1, 0)
 * @return {vec3} A unit vector (0, 1, 0)
 */
vec3.uy = () => vec3(0, 1, 0);

/**
 * Return a unit vector (0, 0, 1)
 * @return {vec3} A unit vector (0, 0, 1)
 */
vec3.uz = () => vec3(0, 0, 1);

/**
 * Add vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a + b
 */
vec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });

/**
 * Subtract vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a - b
 */
vec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });

/**
 * Scale a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a * b
 */
vec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });

/**
 * Scale a vector by a scalar, alias for vec3.mul
 * @param {vec3} a Vector a
 * @param {number} b Scalar b
 * @return {vec3} a * b
 */
vec3.scale = (a, b) => vec3.mul(a, b);

/**
 * Divide a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a / b
 */
vec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });

/**
 * Get the length of a vector
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);

/**
 * Normalise a vector
 * @param {vec3} a The vector to normalise
 * @return {vec3} ^a
 */
vec3.nor = a => {
  let len = vec3.len(a);
  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();
};

/**
 * Get a dot product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {number} a ∙ b
 */
vec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

/**
 * Rotate a vector using a rotation matrix
 * @param {vec3} a The vector to rotate
 * @param {mat} m The rotation matrix
 * @return {vec3} A rotated vector
 */
vec3.rot = (a, m) => vec3(
  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)
);

/**
 * Rotate a vector by r radians around the x axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotx = (a, r) => vec3(
  a.x,
  a.y * Math.cos(r) - a.z * Math.sin(r),
  a.y * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the y axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.roty = (a, r) => vec3(
  a.x * Math.cos(r) + a.z * Math.sin(r),
  a.y,
  -a.x * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the z axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotz = (a, r) => vec3(
  a.x * Math.cos(r) - a.y * Math.sin(r),
  a.x * Math.sin(r) + a.y * Math.cos(r),
  a.z
);

/**
 * Rotate a vector using a quaternion
 * @param {vec3} a The vector to rotate
 * @param {Array<number>} q The quaternion to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rotq = (v, q) => {
  if (q.length !== 4) {
    return vec3();
  }

  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
  if (d === 0) {
    return vec3();
  }

  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];
  const u = vec3(...uq.slice(0, 3));
  const s = uq[3];
  return vec3.add(
    vec3.add(
      vec3.mul(u, 2 * vec3.dot(u, v)),
      vec3.mul(v, s * s - vec3.dot(u, u))
    ),
    vec3.mul(vec3.cross(u, v), 2 * s)
  );
};

/**
 * Rotate a vector using Euler angles
 * @param {vec3} a The vector to rotate
 * @param {vec3} e The Euler angles to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);

/**
 * Get the cross product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {vec3} a × b
 */
vec3.cross = (a, b) => vec3(
  a.y * b.z - a.z * b.y,
  a.z * b.x - a.x * b.z,
  a.x * b.y - a.y * b.x
);

/**
 * Check if two vectors are equal
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;

/**
 * Get the angle of a vector from the x axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radx = a => Math.atan2(a.z, a.y);

/**
 * Get the angle of a vector from the y axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.rady = a => Math.atan2(a.x, a.y);

/**
 * Get the angle of a vector from the z axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radz = a => Math.atan2(a.y, a.z);

/**
 * Copy a vector
 * @param {vec3} a The vector to copy
 * @return {vec3} A copy of vector a
 */
vec3.cpy = a => vec3(a);

/**
 * A function to call on each component of a 3d vector
 * @callback vec3MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y' | 'z'} label The component label (x, y or z)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec3} a Vector a
 * @param {vec3MapCallback} f The function to call on each component of the vector
 * @return {vec3} Vector a mapped through f
 */
vec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });

/**
 * Convert a vector into a string
 * @param {vec3} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x`, `y` or `z`
 * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)
 * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)
 * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec3} a The vector to swizzle
 * @param {string} [s='...'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec3(3, -2, 1);
 * vec3.swiz(a, 'x');     // [3]
 * vec3.swiz(a, 'zyx');   // [1, -2, 3]
 * vec3.swiz(a, 'xYZ');   // [3, 2, -1]
 * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]
 * vec3.swiz(a, 'x.x');   // [3, -2, 3]
 * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]
 */
vec3.swiz = (a, s = '...') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': case 'r': result.push(a.x); break;
      case 'y': case 'v': case 'g': result.push(a.y); break;
      case 'z': case 'w': case 'b': result.push(a.z); break;
      case 'X': case 'U': case 'R': result.push(-a.x); break;
      case 'Y': case 'V': case 'G': result.push(-a.y); break;
      case 'Z': case 'W': case 'B': result.push(-a.z); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 3d vector
 * @typedef {Object} polarCoordinates3d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The tilt angle of the vector
 * @property {number} phi The pan angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec3} a The vector to convert
 * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector
 */
vec3.polar = a => {
  let r = vec3.len(a),
    theta = Math.acos(a.y / r),
    phi = Math.atan2(a.z, a.x);
  return { r, theta, phi };
};

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The tilt of the vector
 * @param {number} phi The pan of the vector
 * @return {vec3} A vector with the given angle and magnitude
 */
vec3.fromPolar = (r, theta, phi) => {
  const sinTheta = Math.sin(theta);
  return vec3(
    r * sinTheta * Math.cos(phi),
    r * Math.cos(theta),
    r * sinTheta * Math.sin(phi)
  );
};

/**
 * A matrix
 * @typedef {Object} mat
 * @property {number} m The number of rows in the matrix
 * @property {number} n The number of columns in the matrix
 * @property {Array<number>} entries The matrix values
 */

/**
 * Create a new matrix
 * @param {number} [m=4] The number of rows
 * @param {number} [n=4] The number of columns
 * @param {Array<number>} [entries=[]] Matrix values in reading order
 * @return {mat} A new matrix
 */
const mat = (m = 4, n = 4, entries = []) => ({
  m, n,
  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)
});

/**
 * Get an identity matrix of size n
 * @param {number} n The size of the matrix
 * @return {mat} An identity matrix
 */
mat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));

/**
 * Get an entry from a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {number} The value at position (i, j) in matrix a
 */
mat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];

/**
 * Set an entry of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @param {number} v The value to set in matrix a
 */
mat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };

/**
 * Get a row from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} m The row offset
 * @return {Array<number>} Row m from matrix a
 */
mat.row = (a, m) => {
  const s = (m - 1) * a.n;
  return a.entries.slice(s, s + a.n);
};

/**
 * Get a column from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} n The column offset
 * @return {Array<number>} Column n from matrix a
 */
mat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);

/**
 * Add matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a + b
 */
mat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);

/**
 * Subtract matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a - b
 */
mat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);

/**
 * Multiply matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat|false} ab or false if the matrices cannot be multiplied
 */
mat.mul = (a, b) => {
  if (a.n !== b.m) { return false; }
  const result = mat(a.m, b.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= b.n; j++) {
      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));
    }
  }
  return result;
};

/**
 * Multiply a matrix by a vector
 * @param {mat} a Matrix a
 * @param {vec2|vec3|number[]} b Vector b
 * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied
 */
mat.mulv = (a, b) => {
  let n, bb, rt;
  if (_vec_is_vec3(b)) {
    bb = vec3.components(b);
    n = 3;
    rt = vec3.fromComponents;
  } else if (_vec_is_vec2(b)) {
    bb = vec2.components(b);
    n = 2;
    rt = vec2.fromComponents;
  } else {
    bb = b;
    n = b.length ?? 0;
    rt = v => v;
  }
  if (a.n !== n) { return false; }
  const result = [];
  for (let i = 1; i <= a.m; i++) {
    result.push(_vec_dot(mat.row(a, i), bb));
  }
  return rt(result);
}

/**
 * Scale a matrix
 * @param {mat} a Matrix a
 * @param {number} b Scalar b
 * @return {mat} a * b
 */
mat.scale = (a, b) => mat.map(a, v => v * b);

/**
 * Transpose a matrix
 * @param {mat} a The matrix to transpose
 * @return {mat} A transposed matrix
 */
mat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());

/**
 * Get the minor of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square
 */
mat.minor = (a, i, j) => {
  if (a.m !== a.n) { return false; }
  const entries = [];
  for (let ii = 1; ii <= a.m; ii++) {
    if (ii === i) { continue; }
    for (let jj = 1; jj <= a.n; jj++) {
      if (jj === j) { continue; }
      entries.push(mat.get(a, ii, jj));
    }
  }
  return mat(a.m - 1, a.n - 1, entries);
};

/**
 * Get the determinant of a matrix
 * @param {mat} a Matrix a
 * @return {number|false} |a| or false if the matrix is not square
 */
mat.det = a => {
  if (a.m !== a.n) { return false; }
  if (a.m === 1) {
    return a.entries[0];
  }
  if (a.m === 2) {
    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];
  }
  let total = 0, sign = 1;
  for (let j = 1; j <= a.n; j++) {
    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));
    sign *= -1;
  }
  return total;
};

/**
 * Normalise a matrix
 * @param {mat} a The matrix to normalise
 * @return {mat|false} ^a or false if the matrix is not square
 */
mat.nor = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  return mat.map(a, i => i * d);
};

/**
 * Get the adjugate of a matrix
 * @param {mat} a The matrix from which to get the adjugate
 * @return {mat} The adjugate of a
 */
mat.adj = a => {
  const minors = mat(a.m, a.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= a.n; j++) {
      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));
    }
  }
  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));
  return mat.trans(cofactors);
};

/**
 * Get the inverse of a matrix
 * @param {mat} a The matrix to invert
 * @return {mat|false} a^-1 or false if the matrix has no inverse
 */
mat.inv = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  if (d === 0) { return false; }
  return mat.scale(mat.adj(a), 1 / d);
};

/**
 * Check if two matrices are equal
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {boolean} True if matrices a and b are identical, false otherwise
 */
mat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);

/**
 * Copy a matrix
 * @param {mat} a The matrix to copy
 * @return {mat} A copy of matrix a
 */
mat.cpy = a => mat(a.m, a.n, [...a.entries]);

/**
 * A function to call on each entry of a matrix
 * @callback matrixMapCallback
 * @param {number} value The entry value
 * @param {number} index The entry index
 * @param {Array<number>} entries The array of matrix entries
 * @return {number} The mapped entry
 */

/**
 * Call a function on each entry of a matrix and build a new matrix from the results
 * @param {mat} a Matrix a
 * @param {matrixMapCallback} f The function to call on each entry of the matrix
 * @return {mat} Matrix a mapped through f
 */
mat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));

/**
 * Convert a matrix into a string
 * @param {mat} a The matrix to convert
 * @param {string} [ms=', '] The separator string for columns
 * @param {string} [ns='\n'] The separator string for rows
 * @return {string} A string representation of the matrix
 */
mat.str = (a, ms = ', ', ns = '\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);

if (true) {
  module.exports = { vec2, vec3, mat };
}


/***/ }),

/***/ "./node_modules/poly-decomp/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/poly-decomp/src/index.js ***!
  \***********************************************/
/***/ ((module) => {

module.exports = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    removeDuplicatePoints: polygonRemoveDuplicatePoints,
    makeCCW: polygonMakeCCW
};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
function lineInt(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!scalar_eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
}

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
function lineSegmentsIntersect(p1, p2, q1, q2){
	var dx = p2[0] - p1[0];
	var dy = p2[1] - p1[1];
	var da = q2[0] - q1[0];
	var db = q2[1] - q1[1];

	// segments are parallel
	if((da*dy - db*dx) === 0){
		return false;
	}

	var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
	var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);

	return (s>=0 && s<=1 && t>=0 && t<=1);
}

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
function triangleArea(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
}

function isLeft(a,b,c){
    return triangleArea(a,b,c) > 0;
}

function isLeftOn(a,b,c) {
    return triangleArea(a, b, c) >= 0;
}

function isRight(a,b,c) {
    return triangleArea(a, b, c) < 0;
}

function isRightOn(a,b,c) {
    return triangleArea(a, b, c) <= 0;
}

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
function collinear(a,b,c,thresholdAngle) {
    if(!thresholdAngle){
        return triangleArea(a, b, c) === 0;
    } else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
}

function sqdist(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
function polygonAt(polygon, i){
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
}

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
function polygonClear(polygon){
    polygon.length = 0;
}

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
function polygonAppend(polygon, poly, from, to){
    for(var i=from; i<to; i++){
        polygon.push(poly[i]);
    }
}

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
function polygonMakeCCW(polygon){
    var br = 0,
        v = polygon;

    // find bottom right point
    for (var i = 1; i < polygon.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
        polygonReverse(polygon);
        return true;
    } else {
        return false;
    }
}

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
function polygonReverse(polygon){
    var tmp = [];
    var N = polygon.length;
    for(var i=0; i!==N; i++){
        tmp.push(polygon.pop());
    }
    for(var i=0; i!==N; i++){
		polygon[i] = tmp[i];
    }
}

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
function polygonIsReflex(polygon, i){
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
}

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee(polygon, a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
        return false;
    }
    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
    for (var i = 0; i !== polygon.length; ++i) { // for each edge
        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges
            continue;
        }
        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge
            l1[0] = polygonAt(polygon, a);
            l1[1] = polygonAt(polygon, b);
            l2[0] = polygonAt(polygon, i);
            l2[1] = polygonAt(polygon, i + 1);
            p = lineInt(l1,l2);
            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
}

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee2
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee2(polygon, a,b) {
    // for each edge
    for (var i = 0; i !== polygon.length; ++i) {
        // ignore incident edges
        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){
            continue;
        }
        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){
            return false;
        }
    }
    return true;
}

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
function polygonCopy(polygon, i,j,targetPoly){
    var p = targetPoly || [];
    polygonClear(p);
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++){
            p.push(polygon[k]);
        }

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++){
            p.push(polygon[k]);
        }

        // Insert vertices i to end
        for(var k=i; k<polygon.length; k++){
            p.push(polygon[k]);
        }
    }

    return p;
}

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
function polygonGetCutEdges(polygon) {
    var min=[], tmp1=[], tmp2=[], tmpPoly = [];
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(polygon, i)) {
            for (var j = 0; j < polygon.length; ++j) {
                if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));

                    for(var k=0; k<tmp2.length; k++){
                        tmp1.push(tmp2[k]);
                    }

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
                    }
                }
            }
        }
    }

    return min;
}

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
function polygonDecomp(polygon){
    var edges = polygonGetCutEdges(polygon);
    if(edges.length > 0){
        return polygonSlice(polygon, edges);
    } else {
        return [polygon];
    }
}

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
function polygonSlice(polygon, cutEdges){
    if(cutEdges.length === 0){
		return [polygon];
    }
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){

        var polys = [polygon];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = polygonSlice(poly, cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = polygon.indexOf(cutEdge[0]);
        var j = polygon.indexOf(cutEdge[1]);

        if(i !== -1 && j !== -1){
            return [polygonCopy(polygon, i,j),
                    polygonCopy(polygon, j,i)];
        } else {
            return false;
        }
    }
}

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
function polygonIsSimple(polygon){
    var path = polygon, i;
    // Check
    for(i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(i=1; i<path.length-2; i++){
        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
}

function getIntersectionPoint(p1, p2, q1, q2, delta){
	delta = delta || 0;
	var a1 = p2[1] - p1[1];
	var b1 = p1[0] - p2[0];
	var c1 = (a1 * p1[0]) + (b1 * p1[1]);
	var a2 = q2[1] - q1[1];
	var b2 = q1[0] - q2[0];
	var c2 = (a2 * q1[0]) + (b2 * q1[1]);
	var det = (a1 * b2) - (a2 * b1);

	if(!scalar_eq(det,0,delta)){
		return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];
	} else {
		return [0,0];
    }
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
function polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!=="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=[], upperPoly=[]; // polygons
    var poly = polygon,
        v = polygon;

    if(v.length < 3){
		return result;
    }

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < polygon.length; ++j) {
                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly
                        d = sqdist(poly[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex === (upperIndex + 1) % polygon.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, i, upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    if (lowerIndex !== 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        polygonAppend(lowerPoly, poly,i,poly.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly,0,upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+polygon.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (
                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&
                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))
                    ) {
                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                        if (d < closestDist && polygonCanSee2(poly, i, j)) {
                            closestDist = d;
                            closestIndex = j % polygon.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly,i,closestIndex+1);
                    if (closestIndex !== 0){
                        polygonAppend(upperPoly, poly,closestIndex,v.length);
                    }
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        polygonAppend(lowerPoly, poly,i,v.length);
                    }
                    polygonAppend(lowerPoly, poly,0,closestIndex+1);
                    polygonAppend(upperPoly, poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.length < upperPoly.length) {
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(polygon);

    return result;
}

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
function polygonRemoveCollinearPoints(polygon, precision){
    var num = 0;
    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){
        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){
            // Remove the middle point
            polygon.splice(i%polygon.length,1);
            num++;
        }
    }
    return num;
}

/**
 * Remove duplicate points in the polygon.
 * @method removeDuplicatePoints
 * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.
 */
function polygonRemoveDuplicatePoints(polygon, precision){
    for(var i=polygon.length-1; i>=1; --i){
        var pi = polygon[i];
        for(var j=i-1; j>=0; --j){
            if(points_eq(pi, polygon[j], precision)){
                polygon.splice(i,1);
                continue;
            }
        }
    }
}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function scalar_eq(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) <= precision;
}

/**
 * Check if two points are equal
 * @static
 * @method points_eq
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function points_eq(a,b,precision){
    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);
}


/***/ }),

/***/ "./src/2d/index.ts":
/*!*************************!*\
  !*** ./src/2d/index.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_62156__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.distance = distance;
exports.angle = angle;
exports.angleBetween = angleBetween;
exports.pointsAreCollinear = pointsAreCollinear;
exports.lineToRay = lineToRay;
exports.rayToLine = rayToLine;
exports.aabb = aabb;
exports.aabbToRectangle = aabbToRectangle;
exports.aabbsOverlap = aabbsOverlap;
exports.pointInAABB = pointInAABB;
exports.rectangleIsRotated = rectangleIsRotated;
exports.rectangleVertices = rectangleVertices;
exports.verticesToEdges = verticesToEdges;
exports.polygonIsConvex = polygonIsConvex;
exports.polygonSelfIntersects = polygonSelfIntersects;
exports.polygonIsValid = polygonIsValid;
exports.polygonWindingOrder = polygonWindingOrder;
exports.polygonArea = polygonArea;
exports.polygonCentroid = polygonCentroid;
exports.polygonConvexHull = polygonConvexHull;
exports.optimisePolygon = optimisePolygon;
exports.decomposePolygon = decomposePolygon;
exports.pointOnRay = pointOnRay;
exports.pointOnLine = pointOnLine;
exports.pointInCircle = pointInCircle;
exports.pointInRectangle = pointInRectangle;
exports.pointInPolygon = pointInPolygon;
exports.rayTraverseGrid = rayTraverseGrid;
exports.rayIntersectsRay = rayIntersectsRay;
exports.rayIntersectsLine = rayIntersectsLine;
exports.rayIntersectsCircle = rayIntersectsCircle;
exports.rayIntersectsRectangle = rayIntersectsRectangle;
exports.rayIntersectsPolygon = rayIntersectsPolygon;
exports.lineIntersectsRay = lineIntersectsRay;
exports.lineIntersectsLine = lineIntersectsLine;
exports.lineIntersectsCircle = lineIntersectsCircle;
exports.lineIntersectsRectangle = lineIntersectsRectangle;
exports.lineIntersectsPolygon = lineIntersectsPolygon;
exports.circleIntersectsCircle = circleIntersectsCircle;
exports.circleIntersectsRectangle = circleIntersectsRectangle;
exports.circleIntersectsPolygon = circleIntersectsPolygon;
exports.rectangleIntersectsRectangle = rectangleIntersectsRectangle;
exports.rectangleIntersectsPolygon = rectangleIntersectsPolygon;
exports.polygonIntersectsPolygon = polygonIntersectsPolygon;
const utils_1 = __nested_webpack_require_62156__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __nested_webpack_require_62156__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const decomp = __importStar(__nested_webpack_require_62156__(/*! poly-decomp */ "./node_modules/poly-decomp/src/index.js"));
const utilities_1 = __nested_webpack_require_62156__(/*! ../utilities */ "./src/utilities/index.ts");
const constants = __importStar(__nested_webpack_require_62156__(/*! ../utilities/constants */ "./src/utilities/constants.ts"));
const types_1 = __nested_webpack_require_62156__(/*! ./types */ "./src/2d/types.ts");
__exportStar(__nested_webpack_require_62156__(/*! ./types */ "./src/2d/types.ts"), exports);
/**
 * Contents
 *
 * Utilities
 * @see distance
 * @see angle
 * @see angleBetween
 * @see pointsAreCollinear
 *
 * Line and ray utilities
 * @see lineToRay
 * @see rayToLine
 *
 * AABBs
 * @see aabb
 * @see aabbToRectangle
 * @see aabbsOverlap
 * @see pointInAABB
 *
 * Rectangle utilities
 * @see rectangleIsRotated
 * @see rectangleVertices
 *
 * Polygon utilities
 * @see verticesToEdges
 * @see findOuterEdges (not exported)
 * @see polygonIsConvex
 * @see polygonSelfIntersects
 * @see polygonIsValid
 * @see polygonWindingOrder
 * @see polygonArea
 * @see polygonCentroid
 * @see polygonConvexHull
 * @see removeDuplicateVertices (not exported)
 * @see removeDuplicateAdjacentVertices (not exported)
 * @see removeCollinearVertices (not exported)
 * @see optimisePolygon
 * @see decomposePolygon
 *
 * Points
 * @see pointOnRay
 * @see pointOnLine
 * @see pointInCircle
 * @see pointInRectangle
 * @see pointInPolygon
 *
 * Rays
 * @see rayTraverseGrid
 * @see rayIntersectsRay
 * @see rayIntersectsLine
 * @see rayIntersectsCircle
 * @see rayIntersectsRectangle
 * @see rayIntersectsValidConvexPolygonEdges (not exported)
 * @see rayIntersectsPolygon
 *
 * Lines
 * @see lineIntersectsRay
 * @see lineIntersectsLine
 * @see lineIntersectsCircle
 * @see lineIntersectsRectangle
 * @see lineIntersectsValidConvexPolygonEdges (not exported)
 * @see lineIntersectsPolygon
 *
 * Circles
 * @see circleIntersectsCircle
 * @see circleIntersectsRectangle
 * @see circleIntersectsValidConvexPolygonEdges (not exported)
 * @see circleIntersectsPolygon
 *
 * Rectangles
 * @see projectVerticesToAxis (not exported)
 * @see rectangleIntersectsRectangle
 * @see rectangleIntersectsPolygon
 *
 * Polygons
 * @see polygonIntersectsPolygon
 */
/**
 * Calculate the distance between two points
 */
function distance(a, b) {
    return vec_1.vec2.len(vec_1.vec2.sub(a, b));
}
/**
 * Calculate the clockwise angle from point a to point b
 *
 * The result is in radians and ranges from 0 to 2π (360 degrees)
 *
 * Returns 0 if the vectors are equal
 */
function angle(a, b) {
    if ((0, utilities_1.vectorsAlmostEqual)(a, b)) {
        return 0;
    }
    const theta = vec_1.vec2.rad(vec_1.vec2.sub(b, a)) % (2 * Math.PI);
    if (theta < 0) {
        return theta + 2 * Math.PI; // Ensure angle is positive
    }
    return theta;
}
/**
 * Calculate the clockwise angle between two lines or rays
 *
 * Returns 0 if either line is zero-length
 */
function angleBetween(a, b) {
    let aLine = (0, types_1.isRay)(a) ? rayToLine(a, 1) : a;
    let bLine = (0, types_1.isRay)(b) ? rayToLine(b, 1) : b;
    if ((0, utilities_1.vectorAlmostZero)(vec_1.vec2.sub(aLine.end, aLine.start)) ||
        (0, utilities_1.vectorAlmostZero)(vec_1.vec2.sub(bLine.end, bLine.start))) {
        return 0; // Zero-length line
    }
    const dirA = vec_1.vec2.nor(vec_1.vec2.sub(aLine.end, aLine.start));
    const dirB = vec_1.vec2.nor(vec_1.vec2.sub(bLine.end, bLine.start));
    // Clamp dot product to [-1, 1] to avoid NaN due to floating-point errors
    const dot = (0, utils_1.clamp)(vec_1.vec2.dot(dirA, dirB), -1, 1);
    const cross = vec_1.vec2.cross(dirA, dirB);
    const angle = Math.atan2(cross, dot);
    return angle < 0 ? angle + 2 * Math.PI : angle; // Ensure angle is positive
}
/**
 * Check if three points in 2D space are collinear
 */
function pointsAreCollinear(a, b, c) {
    // Check if the area of the triangle formed by the points is zero
    const area = 0.5 * Math.abs(a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));
    return Math.abs(area) < constants.EPSILON;
}
/**
 * Convert a line segment to a ray
 */
function lineToRay(line) {
    return {
        origin: line.start,
        direction: vec_1.vec2.nor(vec_1.vec2.sub(line.end, line.start)),
    };
}
/**
 * Convert a ray to a line segment
 */
function rayToLine(ray, length = 1) {
    return {
        start: ray.origin,
        end: vec_1.vec2.add(ray.origin, vec_1.vec2.mul(ray.direction, length)),
    };
}
/**
 * Get the bounding box (AABB) of a geometric object
 */
function aabb(o) {
    if ((0, types_1.isLine)(o)) {
        return {
            position: (0, vec_1.vec2)(Math.min(o.start.x, o.end.x), Math.min(o.start.y, o.end.y)),
            size: (0, vec_1.vec2)(Math.abs(o.end.x - o.start.x), Math.abs(o.end.y - o.start.y)),
        };
    }
    if ((0, types_1.isRectangle)(o)) {
        const vertices = rectangleVertices(o);
        const position = (0, vec_1.vec2)(Math.min(...vertices.map(v => v.x)), Math.min(...vertices.map(v => v.y)));
        return {
            position,
            size: (0, vec_1.vec2)(Math.max(...vertices.map(v => v.x)) - position.x, Math.max(...vertices.map(v => v.y)) - position.y),
        };
    }
    if ((0, types_1.isCircle)(o)) {
        return {
            position: vec_1.vec2.sub(o.position, (0, vec_1.vec2)(o.radius, o.radius)),
            size: (0, vec_1.vec2)(o.radius * 2),
        };
    }
    if ((0, types_1.isPolygon)(o)) {
        const position = (0, vec_1.vec2)(Math.min(...o.vertices.map(v => v.x)), Math.min(...o.vertices.map(v => v.y)));
        return {
            position,
            size: (0, vec_1.vec2)(Math.max(...o.vertices.map(v => v.x)) - position.x, Math.max(...o.vertices.map(v => v.y)) - position.y),
        };
    }
    return null;
}
/**
 * Convert an AABB to a rectangle
 */
function aabbToRectangle(aabb) {
    return {
        position: vec_1.vec2.add(aabb.position, vec_1.vec2.div(aabb.size, 2)),
        size: aabb.size,
        rotation: 0,
    };
}
/**
 * Check if two AABBs overlap and return the overlapping area if so
 */
function aabbsOverlap(a, b) {
    const overlapX = (0, utilities_1.overlapInterval)({ min: a.position.x, max: a.position.x + a.size.x }, { min: b.position.x, max: b.position.x + b.size.x });
    const overlapY = (0, utilities_1.overlapInterval)({ min: a.position.y, max: a.position.y + a.size.y }, { min: b.position.y, max: b.position.y + b.size.y });
    // If the AABBs don't overlap on one or more axes, they don't overlap at all
    if (!overlapX || !overlapY) {
        return { intersects: false };
    }
    return {
        intersects: true,
        overlap: {
            position: (0, vec_1.vec2)(overlapX.min, overlapY.min),
            size: (0, vec_1.vec2)(overlapX.max - overlapX.min, overlapY.max - overlapY.min),
        },
    };
}
/**
 * Check if a point is inside an AABB
 *
 * This should be faster than pointInRectangle since we don't need to consider
 * rotation
 */
function pointInAABB(point, aabb) {
    const { position, size } = aabb;
    const min = position;
    const max = vec_1.vec2.add(position, size);
    // Check if the point is inside the AABB
    const intersects = (0, utilities_1.valueInInterval)(point.x, { min: min.x, max: max.x }) &&
        (0, utilities_1.valueInInterval)(point.y, { min: min.y, max: max.y });
    // Find the closest point on the AABB perimeter to the given point
    let closestPoint;
    if (!intersects) {
        // If the point is outside, clamp to the box
        closestPoint = (0, vec_1.vec2)((0, utils_1.clamp)(point.x, min.x, max.x), (0, utils_1.clamp)(point.y, min.y, max.y));
    }
    else {
        // If the point is inside, project to the nearest edge
        const distances = [
            { x: min.x, y: point.y, d: Math.abs(point.x - min.x) }, // left
            { x: max.x, y: point.y, d: Math.abs(point.x - max.x) }, // right
            { x: point.x, y: min.y, d: Math.abs(point.y - min.y) }, // top
            { x: point.x, y: max.y, d: Math.abs(point.y - max.y) }, // bottom
        ];
        const nearest = distances.reduce((a, b) => (a.d < b.d ? a : b));
        closestPoint = (0, vec_1.vec2)(nearest.x, nearest.y);
    }
    // Calculate the distance from the point to the closest point
    const distance = vec_1.vec2.len(vec_1.vec2.sub(point, closestPoint));
    // If the point is inside, distance should be negative
    return {
        intersects,
        closestPoint,
        distance: intersects ? -distance : distance,
    };
}
/**
 * Check if a rectangle is rotated
 */
function rectangleIsRotated(rectangle) {
    return (rectangle.rotation !== undefined &&
        Math.abs(rectangle.rotation) > constants.EPSILON);
}
/**
 * Get the vertices of a rectangle
 *
 * Vertices will be returned in clockwise order starting at the top-left:
 * - Top-left
 * - Top-right
 * - Bottom-right
 * - Bottom-left
 */
function rectangleVertices(rectangle) {
    const { position, size, rotation = 0 } = rectangle;
    const halfSize = vec_1.vec2.div(size, 2);
    // Calculate the four corners of the rectangle
    let topLeftOffset = vec_1.vec2.fromComponents(vec_1.vec2.swiz(halfSize, 'XY'));
    let topRightOffset = vec_1.vec2.fromComponents(vec_1.vec2.swiz(halfSize, 'xY'));
    let bottomRightOffset = vec_1.vec2.fromComponents(vec_1.vec2.swiz(halfSize, 'xy'));
    let bottomLeftOffset = vec_1.vec2.fromComponents(vec_1.vec2.swiz(halfSize, 'Xy'));
    // Rotate the offsets if the rectangle is rotated
    if (rectangleIsRotated(rectangle)) {
        topLeftOffset = vec_1.vec2.rot(topLeftOffset, rotation);
        topRightOffset = vec_1.vec2.rot(topRightOffset, rotation);
        bottomRightOffset = vec_1.vec2.rot(bottomRightOffset, rotation);
        bottomLeftOffset = vec_1.vec2.rot(bottomLeftOffset, rotation);
    }
    return [
        vec_1.vec2.add(position, topLeftOffset),
        vec_1.vec2.add(position, topRightOffset),
        vec_1.vec2.add(position, bottomRightOffset),
        vec_1.vec2.add(position, bottomLeftOffset),
    ];
}
/**
 * Convert a list of vertices to a list of edges
 */
function verticesToEdges(vertices) {
    const edges = [];
    for (let i = 0; i < vertices.length; i++) {
        const start = vertices[i];
        const end = (0, utils_1.at)(vertices, i + 1);
        edges.push({ start, end });
    }
    return edges;
}
/**
 * Find outer edges in a list of polygons
 *
 * We assume that the polygons were the result of decomposing a concave polygon
 * into a set of convex polygons, and as such they are all convex and share
 * one or more edges
 *
 * This means we can identify outer edges because they'll only appear once
 * in the list of edges, while inner edges will appear twice (once for each
 * polygon that shares them)
 */
function findOuterEdges(polygons) {
    const allEdges = polygons.flatMap(polygon => verticesToEdges(polygon.vertices));
    // Edges are the duplicates if they overlap but have no intersection point
    // (this implies that they have infinitely many intersection points)
    const edgesOverlap = (a, b) => {
        const result = lineIntersectsLine(a, b);
        if (result.intersects && !result.intersectionPoint) {
            // Edge case: if the edges intersect and have no intersect point, but
            // share only one endpoint, then they aren't considered overlapping
            if (((0, utilities_1.vectorsAlmostEqual)(a.end, b.start) &&
                !(0, utilities_1.vectorsAlmostEqual)(a.start, b.end)) ||
                ((0, utilities_1.vectorsAlmostEqual)(a.start, b.end) &&
                    !(0, utilities_1.vectorsAlmostEqual)(a.end, b.start))) {
                return false;
            }
            return true;
        }
        return false;
    };
    // Filter out the edges that appear more than once
    const result = [];
    for (const edge of allEdges) {
        if (!result.some(e => edgesOverlap(e, edge)) &&
            !allEdges.some(e => e !== edge && edgesOverlap(e, edge))) {
            result.push(edge); // This edge is an outer edge
        }
    }
    return result;
}
/**
 * Check if a polygon is convex
 *
 * Returns null if the polygon is invalid
 */
function polygonIsConvex(polygon) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    let sign = 0;
    for (let i = 0; i < polygon.vertices.length; i++) {
        const a = polygon.vertices[i];
        const b = (0, utils_1.at)(polygon.vertices, i + 1);
        const c = (0, utils_1.at)(polygon.vertices, i + 2);
        const crossProduct = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        if (crossProduct !== 0) {
            if (sign === 0) {
                sign = Math.sign(crossProduct);
            }
            else if (Math.sign(crossProduct) !== sign) {
                return false; // Found a change in sign, polygon is not convex
            }
        }
    }
    return true; // All cross products have the same sign, polygon is convex
}
/**
 * Check if a polygon self-intersects
 */
function polygonSelfIntersects(polygon) {
    if (polygon.vertices.length < 3) {
        return false; // A polygon must have at least 3 vertices
    }
    const n = polygon.vertices.length;
    for (let i = 0; i < n; i++) {
        const a = polygon.vertices[i];
        const b = (0, utils_1.at)(polygon.vertices, i + 1);
        for (let j = i + 2; j < n; j++) {
            const c = polygon.vertices[j];
            const d = (0, utils_1.at)(polygon.vertices, j + 1);
            // Skip adjacent edges
            if (i === 0 && j === n - 1) {
                continue;
            }
            // Check if the segments (a, b) and (c, d) intersect
            const { intersects } = lineIntersectsLine({ start: a, end: b }, { start: c, end: d });
            if (intersects) {
                return true; // Found an intersection, polygon self-intersects
            }
        }
    }
    return false; // No intersections found, polygon does not self-intersect
}
/**
 * Check if a polygon is valid
 *
 * A polygon is valid if it has at least 3 vertices and does not
 * self-intersect
 */
function polygonIsValid(polygon) {
    return polygon.vertices.length >= 3 && !polygonSelfIntersects(polygon);
}
/**
 * Determine the winding order of a polygon's vertices
 *
 * Returns 'clockwise' or 'counter-clockwise' depending on the chosen
 * coordinate system
 *
 * By default we use the 'screen' coordinate system (y increases downwards)
 *
 * Returns null if the polygon is invalid
 */
function polygonWindingOrder(polygon, options) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    let sum = 0;
    for (let i = 0; i < polygon.vertices.length; i++) {
        const a = polygon.vertices[i];
        const b = (0, utils_1.at)(polygon.vertices, i + 1);
        sum += (b.x - a.x) * (b.y + a.y);
    }
    const coordinateSystem = (options === null || options === void 0 ? void 0 : options.coordinateSystem) || 'screen';
    switch (coordinateSystem) {
        case 'cartesian':
            return sum > 0 ? 'clockwise' : 'counter-clockwise';
        case 'screen':
            return sum > 0 ? 'counter-clockwise' : 'clockwise';
        default:
            return null;
    }
}
/**
 * Calculate the area of a polygon
 *
 * Returns null if the polygon is invalid
 */
function polygonArea(polygon) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    let area = 0;
    for (let i = 0; i < polygon.vertices.length; i++) {
        const a = polygon.vertices[i];
        const b = (0, utils_1.at)(polygon.vertices, i + 1);
        area += vec_1.vec2.cross(a, b);
    }
    return Math.abs(area) / 2;
}
/**
 * Calculate the centroid of a polygon
 *
 * Returns null if the polygon is invalid or degenerate (i.e. all vertices are
 * collinear)
 */
function polygonCentroid(polygon) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    if (polygon.vertices.every((v, i, a) => pointsAreCollinear(v, (0, utils_1.at)(a, i + 1), (0, utils_1.at)(a, i + 2)))) {
        return null; // All vertices are collinear
    }
    return vec_1.vec2.div([...polygon.vertices].reduce((a, c) => vec_1.vec2.add(a, c), (0, vec_1.vec2)()), polygon.vertices.length);
}
/**
 * Calculate the convex hull of a polygon
 */
function polygonConvexHull(polygon, options) {
    var _a;
    if (!polygonIsValid(polygon)) {
        return null;
    }
    if (polygonIsConvex(polygon)) {
        return polygon; // The polygon is already convex
    }
    const keepWindingOrder = (_a = options === null || options === void 0 ? void 0 : options.keepWindingOrder) !== null && _a !== void 0 ? _a : true;
    const originalWindingOrder = polygonWindingOrder(polygon);
    // Andrew's monotone chain algorithm for convex hull
    // Sort vertices lexicographically (first by x, then by y)
    const sorted = [...polygon.vertices].sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
    const lower = [];
    for (const p of sorted) {
        while (lower.length >= 2 &&
            vec_1.vec2.cross(vec_1.vec2.sub(lower[lower.length - 1], lower[lower.length - 2]), vec_1.vec2.sub(p, lower[lower.length - 1])) <= 0) {
            lower.pop();
        }
        lower.push(p);
    }
    const upper = [];
    for (let i = sorted.length - 1; i >= 0; --i) {
        const p = sorted[i];
        while (upper.length >= 2 &&
            vec_1.vec2.cross(vec_1.vec2.sub(upper[upper.length - 1], upper[upper.length - 2]), vec_1.vec2.sub(p, upper[upper.length - 1])) <= 0) {
            upper.pop();
        }
        upper.push(p);
    }
    // Remove the last point of each half because it's repeated at the start of
    // the other
    lower.pop();
    upper.pop();
    const hull = lower.concat(upper);
    if (hull.length < 3) {
        return null;
    }
    // Optionally ensure the winding order is preserved
    if (keepWindingOrder &&
        polygonWindingOrder({ vertices: hull }) !== originalWindingOrder) {
        hull.reverse();
    }
    return {
        vertices: removeDuplicateVertices(hull),
    };
}
/**
 * Remove duplicate vertices from a list of vertices
 */
function removeDuplicateVertices(vertices) {
    const result = [];
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const current = vertices[i];
        if (!result.some(v => (0, utilities_1.vectorsAlmostEqual)(current, v))) {
            result.push(current);
        }
    }
    return result;
}
/**
 * Remove duplicate adjacent vertices from a list of vertices
 */
function removeDuplicateAdjacentVertices(vertices) {
    const result = [];
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const current = vertices[i];
        const next = (0, utils_1.at)(vertices, i + 1);
        if (!(0, utilities_1.vectorsAlmostEqual)(current, next)) {
            result.push(current);
        }
    }
    return result;
}
/**
 * Remove collinear vertices from a list of vertices
 */
function removeCollinearVertices(vertices) {
    const result = [];
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const a = (0, utils_1.at)(vertices, i - 1);
        const b = vertices[i];
        const c = (0, utils_1.at)(vertices, i + 1);
        // Skip collinear points
        if (pointsAreCollinear(a, b, c)) {
            continue;
        }
        result.push(b);
    }
    return result;
}
/**
 * Optimise a polygon by removing collinear vertices and duplicate adjacent
 * vertices
 */
function optimisePolygon(polygon) {
    // Duplicate adjacent vertices will count the polygon as self-intersecting,
    // so skip that check for now and only check the number of vertices
    if (polygon.vertices.length < 3) {
        return null;
    }
    const optimisedVertices = removeCollinearVertices(removeDuplicateAdjacentVertices(polygon.vertices));
    // If we have less than 3 vertices after optimisation, return null
    if (optimisedVertices.length < 3) {
        return null;
    }
    return { vertices: optimisedVertices };
}
/**
 * Decompose a polygon into a set of convex polygons using the Bayazit
 * algorithm
 *
 * Returns null if the polygon is invalid or cannot be decomposed
 */
function decomposePolygon(polygon, options) {
    var _a;
    if (!polygonIsValid(polygon)) {
        return null;
    }
    if (polygonIsConvex(polygon)) {
        return [polygon]; // The polygon is already convex
    }
    const mode = (options === null || options === void 0 ? void 0 : options.mode) || 'fast';
    const keepWindingOrder = (_a = options === null || options === void 0 ? void 0 : options.keepWindingOrder) !== null && _a !== void 0 ? _a : true;
    const originalWindingOrder = polygonWindingOrder(polygon);
    const vertices = polygon.vertices.map(v => [v.x, v.y]);
    if (originalWindingOrder === 'counter-clockwise') {
        vertices.reverse(); // Ensure clockwise winding
    }
    // Decompose the polygon
    let convexPolygons = [];
    switch (mode) {
        case 'fast':
            convexPolygons = decomp.quickDecomp(vertices);
            break;
        case 'optimal':
            convexPolygons = decomp.decomp(vertices);
            break;
    }
    // Convert the result into a list of Polygon objects
    const result = [];
    for (const convex of convexPolygons) {
        result.push({
            vertices: convex.map(v => (0, vec_1.vec2)(v[0], v[1])),
        });
    }
    // Optionally ensure the winding order is preserved
    if (keepWindingOrder) {
        for (const poly of result) {
            if (polygonWindingOrder(poly) !== originalWindingOrder) {
                poly.vertices.reverse();
            }
        }
    }
    return result.length > 0 ? result : null;
}
/**
 * Check if a point is on a ray
 */
function pointOnRay(point, ray) {
    // Vector from ray origin to point
    const toPoint = vec_1.vec2.sub(point, ray.origin);
    // Get normalized ray direction
    const rayDirection = vec_1.vec2.nor(ray.direction);
    // Project toPoint onto the ray direction
    const projection = vec_1.vec2.dot(toPoint, rayDirection);
    // Calculate closest point on ray
    const closestPoint = vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDirection, Math.max(0, projection)));
    // Calculate distance from point to closest point
    const distance = vec_1.vec2.len(vec_1.vec2.sub(point, closestPoint));
    return {
        // Point is on ray if distance is zero and projection is non-negative
        intersects: distance < constants.EPSILON && projection >= 0,
        closestPoint,
        distance,
    };
}
/**
 * Check if a point intersects a line segment
 */
function pointOnLine(point, line) {
    // Get vector from line start to end
    const lineVector = vec_1.vec2.sub(line.end, line.start);
    // Get normalized line direction
    const lineDirection = vec_1.vec2.nor(lineVector);
    // Get vector from line start to point
    const toPoint = vec_1.vec2.sub(point, line.start);
    // Project toPoint onto the line direction
    const projection = vec_1.vec2.dot(toPoint, lineDirection);
    // Get line length
    const lineLength = vec_1.vec2.len(lineVector);
    // Clamp projection to line segment
    const clampedProjection = Math.max(0, Math.min(lineLength, projection));
    // Calculate closest point on line segment
    const closestPoint = vec_1.vec2.add(line.start, vec_1.vec2.mul(lineDirection, clampedProjection));
    // Calculate distance from point to closest point
    const distance = vec_1.vec2.len(vec_1.vec2.sub(point, closestPoint));
    return {
        // Point is on line if distance is effectively zero
        intersects: distance < constants.EPSILON,
        closestPoint,
        distance,
    };
}
/**
 * Check if a point is inside a circle
 */
function pointInCircle(point, circle) {
    // Calculate vector from circle center to point
    const toPoint = vec_1.vec2.sub(point, circle.position);
    // Calculate distance from point to circle center
    const distanceToCenter = vec_1.vec2.len(toPoint);
    // Check if point is inside the circle
    const intersects = distanceToCenter <= circle.radius;
    // Calculate distance to circle edge
    const distance = intersects
        ? -(circle.radius - distanceToCenter) // Negative if inside
        : distanceToCenter - circle.radius; // Positive if outside
    // Calculate closest point on circle edge
    const closestPoint = vec_1.vec2.add(circle.position, vec_1.vec2.mul(vec_1.vec2.nor(toPoint), circle.radius));
    return {
        intersects,
        closestPoint,
        distance,
    };
}
/**
 * Check if a point is inside a rectangle
 *
 * In cases where the closest point is ambiguous (e.g. corners), the first edge
 * encountered with a closest point will be returned after evaluating edges in
 * this order:
 * top, right, bottom, left (before applying the rectangle's rotation)
 */
function pointInRectangle(point, rectangle) {
    // Edge case: zero-size rectangle
    if ((0, utilities_1.vectorAlmostZero)(rectangle.size)) {
        // If the rectangle has no size, check if the point is at the rectangle's
        // position
        const isAtPosition = (0, utilities_1.vectorsAlmostEqual)(point, rectangle.position);
        return {
            intersects: isAtPosition,
            closestPoint: rectangle.position,
            distance: isAtPosition
                ? 0
                : vec_1.vec2.len(vec_1.vec2.sub(point, rectangle.position)),
        };
    }
    // Convert rectangle to polygon
    const vertices = rectangleVertices(rectangle);
    const polygonResult = pointInPolygon(point, { vertices });
    // We should always have a valid polygon, but just in case...
    if (!polygonResult) {
        throw new Error('Invalid rectangle vertices');
    }
    return polygonResult;
}
/**
 * Check if a point is inside a polygon
 *
 * Returns null if the polygon is invalid
 */
function pointInPolygon(point, polygon) {
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // Find if point is inside polygon using ray casting algorithm
    let inside = false;
    const vertices = polygon.vertices;
    // We'll also keep track of the closest edge while we iterate
    let minDistanceSquared = Infinity;
    let closestPoint = point;
    for (let i = 0; i < vertices.length; i++) {
        const j = (i + 1) % vertices.length;
        const vi = vertices[i];
        const vj = vertices[j];
        // Ray casting algorithm
        if (vi.y > point.y !== vj.y > point.y &&
            point.x < ((vj.x - vi.x) * (point.y - vi.y)) / (vj.y - vi.y) + vi.x) {
            inside = !inside;
        }
        // Find closest point on this edge
        const edge = { start: vi, end: vj };
        const { closestPoint: edgeClosest, distance: edgeDistance } = pointOnLine(point, edge);
        const distanceSquared = edgeDistance * edgeDistance;
        if (distanceSquared < minDistanceSquared) {
            minDistanceSquared = distanceSquared;
            closestPoint = edgeClosest;
        }
    }
    const distance = Math.sqrt(minDistanceSquared);
    return {
        intersects: inside,
        closestPoint,
        distance: inside ? -distance : distance,
    };
}
/**
 * Check which grid cells a ray traverses
 *
 * Based on "A Fast Voxel Traversal Algorithm for Ray Tracing" by Amanatides
 * and Woo
 *
 * We can optionally limit the number of cells traversed by the ray, or set
 * maxCells to -1 to continue traversing until the ray exits the grid (or until
 * we hit the hard limit of 10000 cells).
 */
function rayTraverseGrid(ray, cellSize, gridTopLeft, gridBottomRight, maxCells = -1) {
    if (cellSize <= 0) {
        return { cells: [] }; // Invalid cell size, return empty cells array
    }
    // Set a limit on the number of cells traversed
    const HARD_LIMIT = 10000;
    maxCells = (0, utils_1.clamp)(maxCells === -1 ? HARD_LIMIT : maxCells, 0, HARD_LIMIT);
    if (maxCells <= 0) {
        return { cells: [] }; // No cells to traverse
    }
    // Make sure the grid top-left and bottom-right boundaries are integers
    gridTopLeft = vec_1.vec2.map(gridTopLeft, Math.floor);
    gridBottomRight = vec_1.vec2.map(gridBottomRight, Math.ceil);
    // Normalize ray direction and handle zero components
    const rayDir = vec_1.vec2.nor(ray.direction);
    if ((0, utilities_1.vectorAlmostZero)(rayDir)) {
        return { cells: [] };
    }
    const cells = [];
    // Calculate initial cell coordinates
    let currentCell = vec_1.vec2.map(vec_1.vec2.div(vec_1.vec2.sub(ray.origin, gridTopLeft), cellSize), Math.floor);
    // Calculate grid size in cells
    const gridSize = vec_1.vec2.sub(gridBottomRight, gridTopLeft);
    // If starting point is outside grid bounds, find entry point
    if (currentCell.x < 0 ||
        currentCell.x >= gridSize.x ||
        currentCell.y < 0 ||
        currentCell.y >= gridSize.y) {
        // Use rayIntersectsRectangle to find grid entry point
        const gridRect = {
            position: vec_1.vec2.add(gridTopLeft, vec_1.vec2.div(vec_1.vec2.sub(gridBottomRight, gridTopLeft), 2)),
            size: vec_1.vec2.sub(gridBottomRight, gridTopLeft),
        };
        const intersection = rayIntersectsRectangle(ray, gridRect);
        if (!intersection.intersects || !intersection.intersectionPoints) {
            return { cells }; // Ray misses grid entirely
        }
        // Get the first intersection point (closest to ray origin)
        const entryPoint = intersection.intersectionPoints[0];
        currentCell = vec_1.vec2.map(vec_1.vec2.div(vec_1.vec2.sub(entryPoint, gridTopLeft), cellSize), Math.floor);
        // Check if entry point is valid (this should never fail but check anyway)
        if (currentCell.x < 0 ||
            currentCell.x >= gridSize.x ||
            currentCell.y < 0 ||
            currentCell.y >= gridSize.y) {
            return { cells }; // No valid entry point found
        }
    }
    // Calculate step direction (either 1 or -1) for each axis
    const step = {
        x: Math.sign(rayDir.x),
        y: Math.sign(rayDir.y),
    };
    // Calculate tDelta - distance along ray from one grid line to next
    const tDelta = {
        x: rayDir.x !== 0 ? Math.abs(cellSize / rayDir.x) : Infinity,
        y: rayDir.y !== 0 ? Math.abs(cellSize / rayDir.y) : Infinity,
    };
    // Calculate initial cell boundary positions
    const initialBoundary = (0, vec_1.vec2)(gridTopLeft.x + (currentCell.x + (step.x > 0 ? 1 : 0)) * cellSize, gridTopLeft.y + (currentCell.y + (step.y > 0 ? 1 : 0)) * cellSize);
    // Calculate initial tMax values, handling boundary cases
    const tMax = {
        x: rayDir.x !== 0
            ? Math.abs((initialBoundary.x - ray.origin.x) / rayDir.x)
            : Infinity,
        y: rayDir.y !== 0
            ? Math.abs((initialBoundary.y - ray.origin.y) / rayDir.y)
            : Infinity,
    };
    // If we're exactly on a boundary, we need to adjust tMax
    if (Math.abs(ray.origin.x - initialBoundary.x) < constants.EPSILON) {
        tMax.x = tDelta.x;
    }
    if (Math.abs(ray.origin.y - initialBoundary.y) < constants.EPSILON) {
        tMax.y = tDelta.y;
    }
    // Add starting cell
    cells.push((0, vec_1.vec2)(currentCell.x, currentCell.y));
    let cellCount = 1;
    // Main loop
    while (cellCount < maxCells &&
        currentCell.x >= 0 &&
        currentCell.x < gridSize.x &&
        currentCell.y >= 0 &&
        currentCell.y < gridSize.y) {
        // Advance to next cell based on shortest tMax
        if (tMax.x < tMax.y) {
            tMax.x += tDelta.x;
            currentCell.x += step.x;
        }
        else {
            tMax.y += tDelta.y;
            currentCell.y += step.y;
        }
        // Check if we're still in bounds
        if (currentCell.x < 0 ||
            currentCell.x >= gridSize.x ||
            currentCell.y < 0 ||
            currentCell.y >= gridSize.y) {
            break;
        }
        // Add current cell
        cells.push((0, vec_1.vec2)(currentCell.x, currentCell.y));
        cellCount++;
    }
    return { cells };
}
/**
 * Check if two rays intersect
 */
function rayIntersectsRay(rayA, rayB) {
    // Normalize the direction vectors
    const dirA = vec_1.vec2.nor(rayA.direction);
    const dirB = vec_1.vec2.nor(rayB.direction);
    // If either ray has zero direction, they cannot intersect
    if ((0, utilities_1.vectorAlmostZero)(dirA) || (0, utilities_1.vectorAlmostZero)(dirB)) {
        return {
            intersects: false,
        };
    }
    // Calculate the cross product determinant
    const det = vec_1.vec2.cross(dirA, dirB);
    // Get the vector between starting points
    const startDiff = vec_1.vec2.sub(rayB.origin, rayA.origin);
    // If determinant is close to 0, rays are parallel or collinear
    if (Math.abs(det) < constants.EPSILON) {
        // Check if rays are collinear
        if (Math.abs(vec_1.vec2.cross(startDiff, dirA)) < constants.EPSILON) {
            // Rays are collinear - check if they overlap
            const t = vec_1.vec2.dot(startDiff, dirA);
            // For rays pointing in the same direction:
            // If t <= 0: rayA's origin is behind or at rayB's origin
            // If t >= 0: rayB's origin is behind or at rayA's origin
            // dot(dirA, dirB) should be close to 1 for same direction
            if ((t <= 0 || t >= 0) && vec_1.vec2.dot(dirA, dirB) > 1 - constants.EPSILON) {
                return {
                    intersects: true,
                    // No single intersection point for overlapping rays
                };
            }
        }
        return {
            intersects: false,
        };
    }
    // Calculate intersection parameters
    const t = vec_1.vec2.cross(startDiff, dirB) / det;
    const s = vec_1.vec2.cross(startDiff, dirA) / det;
    // Check if intersection occurs on both rays (t >= 0 and s >= 0)
    if (t >= 0 && s >= 0) {
        return {
            intersects: true,
            intersectionPoint: vec_1.vec2.add(rayA.origin, vec_1.vec2.mul(dirA, t)),
        };
    }
    return {
        intersects: false,
    };
}
/**
 * Check if a ray intersects a line segment
 */
function rayIntersectsLine(ray, line) {
    // Convert line to a direction vector
    const lineDir = vec_1.vec2.sub(line.end, line.start);
    // Normalize the ray direction
    const rayDir = vec_1.vec2.nor(ray.direction);
    // If either the ray or the line has zero direction, they cannot intersect
    if ((0, utilities_1.vectorAlmostZero)(lineDir) || (0, utilities_1.vectorAlmostZero)(rayDir)) {
        return {
            intersects: false,
        };
    }
    // Calculate the cross product determinant
    const det = vec_1.vec2.cross(rayDir, lineDir);
    // Get the vector between ray origin and line start
    const startDiff = vec_1.vec2.sub(line.start, ray.origin);
    // If determinant is close to 0, ray and line are parallel or collinear
    if (Math.abs(det) < constants.EPSILON) {
        // Check if they are collinear
        if (Math.abs(vec_1.vec2.cross(startDiff, rayDir)) < constants.EPSILON) {
            // They are collinear - project the line endpoints onto the ray
            const t1 = vec_1.vec2.dot(vec_1.vec2.sub(line.start, ray.origin), rayDir);
            const t2 = vec_1.vec2.dot(vec_1.vec2.sub(line.end, ray.origin), rayDir);
            // Check if any part of the line segment is in front of the ray
            if ((t1 >= 0 || t2 >= 0) && Math.min(t1, t2) <= vec_1.vec2.len(lineDir)) {
                return {
                    intersects: true,
                    // No single intersection point for overlapping segments
                };
            }
        }
        return {
            intersects: false,
        };
    }
    // Calculate intersection parameters
    const t = vec_1.vec2.cross(startDiff, lineDir) / det; // Ray parameter
    const s = vec_1.vec2.cross(startDiff, rayDir) / det; // Line parameter
    // Check if intersection occurs on the ray (t >= 0) and within the line
    // segment (0 <= s <= 1)
    if (t >= 0 && s >= 0 && s <= 1) {
        return {
            intersects: true,
            intersectionPoint: vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDir, t)),
        };
    }
    return {
        intersects: false,
    };
}
/**
 * Check if a ray intersects a circle
 */
function rayIntersectsCircle(ray, circle) {
    // 1. Parameterized ray equation: P(t) = origin + t * direction
    const rayDir = vec_1.vec2.nor(ray.direction);
    // Calculate vector from ray origin to circle center
    const toCenter = vec_1.vec2.sub(circle.position, ray.origin);
    // 2. Substitute ray equation into circle equation:
    // (origin.x + t*dir.x - circle.x)² + (origin.y + t*dir.y - circle.y)² = r²
    // Expand and collect terms to get quadratic equation: at² + bt + c = 0
    // a = dot(dir, dir) (should be 1 since dir is normalized)
    const a = vec_1.vec2.dot(rayDir, rayDir);
    // b = 2 * dot(dir, (origin - center))
    const b = 2 * vec_1.vec2.dot(rayDir, vec_1.vec2.mul(toCenter, -1));
    // c = dot((origin - center), (origin - center)) - radius²
    const c = vec_1.vec2.dot(toCenter, toCenter) - circle.radius * circle.radius;
    // 3. Solve quadratic equation using discriminant
    const discriminant = b * b - 4 * a * c;
    // 4. Check if solutions exist (discriminant >= 0)
    if (discriminant < -constants.EPSILON) {
        return { intersects: false };
    }
    // Handle case where ray just touches circle (discriminant ≈ 0)
    if (Math.abs(discriminant) < constants.EPSILON) {
        const t = -b / (2 * a);
        if (t >= 0) {
            const point = vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDir, t));
            return {
                intersects: true,
                intersectionPoints: [point],
            };
        }
        return { intersects: false };
    }
    // 5. Calculate intersection points for discriminant > 0
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b - sqrtDiscriminant) / (2 * a);
    const t2 = (-b + sqrtDiscriminant) / (2 * a);
    // If both t values are negative, ray points away from circle
    if (t2 < 0) {
        return { intersects: false };
    }
    // Calculate intersection points for positive t values
    let intersectionPoints = [];
    if (t1 >= 0) {
        intersectionPoints.push(vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDir, t1)));
    }
    if (t2 >= 0) {
        intersectionPoints.push(vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDir, t2)));
    }
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a ray intersects a rectangle
 */
function rayIntersectsRectangle(ray, rectangle) {
    // Get vertices of the rectangle in clockwise order
    const vertices = rectangleVertices(rectangle);
    let intersectionPoints = [];
    // Check each edge of the rectangle for intersection
    const edges = verticesToEdges(vertices);
    for (const edge of edges) {
        const intersection = rayIntersectsLine(ray, edge);
        if (intersection.intersects && intersection.intersectionPoint) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    }
    // Remove duplicate intersection points and sort by distance to ray origin
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        const rayDir = vec_1.vec2.nor(ray.direction);
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.dot(vec_1.vec2.sub(a, ray.origin), rayDir);
            const distB = vec_1.vec2.dot(vec_1.vec2.sub(b, ray.origin), rayDir);
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a ray intersects the edges of a convex polygon
 *
 * We assume the polygon has already been checked for validity and convexity
 */
function rayIntersectsValidConvexPolygonEdges(ray, edges) {
    let intersectionPoints = [];
    // Check each outer edge for intersections
    for (const edge of edges) {
        const intersection = rayIntersectsLine(ray, edge);
        if (intersection.intersects && intersection.intersectionPoint) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    }
    // Remove duplicate intersection points and sort by distance to ray origin
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        const rayDir = vec_1.vec2.nor(ray.direction);
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.dot(vec_1.vec2.sub(a, ray.origin), rayDir);
            const distB = vec_1.vec2.dot(vec_1.vec2.sub(b, ray.origin), rayDir);
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a ray intersects a polygon
 *
 * Returns null if the polygon is invalid
 */
function rayIntersectsPolygon(ray, polygon) {
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // If polygon is not convex, decompose it into convex polygons
    if (!polygonIsConvex(polygon)) {
        const convexPolygons = decomposePolygon(polygon);
        if (!convexPolygons) {
            return null;
        }
        // Check the ray against the outer edges of each convex polygons
        return rayIntersectsValidConvexPolygonEdges(ray, findOuterEdges(convexPolygons));
    }
    // For convex polygons, check each edge
    return rayIntersectsValidConvexPolygonEdges(ray, verticesToEdges(polygon.vertices));
}
/**
 * Check if a line segment intersects a ray
 */
function lineIntersectsRay(line, ray) {
    return rayIntersectsLine(ray, line);
}
/**
 * Check if two line segments intersect
 */
function lineIntersectsLine(lineA, lineB) {
    // Get the vectors representing the directions of each line
    const dirA = vec_1.vec2.sub(lineA.end, lineA.start);
    const dirB = vec_1.vec2.sub(lineB.end, lineB.start);
    // If either line has zero direction, they cannot intersect
    if ((0, utilities_1.vectorAlmostZero)(dirA) || (0, utilities_1.vectorAlmostZero)(dirB)) {
        return {
            intersects: false,
        };
    }
    // Calculate the cross product determinant
    const det = vec_1.vec2.cross(dirA, dirB);
    // Get the vector between starting points
    const startDiff = vec_1.vec2.sub(lineB.start, lineA.start);
    // If determinant is close to 0, lines are parallel or collinear
    if (Math.abs(det) < constants.EPSILON) {
        // Check if lines are collinear
        if (Math.abs(vec_1.vec2.cross(startDiff, dirA)) < constants.EPSILON) {
            // Lines are collinear - check if they overlap
            const t0 = vec_1.vec2.dot(startDiff, dirA) / vec_1.vec2.dot(dirA, dirA);
            const t1 = t0 + vec_1.vec2.dot(dirB, dirA) / vec_1.vec2.dot(dirA, dirA);
            // Check if segments overlap
            const interval0 = Math.min(t0, t1);
            const interval1 = Math.max(t0, t1);
            if (interval0 <= 1 && interval1 >= 0) {
                return {
                    intersects: true,
                    // No single intersection point for overlapping lines
                };
            }
        }
        return {
            intersects: false,
        };
    }
    // Calculate intersection parameters
    const t = vec_1.vec2.cross(startDiff, dirB) / det;
    const s = vec_1.vec2.cross(startDiff, dirA) / det;
    // Check if intersection occurs within both line segments
    if (t >= 0 && t <= 1 && s >= 0 && s <= 1) {
        return {
            intersects: true,
            intersectionPoint: vec_1.vec2.add(lineA.start, vec_1.vec2.mul(dirA, t)),
        };
    }
    return {
        intersects: false,
    };
}
/**
 * Check if a line segment intersects a circle
 */
function lineIntersectsCircle(line, circle) {
    // 1. Parameterized line equation: P(t) = start + t * (end - start)
    const lineDir = vec_1.vec2.sub(line.end, line.start);
    const lineLengthSquared = vec_1.vec2.dot(lineDir, lineDir);
    // If the line segment has zero length, it cannot intersect
    if (lineLengthSquared < constants.EPSILON) {
        return { intersects: false };
    }
    // If both endpoints of the line are inside the circle, then we have an
    // intersection (but no intersection points)
    if (pointInCircle(line.start, circle).intersects &&
        pointInCircle(line.end, circle).intersects) {
        return { intersects: true };
    }
    // Calculate vector from circle center to line start
    const toCenter = vec_1.vec2.sub(circle.position, line.start);
    // 2. Substitute line equation into circle equation:
    // (start.x + t*dir.x - circle.x)² + (start.y + t*dir.y - circle.y)² = r²
    // Expand and collect terms to get quadratic equation: at² + bt + c = 0
    // a = dot(dir, dir)
    const a = lineLengthSquared;
    // b = 2 * dot(dir, (start - center))
    const b = 2 * vec_1.vec2.dot(lineDir, vec_1.vec2.mul(toCenter, -1));
    // c = dot((start - center), (start - center)) - radius²
    const c = vec_1.vec2.dot(toCenter, toCenter) - circle.radius * circle.radius;
    // 3. Solve quadratic equation using discriminant
    const discriminant = b * b - 4 * a * c;
    // If discriminant is negative, no intersection
    if (discriminant < -constants.EPSILON) {
        return { intersects: false };
    }
    // Handle case where line just touches circle (discriminant ≈ 0)
    if (Math.abs(discriminant) < constants.EPSILON) {
        const t = -b / (2 * a);
        if (t >= 0 && t <= 1) {
            const point = vec_1.vec2.add(line.start, vec_1.vec2.mul(lineDir, t));
            return {
                intersects: true,
                intersectionPoints: [point],
            };
        }
        return { intersects: false };
    }
    // Calculate intersection points for discriminant > 0
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b - sqrtDiscriminant) / (2 * a);
    const t2 = (-b + sqrtDiscriminant) / (2 * a);
    let intersectionPoints = [];
    // If both t values are outside [0, 1], no intersection
    if (t2 < 0 || t1 > 1) {
        return { intersects: false };
    }
    // Calculate intersection points for valid t values
    if (t1 >= 0 && t1 <= 1) {
        intersectionPoints.push(vec_1.vec2.add(line.start, vec_1.vec2.mul(lineDir, t1)));
    }
    if (t2 >= 0 && t2 <= 1) {
        intersectionPoints.push(vec_1.vec2.add(line.start, vec_1.vec2.mul(lineDir, t2)));
    }
    // Remove duplicate intersection points and sort by distance to line start
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.len(vec_1.vec2.sub(a, line.start));
            const distB = vec_1.vec2.len(vec_1.vec2.sub(b, line.start));
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a line segment intersects a rectangle
 */
function lineIntersectsRectangle(line, rectangle) {
    // Edge case: zero-size rectangle
    if ((0, utilities_1.vectorAlmostZero)(rectangle.size)) {
        return {
            intersects: false,
        };
    }
    // Get vertices of the rectangle in clockwise order
    const vertices = rectangleVertices(rectangle);
    // If both endpoints are inside, line is completely contained
    if (pointInRectangle(line.start, rectangle).intersects &&
        pointInRectangle(line.end, rectangle).intersects) {
        return {
            intersects: true,
        };
    }
    let intersectionPoints = [];
    // Check each edge of the rectangle for intersection
    const edges = verticesToEdges(vertices);
    for (const edge of edges) {
        const intersection = lineIntersectsLine(line, edge);
        if (intersection.intersects && intersection.intersectionPoint) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    }
    // Remove duplicate intersection points and sort by distance to line start
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.len(vec_1.vec2.sub(a, line.start));
            const distB = vec_1.vec2.len(vec_1.vec2.sub(b, line.start));
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a line segment intersects the edges of a convex polygon
 *
 * We assume the polygon has already been checked for validity and convexity
 */
function lineIntersectsValidConvexPolygonEdges(line, polygon, edges) {
    // Special case: line segment is entirely inside polygon
    const midpoint = {
        x: (line.start.x + line.end.x) / 2,
        y: (line.start.y + line.end.y) / 2,
    };
    const pointInside = pointInPolygon(midpoint, polygon);
    const startInside = pointInPolygon(line.start, polygon);
    const endInside = pointInPolygon(line.end, polygon);
    if ((pointInside === null || pointInside === void 0 ? void 0 : pointInside.intersects) &&
        (startInside === null || startInside === void 0 ? void 0 : startInside.intersects) &&
        (endInside === null || endInside === void 0 ? void 0 : endInside.intersects)) {
        return {
            intersects: true,
        };
    }
    let intersectionPoints = [];
    // Check each outer edge for intersections
    for (const edge of edges) {
        const intersection = lineIntersectsLine(line, edge);
        if (intersection.intersects && intersection.intersectionPoint) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    }
    // Remove duplicate intersection points and sort by distance to line start
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.len(vec_1.vec2.sub(a, line.start));
            const distB = vec_1.vec2.len(vec_1.vec2.sub(b, line.start));
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a line segment intersects a polygon
 *
 * Returns null if the polygon is invalid
 */
function lineIntersectsPolygon(line, polygon) {
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // If polygon is not convex, decompose it into convex polygons
    if (!polygonIsConvex(polygon)) {
        const convexPolygons = decomposePolygon(polygon);
        if (!convexPolygons) {
            return null;
        }
        // Check the line against the outer edges of each convex polygon
        return lineIntersectsValidConvexPolygonEdges(line, polygon, findOuterEdges(convexPolygons));
    }
    // For convex polygons, check each edge
    return lineIntersectsValidConvexPolygonEdges(line, polygon, verticesToEdges(polygon.vertices));
}
/**
 * Check if two circles intersect
 */
function circleIntersectsCircle(circleA, circleB) {
    // Calculate the vector from center A to center B
    const centerToCenterVec = vec_1.vec2.sub(circleB.position, circleA.position);
    const centerToCenter = vec_1.vec2.len(centerToCenterVec);
    const sumRadii = circleA.radius + circleB.radius;
    // If distance between centers is greater than sum of radii, the circles
    // don't intersect
    if (centerToCenter > sumRadii + constants.EPSILON) {
        return { intersects: false };
    }
    // If circles are identical (same position and radius), they have infinitely
    // many intersection points
    if (centerToCenter < constants.EPSILON &&
        Math.abs(circleA.radius - circleB.radius) < constants.EPSILON) {
        return {
            intersects: true,
            minimumSeparation: vec_1.vec2.mul(vec_1.vec2.ux(), 2 * circleA.radius),
        };
    }
    // Check if one circle is inside the other (no intersection points but still
    // intersecting)
    const radiusDiff = Math.abs(circleA.radius - circleB.radius);
    if (centerToCenter < radiusDiff - constants.EPSILON) {
        return {
            intersects: true,
            minimumSeparation: vec_1.vec2.mul(vec_1.vec2.nor(centerToCenterVec), circleA.radius - centerToCenter + circleB.radius),
        };
    }
    // Calculate intersection points for standard intersecting case
    // http://mathworld.wolfram.com/Circle-CircleIntersection.html
    const a = (circleA.radius * circleA.radius -
        circleB.radius * circleB.radius +
        centerToCenter * centerToCenter) /
        (2 * centerToCenter);
    const h = Math.sqrt(Math.max(0, circleA.radius * circleA.radius - a * a));
    // Calculate the point on the line between centers that is distance 'a' from
    // circle A's center
    const p = vec_1.vec2.add(circleA.position, vec_1.vec2.mul(vec_1.vec2.nor(centerToCenterVec), a));
    // If circles are tangent (touching at one point)
    if (Math.abs(centerToCenter - sumRadii) < constants.EPSILON) {
        return {
            intersects: true,
            intersectionPoints: [p],
            minimumSeparation: (0, vec_1.vec2)(),
        };
    }
    // Calculate the perpendicular vector to get both intersection points
    const perpVec = vec_1.vec2.mul((0, vec_1.vec2)({ x: -centerToCenterVec.y, y: centerToCenterVec.x }), h / centerToCenter);
    const intersectionPoints = [vec_1.vec2.add(p, perpVec), vec_1.vec2.sub(p, perpVec)];
    // Calculate the minimum separation vector
    const minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(centerToCenterVec), sumRadii - centerToCenter);
    return {
        intersects: true,
        intersectionPoints,
        minimumSeparation,
    };
}
/**
 * Check if a circle intersects a rectangle
 */
function circleIntersectsRectangle(circle, rectangle) {
    // Get rectangle vertices so we can test against rotated rectangles
    const vertices = rectangleVertices(rectangle);
    const edges = verticesToEdges(vertices);
    // Check if circle's center is inside rectangle
    const pointInRectResult = pointInRectangle(circle.position, rectangle);
    const circleCenterInsideRectangle = pointInRectResult.intersects;
    // Check if rectangle's center is inside circle
    const pointInCircleResult = pointInCircle(rectangle.position, circle);
    const rectangleCenterInsideCircle = pointInCircleResult.intersects;
    // Check circle intersection with rectangle edges
    const intersectionPoints = [];
    for (const edge of edges) {
        const result = lineIntersectsCircle(edge, circle);
        if (result.intersects && result.intersectionPoints) {
            intersectionPoints.push(...result.intersectionPoints);
        }
    }
    // Calculate the minimum separation vector
    let minimumSeparation;
    if (Math.abs(pointInRectResult.distance) < constants.EPSILON) {
        minimumSeparation = (0, vec_1.vec2)();
    }
    else if (pointInRectResult.distance < 0) {
        minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(pointInRectResult.closestPoint, circle.position)), circle.radius + Math.abs(pointInRectResult.distance));
    }
    else {
        minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(circle.position, pointInRectResult.closestPoint)), circle.radius - pointInRectResult.distance);
    }
    // If either shape's center is inside the other and there are no intersection
    // points, it means one of the shapes completely encloses the other
    if ((circleCenterInsideRectangle || rectangleCenterInsideCircle) &&
        intersectionPoints.length === 0) {
        return {
            intersects: true,
            minimumSeparation,
        };
    }
    // Remove duplicate intersection points
    const uniquePoints = removeDuplicateVertices(intersectionPoints);
    if (uniquePoints.length > 0) {
        return {
            intersects: true,
            intersectionPoints: uniquePoints,
            minimumSeparation,
        };
    }
    return { intersects: false };
}
/**
 * Check if a circle intersects the edges of a convex polygon
 *
 * We assume the polygon has already been checked for validity and convexity
 */
function circleIntersectsValidConvexPolygonEdges(circle, edges, circleCenterInsidePolygon, polygonCenterInsideCircle) {
    let intersectionPoints = [];
    // Check each outer edge for intersections with the circle
    for (const edge of edges) {
        const result = lineIntersectsCircle(edge, circle);
        if (result.intersects && result.intersectionPoints) {
            intersectionPoints.push(...result.intersectionPoints);
        }
    }
    // If either shape's center is inside the other and there are no
    // intersection points, one shape completely encloses the other
    if ((circleCenterInsidePolygon || polygonCenterInsideCircle) &&
        intersectionPoints.length === 0) {
        return { intersects: true };
    }
    // Remove duplicate intersection points
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a circle intersects a polygon
 *
 * Returns null if the polygon is invalid
 */
function circleIntersectsPolygon(circle, polygon, options) {
    var _a, _b, _c, _d, _e, _f;
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    const MAX_ITERATIONS = 10;
    const findMinimumSeparation = (_a = options === null || options === void 0 ? void 0 : options.findMinimumSeparation) !== null && _a !== void 0 ? _a : false;
    // Check if circle's center is inside polygon
    const pointInPolygonResult = pointInPolygon(circle.position, polygon);
    const circleCenterInsidePolygon = (_b = pointInPolygonResult === null || pointInPolygonResult === void 0 ? void 0 : pointInPolygonResult.intersects) !== null && _b !== void 0 ? _b : false;
    // If polygon is not convex, decompose it into convex polygons
    if (!polygonIsConvex(polygon)) {
        const convexPolygons = decomposePolygon(polygon);
        if (!convexPolygons) {
            return null;
        }
        // For a concave polygon, the centroid might be outside of the polygon, so
        // in order to check if the polygon is entirely inside the circle, we need
        // to check if all sub-polygon centroids are inside the circle
        const polygonCenterInsideCircle = convexPolygons.every(convexPolygon => {
            var _a;
            const centroid = polygonCentroid(convexPolygon);
            if (!centroid) {
                return false; // Invalid centroid
            }
            return (_a = pointInCircle(centroid, circle).intersects) !== null && _a !== void 0 ? _a : false;
        });
        // Find outer edges from the decomposed polygons
        const outerEdges = findOuterEdges(convexPolygons);
        const result = circleIntersectsValidConvexPolygonEdges(circle, outerEdges, circleCenterInsidePolygon, polygonCenterInsideCircle);
        if (result.intersects && findMinimumSeparation) {
            let iteration = 0;
            let previousSeparation = null;
            let currentSeparation = (0, vec_1.vec2)();
            let currentSeparationIntersects = true;
            while (
            // Continue if we still haven't found a separation that doesn't
            // intersect
            currentSeparationIntersects &&
                // Continue if we're still converging (i.e. if we didn't make any
                // progress in the last iteration then we can stop)
                (previousSeparation === null ||
                    !(0, utilities_1.vectorsAlmostEqual)(previousSeparation, currentSeparation)) &&
                // Continue until we reach the maximum number of iterations
                ++iteration < MAX_ITERATIONS) {
                let minimumSeparations = [];
                let circlePosition = vec_1.vec2.add(circle.position, currentSeparation);
                // Find minimum separation vectors for each convex sub-polygon
                for (const convexPolygon of convexPolygons) {
                    const pointInConvexPolygonResult = pointInPolygon(circlePosition, convexPolygon);
                    if (!pointInConvexPolygonResult) {
                        continue;
                    }
                    let minimumSeparation;
                    if (Math.abs(pointInConvexPolygonResult.distance) < constants.EPSILON) {
                        minimumSeparation = (0, vec_1.vec2)();
                    }
                    else if (pointInConvexPolygonResult.distance < 0) {
                        minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(pointInConvexPolygonResult.closestPoint, circlePosition)), circle.radius + Math.abs(pointInConvexPolygonResult.distance));
                    }
                    else {
                        minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(circlePosition, pointInConvexPolygonResult.closestPoint)), circle.radius - pointInConvexPolygonResult.distance);
                    }
                    minimumSeparations.push({
                        separation: minimumSeparation,
                        distance: Math.abs(pointInConvexPolygonResult.distance),
                    });
                }
                // Sort minimum separations by penetration distance
                minimumSeparations = minimumSeparations.sort((a, b) => a.distance - b.distance);
                previousSeparation = vec_1.vec2.cpy(currentSeparation);
                currentSeparation = vec_1.vec2.add(currentSeparation, ((_c = minimumSeparations[0]) === null || _c === void 0 ? void 0 : _c.separation) || (0, vec_1.vec2)());
                // Check if the current separation still intersects
                currentSeparationIntersects =
                    (_e = (_d = circleIntersectsPolygon({
                        ...circle,
                        position: vec_1.vec2.add(circle.position, 
                        // Add a small buffer to avoid numerical/precision issues
                        vec_1.vec2.mul(currentSeparation, 1.01)),
                    }, polygon, {
                        ...options,
                        // Don't recurse to avoid infinite loops
                        findMinimumSeparation: false,
                    })) === null || _d === void 0 ? void 0 : _d.intersects) !== null && _e !== void 0 ? _e : false;
            }
            return {
                ...result,
                minimumSeparation: currentSeparation,
            };
        }
        return result;
    }
    // Check if polygon's centroid is inside circle
    // For a convex polygon, the centroid is always inside the polygon
    const polygonCenter = polygonCentroid(polygon);
    const pointInCircleResult = pointInCircle(polygonCenter, circle);
    const polygonCenterInsideCircle = (_f = pointInCircleResult.intersects) !== null && _f !== void 0 ? _f : false;
    // For convex polygons, check each edge directly
    const edges = verticesToEdges(polygon.vertices);
    const result = circleIntersectsValidConvexPolygonEdges(circle, edges, circleCenterInsidePolygon, polygonCenterInsideCircle);
    if (result.intersects && findMinimumSeparation) {
        // Calculate the minimum separation vector
        let minimumSeparation;
        if (Math.abs(pointInPolygonResult.distance) < constants.EPSILON) {
            minimumSeparation = (0, vec_1.vec2)();
        }
        else if (pointInPolygonResult.distance < 0) {
            minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(pointInPolygonResult.closestPoint, circle.position)), circle.radius + Math.abs(pointInPolygonResult.distance));
        }
        else {
            minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(circle.position, pointInPolygonResult.closestPoint)), circle.radius - pointInPolygonResult.distance);
        }
        return {
            ...result,
            minimumSeparation,
        };
    }
    return result;
}
/**
 * Project vertices onto an axis and return the min/max values
 */
function projectVerticesToAxis(vertices, axis) {
    let min = Infinity;
    let max = -Infinity;
    for (const vertex of vertices) {
        const projection = vec_1.vec2.dot(vertex, axis);
        min = Math.min(min, projection);
        max = Math.max(max, projection);
    }
    return { min, max };
}
/**
 * Check if two rectangles intersect
 */
function rectangleIntersectsRectangle(rectangleA, rectangleB) {
    // Edge case: if either rectangle has zero size, they cannot intersect
    if ((0, utilities_1.vectorAlmostZero)(rectangleA.size) || (0, utilities_1.vectorAlmostZero)(rectangleB.size)) {
        return { intersects: false };
    }
    // Get vertices of both rectangles
    const verticesA = rectangleVertices(rectangleA);
    const verticesB = rectangleVertices(rectangleB);
    // Get edges of both rectangles
    const edgesA = verticesToEdges(verticesA);
    const edgesB = verticesToEdges(verticesB);
    // Get separating axes by calculating the normals of each edge
    const axes = [];
    for (const edge of [...edgesA, ...edgesB]) {
        const edgeVec = vec_1.vec2.sub(edge.end, edge.start);
        const normal = vec_1.vec2.nor(vec_1.vec2.rotf(edgeVec, -1));
        // Only add unique axes
        if (!axes.some(axis => Math.abs(vec_1.vec2.dot(axis, normal)) > 1 - constants.EPSILON)) {
            axes.push(normal);
        }
    }
    // Track minimum penetration for separation vector
    let minPenetration = Infinity;
    let minAxis = (0, vec_1.vec2)();
    // Test each axis
    for (const axis of axes) {
        // Project both rectangles onto the axis
        const projectionA = projectVerticesToAxis(verticesA, axis);
        const projectionB = projectVerticesToAxis(verticesB, axis);
        // If we find a separating axis, the rectangles don't intersect
        if (projectionA.max < projectionB.min ||
            projectionB.max < projectionA.min) {
            return { intersects: false };
        }
        // Calculate penetration depth
        const overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);
        // Track minimum penetration and its axis
        if (overlap < minPenetration) {
            minPenetration = overlap;
            minAxis = axis;
        }
    }
    // Find intersection points by checking each edge of rectangle A against each
    // edge of rectangle B
    const intersectionPoints = [];
    for (const edgeA of edgesA) {
        for (const edgeB of edgesB) {
            const intersection = lineIntersectsLine(edgeA, edgeB);
            if (intersection.intersects && intersection.intersectionPoint) {
                intersectionPoints.push(intersection.intersectionPoint);
            }
        }
    }
    // Remove duplicate intersection points
    const uniquePoints = removeDuplicateVertices(intersectionPoints);
    // Calculate the minimum separation vector
    const centerA = rectangleA.position;
    const centerB = rectangleB.position;
    const centerToCenter = vec_1.vec2.sub(centerB, centerA);
    // If the dot product is negative, we need to flip the axis
    if (vec_1.vec2.dot(minAxis, centerToCenter) < 0) {
        minAxis = vec_1.vec2.mul(minAxis, -1);
    }
    // The minimum separation vector is the axis scaled by the penetration depth
    const minimumSeparation = vec_1.vec2.mul(minAxis, minPenetration);
    return {
        intersects: true,
        intersectionPoints: uniquePoints.length > 0 ? uniquePoints : undefined,
        minimumSeparation,
    };
}
/**
 * Check if a rectangle intersects a polygon
 *
 * Returns null if the polygon is invalid
 */
function rectangleIntersectsPolygon(rectangle, polygon) {
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // Edge case: if the rectangle has zero size, there is no intersection
    if ((0, utilities_1.vectorAlmostZero)(rectangle.size)) {
        return { intersects: false };
    }
    // Convert rectangle to polygon
    const rectVertices = rectangleVertices(rectangle);
    const rectPolygon = {
        vertices: rectVertices,
    };
    // Use polygon intersection algorithm
    return polygonIntersectsPolygon(rectPolygon, polygon);
}
/**
 * Check if two polygons intersect
 *
 * Returns null if either polygon is invalid
 */
function polygonIntersectsPolygon(polygonA, polygonB) {
    // First check if both polygons are valid
    if (!polygonIsValid(polygonA) || !polygonIsValid(polygonB)) {
        return null;
    }
    // Decompose polygon A if it's concave
    let convexPolygonsA = [];
    if (!polygonIsConvex(polygonA)) {
        const decomposedA = decomposePolygon(polygonA);
        if (!decomposedA) {
            return null;
        }
        convexPolygonsA = decomposedA;
    }
    else {
        convexPolygonsA = [polygonA];
    }
    // Decompose polygon B if it's concave
    let convexPolygonsB = [];
    if (!polygonIsConvex(polygonB)) {
        const decomposedB = decomposePolygon(polygonB);
        if (!decomposedB) {
            return null;
        }
        convexPolygonsB = decomposedB;
    }
    else {
        convexPolygonsB = [polygonB];
    }
    // Get the outer edges of the decomposed polygons
    const outerEdgesA = findOuterEdges(convexPolygonsA);
    const outerEdgesB = findOuterEdges(convexPolygonsB);
    // Find intersection points between outer edges only
    const intersectionPoints = [];
    for (const edgeA of outerEdgesA) {
        for (const edgeB of outerEdgesB) {
            const intersection = lineIntersectsLine(edgeA, edgeB);
            if (intersection.intersects && intersection.intersectionPoint) {
                intersectionPoints.push(intersection.intersectionPoint);
            }
        }
    }
    // Check if one polygon is contained within the other
    // A polygon is contained within another if the centroids of all its
    // convex sub-polygons are inside the other polygon
    if (intersectionPoints.length === 0) {
        const polygonACentroids = convexPolygonsA
            .map(polygonCentroid)
            .filter(centroid => !!centroid);
        if (polygonACentroids.every(centroid => { var _a; return (_a = pointInPolygon(centroid, polygonB)) === null || _a === void 0 ? void 0 : _a.intersects; })) {
            return { intersects: true };
        }
        const polygonBCentroids = convexPolygonsB
            .map(polygonCentroid)
            .filter(centroid => !!centroid);
        if (polygonBCentroids.every(centroid => { var _a; return (_a = pointInPolygon(centroid, polygonA)) === null || _a === void 0 ? void 0 : _a.intersects; })) {
            return { intersects: true };
        }
    }
    // Remove duplicate intersection points
    const uniquePoints = removeDuplicateVertices(intersectionPoints);
    return {
        intersects: uniquePoints.length > 0,
        intersectionPoints: uniquePoints.length > 0 ? uniquePoints : undefined,
    };
}


/***/ }),

/***/ "./src/2d/types.ts":
/*!*************************!*\
  !*** ./src/2d/types.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_138183__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isPoint = isPoint;
exports.isRay = isRay;
exports.isLine = isLine;
exports.isCircle = isCircle;
exports.isAABB = isAABB;
exports.isRectangle = isRectangle;
exports.isPolygon = isPolygon;
const types_1 = __nested_webpack_require_138183__(/*! ../utilities/types */ "./src/utilities/types.ts");
/**
 * Type guard to check if a value is a Point
 */
function isPoint(value) {
    return (0, types_1.isVec2)(value);
}
/**
 * Check if a value is a Ray
 */
function isRay(value) {
    return (value &&
        typeof value === 'object' &&
        'origin' in value &&
        isPoint(value.origin) &&
        'direction' in value &&
        (0, types_1.isVec2)(value.direction));
}
/**
 * Check if a value is a Line
 */
function isLine(value) {
    return (value &&
        typeof value === 'object' &&
        'start' in value &&
        isPoint(value.start) &&
        'end' in value &&
        isPoint(value.end));
}
/**
 * Check if a value is a Circle
 */
function isCircle(value) {
    return (value &&
        typeof value === 'object' &&
        'position' in value &&
        isPoint(value.position) &&
        'radius' in value &&
        typeof value.radius === 'number');
}
/**
 * Check if a value is an AABB
 */
function isAABB(value) {
    return (value &&
        typeof value === 'object' &&
        'position' in value &&
        isPoint(value.position) &&
        'size' in value &&
        (0, types_1.isVec2)(value.size));
}
/**
 * Check if a value is a Rectangle
 */
function isRectangle(value) {
    return (value &&
        typeof value === 'object' &&
        'position' in value &&
        isPoint(value.position) &&
        'size' in value &&
        (0, types_1.isVec2)(value.size) &&
        ('rotation' in value ? typeof value.rotation === 'number' : true));
}
/**
 * Check if a value is a Polygon
 */
function isPolygon(value) {
    return (value &&
        typeof value === 'object' &&
        'vertices' in value &&
        Array.isArray(value.vertices) &&
        value.vertices.every(isPoint));
}


/***/ }),

/***/ "./src/3d/index.ts":
/*!*************************!*\
  !*** ./src/3d/index.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_140488__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.distance = distance;
exports.angle = angle;
exports.angleBetween = angleBetween;
exports.pointsAreCollinear = pointsAreCollinear;
exports.lineToRay = lineToRay;
exports.rayToLine = rayToLine;
exports.aabb = aabb;
exports.aabbToCuboid = aabbToCuboid;
exports.aabbsOverlap = aabbsOverlap;
exports.pointInAABB = pointInAABB;
exports.cuboidIsRotated = cuboidIsRotated;
exports.cuboidVertices = cuboidVertices;
exports.cuboidToPolygons = cuboidToPolygons;
exports.verticesToEdges = verticesToEdges;
exports.polygonIsValid = polygonIsValid;
exports.polygonWindingOrder = polygonWindingOrder;
exports.polygonArea = polygonArea;
exports.polygonCentroid = polygonCentroid;
exports.polygonToPlane = polygonToPlane;
exports.polygonsToMesh = polygonsToMesh;
exports.meshToPolygons = meshToPolygons;
exports.meshToEdges = meshToEdges;
exports.meshCentroid = meshCentroid;
exports.meshIsWatertight = meshIsWatertight;
exports.pointOnRay = pointOnRay;
exports.pointOnLine = pointOnLine;
exports.pointInSphere = pointInSphere;
exports.pointInCuboid = pointInCuboid;
exports.pointOnPolygon = pointOnPolygon;
exports.rayTraverseGrid = rayTraverseGrid;
exports.rayIntersectsRay = rayIntersectsRay;
exports.rayIntersectsLine = rayIntersectsLine;
exports.rayIntersectsSphere = rayIntersectsSphere;
exports.rayIntersectsPlane = rayIntersectsPlane;
exports.rayIntersectsCuboid = rayIntersectsCuboid;
exports.rayIntersectsPolygon = rayIntersectsPolygon;
exports.rayIntersectsMesh = rayIntersectsMesh;
exports.lineIntersectsRay = lineIntersectsRay;
exports.lineIntersectsLine = lineIntersectsLine;
exports.lineIntersectsSphere = lineIntersectsSphere;
exports.lineIntersectsPlane = lineIntersectsPlane;
exports.lineIntersectsCuboid = lineIntersectsCuboid;
exports.lineIntersectsPolygon = lineIntersectsPolygon;
exports.lineIntersectsMesh = lineIntersectsMesh;
exports.sphereIntersectsSphere = sphereIntersectsSphere;
exports.sphereIntersectsPlane = sphereIntersectsPlane;
exports.sphereIntersectsCuboid = sphereIntersectsCuboid;
exports.sphereIntersectsPolygon = sphereIntersectsPolygon;
exports.sphereIntersectsMesh = sphereIntersectsMesh;
exports.planeIntersectsPlane = planeIntersectsPlane;
exports.planeIntersectsMesh = planeIntersectsMesh;
exports.cuboidIntersectsCuboid = cuboidIntersectsCuboid;
exports.cuboidIntersectsPlane = cuboidIntersectsPlane;
exports.cuboidIntersectsPolygon = cuboidIntersectsPolygon;
exports.cuboidIntersectsMesh = cuboidIntersectsMesh;
exports.polygonIntersectsPolygon = polygonIntersectsPolygon;
exports.polygonIntersectsPlane = polygonIntersectsPlane;
exports.polygonIntersectsMesh = polygonIntersectsMesh;
exports.meshIntersectsMesh = meshIntersectsMesh;
exports.meshIntersectsPlane = meshIntersectsPlane;
const utils_1 = __nested_webpack_require_140488__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __nested_webpack_require_140488__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const utilities_1 = __nested_webpack_require_140488__(/*! ../utilities */ "./src/utilities/index.ts");
const constants = __importStar(__nested_webpack_require_140488__(/*! ../utilities/constants */ "./src/utilities/constants.ts"));
const types_1 = __nested_webpack_require_140488__(/*! ./types */ "./src/3d/types.ts");
__exportStar(__nested_webpack_require_140488__(/*! ./types */ "./src/3d/types.ts"), exports);
/**
 * Contents
 *
 * Utilities
 * @see distance
 * @see angle
 * @see angleBetween
 * @see pointsAreCollinear
 *
 * Line and ray utilities
 * @see lineToRay
 * @see rayToLine
 *
 * AABBs
 * @see aabb
 * @see aabbToCuboid
 * @see aabbsOverlap
 * @see pointInAABB
 *
 * Cuboid utilities
 * @see cuboidIsRotated
 * @see cuboidVertices
 * @see cuboidToPolygons
 *
 * Polygon utilities
 * @see verticesToEdges
 * @see polygonIsValid
 * @see polygonWindingOrder
 * @see polygonArea
 * @see polygonCentroid
 * @see polygonToPlane
 *
 * Mesh utilities
 * @see polygonsToMesh
 * @see meshToPolygons
 * @see meshToEdges
 * @see meshCentroid
 * @see meshIsWatertight
 *
 * Points
 * @see pointOnRay
 * @see pointOnLine
 * @see pointInSphere
 * @see pointInCuboid
 * @see pointOnPolygon
 *
 * Rays
 * @see rayTraverseGrid
 * @see rayIntersectsRay
 * @see rayIntersectsLine
 * @see rayIntersectsSphere
 * @see rayIntersectsPlane
 * @see rayIntersectsCuboid
 * @see rayIntersectsPolygon
 * @see rayIntersectsMesh
 *
 * Lines
 * @see lineIntersectsRay
 * @see lineIntersectsLine
 * @see lineIntersectsSphere
 * @see lineIntersectsPlane
 * @see lineIntersectsCuboid
 * @see lineIntersectsPolygon
 * @see lineIntersectsMesh
 *
 * Spheres
 * @see sphereIntersectsSphere
 * @see sphereIntersectsPlane
 * @see sphereIntersectsCuboid
 * @see sphereIntersectsPolygon
 * @see sphereIntersectsMesh
 *
 * Planes
 * @see planeIntersectsPlane
 * @see planeIntersectsMesh
 *
 * Cuboids
 * @see cuboidIntersectsCuboid
 * @see cuboidIntersectsPlane
 * @see cuboidIntersectsPolygon
 * @see cuboidIntersectsMesh
 *
 * Polygons
 * @see polygonIntersectsPolygon
 * @see polygonIntersectsPlane
 * @see polygonIntersectsMesh
 *
 * Meshes
 * @see meshIntersectsMesh
 * @see meshIntersectsPlane
 */
/**
 * Calculate the distance between two points in 3D space
 */
function distance(a, b) {
    return vec_1.vec3.len(vec_1.vec3.sub(a, b));
}
/**
 * Calculate the Euler angle from point a to point b
 */
function angle(a, b) {
    if ((0, utilities_1.vectorsAlmostEqual)(a, b)) {
        return (0, vec_1.vec3)();
    }
    let thetaX = vec_1.vec3.radx(vec_1.vec3.sub(b, a)) % (2 * Math.PI);
    if (thetaX < 0) {
        thetaX += 2 * Math.PI; // Ensure angle is positive
    }
    let thetaY = vec_1.vec3.rady(vec_1.vec3.sub(b, a)) % (2 * Math.PI);
    if (thetaY < 0) {
        thetaY += 2 * Math.PI; // Ensure angle is positive
    }
    let thetaZ = vec_1.vec3.radz(vec_1.vec3.sub(b, a)) % (2 * Math.PI);
    if (thetaZ < 0) {
        thetaZ += 2 * Math.PI; // Ensure angle is positive
    }
    return (0, vec_1.vec3)(thetaX, thetaY, thetaZ);
}
/**
 * Calculate the angle between two lines or rays
 *
 * Returns 0 if either line is zero-length
 */
function angleBetween(a, b) {
    let aLine = (0, types_1.isRay)(a) ? rayToLine(a, 1) : a;
    let bLine = (0, types_1.isRay)(b) ? rayToLine(b, 1) : b;
    if ((0, utilities_1.vectorAlmostZero)(vec_1.vec3.sub(aLine.start, aLine.end)) ||
        (0, utilities_1.vectorAlmostZero)(vec_1.vec3.sub(bLine.start, bLine.end))) {
        return 0; // Zero-length line
    }
    const dirA = vec_1.vec3.nor(vec_1.vec3.sub(aLine.end, aLine.start));
    const dirB = vec_1.vec3.nor(vec_1.vec3.sub(bLine.end, bLine.start));
    // Clamp dot product to [-1, 1] to avoid NaN due to floating-point errors
    const dot = (0, utils_1.clamp)(vec_1.vec3.dot(dirA, dirB), -1, 1);
    const angle = Math.acos(dot);
    return angle < 0 ? angle + 2 * Math.PI : angle; // Ensure angle is positive
}
/**
 * Check if three points in 3D space are collinear
 */
function pointsAreCollinear(a, b, c) {
    // Create two vectors from the points:
    // v1 = b - a
    // v2 = c - a
    const v1 = vec_1.vec3.sub(b, a);
    const v2 = vec_1.vec3.sub(c, a);
    // Calculate the cross product of the two vectors
    const cross = vec_1.vec3.cross(v1, v2);
    // If the cross product is zero (or very close to zero),
    // the points are collinear
    return vec_1.vec3.len(cross) < constants.EPSILON;
}
/**
 * Convert a line segment to a ray
 */
function lineToRay(line) {
    return {
        origin: line.start,
        direction: vec_1.vec3.nor(vec_1.vec3.sub(line.end, line.start)),
    };
}
/**
 * Convert a ray to a line segment
 */
function rayToLine(ray, length = 1) {
    return {
        start: ray.origin,
        end: vec_1.vec3.add(ray.origin, vec_1.vec3.mul(ray.direction, length)),
    };
}
/**
 * Get the bounding box (AABB) of a geometric object
 */
function aabb(o) {
    if ((0, types_1.isLine)(o)) {
        return {
            position: (0, vec_1.vec3)(Math.min(o.start.x, o.end.y), Math.min(o.start.y, o.end.y), Math.min(o.start.z, o.end.z)),
            size: (0, vec_1.vec3)(Math.abs(o.start.x - o.end.x), Math.abs(o.start.y - o.end.y), Math.abs(o.start.z - o.end.z)),
        };
    }
    if ((0, types_1.isSphere)(o)) {
        return {
            position: o.position,
            size: (0, vec_1.vec3)(o.radius * 2),
        };
    }
    if ((0, types_1.isCuboid)(o)) {
        const vertices = cuboidVertices(o);
        const position = (0, vec_1.vec3)(Math.min(...vertices.map(v => v.x)), Math.min(...vertices.map(v => v.y)), Math.min(...vertices.map(v => v.z)));
        return {
            position,
            size: (0, vec_1.vec3)(Math.max(...vertices.map(v => v.x)) - position.x, Math.max(...vertices.map(v => v.y)) - position.y, Math.max(...vertices.map(v => v.z)) - position.z),
        };
    }
    if ((0, types_1.isMesh)(o) || (0, types_1.isPolygon)(o)) {
        const position = (0, vec_1.vec3)(Math.min(...o.vertices.map(v => v.x)), Math.min(...o.vertices.map(v => v.y)), Math.min(...o.vertices.map(v => v.z)));
        return {
            position,
            size: (0, vec_1.vec3)(Math.max(...o.vertices.map(v => v.x)) - position.x, Math.max(...o.vertices.map(v => v.y)) - position.y, Math.max(...o.vertices.map(v => v.z)) - position.z),
        };
    }
    return null;
}
/**
 * Convert an AABB to a cuboid
 */
function aabbToCuboid(aabb) {
    return {
        position: vec_1.vec3.add(aabb.position, vec_1.vec3.div(aabb.size, 2)),
        size: aabb.size,
        rotation: (0, vec_1.vec3)(0, 0, 0),
    };
}
/**
 * Check if two AABBs overlap and return the overlapping volume if they do
 */
function aabbsOverlap(a, b) {
    const overlapX = (0, utilities_1.overlapInterval)({ min: a.position.x, max: a.position.x + a.size.x }, { min: b.position.x, max: b.position.x + b.size.x });
    const overlapY = (0, utilities_1.overlapInterval)({ min: a.position.y, max: a.position.y + a.size.y }, { min: b.position.y, max: b.position.y + b.size.y });
    const overlapZ = (0, utilities_1.overlapInterval)({ min: a.position.z, max: a.position.z + a.size.z }, { min: b.position.z, max: b.position.z + b.size.z });
    // If the AABBs don't overlap on one or more axes, they don't overlap at all
    if (!overlapX || !overlapY || !overlapZ) {
        return { intersects: false };
    }
    return {
        intersects: true,
        overlap: {
            position: (0, vec_1.vec3)(overlapX.min, overlapY.min, overlapZ.min),
            size: (0, vec_1.vec3)(overlapX.max - overlapX.min, overlapY.max - overlapY.min, overlapZ.max - overlapZ.min),
        },
    };
}
/**
 * Check if a point is inside an AABB
 *
 * This should be a bit faster than pointInRectangle since we don't need to
 * worry about rotation
 */
function pointInAABB(point, aabb) {
    const { position, size } = aabb;
    const min = position;
    const max = vec_1.vec3.add(position, size);
    // Check if the point is inside the AABB
    const intersects = (0, utilities_1.valueInInterval)(point.x, { min: min.x, max: max.x }) &&
        (0, utilities_1.valueInInterval)(point.y, { min: min.y, max: max.y }) &&
        (0, utilities_1.valueInInterval)(point.z, { min: min.z, max: max.z });
    // Find the closest point on the AABB surface to the given point
    let closestPoint;
    if (!intersects) {
        // If the point is outside, clamp to the box
        closestPoint = (0, vec_1.vec3)((0, utils_1.clamp)(point.x, min.x, max.x), (0, utils_1.clamp)(point.y, min.y, max.y), (0, utils_1.clamp)(point.z, min.z, max.z));
    }
    else {
        // If the point is inside, project to the nearest edge
        const distances = [
            { x: min.x, y: point.y, z: point.z, d: Math.abs(point.x - min.x) }, // left
            { x: max.x, y: point.y, z: point.z, d: Math.abs(point.x - max.x) }, // right
            { x: point.x, y: min.y, z: point.z, d: Math.abs(point.y - min.y) }, // bottom
            { x: point.x, y: max.y, z: point.z, d: Math.abs(point.y - max.y) }, // top
            { x: point.x, y: point.y, z: min.z, d: Math.abs(point.z - min.z) }, // front
            { x: point.x, y: point.y, z: max.z, d: Math.abs(point.z - max.z) }, // back
        ];
        const nearest = distances.reduce((a, b) => (a.d < b.d ? a : b));
        closestPoint = (0, vec_1.vec3)(nearest.x, nearest.y, nearest.z);
    }
    // Calculate the distance from the point to the closest point
    const distance = vec_1.vec3.len(vec_1.vec3.sub(point, closestPoint));
    // If the point is inside, distance should be negative
    return {
        intersects,
        closestPoint,
        distance: intersects ? -distance : distance,
    };
}
/**
 * Check if a cuboid is rotated
 */
function cuboidIsRotated(cuboid) {
    return cuboid.rotation !== undefined && !(0, utilities_1.vectorAlmostZero)(cuboid.rotation);
}
/**
 * Get the vertices of a cuboid
 *
 * Vertices will be returned in the following order:
 * - Upper face (max z, clockwise starting at the top-left)
 *   - Top-left
 *   - Top-right
 *   - Bottom-right
 *   - Bottom-left
 * - Lower face (min z, clockwise starting at the top-left)
 *   - Top-left
 *   - Top-right
 *   - Bottom-right
 *   - Bottom-left
 */
function cuboidVertices(cuboid) {
    const { position, size, rotation = (0, vec_1.vec3)() } = cuboid;
    const halfSize = vec_1.vec3.div(size, 2);
    // Calculate the 8 corners of the cuboid
    let upperTopLeftOffset = vec_1.vec3.fromComponents(vec_1.vec3.swiz(halfSize, 'XYz'));
    let upperTopRightOffset = vec_1.vec3.fromComponents(vec_1.vec3.swiz(halfSize, 'xYz'));
    let upperBottomRightOffset = vec_1.vec3.fromComponents(vec_1.vec3.swiz(halfSize, 'xyz'));
    let upperBottomLeftOffset = vec_1.vec3.fromComponents(vec_1.vec3.swiz(halfSize, 'Xyz'));
    let lowerTopLeftOffset = vec_1.vec3.fromComponents(vec_1.vec3.swiz(halfSize, 'XYZ'));
    let lowerTopRightOffset = vec_1.vec3.fromComponents(vec_1.vec3.swiz(halfSize, 'xYZ'));
    let lowerBottomRightOffset = vec_1.vec3.fromComponents(vec_1.vec3.swiz(halfSize, 'xyZ'));
    let lowerBottomLeftOffset = vec_1.vec3.fromComponents(vec_1.vec3.swiz(halfSize, 'XyZ'));
    // Rotate the offsets if the cuboid is rotated
    if (cuboidIsRotated(cuboid)) {
        upperTopLeftOffset = vec_1.vec3.rota(upperTopLeftOffset, rotation);
        upperTopRightOffset = vec_1.vec3.rota(upperTopRightOffset, rotation);
        upperBottomRightOffset = vec_1.vec3.rota(upperBottomRightOffset, rotation);
        upperBottomLeftOffset = vec_1.vec3.rota(upperBottomLeftOffset, rotation);
        lowerTopLeftOffset = vec_1.vec3.rota(lowerTopLeftOffset, rotation);
        lowerTopRightOffset = vec_1.vec3.rota(lowerTopRightOffset, rotation);
        lowerBottomRightOffset = vec_1.vec3.rota(lowerBottomRightOffset, rotation);
        lowerBottomLeftOffset = vec_1.vec3.rota(lowerBottomLeftOffset, rotation);
    }
    return [
        // Upper face vertices
        vec_1.vec3.add(position, upperTopLeftOffset),
        vec_1.vec3.add(position, upperTopRightOffset),
        vec_1.vec3.add(position, upperBottomRightOffset),
        vec_1.vec3.add(position, upperBottomLeftOffset),
        // Lower face vertices
        vec_1.vec3.add(position, lowerTopLeftOffset),
        vec_1.vec3.add(position, lowerTopRightOffset),
        vec_1.vec3.add(position, lowerBottomRightOffset),
        vec_1.vec3.add(position, lowerBottomLeftOffset),
    ];
}
/**
 * Convert a cuboid to a list of polygons representing its faces
 *
 * Polygons will be returned in the following order:
 * - Upper face (top)
 * - Lower face (bottom)
 * - Front face
 * - Back face
 * - Left face
 * - Right face
 */
function cuboidToPolygons(cuboid) {
    const vertices = cuboidVertices(cuboid);
    if (vertices.length !== 8) {
        throw new Error('Cuboid must have exactly 8 vertices');
    }
    // Create polygons for each face of the cuboid
    return [
        // Upper face
        { vertices: [vertices[0], vertices[1], vertices[2]] },
        { vertices: [vertices[0], vertices[2], vertices[3]] },
        // Lower face
        { vertices: [vertices[4], vertices[5], vertices[6]] },
        { vertices: [vertices[4], vertices[6], vertices[7]] },
        // Front face
        { vertices: [vertices[0], vertices[1], vertices[5]] },
        { vertices: [vertices[0], vertices[5], vertices[4]] },
        // Back face
        { vertices: [vertices[2], vertices[3], vertices[7]] },
        { vertices: [vertices[2], vertices[7], vertices[6]] },
        // Left face
        { vertices: [vertices[0], vertices[3], vertices[7]] },
        { vertices: [vertices[0], vertices[7], vertices[4]] },
        // Right face
        { vertices: [vertices[1], vertices[2], vertices[6]] },
        { vertices: [vertices[1], vertices[6], vertices[5]] },
    ];
}
/**
 * Convert a list of vertices to a list of edges
 */
function verticesToEdges(vertices) {
    const edges = [];
    for (let i = 0; i < vertices.length; i++) {
        const start = vertices[i];
        const end = (0, utils_1.at)(vertices, i + 1);
        edges.push({ start, end });
    }
    return edges;
}
/**
 * Check if a polygon is valid
 *
 * A polygon is valid if it has exactly 3 vertices
 */
function polygonIsValid(polygon) {
    return polygon.vertices.length === 3;
}
/**
 * Determine the winding order of a polygon's vertices
 *
 * Returns 'clockwise' or 'counter-clockwise'
 *
 * By default uses the right-hand rule: if the vertices are ordered
 * counter-clockwise, the normal points towards the viewer
 *
 * Returns null if the polygon is invalid or degenerate
 */
function polygonWindingOrder(polygon, options) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    const [a, b, c] = polygon.vertices;
    const handedness = (options === null || options === void 0 ? void 0 : options.handedness) || 'right';
    // Calculate vectors from vertex a to b and a to c
    const ab = vec_1.vec3.sub(b, a);
    const ac = vec_1.vec3.sub(c, a);
    // Calculate normal vector using cross product
    const normal = vec_1.vec3.cross(ab, ac);
    // If normal is zero vector (or very close to zero), vertices are collinear
    if ((0, utilities_1.vectorAlmostZero)(normal)) {
        return null;
    }
    // If a reference normal was provided, use it
    if (options === null || options === void 0 ? void 0 : options.normal) {
        const dot = vec_1.vec3.dot(vec_1.vec3.nor(normal), vec_1.vec3.nor(options.normal));
        // Dot product > 0 means normals point in similar direction
        if (Math.abs(dot) < constants.EPSILON) {
            return null; // Normals are perpendicular, can't determine order
        }
        if (handedness === 'right') {
            return dot > 0 ? 'counter-clockwise' : 'clockwise';
        }
        else {
            return dot > 0 ? 'clockwise' : 'counter-clockwise';
        }
    }
    // Without a reference normal, we'll use the z-component of the normal
    // to determine winding order (positive z points towards viewer)
    if (Math.abs(normal.z) < constants.EPSILON) {
        return null; // Normal is perpendicular to view direction
    }
    if (handedness === 'right') {
        return normal.z > 0 ? 'counter-clockwise' : 'clockwise';
    }
    else {
        return normal.z > 0 ? 'clockwise' : 'counter-clockwise';
    }
}
/**
 * Calculate the 2D area of a polygon in 3D space
 *
 * Returns null if the polygon is invalid
 */
function polygonArea(polygon) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    const [a, b, c] = polygon.vertices;
    // Use the shoelace formula to calculate the area of the triangle
    // https://en.wikipedia.org/wiki/Shoelace_formula
    return (Math.abs(a.x * (b.y - b.x) * a.y +
        b.x * (c.y - c.x) * b.y +
        c.x * (a.y - a.x) * c.y) / 2);
}
/**
 * Calculate the centroid of a polygon
 *
 * Returns null if the polygon is invalid
 */
function polygonCentroid(polygon) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    return vec_1.vec3.div(vec_1.vec3.add(polygon.vertices[0], vec_1.vec3.add(polygon.vertices[1], polygon.vertices[2])), 3);
}
/**
 * Convert a polygon to a plane
 */
function polygonToPlane(polygon) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // Calculate the normal vector
    const [a, b, c] = polygon.vertices;
    const ab = vec_1.vec3.sub(b, a);
    const ac = vec_1.vec3.sub(c, a);
    const normal = vec_1.vec3.nor(vec_1.vec3.cross(ab, ac));
    // Calculate the plane's position as the centroid of the polygon
    const point = polygonCentroid(polygon);
    return {
        point,
        normal,
    };
}
/**
 * Convert a list of polygons to a mesh
 *
 * This optimises the number of vertices and edges by merging common vertices
 */
function polygonsToMesh(polygons) {
    if (polygons.length === 0) {
        return { vertices: [], indices: [] };
    }
    // Create a map to store unique vertices
    const vertexMap = new Map();
    const indices = [];
    // Iterate over each polygon
    polygons.forEach((polygon, polygonIndex) => {
        if (!polygonIsValid(polygon)) {
            throw new Error(`Invalid polygon at index ${polygonIndex}`);
        }
        // Iterate over each vertex in the polygon
        polygon.vertices.forEach(vertex => {
            // Create a unique key for the vertex
            const key = `${vertex.x},${vertex.y},${vertex.z}`;
            if (!vertexMap.has(key)) {
                // If the vertex is not in the map, add it
                vertexMap.set(key, vertex);
            }
            // Get the index of the vertex in the map
            const index = Array.from(vertexMap.keys()).indexOf(key);
            indices.push(index);
        });
    });
    // Convert the vertex map to an array
    const vertices = Array.from(vertexMap.values());
    return {
        vertices,
        indices,
    };
}
/**
 * Convert a mesh to a list of polygons
 */
function meshToPolygons(mesh) {
    if (mesh.indices.length % 3 !== 0) {
        throw new Error('Mesh indices must be a multiple of 3 to form triangles');
    }
    const polygons = [];
    for (let i = 0; i < mesh.indices.length; i += 3) {
        const indices = mesh.indices.slice(i, i + 3);
        if (indices.length !== 3) {
            throw new Error('Mesh indices must form triangles');
        }
        const vertices = indices.map(index => mesh.vertices[index]);
        polygons.push({ vertices });
    }
    return polygons;
}
/**
 * Convert a mesh to a list of edges
 */
function meshToEdges(mesh) {
    if (mesh.indices.length % 2 !== 0) {
        throw new Error('Mesh indices must be a multiple of 2 to form edges');
    }
    const edges = [];
    for (let i = 0; i < mesh.indices.length; i += 2) {
        const startIndex = mesh.indices[i];
        const endIndex = mesh.indices[i + 1];
        if (startIndex >= mesh.vertices.length ||
            endIndex >= mesh.vertices.length) {
            throw new Error('Mesh indices out of bounds');
        }
        edges.push({
            start: mesh.vertices[startIndex],
            end: mesh.vertices[endIndex],
        });
    }
    return edges;
}
/**
 * Calculate the centroid of a mesh
 */
function meshCentroid(mesh) {
    return vec_1.vec3.div(mesh.vertices.reduce((acc, v) => vec_1.vec3.add(acc, v), (0, vec_1.vec3)()), mesh.vertices.length);
}
/**
 * Perform an edge manifold check to tell if a mesh is watertight
 *
 * Every edge in a watertight mesh should be shared by exactly two triangles
 *
 * This isn't perfect, but it should be sufficient for most simple cases
 */
function meshIsWatertight(mesh) {
    // Create a map to store edge counts
    // Key format: "smallerVertexIndex,largerVertexIndex"
    const edgeCounts = new Map();
    // Process each triangle
    for (let i = 0; i < mesh.indices.length; i += 3) {
        const v1 = mesh.indices[i];
        const v2 = mesh.indices[i + 1];
        const v3 = mesh.indices[i + 2];
        // For each edge in the triangle, create a canonical key
        const edges = [
            [Math.min(v1, v2), Math.max(v1, v2)],
            [Math.min(v2, v3), Math.max(v2, v3)],
            [Math.min(v3, v1), Math.max(v3, v1)],
        ];
        // Count each edge
        edges.forEach(([a, b]) => {
            const key = `${a},${b}`;
            edgeCounts.set(key, (edgeCounts.get(key) || 0) + 1);
        });
    }
    // Check if all edges appear exactly twice
    return Array.from(edgeCounts.values()).every(count => count === 2);
}
/**
 * Check if a point is on a ray
 *
 * Also returns the closest point on the ray and the distance to it
 */
function pointOnRay(point, ray) {
    // Vector from ray origin to point
    const toPoint = vec_1.vec3.sub(point, ray.origin);
    // Get normalized ray direction
    const rayDirection = vec_1.vec3.nor(ray.direction);
    // Project toPoint onto the ray direction
    const projection = vec_1.vec3.dot(toPoint, rayDirection);
    // Calculate closest point on ray
    const closestPoint = vec_1.vec3.add(ray.origin, vec_1.vec3.mul(rayDirection, Math.max(0, projection)));
    // Calculate distance from point to closest point
    const distance = vec_1.vec3.len(vec_1.vec3.sub(point, closestPoint));
    return {
        // Point is on ray if distance is zero and projection is non-negative
        intersects: distance < constants.EPSILON && projection >= 0,
        closestPoint,
        distance,
    };
}
/**
 * Check if a point intersects a line segment
 *
 * Also returns the closest point on the line segment and the distance to it
 */
function pointOnLine(point, line) {
    // Get vector from line start to end
    const lineVector = vec_1.vec3.sub(line.end, line.start);
    // Get normalized line direction
    const lineDirection = vec_1.vec3.nor(lineVector);
    // Get vector from line start to point
    const toPoint = vec_1.vec3.sub(point, line.start);
    // Project toPoint onto the line direction
    const projection = vec_1.vec3.dot(toPoint, lineDirection);
    // Get line length
    const lineLength = vec_1.vec3.len(lineVector);
    // Clamp projection to line segment
    const clampedProjection = Math.max(0, Math.min(lineLength, projection));
    // Calculate closest point on line segment
    const closestPoint = vec_1.vec3.add(line.start, vec_1.vec3.mul(lineDirection, clampedProjection));
    // Calculate distance from point to closest point
    const distance = vec_1.vec3.len(vec_1.vec3.sub(point, closestPoint));
    return {
        // Point is on line if distance is effectively zero
        intersects: distance < constants.EPSILON,
        closestPoint,
        distance,
    };
}
/**
 * Check if a point is inside a sphere
 *
 * Also returns the closest point on the sphere edge and the distance to it
 *
 * If the point is inside the sphere, the distance will be negative
 */
function pointInSphere(point, sphere) {
    // Calculate vector from sphere center to point
    const toPoint = vec_1.vec3.sub(point, sphere.position);
    // Calculate distance from point to sphere center
    const distanceToCenter = vec_1.vec3.len(toPoint);
    // Check if point is inside the sphere
    const intersects = distanceToCenter <= sphere.radius;
    // Calculate distance to circle edge
    const distance = intersects
        ? -(sphere.radius - distanceToCenter) // Negative if inside
        : distanceToCenter - sphere.radius; // Positive if outside
    // Calculate closest point on sphere edge
    const closestPoint = vec_1.vec3.add(sphere.position, vec_1.vec3.mul(vec_1.vec3.nor(toPoint), sphere.radius));
    return {
        intersects,
        closestPoint,
        distance,
    };
}
/**
 * Check if a point is inside a cuboid
 */
function pointInCuboid(point, cuboid) {
    const { position, size, rotation = (0, vec_1.vec3)() } = cuboid;
    const halfSize = vec_1.vec3.div(size, 2);
    // Transform point to local space by undoing rotation and translation
    let localPoint = vec_1.vec3.sub(point, position);
    if (cuboidIsRotated(cuboid)) {
        localPoint = vec_1.vec3.rota(localPoint, vec_1.vec3.mul(rotation, -1));
    }
    // Calculate distances to each face in local space
    const dx = Math.max(Math.abs(localPoint.x) - halfSize.x, 0);
    const dy = Math.max(Math.abs(localPoint.y) - halfSize.y, 0);
    const dz = Math.max(Math.abs(localPoint.z) - halfSize.z, 0);
    // Calculate closest point in local space
    const closestLocalPoint = (0, vec_1.vec3)((0, utils_1.clamp)(localPoint.x, -halfSize.x, halfSize.x), (0, utils_1.clamp)(localPoint.y, -halfSize.y, halfSize.y), (0, utils_1.clamp)(localPoint.z, -halfSize.z, halfSize.z));
    // Transform closest point back to world space
    let closestPoint = closestLocalPoint;
    if (cuboidIsRotated(cuboid)) {
        closestPoint = vec_1.vec3.rota(closestPoint, rotation);
    }
    closestPoint = vec_1.vec3.add(closestPoint, position);
    // Calculate if point is inside and the distance
    const intersects = dx === 0 && dy === 0 && dz === 0;
    const distance = intersects
        ? -Math.min(halfSize.x - Math.abs(localPoint.x), halfSize.y - Math.abs(localPoint.y), halfSize.z - Math.abs(localPoint.z))
        : Math.sqrt(dx * dx + dy * dy + dz * dz);
    return {
        intersects,
        closestPoint,
        distance,
    };
}
function pointOnPolygon(point, polygon) {
    // First validate the polygon
    if (!polygonIsValid(polygon)) {
        return null;
    }
    const [v1, v2, v3] = polygon.vertices;
    // Calculate two edges of the triangle
    const edge1 = vec_1.vec3.sub(v2, v1);
    const edge2 = vec_1.vec3.sub(v3, v1);
    // Calculate the normal vector of the plane containing the triangle
    const normal = vec_1.vec3.nor(vec_1.vec3.cross(edge1, edge2));
    // Calculate plane constant d
    const d = -vec_1.vec3.dot(normal, v1);
    // Calculate the signed distance from the point to the plane
    const signedDistance = vec_1.vec3.dot(normal, point) + d;
    // Project the point onto the plane
    const projectedPoint = vec_1.vec3.sub(point, vec_1.vec3.mul(normal, signedDistance));
    // Now we need to check if the projected point is inside the triangle
    // We'll use the barycentric coordinate method
    const area = vec_1.vec3.len(vec_1.vec3.cross(edge1, edge2)) / 2; // Triangle area
    // Calculate barycentric coordinates using sub-triangle areas
    const edge3 = vec_1.vec3.sub(v3, v2);
    const vp1 = vec_1.vec3.sub(projectedPoint, v1);
    const vp2 = vec_1.vec3.sub(projectedPoint, v2);
    const vp3 = vec_1.vec3.sub(projectedPoint, v3);
    const alpha = vec_1.vec3.len(vec_1.vec3.cross(edge3, vp2)) / (2 * area);
    const beta = vec_1.vec3.len(vec_1.vec3.cross(edge2, vp3)) / (2 * area);
    const gamma = vec_1.vec3.len(vec_1.vec3.cross(edge1, vp1)) / (2 * area);
    // Point is inside triangle if all barycentric coordinates are between 0 and 1
    // and their sum is approximately 1
    const sum = alpha + beta + gamma;
    const isInside = alpha >= -constants.EPSILON &&
        beta >= -constants.EPSILON &&
        gamma >= -constants.EPSILON &&
        Math.abs(sum - 1) < constants.EPSILON;
    // If point is inside, the closest point is the projected point
    // If point is outside, find the closest point on the triangle's edges
    let closestPoint;
    let distance;
    if (isInside) {
        closestPoint = projectedPoint;
        distance = Math.abs(signedDistance);
    }
    else {
        // Check distances to each edge
        const p1 = pointOnLine(point, { start: v1, end: v2 });
        const p2 = pointOnLine(point, { start: v2, end: v3 });
        const p3 = pointOnLine(point, { start: v3, end: v1 });
        // Find the minimum distance
        const minDist = Math.min(p1.distance, p2.distance, p3.distance);
        // Use the closest point from the edge with minimum distance
        if (minDist === p1.distance) {
            closestPoint = p1.closestPoint;
        }
        else if (minDist === p2.distance) {
            closestPoint = p2.closestPoint;
        }
        else {
            closestPoint = p3.closestPoint;
        }
        distance = minDist;
    }
    return {
        intersects: distance < constants.EPSILON,
        closestPoint,
        distance,
    };
}
/**
 * Check which grid cells a ray traverses
 *
 * Based on "A Fast Voxel Traversal Algorithm for Ray Tracing" by Amanatides
 * and Woo
 *
 * We can optionally limit the number of cells traversed by the ray, or set
 * maxCells to -1 to continue traversing until the ray exits the grid (or until
 * we hit the hard limit of 10000 cells).
 */
function rayTraverseGrid(ray, cellSize, gridTopLeftFront, gridBottomRightBack, maxCells = -1) {
    if (cellSize <= 0) {
        return { cells: [] }; // Invalid cell size, return empty cells array
    }
    // Set a limit on the number of cells traversed
    const HARD_LIMIT = 10000;
    maxCells = (0, utils_1.clamp)(maxCells === -1 ? HARD_LIMIT : maxCells, 0, HARD_LIMIT);
    if (maxCells <= 0) {
        return { cells: [] }; // No cells to traverse
    }
    // Make sure the grid boundaries are integers
    gridTopLeftFront = vec_1.vec3.map(gridTopLeftFront, Math.floor);
    gridBottomRightBack = vec_1.vec3.map(gridBottomRightBack, Math.ceil);
    // Normalize ray direction and handle zero components
    const rayDir = vec_1.vec3.nor(ray.direction);
    if ((0, utilities_1.vectorAlmostZero)(rayDir)) {
        return { cells: [] };
    }
    const cells = [];
    // Calculate initial cell coordinates
    let currentCell = vec_1.vec3.map(vec_1.vec3.div(vec_1.vec3.sub(ray.origin, gridTopLeftFront), cellSize), Math.floor);
    // Calculate grid size in cells
    const gridSize = vec_1.vec3.sub(gridBottomRightBack, gridTopLeftFront);
    // If starting point is outside grid bounds, find entry point
    if (currentCell.x < 0 ||
        currentCell.x >= gridSize.x ||
        currentCell.y < 0 ||
        currentCell.y >= gridSize.y ||
        currentCell.z < 0 ||
        currentCell.z >= gridSize.z) {
        // Use cuboid intersection to find grid entry point
        const gridCuboid = {
            position: vec_1.vec3.add(gridTopLeftFront, vec_1.vec3.div(vec_1.vec3.sub(gridBottomRightBack, gridTopLeftFront), 2)),
            size: vec_1.vec3.sub(gridBottomRightBack, gridTopLeftFront),
        };
        const intersection = rayIntersectsCuboid(ray, gridCuboid);
        if (!intersection.intersects || !intersection.intersectionPoints) {
            return { cells }; // Ray misses grid entirely
        }
        // Get the first intersection point (closest to ray origin)
        const entryPoint = intersection.intersectionPoints[0];
        currentCell = vec_1.vec3.map(vec_1.vec3.div(vec_1.vec3.sub(entryPoint, gridTopLeftFront), cellSize), Math.floor);
        // Check if entry point is valid
        if (currentCell.x < 0 ||
            currentCell.x >= gridSize.x ||
            currentCell.y < 0 ||
            currentCell.y >= gridSize.y ||
            currentCell.z < 0 ||
            currentCell.z >= gridSize.z) {
            return { cells }; // No valid entry point found
        }
    }
    // Calculate step direction (either 1 or -1) for each axis
    const step = {
        x: Math.sign(rayDir.x),
        y: Math.sign(rayDir.y),
        z: Math.sign(rayDir.z),
    };
    // Calculate tDelta - distance along ray from one grid line to next
    const tDelta = {
        x: rayDir.x !== 0 ? Math.abs(cellSize / rayDir.x) : Infinity,
        y: rayDir.y !== 0 ? Math.abs(cellSize / rayDir.y) : Infinity,
        z: rayDir.z !== 0 ? Math.abs(cellSize / rayDir.z) : Infinity,
    };
    // Calculate initial cell boundary positions
    const initialBoundary = (0, vec_1.vec3)(gridTopLeftFront.x + (currentCell.x + (step.x > 0 ? 1 : 0)) * cellSize, gridTopLeftFront.y + (currentCell.y + (step.y > 0 ? 1 : 0)) * cellSize, gridTopLeftFront.z + (currentCell.z + (step.z > 0 ? 1 : 0)) * cellSize);
    // Calculate initial tMax values
    const tMax = {
        x: rayDir.x !== 0
            ? Math.abs((initialBoundary.x - ray.origin.x) / rayDir.x)
            : Infinity,
        y: rayDir.y !== 0
            ? Math.abs((initialBoundary.y - ray.origin.y) / rayDir.y)
            : Infinity,
        z: rayDir.z !== 0
            ? Math.abs((initialBoundary.z - ray.origin.z) / rayDir.z)
            : Infinity,
    };
    // If we're exactly on a boundary, we need to adjust tMax
    if (Math.abs(ray.origin.x - initialBoundary.x) < constants.EPSILON) {
        tMax.x = tDelta.x;
    }
    if (Math.abs(ray.origin.y - initialBoundary.y) < constants.EPSILON) {
        tMax.y = tDelta.y;
    }
    if (Math.abs(ray.origin.z - initialBoundary.z) < constants.EPSILON) {
        tMax.z = tDelta.z;
    }
    // Add starting cell
    cells.push((0, vec_1.vec3)(currentCell.x, currentCell.y, currentCell.z));
    let cellCount = 1;
    // Main loop
    while (cellCount < maxCells &&
        currentCell.x >= 0 &&
        currentCell.x < gridSize.x &&
        currentCell.y >= 0 &&
        currentCell.y < gridSize.y &&
        currentCell.z >= 0 &&
        currentCell.z < gridSize.z) {
        // Advance to next cell based on shortest tMax
        if (tMax.x < tMax.y && tMax.x < tMax.z) {
            tMax.x += tDelta.x;
            currentCell.x += step.x;
        }
        else if (tMax.y < tMax.z) {
            tMax.y += tDelta.y;
            currentCell.y += step.y;
        }
        else {
            tMax.z += tDelta.z;
            currentCell.z += step.z;
        }
        // Check if we're still in bounds
        if (currentCell.x < 0 ||
            currentCell.x >= gridSize.x ||
            currentCell.y < 0 ||
            currentCell.y >= gridSize.y ||
            currentCell.z < 0 ||
            currentCell.z >= gridSize.z) {
            break;
        }
        // Add current cell
        cells.push((0, vec_1.vec3)(currentCell.x, currentCell.y, currentCell.z));
        cellCount++;
    }
    return { cells };
}
/**
 * Check if two rays intersect
 */
function rayIntersectsRay(rayA, rayB) {
    // Normalize ray directions
    const dirA = vec_1.vec3.nor(rayA.direction);
    const dirB = vec_1.vec3.nor(rayB.direction);
    // If either ray has zero direction, they cannot intersect
    if ((0, utilities_1.vectorAlmostZero)(dirA) || (0, utilities_1.vectorAlmostZero)(dirB)) {
        return {
            intersects: false,
        };
    }
    // Calculate vector between ray origins
    const originDiff = vec_1.vec3.sub(rayB.origin, rayA.origin);
    // Calculate triple products
    const normal = vec_1.vec3.cross(dirA, dirB);
    const normalLengthSq = vec_1.vec3.dot(normal, normal);
    // If normal is zero, rays are parallel
    if (normalLengthSq < constants.EPSILON) {
        // Check if rays are coincident
        const crossOrigins = vec_1.vec3.cross(originDiff, dirA);
        if (vec_1.vec3.len(crossOrigins) < constants.EPSILON) {
            // Rays are coincident - return point on rayA closest to rayB.origin
            const t = vec_1.vec3.dot(originDiff, dirA);
            if (t >= 0) {
                return {
                    intersects: true,
                    intersectionPoint: vec_1.vec3.add(rayA.origin, vec_1.vec3.mul(dirA, t)),
                };
            }
        }
        return { intersects: false };
    }
    // Calculate parameters for closest points
    const c1 = vec_1.vec3.dot(originDiff, vec_1.vec3.cross(dirB, normal)) / normalLengthSq;
    const c2 = vec_1.vec3.dot(originDiff, vec_1.vec3.cross(dirA, normal)) / normalLengthSq;
    // If either parameter is negative, closest points are behind ray origins
    if (c1 < 0 || c2 < 0) {
        return { intersects: false };
    }
    // Calculate closest points on each ray
    const pointA = vec_1.vec3.add(rayA.origin, vec_1.vec3.mul(dirA, c1));
    const pointB = vec_1.vec3.add(rayB.origin, vec_1.vec3.mul(dirB, c2));
    // Check if points are close enough to consider intersection
    const distance = vec_1.vec3.len(vec_1.vec3.sub(pointA, pointB));
    if (distance < constants.EPSILON) {
        // Use midpoint as intersection point
        return {
            intersects: true,
            intersectionPoint: vec_1.vec3.add(pointA, vec_1.vec3.mul(vec_1.vec3.sub(pointB, pointA), 0.5)),
        };
    }
    return { intersects: false };
}
/**
 * Check if a ray intersects a line segment
 */
function rayIntersectsLine(ray, line) {
    // Convert line to a direction vector
    let lineDir = vec_1.vec3.sub(line.end, line.start);
    const lineLength = vec_1.vec3.len(lineDir);
    // If the line has zero length, it cannot intersect
    if (lineLength < constants.EPSILON) {
        return {
            intersects: false,
        };
    }
    // Normalize ray and line directions
    const rayDir = vec_1.vec3.nor(ray.direction);
    lineDir = vec_1.vec3.div(lineDir, lineLength); // Normalize line direction
    // Calculate vector between ray origin and line start
    const startDiff = vec_1.vec3.sub(line.start, ray.origin);
    // Calculate triple products
    const normal = vec_1.vec3.cross(rayDir, lineDir);
    const normalLengthSq = vec_1.vec3.dot(normal, normal);
    // If normal is zero, ray and line are parallel
    if (normalLengthSq < constants.EPSILON) {
        // Check if they are collinear
        const crossOrigins = vec_1.vec3.cross(startDiff, rayDir);
        if (vec_1.vec3.len(crossOrigins) < constants.EPSILON) {
            // They are collinear - find closest point on line to ray origin
            const t = vec_1.vec3.dot(startDiff, lineDir);
            if (t >= 0 && t <= lineLength) {
                return {
                    intersects: true,
                    intersectionPoint: vec_1.vec3.add(line.start, vec_1.vec3.mul(lineDir, t)),
                };
            }
        }
        return { intersects: false };
    }
    // Calculate parameters for closest points
    const c1 = vec_1.vec3.dot(startDiff, vec_1.vec3.cross(lineDir, normal)) / normalLengthSq;
    const c2 = vec_1.vec3.dot(startDiff, vec_1.vec3.cross(rayDir, normal)) / normalLengthSq;
    // Check if intersection occurs on ray and within line segment bounds
    if (c1 >= 0 && c2 >= 0 && c2 <= lineLength) {
        // Calculate closest points
        const pointOnRay = vec_1.vec3.add(ray.origin, vec_1.vec3.mul(rayDir, c1));
        const pointOnLine = vec_1.vec3.add(line.start, vec_1.vec3.mul(lineDir, c2));
        // Check if points are close enough to consider intersection
        const distance = vec_1.vec3.len(vec_1.vec3.sub(pointOnRay, pointOnLine));
        if (distance < constants.EPSILON) {
            // Use midpoint as intersection point
            return {
                intersects: true,
                intersectionPoint: vec_1.vec3.add(pointOnRay, vec_1.vec3.mul(vec_1.vec3.sub(pointOnLine, pointOnRay), 0.5)),
            };
        }
    }
    return { intersects: false };
}
/**
 * Check if a ray intersects a sphere
 */
function rayIntersectsSphere(ray, sphere) {
    // Normalize ray direction
    const rayDir = vec_1.vec3.nor(ray.direction);
    // Calculate vector from ray origin to sphere center
    const toCenter = vec_1.vec3.sub(sphere.position, ray.origin);
    // Calculate quadratic equation coefficients
    // a = dot(dir, dir) (should be 1 since dir is normalized)
    const a = vec_1.vec3.dot(rayDir, rayDir);
    // b = 2 * dot(dir, (origin - center))
    const b = 2 * vec_1.vec3.dot(rayDir, vec_1.vec3.mul(toCenter, -1));
    // c = dot((origin - center), (origin - center)) - radius²
    const c = vec_1.vec3.dot(toCenter, toCenter) - sphere.radius * sphere.radius;
    // Solve quadratic equation using discriminant
    const discriminant = b * b - 4 * a * c;
    // No intersection if discriminant is negative
    if (discriminant < -constants.EPSILON) {
        return { intersects: false };
    }
    // Handle case where ray just touches sphere (discriminant ≈ 0)
    if (Math.abs(discriminant) < constants.EPSILON) {
        const t = -b / (2 * a);
        if (t >= 0) {
            const point = vec_1.vec3.add(ray.origin, vec_1.vec3.mul(rayDir, t));
            return {
                intersects: true,
                intersectionPoints: [point],
            };
        }
        return { intersects: false };
    }
    // Calculate intersection points for discriminant > 0
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b - sqrtDiscriminant) / (2 * a);
    const t2 = (-b + sqrtDiscriminant) / (2 * a);
    // If both t values are negative, ray points away from sphere
    if (t2 < 0) {
        return { intersects: false };
    }
    // Calculate intersection points for positive t values
    const intersectionPoints = [];
    if (t1 >= 0) {
        intersectionPoints.push(vec_1.vec3.add(ray.origin, vec_1.vec3.mul(rayDir, t1)));
    }
    if (t2 >= 0) {
        intersectionPoints.push(vec_1.vec3.add(ray.origin, vec_1.vec3.mul(rayDir, t2)));
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a ray intersects a plane
 */
function rayIntersectsPlane(ray, plane) {
    // Normalize the ray direction and plane normal
    const rayDir = vec_1.vec3.nor(ray.direction);
    const planeNormal = vec_1.vec3.nor(plane.normal);
    // Calculate denominator (dot product of ray direction and plane normal)
    const denominator = vec_1.vec3.dot(rayDir, planeNormal);
    // If denominator is close to 0, ray is parallel to plane
    if (Math.abs(denominator) < constants.EPSILON) {
        // Check if the ray lies in the plane (origin is on the plane)
        const distanceToPlane = vec_1.vec3.dot(vec_1.vec3.sub(ray.origin, plane.point), planeNormal);
        if (Math.abs(distanceToPlane) < constants.EPSILON) {
            // Ray lies in the plane: infinite intersection points
            return { intersects: true };
        }
        // Ray is parallel and not on the plane
        return { intersects: false };
    }
    // Calculate distance from ray origin to plane
    const t = vec_1.vec3.dot(vec_1.vec3.sub(plane.point, ray.origin), planeNormal) / denominator;
    // If t is negative, intersection is behind ray origin
    if (t < 0) {
        return { intersects: false };
    }
    // Calculate intersection point
    const intersectionPoint = vec_1.vec3.add(ray.origin, vec_1.vec3.mul(rayDir, t));
    return {
        intersects: true,
        intersectionPoint,
    };
}
/**
 * Check if a ray intersects a cuboid
 */
function rayIntersectsCuboid(ray, cuboid) {
    // Normalize ray direction
    const rayDir = vec_1.vec3.nor(ray.direction);
    // Extract cuboid properties with default rotation
    const { position, size, rotation = (0, vec_1.vec3)() } = cuboid;
    // Transform ray to local space if cuboid is rotated
    let localRayOrigin = vec_1.vec3.sub(ray.origin, position);
    let localRayDir = rayDir;
    if (cuboidIsRotated(cuboid)) {
        // Undo rotation by applying inverse rotation to ray
        const inverseRotation = vec_1.vec3.mul(rotation, -1);
        localRayOrigin = vec_1.vec3.rota(localRayOrigin, inverseRotation);
        localRayDir = vec_1.vec3.rota(localRayDir, inverseRotation);
    }
    const halfSize = vec_1.vec3.div(size, 2);
    // Calculate intersection with each pair of parallel planes
    const txMin = vec_1.vec3.div(vec_1.vec3.sub(vec_1.vec3.mul(halfSize, -1), localRayOrigin), localRayDir);
    const txMax = vec_1.vec3.div(vec_1.vec3.sub(halfSize, localRayOrigin), localRayDir);
    // Find the farthest near intersection and the closest far intersection
    const tNear = (0, vec_1.vec3)(Math.min(txMin.x, txMax.x), Math.min(txMin.y, txMax.y), Math.min(txMin.z, txMax.z));
    const tFar = (0, vec_1.vec3)(Math.max(txMin.x, txMax.x), Math.max(txMin.y, txMax.y), Math.max(txMin.z, txMax.z));
    // If the largest tNear is greater than the smallest tFar, there is no
    // intersection
    const tMin = Math.max(tNear.x, tNear.y, tNear.z);
    const tMax = Math.min(tFar.x, tFar.y, tFar.z);
    if (tMin > tMax || tMax < 0) {
        return { intersects: false };
    }
    // Calculate intersection points
    const intersectionPoints = [];
    // Add entry point if it's in front of ray origin
    if (tMin >= 0) {
        let point = vec_1.vec3.add(localRayOrigin, vec_1.vec3.mul(localRayDir, tMin));
        if (cuboidIsRotated(cuboid)) {
            point = vec_1.vec3.rota(point, rotation);
        }
        intersectionPoints.push(vec_1.vec3.add(position, point));
    }
    // Add exit point if different from entry point
    if (tMax > tMin && tMax >= 0) {
        let point = vec_1.vec3.add(localRayOrigin, vec_1.vec3.mul(localRayDir, tMax));
        if (cuboidIsRotated(cuboid)) {
            point = vec_1.vec3.rota(point, rotation);
        }
        intersectionPoints.push(vec_1.vec3.add(position, point));
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a ray intersects a polygon
 */
function rayIntersectsPolygon(ray, polygon) {
    // First validate the polygon
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // Calculate the plane of the polygon
    const [v1, v2, v3] = polygon.vertices;
    const edge1 = vec_1.vec3.sub(v2, v1);
    const edge2 = vec_1.vec3.sub(v3, v1);
    const normal = vec_1.vec3.nor(vec_1.vec3.cross(edge1, edge2));
    // Create a plane from the polygon
    const plane = {
        point: v1,
        normal,
    };
    // Check if the ray intersects the plane
    const intersection = rayIntersectsPlane(ray, plane);
    if (!intersection.intersects || !intersection.intersectionPoint) {
        return { intersects: false };
    }
    // Check if the intersection point is inside the polygon
    const pointCheck = pointOnPolygon(intersection.intersectionPoint, polygon);
    if (!pointCheck || !pointCheck.intersects) {
        return { intersects: false };
    }
    return {
        intersects: true,
        intersectionPoint: intersection.intersectionPoint,
    };
}
/**
 * Check if a ray intersects any of the polygons in a mesh
 */
function rayIntersectsMesh(ray, mesh) {
    const polygons = meshToPolygons(mesh);
    const intersectionPoints = [];
    polygons.forEach(polygon => {
        const intersection = rayIntersectsPolygon(ray, polygon);
        if (intersection && intersection.intersects) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    });
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a line segment intersects a ray
 */
function lineIntersectsRay(line, ray) {
    return rayIntersectsLine(ray, line);
}
/**
 * Check if two line segments intersect
 */
function lineIntersectsLine(lineA, lineB) {
    // Convert lines to direction vectors
    const dirA = vec_1.vec3.sub(lineA.end, lineA.start);
    const dirB = vec_1.vec3.sub(lineB.end, lineB.start);
    // Get line lengths
    const lengthA = vec_1.vec3.len(dirA);
    const lengthB = vec_1.vec3.len(dirB);
    // If either line has zero length, they cannot intersect
    if (lengthA < constants.EPSILON || lengthB < constants.EPSILON) {
        return { intersects: false };
    }
    // Normalize directions
    const normA = vec_1.vec3.div(dirA, lengthA);
    const normB = vec_1.vec3.div(dirB, lengthB);
    // Calculate vector between line starts
    const startDiff = vec_1.vec3.sub(lineB.start, lineA.start);
    // Calculate cross product of directions
    const normal = vec_1.vec3.cross(normA, normB);
    const normalLengthSq = vec_1.vec3.dot(normal, normal);
    // If normal is zero, lines are parallel
    if (normalLengthSq < constants.EPSILON) {
        // Check if they are collinear
        const crossStarts = vec_1.vec3.cross(startDiff, normA);
        if (vec_1.vec3.len(crossStarts) < constants.EPSILON) {
            // They are collinear - check for overlap
            const t0 = vec_1.vec3.dot(startDiff, normA);
            const t1 = t0 + vec_1.vec3.dot(dirB, normA);
            // Find overlap interval
            const tMin = Math.min(t0, t1);
            const tMax = Math.max(t0, t1);
            // Check if lines overlap
            if (tMin <= lengthA && tMax >= 0) {
                // Calculate intersection point at middle of overlap
                const t = (0, utils_1.clamp)(0, Math.max(0, tMin), lengthA);
                return {
                    intersects: true,
                    intersectionPoint: vec_1.vec3.add(lineA.start, vec_1.vec3.mul(normA, t)),
                };
            }
        }
        return { intersects: false };
    }
    // Calculate parameters for closest points
    const c1 = vec_1.vec3.dot(startDiff, vec_1.vec3.cross(dirB, normal)) / normalLengthSq;
    const c2 = vec_1.vec3.dot(startDiff, vec_1.vec3.cross(dirA, normal)) / normalLengthSq;
    // Check if closest points lie within line segments
    if (c1 >= 0 && c1 <= lengthA && c2 >= 0 && c2 <= lengthB) {
        // Calculate closest points
        const pointOnA = vec_1.vec3.add(lineA.start, vec_1.vec3.mul(normA, c1));
        const pointOnB = vec_1.vec3.add(lineB.start, vec_1.vec3.mul(normB, c2));
        // Check if points are close enough to consider intersection
        const distance = vec_1.vec3.len(vec_1.vec3.sub(pointOnA, pointOnB));
        if (distance < constants.EPSILON) {
            // Use midpoint as intersection point
            return {
                intersects: true,
                intersectionPoint: vec_1.vec3.add(pointOnA, vec_1.vec3.mul(vec_1.vec3.sub(pointOnB, pointOnA), 0.5)),
            };
        }
    }
    return { intersects: false };
}
/**
 * Check if a line segments intersects a sphere
 */
function lineIntersectsSphere(line, sphere) {
    // Calculate line direction and length
    const lineDir = vec_1.vec3.sub(line.end, line.start);
    const lineLength = vec_1.vec3.len(lineDir);
    // If line has zero length, treat as point-sphere intersection
    if (lineLength < constants.EPSILON) {
        const distance = vec_1.vec3.len(vec_1.vec3.sub(line.start, sphere.position));
        if (distance <= sphere.radius) {
            return {
                intersects: true,
                intersectionPoints: [line.start],
            };
        }
        return { intersects: false };
    }
    // Normalize line direction
    const normDir = vec_1.vec3.div(lineDir, lineLength);
    // Calculate vector from line start to sphere center
    const toCenter = vec_1.vec3.sub(sphere.position, line.start);
    // Calculate quadratic equation coefficients
    // a = dot(dir, dir) = 1 since dir is normalized
    const a = vec_1.vec3.dot(normDir, normDir);
    // b = 2 * dot(dir, (start - center))
    const b = 2 * vec_1.vec3.dot(normDir, vec_1.vec3.mul(toCenter, -1));
    // c = dot((start - center), (start - center)) - radius²
    const c = vec_1.vec3.dot(toCenter, toCenter) - sphere.radius * sphere.radius;
    // Solve quadratic equation using discriminant
    const discriminant = b * b - 4 * a * c;
    // No intersection if discriminant is negative
    if (discriminant < -constants.EPSILON) {
        return { intersects: false };
    }
    // Handle case where line just touches sphere (discriminant ≈ 0)
    if (Math.abs(discriminant) < constants.EPSILON) {
        const t = -b / (2 * a);
        if (t >= 0 && t <= lineLength) {
            const point = vec_1.vec3.add(line.start, vec_1.vec3.mul(normDir, t));
            return {
                intersects: true,
                intersectionPoints: [point],
            };
        }
        return { intersects: false };
    }
    // Calculate intersection points for discriminant > 0
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b - sqrtDiscriminant) / (2 * a);
    const t2 = (-b + sqrtDiscriminant) / (2 * a);
    // Collect intersection points that lie within line segment
    const intersectionPoints = [];
    if (t1 >= 0 && t1 <= lineLength) {
        intersectionPoints.push(vec_1.vec3.add(line.start, vec_1.vec3.mul(normDir, t1)));
    }
    if (t2 >= 0 && t2 <= lineLength) {
        intersectionPoints.push(vec_1.vec3.add(line.start, vec_1.vec3.mul(normDir, t2)));
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a line segments intersects a plane
 */
function lineIntersectsPlane(line, plane) {
    // Convert line to direction vector
    const lineDir = vec_1.vec3.sub(line.end, line.start);
    const lineLength = vec_1.vec3.len(lineDir);
    // If the line has zero length, it cannot intersect
    if (lineLength < constants.EPSILON) {
        return { intersects: false };
    }
    // Normalize line direction
    const normDir = vec_1.vec3.div(lineDir, lineLength);
    // Calculate denominator (dot product of line direction and plane normal)
    const denominator = vec_1.vec3.dot(normDir, plane.normal);
    // If denominator is close to 0, line is parallel to plane
    if (Math.abs(denominator) < constants.EPSILON) {
        // Check if the line start is on the plane
        const distanceToPlane = vec_1.vec3.dot(vec_1.vec3.sub(line.start, plane.point), plane.normal);
        if (Math.abs(distanceToPlane) < constants.EPSILON) {
            // Line lies in the plane: infinite intersection points
            return { intersects: true };
        }
        // Line is parallel and not on the plane
        return { intersects: false };
    }
    // Calculate distance from line start to plane
    const t = vec_1.vec3.dot(vec_1.vec3.sub(plane.point, line.start), plane.normal) / denominator;
    // If t is negative or greater than line length, intersection is outside of
    // the line segment
    if (t < 0 || t > lineLength) {
        return { intersects: false };
    }
    // Calculate intersection point
    const intersectionPoint = vec_1.vec3.add(line.start, vec_1.vec3.mul(normDir, t));
    return {
        intersects: true,
        intersectionPoint,
    };
}
/**
 * Check if a line segment intersects a cuboid
 */
function lineIntersectsCuboid(line, cuboid) {
    // Get line direction and length
    const lineDir = vec_1.vec3.sub(line.end, line.start);
    const lineLength = vec_1.vec3.len(lineDir);
    // If line has zero length, treat as point-cuboid intersection
    if (lineLength < constants.EPSILON) {
        const result = pointInCuboid(line.start, cuboid);
        return {
            intersects: result.intersects,
            intersectionPoints: result.intersects ? [line.start] : undefined,
        };
    }
    // Normalize line direction
    const normDir = vec_1.vec3.div(lineDir, lineLength);
    // Extract cuboid properties with default rotation
    const { position, size, rotation = (0, vec_1.vec3)() } = cuboid;
    // Transform line to local space if cuboid is rotated
    let localLineStart = vec_1.vec3.sub(line.start, position);
    let localLineDir = normDir;
    if (cuboidIsRotated(cuboid)) {
        // Undo rotation by applying inverse rotation
        const inverseRotation = vec_1.vec3.mul(rotation, -1);
        localLineStart = vec_1.vec3.rota(localLineStart, inverseRotation);
        localLineDir = vec_1.vec3.rota(localLineDir, inverseRotation);
    }
    const halfSize = vec_1.vec3.div(size, 2);
    // Calculate intersection with each pair of parallel planes
    const txMin = vec_1.vec3.div(vec_1.vec3.sub(vec_1.vec3.mul(halfSize, -1), localLineStart), localLineDir);
    const txMax = vec_1.vec3.div(vec_1.vec3.sub(halfSize, localLineStart), localLineDir);
    // Find the farthest near intersection and the closest far intersection
    const tNear = (0, vec_1.vec3)(Math.min(txMin.x, txMax.x), Math.min(txMin.y, txMax.y), Math.min(txMin.z, txMax.z));
    const tFar = (0, vec_1.vec3)(Math.max(txMin.x, txMax.x), Math.max(txMin.y, txMax.y), Math.max(txMin.z, txMax.z));
    // Find the latest entry and earliest exit
    const tMin = Math.max(tNear.x, tNear.y, tNear.z);
    const tMax = Math.min(tFar.x, tFar.y, tFar.z);
    // If the entry is after the exit, or the exit is before the start of the
    // line, or the entry is after the end of the line, there is no intersection
    if (tMin > tMax || tMax < 0 || tMin > lineLength) {
        return { intersects: false };
    }
    // Calculate intersection points
    const intersectionPoints = [];
    // Add entry point if it's within line segment
    if (tMin >= 0 && tMin <= lineLength) {
        let point = vec_1.vec3.add(localLineStart, vec_1.vec3.mul(localLineDir, tMin));
        if (cuboidIsRotated(cuboid)) {
            point = vec_1.vec3.rota(point, rotation);
        }
        intersectionPoints.push(vec_1.vec3.add(position, point));
    }
    // Add exit point if it's different from entry point and within line segment
    if (tMax > tMin && tMax >= 0 && tMax <= lineLength) {
        let point = vec_1.vec3.add(localLineStart, vec_1.vec3.mul(localLineDir, tMax));
        if (cuboidIsRotated(cuboid)) {
            point = vec_1.vec3.rota(point, rotation);
        }
        intersectionPoints.push(vec_1.vec3.add(position, point));
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a line segment intersects a polygon
 */
function lineIntersectsPolygon(line, polygon) {
    // First validate the polygon
    if (!polygonIsValid(polygon)) {
        return { intersects: false };
    }
    // Calculate the plane of the polygon
    const [v1, v2, v3] = polygon.vertices;
    const edge1 = vec_1.vec3.sub(v2, v1);
    const edge2 = vec_1.vec3.sub(v3, v1);
    const normal = vec_1.vec3.nor(vec_1.vec3.cross(edge1, edge2));
    // Create a plane from the polygon
    const plane = {
        point: v1,
        normal,
    };
    // Check if the line intersects the plane
    const intersection = lineIntersectsPlane(line, plane);
    if (!intersection.intersects || !intersection.intersectionPoint) {
        return { intersects: false };
    }
    // Check if the intersection point is inside the polygon
    const pointCheck = pointOnPolygon(intersection.intersectionPoint, polygon);
    if (!pointCheck || !pointCheck.intersects) {
        return { intersects: false };
    }
    return {
        intersects: true,
        intersectionPoint: intersection.intersectionPoint,
    };
}
/**
 * Check if a line segment intersects a cuboid
 */
function lineIntersectsMesh(line, mesh) {
    const polygons = meshToPolygons(mesh);
    const intersectionPoints = [];
    polygons.forEach(polygon => {
        const intersection = lineIntersectsPolygon(line, polygon);
        if (intersection && intersection.intersects) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    });
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if two spheres intersect
 */
function sphereIntersectsSphere(sphereA, sphereB) {
    // Calculate vector from center of sphere A to center of sphere B
    const centerToCenter = vec_1.vec3.sub(sphereB.position, sphereA.position);
    // Calculate actual distance between centers
    const distance = vec_1.vec3.len(centerToCenter);
    // Calculate sum of radii
    const radiiSum = sphereA.radius + sphereB.radius;
    // If distance is greater than sum of radii, spheres don't intersect
    if (distance > radiiSum) {
        return { intersects: false };
    }
    // If distance is zero, spheres are concentric
    if (distance < constants.EPSILON) {
        return {
            intersects: true,
            intersectionPoint: sphereA.position,
            penetrationDepth: radiiSum,
            normal: (0, vec_1.vec3)(1, 0, 0), // Arbitrary normal for concentric spheres
            contactPoints: {
                sphereA: vec_1.vec3.add(sphereA.position, (0, vec_1.vec3)(sphereA.radius, 0, 0)),
                sphereB: vec_1.vec3.add(sphereB.position, (0, vec_1.vec3)(sphereB.radius, 0, 0)),
            },
        };
    }
    // Calculate normalized direction from sphere A to sphere B
    const normal = vec_1.vec3.nor(centerToCenter);
    // Calculate penetration depth
    const penetrationDepth = radiiSum - distance;
    // Calculate intersection center point (halfway between surface intersection
    // points)
    const intersectionPoint = vec_1.vec3.add(sphereA.position, vec_1.vec3.mul(normal, sphereA.radius + penetrationDepth / 2));
    // Calculate contact points on each sphere's surface
    const contactPoints = {
        sphereA: vec_1.vec3.add(sphereA.position, vec_1.vec3.mul(normal, sphereA.radius)),
        sphereB: vec_1.vec3.add(sphereB.position, vec_1.vec3.mul(normal, -sphereB.radius)),
    };
    return {
        intersects: true,
        intersectionPoint,
        penetrationDepth,
        normal,
        contactPoints,
    };
}
/**
 * Check if a sphere intersects a plane
 */
function sphereIntersectsPlane(sphere, plane) {
    // Normalize the plane normal
    const normal = vec_1.vec3.nor(plane.normal);
    // Calculate signed distance from sphere center to plane
    const signedDistance = vec_1.vec3.dot(vec_1.vec3.sub(sphere.position, plane.point), normal);
    // If the distance is greater than sphere radius, no intersection
    if (Math.abs(signedDistance) > sphere.radius) {
        return { intersects: false };
    }
    // Calculate penetration depth
    const penetrationDepth = sphere.radius - Math.abs(signedDistance);
    // Calculate intersection point (center of intersection circle)
    // This is the projection of the sphere's center onto the plane
    const intersectionPoint = vec_1.vec3.sub(sphere.position, vec_1.vec3.mul(normal, signedDistance));
    // Calculate radius of intersection circle using Pythagorean theorem
    const intersectionRadius = Math.sqrt(sphere.radius * sphere.radius - signedDistance * signedDistance);
    return {
        intersects: true,
        intersectionPoint,
        penetrationDepth,
        intersectionRadius,
    };
}
/**
 * Check if a sphere intersects a cuboid
 */
function sphereIntersectsCuboid(sphere, cuboid) {
    const { position, size, rotation = (0, vec_1.vec3)() } = cuboid;
    const halfSize = vec_1.vec3.div(size, 2);
    // Transform sphere center to cuboid's local space
    let localSphereCenter = vec_1.vec3.sub(sphere.position, position);
    if (cuboidIsRotated(cuboid)) {
        localSphereCenter = vec_1.vec3.rota(localSphereCenter, vec_1.vec3.mul(rotation, -1));
    }
    // Find the closest point on the cuboid to the sphere center
    const closestLocalPoint = (0, vec_1.vec3)((0, utils_1.clamp)(localSphereCenter.x, -halfSize.x, halfSize.x), (0, utils_1.clamp)(localSphereCenter.y, -halfSize.y, halfSize.y), (0, utils_1.clamp)(localSphereCenter.z, -halfSize.z, halfSize.z));
    // Transform closest point back to world space
    let closestPoint = closestLocalPoint;
    if (cuboidIsRotated(cuboid)) {
        closestPoint = vec_1.vec3.rota(closestPoint, rotation);
    }
    closestPoint = vec_1.vec3.add(closestPoint, position);
    // Calculate vector from closest point to sphere center
    const separationVector = vec_1.vec3.sub(sphere.position, closestPoint);
    const distance = vec_1.vec3.len(separationVector);
    // If distance is greater than sphere radius, no intersection
    if (distance > sphere.radius) {
        return { intersects: false };
    }
    // Handle case where sphere center is exactly on cuboid surface
    if (distance < constants.EPSILON) {
        // Use vector from cuboid center to sphere center as normal
        let normal = vec_1.vec3.nor(vec_1.vec3.sub(sphere.position, position));
        const penetrationDepth = sphere.radius;
        return {
            intersects: true,
            intersectionPoint: sphere.position,
            penetrationDepth,
            normal,
            contactPoint: closestPoint,
        };
    }
    // Calculate normal and penetration depth
    const normal = vec_1.vec3.nor(separationVector);
    const penetrationDepth = sphere.radius - distance;
    // Calculate intersection point at center of intersection volume
    const intersectionPoint = vec_1.vec3.add(closestPoint, vec_1.vec3.mul(normal, penetrationDepth / 2));
    return {
        intersects: true,
        intersectionPoint,
        penetrationDepth,
        normal,
        contactPoint: closestPoint,
    };
}
/**
 * Check if a sphere intersects a polygon
 */
function sphereIntersectsPolygon(sphere, polygon) {
    // First validate the polygon
    if (!polygonIsValid(polygon)) {
        return null;
    }
    const [v1, v2, v3] = polygon.vertices;
    // Calculate polygon plane
    const edge1 = vec_1.vec3.sub(v2, v1);
    const edge2 = vec_1.vec3.sub(v3, v1);
    const normal = vec_1.vec3.nor(vec_1.vec3.cross(edge1, edge2));
    // Create plane from polygon
    const plane = {
        point: v1,
        normal,
    };
    // Check sphere-plane intersection first
    const planeIntersection = sphereIntersectsPlane(sphere, plane);
    if (!planeIntersection.intersects) {
        return { intersects: false };
    }
    // Check each vertex distance from sphere center
    const vertexDistances = polygon.vertices.map(vertex => vec_1.vec3.len(vec_1.vec3.sub(vertex, sphere.position)));
    // If all vertices are inside sphere, polygon is contained
    if (vertexDistances.every(dist => dist <= sphere.radius)) {
        return {
            intersects: true,
            intersectionPoint: planeIntersection.intersectionPoint,
            penetrationDepth: sphere.radius,
        };
    }
    // Create polygon edges
    const edges = [
        { start: v1, end: v2 },
        { start: v2, end: v3 },
        { start: v3, end: v1 },
    ];
    // Check each edge for intersection with sphere
    const polygonIntersectionPoints = [];
    edges.forEach(edge => {
        const lineIntersection = lineIntersectsSphere(edge, sphere);
        if (lineIntersection.intersects && lineIntersection.intersectionPoints) {
            // Only add points that lie on the polygon edges
            lineIntersection.intersectionPoints.forEach(point => {
                const onLine = pointOnLine(point, edge);
                if (onLine.intersects) {
                    polygonIntersectionPoints.push(point);
                }
            });
        }
    });
    // Check if sphere center projects onto polygon
    const projectedCenter = pointOnPolygon(sphere.position, polygon);
    if (projectedCenter && projectedCenter.intersects) {
        const distance = vec_1.vec3.len(vec_1.vec3.sub(sphere.position, projectedCenter.closestPoint));
        if (distance <= sphere.radius) {
            return {
                intersects: true,
                intersectionPoint: projectedCenter.closestPoint,
                penetrationDepth: sphere.radius - distance,
                polygonIntersectionPoints: polygonIntersectionPoints.length > 0
                    ? polygonIntersectionPoints
                    : undefined,
            };
        }
    }
    // If we have intersection points but no center projection,
    // use the midpoint of intersection points as intersection point
    if (polygonIntersectionPoints.length > 0) {
        const midPoint = vec_1.vec3.div(polygonIntersectionPoints.reduce((sum, p) => vec_1.vec3.add(sum, p), (0, vec_1.vec3)()), polygonIntersectionPoints.length);
        return {
            intersects: true,
            intersectionPoint: midPoint,
            penetrationDepth: sphere.radius - vec_1.vec3.len(vec_1.vec3.sub(midPoint, sphere.position)),
            polygonIntersectionPoints: polygonIntersectionPoints,
        };
    }
    // No intersection found
    return { intersects: false };
}
/**
 * Check if a sphere intersects any polygon in a mesh
 */
function sphereIntersectsMesh(sphere, mesh) {
    const polygons = meshToPolygons(mesh);
    let intersects = false;
    const intersectionPoints = [];
    const polygonIntersectionPoints = [];
    polygons.forEach(polygon => {
        const intersection = sphereIntersectsPolygon(sphere, polygon);
        if (intersection && intersection.intersects) {
            intersects = true;
            intersectionPoints.push(intersection.intersectionPoint);
            if (intersection.polygonIntersectionPoints) {
                polygonIntersectionPoints.push(...intersection.polygonIntersectionPoints);
            }
        }
    });
    return {
        intersects,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
        polygonIntersectionPoints: polygonIntersectionPoints.length > 0
            ? polygonIntersectionPoints
            : undefined,
    };
}
/**
 * Check if two planes intersect
 *
 * Based on the algorithm described in "Real-Time Collision Detection" by
 * Christer Ericson
 */
function planeIntersectsPlane(planeA, planeB) {
    // Normalize plane normals
    const normalA = vec_1.vec3.nor(planeA.normal);
    const normalB = vec_1.vec3.nor(planeB.normal);
    // Calculate direction of intersection line using cross product
    const direction = vec_1.vec3.cross(normalA, normalB);
    const directionLengthSq = vec_1.vec3.dot(direction, direction);
    // If direction length is almost zero, planes are parallel
    if (directionLengthSq < constants.EPSILON) {
        // Check if planes are coincident by comparing distance from one plane's point to other plane
        const signedDistance = vec_1.vec3.dot(vec_1.vec3.sub(planeB.point, planeA.point), normalA);
        // If distance is effectively zero, planes are coincident
        if (Math.abs(signedDistance) < constants.EPSILON) {
            return {
                intersects: true, // Coincident planes have infinite intersection
            };
        }
        // Planes are parallel with gap between them
        return {
            intersects: false,
        };
    }
    // Planes intersect along a line
    // Calculate a point on the intersection line using:
    // point = (b₂n₁ - b₁n₂) × (n₁ × n₂) / |n₁ × n₂|²
    // where b₁, b₂ are the plane constants (d in ax + by + cz + d = 0 form)
    // and n₁, n₂ are the plane normals
    const b1 = -vec_1.vec3.dot(normalA, planeA.point);
    const b2 = -vec_1.vec3.dot(normalB, planeB.point);
    const point = vec_1.vec3.div(vec_1.vec3.cross(vec_1.vec3.sub(vec_1.vec3.mul(normalA, b2), vec_1.vec3.mul(normalB, b1)), direction), directionLengthSq);
    return {
        intersects: true,
        intersectionLine: {
            start: point,
            end: vec_1.vec3.add(point, direction),
        },
    };
}
/**
 * Check if a plane intersects one or more polygons in a mesh
 */
function planeIntersectsMesh(plane, mesh) {
    return meshIntersectsPlane(mesh, plane);
}
/**
 * Check if two cuboids intersect using the Separating Axis Theorem
 */
function cuboidIntersectsCuboid(cuboidA, cuboidB) {
    // Extract properties with default rotations
    const { position: posA, size: sizeA, rotation: rotationA = (0, vec_1.vec3)() } = cuboidA;
    const { position: posB, size: sizeB, rotation: rotationB = (0, vec_1.vec3)() } = cuboidB;
    // Calculate half-sizes
    const halfSizeA = vec_1.vec3.div(sizeA, 2);
    const halfSizeB = vec_1.vec3.div(sizeB, 2);
    // Get rotation matrices for both cuboids
    const rotMatA = cuboidIsRotated(cuboidA)
        ? getRotationMatrix(rotationA)
        : null;
    const rotMatB = cuboidIsRotated(cuboidB)
        ? getRotationMatrix(rotationB)
        : null;
    // Get cuboid axes (face normals)
    const axesA = getRotatedAxes(rotMatA);
    const axesB = getRotatedAxes(rotMatB);
    // Vector between cuboid centers
    const centerDiff = vec_1.vec3.sub(posB, posA);
    // Test all 15 potential separating axes:
    // - 3 from cuboid A's face normals
    // - 3 from cuboid B's face normals
    // - 9 from cross products of edges (3x3)
    const axes = [...axesA, ...axesB, ...getCrossProductAxes(axesA, axesB)];
    let minPenetration = Infinity;
    let separationAxis = null;
    // Test each axis
    for (const axis of axes) {
        const axisLength = vec_1.vec3.len(axis);
        if (axisLength < constants.EPSILON)
            continue;
        // Normalize axis
        const normAxis = vec_1.vec3.div(axis, axisLength);
        // Project center-to-center vector onto axis
        const centerProj = vec_1.vec3.dot(centerDiff, normAxis);
        // Project both cuboids onto axis
        const projA = projectCuboid(halfSizeA, rotMatA, normAxis);
        const projB = projectCuboid(halfSizeB, rotMatB, normAxis);
        // Calculate penetration depth along this axis
        const penetration = projA + projB - Math.abs(centerProj);
        // If there's a gap, cuboids are separated
        if (penetration <= 0) {
            return { intersects: false };
        }
        // Track minimum penetration and its axis
        if (penetration < minPenetration) {
            minPenetration = penetration;
            separationAxis = normAxis;
        }
    }
    // If we get here, no separating axis was found - cuboids intersect
    if (!separationAxis) {
        return { intersects: true };
    }
    // Ensure normal points from A to B
    const normal = vec_1.vec3.dot(centerDiff, separationAxis) < 0
        ? vec_1.vec3.mul(separationAxis, -1)
        : separationAxis;
    // Calculate contact points on each cuboid's surface
    const contactA = getContactPoint(cuboidA, normal);
    const contactB = getContactPoint(cuboidB, vec_1.vec3.mul(normal, -1));
    // Calculate intersection point halfway between contacts
    const intersectionPoint = vec_1.vec3.add(contactA, vec_1.vec3.mul(vec_1.vec3.sub(contactB, contactA), 0.5));
    return {
        intersects: true,
        intersectionPoint,
        penetrationDepth: minPenetration,
        normal,
        contactPoints: {
            cuboidA: contactA,
            cuboidB: contactB,
        },
    };
}
/**
 * Helper function to create a rotation matrix from Euler angles
 */
function getRotationMatrix(rotation) {
    const cx = Math.cos(rotation.x);
    const cy = Math.cos(rotation.y);
    const cz = Math.cos(rotation.z);
    const sx = Math.sin(rotation.x);
    const sy = Math.sin(rotation.y);
    const sz = Math.sin(rotation.z);
    return [
        (0, vec_1.vec3)(cy * cz, cy * sz, -sy),
        (0, vec_1.vec3)(sx * sy * cz - cx * sz, sx * sy * sz + cx * cz, sx * cy),
        (0, vec_1.vec3)(cx * sy * cz + sx * sz, cx * sy * sz - sx * cz, cx * cy),
    ];
}
/**
 * Helper function to get rotated axes for a cuboid
 */
function getRotatedAxes(rotationMatrix) {
    if (!rotationMatrix) {
        return [(0, vec_1.vec3)(1, 0, 0), (0, vec_1.vec3)(0, 1, 0), (0, vec_1.vec3)(0, 0, 1)];
    }
    return rotationMatrix;
}
/**
 * Helper function to generate cross product axes
 */
function getCrossProductAxes(axesA, axesB) {
    const crossAxes = [];
    for (const axisA of axesA) {
        for (const axisB of axesB) {
            crossAxes.push(vec_1.vec3.cross(axisA, axisB));
        }
    }
    return crossAxes;
}
/**
 * Helper function to project cuboid onto axis
 */
function projectCuboid(halfSize, rotationMatrix, axis) {
    let projection = 0;
    if (!rotationMatrix) {
        // Unrotated cuboid - just sum up the components
        projection =
            Math.abs(halfSize.x * axis.x) +
                Math.abs(halfSize.y * axis.y) +
                Math.abs(halfSize.z * axis.z);
    }
    else {
        // Rotated cuboid - need to account for rotation
        projection =
            Math.abs(vec_1.vec3.dot(vec_1.vec3.mul(rotationMatrix[0], halfSize.x), axis)) +
                Math.abs(vec_1.vec3.dot(vec_1.vec3.mul(rotationMatrix[1], halfSize.y), axis)) +
                Math.abs(vec_1.vec3.dot(vec_1.vec3.mul(rotationMatrix[2], halfSize.z), axis));
    }
    return projection;
}
/**
 * Helper function to get contact point on cuboid surface
 */
function getContactPoint(cuboid, normal) {
    const vertices = cuboidVertices(cuboid);
    let maxProj = -Infinity;
    let contactPoint = vertices[0];
    // Find vertex with maximum projection along normal
    for (const vertex of vertices) {
        const proj = vec_1.vec3.dot(vertex, normal);
        if (proj > maxProj) {
            maxProj = proj;
            contactPoint = vertex;
        }
    }
    return contactPoint;
}
/**
 * Check if a cuboid intersects a plane
 */
function cuboidIntersectsPlane(cuboid, plane) {
    // Get cuboid faces as triangles
    const polygons = cuboidToPolygons(cuboid);
    const allIntersectionPoints = [];
    // Track vertices on each side of the plane for penetration depth calculation
    const normalizedPlaneNormal = vec_1.vec3.nor(plane.normal);
    let maxPenetration = -Infinity;
    let minPenetration = Infinity;
    // Check each vertex's signed distance to plane
    const vertices = cuboidVertices(cuboid);
    vertices.forEach(vertex => {
        const signedDistance = vec_1.vec3.dot(vec_1.vec3.sub(vertex, plane.point), normalizedPlaneNormal);
        maxPenetration = Math.max(maxPenetration, signedDistance);
        minPenetration = Math.min(minPenetration, signedDistance);
    });
    // Check each polygon for intersection
    for (const polygon of polygons) {
        const intersection = polygonIntersectsPlane(polygon, plane);
        if (intersection === null || intersection === void 0 ? void 0 : intersection.intersects) {
            // If polygon has specific intersection points, add them
            if (intersection.intersectionPoints) {
                intersection.intersectionPoints.forEach(point => {
                    // Check if point is already in list (within epsilon)
                    const isDuplicate = allIntersectionPoints.some(existing => vec_1.vec3.len(vec_1.vec3.sub(existing, point)) < constants.EPSILON);
                    if (!isDuplicate) {
                        allIntersectionPoints.push(point);
                    }
                });
            }
        }
    }
    // Calculate penetration depth
    // If min and max penetrations have different signs, cuboid straddles the
    // plane. Otherwise, penetration is the minimum absolute distance to plane
    let penetrationDepth;
    if (minPenetration * maxPenetration <= 0) {
        // Cuboid straddles plane - penetration is the larger absolute value
        penetrationDepth = Math.max(Math.abs(minPenetration), Math.abs(maxPenetration));
    }
    else if (Math.abs(maxPenetration) < Math.abs(minPenetration)) {
        // All vertices on positive side of plane
        penetrationDepth = Math.abs(maxPenetration);
    }
    else {
        // All vertices on negative side of plane
        penetrationDepth = Math.abs(minPenetration);
    }
    return {
        intersects: allIntersectionPoints.length > 0,
        intersectionPoints: allIntersectionPoints.length > 0 ? allIntersectionPoints : undefined,
        penetrationDepth: penetrationDepth,
    };
}
/**
 * Check if a cuboid intersects a polygon
 */
function cuboidIntersectsPolygon(cuboid, polygon) {
    // First validate the polygon
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // Check if any polygon vertex is inside the cuboid
    const verticesInside = polygon.vertices.map(v => pointInCuboid(v, cuboid));
    if (verticesInside.every(result => result.intersects)) {
        // Polygon is entirely contained within cuboid
        return { intersects: true };
    }
    // Get cuboid vertices and check if any are on the polygon
    const cuboidVerticesArray = cuboidVertices(cuboid);
    const verticesOnPolygon = cuboidVerticesArray.map(v => pointOnPolygon(v, polygon));
    if (verticesOnPolygon.some(result => result === null || result === void 0 ? void 0 : result.intersects)) {
        // At least one cuboid vertex lies on the polygon
        // This likely means the polygon is coincident with a cuboid face
        return { intersects: true };
    }
    // Get cuboid edges
    const cuboidEdges = verticesToEdges(cuboidVerticesArray);
    const intersectionPoints = [];
    // Check each cuboid edge for intersection with the polygon
    for (const edge of cuboidEdges) {
        const intersection = lineIntersectsPolygon(edge, polygon);
        if (intersection &&
            intersection.intersects &&
            intersection.intersectionPoint) {
            // Check if this point is already in our list (within epsilon)
            const isDuplicate = intersectionPoints.some(existing => (0, utilities_1.vectorsAlmostEqual)(existing, intersection.intersectionPoint));
            if (!isDuplicate) {
                intersectionPoints.push(intersection.intersectionPoint);
            }
        }
    }
    // Get polygon edges and check against cuboid faces
    const polygonEdges = verticesToEdges(polygon.vertices);
    const cuboidPolygons = cuboidToPolygons(cuboid);
    // Check each polygon edge against each cuboid face
    for (const edge of polygonEdges) {
        for (const face of cuboidPolygons) {
            const intersection = lineIntersectsPolygon(edge, face);
            if (intersection &&
                intersection.intersects &&
                intersection.intersectionPoint) {
                // Check if this point is already in our list (within epsilon)
                const isDuplicate = intersectionPoints.some(existing => (0, utilities_1.vectorsAlmostEqual)(existing, intersection.intersectionPoint));
                if (!isDuplicate) {
                    intersectionPoints.push(intersection.intersectionPoint);
                }
            }
        }
    }
    return {
        intersects: intersectionPoints.length > 0 ||
            verticesInside.some(result => result.intersects) ||
            verticesOnPolygon.some(result => result === null || result === void 0 ? void 0 : result.intersects),
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a cuboid intersects any polygon in a mesh
 */
function cuboidIntersectsMesh(cuboid, mesh) {
    const polygons = meshToPolygons(mesh);
    const intersectionPoints = [];
    // Check each polygon in the mesh against the cuboid
    for (const polygon of polygons) {
        const intersection = cuboidIntersectsPolygon(cuboid, polygon);
        if (intersection && intersection.intersects) {
            // If we have specific intersection points, add them
            if (intersection.intersectionPoints) {
                intersection.intersectionPoints.forEach(point => {
                    // Check if point is already in list (within epsilon)
                    const isDuplicate = intersectionPoints.some(existing => (0, utilities_1.vectorsAlmostEqual)(existing, point));
                    if (!isDuplicate) {
                        intersectionPoints.push(point);
                    }
                });
            }
            else {
                // If we don't have intersection points but we know there's an
                // intersection, we can early return since we know they intersect
                // (this happens when a polygon is inside the cuboid or coincident
                // with a face)
                return {
                    intersects: true,
                };
            }
        }
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if two polygons intersect
 */
function polygonIntersectsPolygon(polygonA, polygonB) {
    // First validate both polygons
    if (!polygonIsValid(polygonA) || !polygonIsValid(polygonB)) {
        return null;
    }
    // Create planes from both polygons
    const planeA = {
        point: polygonA.vertices[0],
        normal: vec_1.vec3.nor(vec_1.vec3.cross(vec_1.vec3.sub(polygonA.vertices[1], polygonA.vertices[0]), vec_1.vec3.sub(polygonA.vertices[2], polygonA.vertices[0]))),
    };
    const planeB = {
        point: polygonB.vertices[0],
        normal: vec_1.vec3.nor(vec_1.vec3.cross(vec_1.vec3.sub(polygonB.vertices[1], polygonB.vertices[0]), vec_1.vec3.sub(polygonB.vertices[2], polygonB.vertices[0]))),
    };
    // Check if planes intersect
    const planeIntersection = planeIntersectsPlane(planeA, planeB);
    // If planes don't intersect, polygons can't intersect
    if (!planeIntersection.intersects) {
        return { intersects: false };
    }
    // If planes are coincident, we need to check for polygon overlap
    if (!planeIntersection.intersectionLine) {
        // First check if any vertex of polygon A lies inside polygon B
        for (const vertex of polygonA.vertices) {
            const pointCheck = pointOnPolygon(vertex, polygonB);
            if (pointCheck === null || pointCheck === void 0 ? void 0 : pointCheck.intersects) {
                return { intersects: true }; // Coplanar overlap
            }
        }
        // Then check if any vertex of polygon B lies inside polygon A
        for (const vertex of polygonB.vertices) {
            const pointCheck = pointOnPolygon(vertex, polygonA);
            if (pointCheck === null || pointCheck === void 0 ? void 0 : pointCheck.intersects) {
                return { intersects: true }; // Coplanar overlap
            }
        }
        // No overlap found
        return { intersects: false };
    }
    // Get edges from both polygons
    const edgesA = verticesToEdges(polygonA.vertices);
    const edgesB = verticesToEdges(polygonB.vertices);
    const intersectionPoints = [];
    // Check each edge of polygon A against each edge of polygon B
    for (const edgeA of edgesA) {
        for (const edgeB of edgesB) {
            const intersection = lineIntersectsLine(edgeA, edgeB);
            if (intersection.intersects && intersection.intersectionPoint) {
                // Verify the intersection point lies on both edges
                const onEdgeA = pointOnLine(intersection.intersectionPoint, edgeA);
                const onEdgeB = pointOnLine(intersection.intersectionPoint, edgeB);
                if (onEdgeA.intersects && onEdgeB.intersects) {
                    // Check if this point is already in our list (within epsilon)
                    const isDuplicate = intersectionPoints.some(existing => vec_1.vec3.len(vec_1.vec3.sub(existing, intersection.intersectionPoint)) <
                        constants.EPSILON);
                    if (!isDuplicate) {
                        intersectionPoints.push(intersection.intersectionPoint);
                    }
                }
            }
        }
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a polygon intersects a plane
 */
function polygonIntersectsPlane(polygon, plane) {
    // First validate the polygon
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // Convert polygon vertices to edges
    const edges = verticesToEdges(polygon.vertices);
    const intersectionPoints = [];
    let edgeInPlane = false;
    // Check each edge for intersection with the plane
    for (const edge of edges) {
        const intersection = lineIntersectsPlane(edge, plane);
        if (intersection.intersects) {
            if (intersection.intersectionPoint) {
                // Edge intersects plane at a point
                intersectionPoints.push(intersection.intersectionPoint);
            }
            else {
                // Edge lies in the plane
                edgeInPlane = true;
                break; // Early exit as polygon must lie in plane
            }
        }
    }
    // If any edge lies in the plane, the whole polygon must lie in the plane
    // (since we've verified it's a valid triangle)
    if (edgeInPlane) {
        return {
            intersects: true,
        };
    }
    // Remove duplicate intersection points (within epsilon)
    const uniquePoints = intersectionPoints.filter((point, index) => {
        return !intersectionPoints.some((p, i) => i < index && vec_1.vec3.len(vec_1.vec3.sub(p, point)) < constants.EPSILON);
    });
    return {
        intersects: uniquePoints.length > 0,
        intersectionPoints: uniquePoints.length > 0 ? uniquePoints : undefined,
    };
}
/**
 * Check if a polygon intersects any polygon in a mesh
 */
function polygonIntersectsMesh(polygon, mesh) {
    // First validate the polygon
    if (!polygonIsValid(polygon)) {
        return null;
    }
    const meshPolygons = meshToPolygons(mesh);
    const intersectionPoints = [];
    // Check the polygon against each mesh polygon
    for (const meshPolygon of meshPolygons) {
        const intersection = polygonIntersectsPolygon(polygon, meshPolygon);
        if (intersection && intersection.intersects) {
            // If we have intersection points, collect them
            if (intersection.intersectionPoints) {
                intersection.intersectionPoints.forEach(point => {
                    // Check if point is already in list (within epsilon)
                    const isDuplicate = intersectionPoints.some(existing => (0, utilities_1.vectorsAlmostEqual)(existing, point));
                    if (!isDuplicate) {
                        intersectionPoints.push(point);
                    }
                });
            }
            else {
                // If we have an intersection but no points, it means we have
                // coplanar overlapping polygons - we can return early
                return {
                    intersects: true,
                };
            }
        }
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if two meshes intersect using their polygons
 */
function meshIntersectsMesh(meshA, meshB) {
    const polygonsA = meshToPolygons(meshA);
    const polygonsB = meshToPolygons(meshB);
    const intersectionPoints = [];
    // Check each polygon in mesh A against each polygon in mesh B
    for (const polygonA of polygonsA) {
        for (const polygonB of polygonsB) {
            const intersection = polygonIntersectsPolygon(polygonA, polygonB);
            if (intersection && intersection.intersects) {
                if (intersection.intersectionPoints) {
                    intersection.intersectionPoints.forEach(point => {
                        // Check if point is already in list (within epsilon)
                        const isDuplicate = intersectionPoints.some(existing => vec_1.vec3.len(vec_1.vec3.sub(existing, point)) < constants.EPSILON);
                        if (!isDuplicate) {
                            intersectionPoints.push(point);
                        }
                    });
                }
            }
        }
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if any polygons in a mesh intersect a plane
 */
function meshIntersectsPlane(mesh, plane) {
    // Convert mesh to polygons
    const polygons = meshToPolygons(mesh);
    const allIntersectionPoints = [];
    // Track maximum penetration depth
    let maxPenetration = -Infinity;
    let minPenetration = Infinity;
    // Normalize plane normal for consistent signed distance calculations
    const normalizedPlaneNormal = vec_1.vec3.nor(plane.normal);
    // Check each vertex's signed distance to plane
    mesh.vertices.forEach(vertex => {
        const signedDistance = vec_1.vec3.dot(vec_1.vec3.sub(vertex, plane.point), normalizedPlaneNormal);
        maxPenetration = Math.max(maxPenetration, signedDistance);
        minPenetration = Math.min(minPenetration, signedDistance);
    });
    // Check each polygon for intersection
    let hasIntersection = false;
    for (const polygon of polygons) {
        const intersection = polygonIntersectsPlane(polygon, plane);
        if (intersection === null || intersection === void 0 ? void 0 : intersection.intersects) {
            hasIntersection = true;
            // If polygon has specific intersection points, add them
            if (intersection.intersectionPoints) {
                intersection.intersectionPoints.forEach(point => {
                    // Check if point is already in list (within epsilon)
                    const isDuplicate = allIntersectionPoints.some(existing => vec_1.vec3.len(vec_1.vec3.sub(existing, point)) < constants.EPSILON);
                    if (!isDuplicate) {
                        allIntersectionPoints.push(point);
                    }
                });
            }
        }
    }
    // Calculate penetration depth
    // If min and max penetrations have different signs, mesh straddles the plane
    // Otherwise, penetration is the minimum absolute distance to plane
    let penetrationDepth;
    if (minPenetration * maxPenetration <= 0) {
        // Mesh straddles plane - penetration is the larger absolute value
        penetrationDepth = Math.max(Math.abs(minPenetration), Math.abs(maxPenetration));
    }
    else if (Math.abs(maxPenetration) < Math.abs(minPenetration)) {
        // All vertices on positive side of plane
        penetrationDepth = Math.abs(maxPenetration);
    }
    else {
        // All vertices on negative side of plane
        penetrationDepth = Math.abs(minPenetration);
    }
    return {
        intersects: hasIntersection,
        intersectionPoints: allIntersectionPoints.length > 0 ? allIntersectionPoints : undefined,
        penetrationDepth: penetrationDepth,
    };
}


/***/ }),

/***/ "./src/3d/types.ts":
/*!*************************!*\
  !*** ./src/3d/types.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_240199__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isPoint = isPoint;
exports.isRay = isRay;
exports.isLine = isLine;
exports.isSphere = isSphere;
exports.isAABB = isAABB;
exports.isCuboid = isCuboid;
exports.isPlane = isPlane;
exports.isPolygon = isPolygon;
exports.isMesh = isMesh;
const types_1 = __nested_webpack_require_240199__(/*! ../utilities/types */ "./src/utilities/types.ts");
/**
 * Type guard to check if a value is a Point
 */
function isPoint(value) {
    return (0, types_1.isVec3)(value);
}
/**
 * Check if a value is a Ray
 */
function isRay(value) {
    return (value &&
        typeof value === 'object' &&
        'origin' in value &&
        isPoint(value.origin) &&
        'direction' in value &&
        (0, types_1.isVec3)(value.direction));
}
/**
 * Check if a value is a Line
 */
function isLine(value) {
    return (value &&
        typeof value === 'object' &&
        'start' in value &&
        isPoint(value.start) &&
        'end' in value &&
        isPoint(value.end));
}
/**
 * Check if a value is a Sphere
 */
function isSphere(value) {
    return (value &&
        typeof value === 'object' &&
        'position' in value &&
        isPoint(value.position) &&
        'radius' in value &&
        typeof value.radius === 'number');
}
/**
 * Check if a value is an AABB
 */
function isAABB(value) {
    return (value &&
        typeof value === 'object' &&
        'position' in value &&
        isPoint(value.position) &&
        'size' in value &&
        (0, types_1.isVec3)(value.size));
}
/**
 * Check if a value is a Cuboid
 */
function isCuboid(value) {
    return (value &&
        typeof value === 'object' &&
        'position' in value &&
        isPoint(value.position) &&
        'size' in value &&
        (0, types_1.isVec3)(value.size) &&
        ('rotation' in value ? (0, types_1.isVec3)(value.rotation) : true));
}
/**
 * Check if a value is a Plane
 */
function isPlane(value) {
    return (value &&
        typeof value === 'object' &&
        'point' in value &&
        isPoint(value.point) &&
        'normal' in value &&
        (0, types_1.isVec3)(value.normal));
}
/**
 * Check if a value is a Polygon
 */
function isPolygon(value) {
    return (value &&
        typeof value === 'object' &&
        'vertices' in value &&
        Array.isArray(value.vertices) &&
        value.vertices.length === 3 &&
        value.vertices.every(isPoint) &&
        !('indices' in value));
}
/**
 * Check if a value is a Mesh
 */
function isMesh(value) {
    return (value &&
        typeof value === 'object' &&
        'vertices' in value &&
        Array.isArray(value.vertices) &&
        value.vertices.every(isPoint) &&
        'indices' in value &&
        Array.isArray(value.indices) &&
        value.indices.every((i) => typeof i === 'number'));
}


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_243229__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.intersectionUtilities = exports.intersection3d = exports.intersection2d = void 0;
exports.intersection2d = __importStar(__nested_webpack_require_243229__(/*! ./2d */ "./src/2d/index.ts"));
exports.intersection3d = __importStar(__nested_webpack_require_243229__(/*! ./3d */ "./src/3d/index.ts"));
exports.intersectionUtilities = __importStar(__nested_webpack_require_243229__(/*! ./utilities */ "./src/utilities/index.ts"));


/***/ }),

/***/ "./src/utilities/constants.ts":
/*!************************************!*\
  !*** ./src/utilities/constants.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EPSILON = void 0;
exports.EPSILON = 1e-6;


/***/ }),

/***/ "./src/utilities/index.ts":
/*!********************************!*\
  !*** ./src/utilities/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_245646__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vectorAlmostZero = vectorAlmostZero;
exports.vectorsAlmostEqual = vectorsAlmostEqual;
exports.valueInInterval = valueInInterval;
exports.intervalsOverlap = intervalsOverlap;
exports.overlapInterval = overlapInterval;
const constants = __importStar(__nested_webpack_require_245646__(/*! ./constants */ "./src/utilities/constants.ts"));
const types_1 = __nested_webpack_require_245646__(/*! ./types */ "./src/utilities/types.ts");
__exportStar(__nested_webpack_require_245646__(/*! ./types */ "./src/utilities/types.ts"), exports);
function vectorAlmostZero(v) {
    if ((0, types_1.isVec3)(v)) {
        return (Math.abs(v.x) < constants.EPSILON &&
            Math.abs(v.y) < constants.EPSILON &&
            Math.abs(v.z) < constants.EPSILON);
    }
    if ((0, types_1.isVec2)(v)) {
        return (Math.abs(v.x) < constants.EPSILON && Math.abs(v.y) < constants.EPSILON);
    }
    return false;
}
function vectorsAlmostEqual(a, b) {
    if ((0, types_1.isVec3)(a) && (0, types_1.isVec3)(b)) {
        return (Math.abs(a.x - b.x) < constants.EPSILON &&
            Math.abs(a.y - b.y) < constants.EPSILON &&
            Math.abs(a.z - b.z) < constants.EPSILON);
    }
    if ((0, types_1.isVec2)(a) && (0, types_1.isVec2)(b)) {
        return (Math.abs(a.x - b.x) < constants.EPSILON &&
            Math.abs(a.y - b.y) < constants.EPSILON);
    }
    return false;
}
/**
 * Check if a value is within a specified interval
 */
function valueInInterval(value, interval) {
    const { min, minInclusive = true, max, maxInclusive = true } = interval;
    return ((minInclusive ? value >= min : value > min) &&
        (maxInclusive ? value <= max : value < max));
}
/**
 * Check if two intervals (a1, a2) and (b1, b2) overlap
 */
function intervalsOverlap(a, b) {
    return Math.max(a.min, b.min) <= Math.min(a.max, b.max);
}
/**
 * Get the overlapping part of two intervals (a1, a2) and (b1, b2)
 *
 * If the intervals do not overlap, return null
 */
function overlapInterval(a, b) {
    if (!intervalsOverlap(a, b)) {
        return null;
    }
    return { min: Math.max(a.min, b.min), max: Math.min(a.max, b.max) };
}


/***/ }),

/***/ "./src/utilities/types.ts":
/*!********************************!*\
  !*** ./src/utilities/types.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVec2 = isVec2;
exports.isVec3 = isVec3;
/**
 * Check if a value is a vec2
 */
function isVec2(value) {
    return (value &&
        typeof value === 'object' &&
        'x' in value &&
        typeof value.x === 'number' &&
        'y' in value &&
        typeof value.y === 'number' &&
        !('z' in value));
}
/**
 * Check if a value is a vec3
 */
function isVec3(value) {
    return (value &&
        typeof value === 'object' &&
        'x' in value &&
        typeof value.x === 'number' &&
        'y' in value &&
        typeof value.y === 'number' &&
        'z' in value &&
        typeof value.z === 'number');
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_250554__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_250554__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_250554__("./src/index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * @overview A library of useful functions
 * @author Gordon Larrigan
 */

/**
 * Memoize a function
 * @param {Function} f The function to memoize
 * @returns {Function} A memoized version of the function
 */
const memoize = f => {
  var cache = {};
  return function(...args) {
    return cache[args] ?? (cache[args] = f.apply(this, args));
  };
};

/**
 * Check if two numbers are approximately equal
 * @param {number} a Number a
 * @param {number} b Number b
 * @param {number} [p=Number.EPSILON] The precision value
 * @return {boolean} True if numbers a and b are approximately equal
 */
const floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;

/**
 * Clamp a number between min and max
 * @param {number} a The number to clamp
 * @param {number} [min=0] The minimum value
 * @param {number} [max=1] The maximum value
 * @return {number} A clamped number
 */
const clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);

/**
 * Get the fractional part of a number
 * @param {number} a The number from which to get the fractional part
 * @return {number} The fractional part of the number
 */
const frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);

/**
 * Round n to d decimal places
 * @param {number} n The number to round
 * @param {number} [d=0] The number of decimal places to round to
 * @return {number} A rounded number
 */
const round = (n, d = 0) => {
  const p = Math.pow(10, d);
  return Math.round(n * p + Number.EPSILON) / p;
}

/**
 * Do a linear interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} An interpolated value in the interval [a, b]
 */
const lerp = (a, b, i) => a + (b - a) * i;

/**
 * Get the position of i between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolated value in the interval [a, b]
 * @return {number} The position of i between a and b
 */
const unlerp = (a, b, i) => (i - a) / (b - a);

/**
 * Do a bilinear interpolation
 * @param {number} c00 Top-left value
 * @param {number} c10 Top-right value
 * @param {number} c01 Bottom-left value
 * @param {number} c11 Bottom-right value
 * @param {number} ix Interpolation value along x
 * @param {number} iy Interpolation value along y
 * @return {number} A bilinear interpolated value
 */
const blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);

/**
 * Re-map a number i from range a1...a2 to b1...b2
 * @param {number} i The number to re-map
 * @param {number} a1
 * @param {number} a2
 * @param {number} b1
 * @param {number} b2
 * @return {number}
 */
const remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);

/**
 * Do a smooth interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value
 * @return {number} An interpolated value in the interval [a, b]
 */
const smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));

/**
 * Get an angle in radians
 * @param {number} degrees The angle in degrees
 * @return {number} The angle in radians
 */
const radians = degrees => (Math.PI / 180) * degrees;

/**
 * Get an angle in degrees
 * @param {number} radians The angle in radians
 * @return {number} The angle in degrees
 */
const degrees = radians => (180 / Math.PI) * radians;

/**
 * Get a random float in the interval [min, max)
 * @param {number} min Inclusive min
 * @param {number} max Exclusive max
 * @return {number} A random float in the interval [min, max)
 */
const randomBetween = (min, max) => Math.random() * (max - min) + min;

/**
 * Get a random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A random integer in the interval [min, max]
 */
const randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

/**
 * Get a normally-distributed random number
 * @param {number} [mu=0.5] The mean value
 * @param {number} [sigma=0.5] The standard deviation
 * @param {number} [samples=2] The number of samples
 * @return {number} A normally-distributed random number
 */
const cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {
  let total = 0;
  for (let i = samples; i--;) {
    total += Math.random();
  }
  return mu + (total - samples / 2) / (samples / 2) * sigma;
};

/**
 * Get a normally-distributed random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A normally-distributed random integer
 */
const cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));

/**
 * Return a weighted random integer
 * @param {Array<number>} w An array of weights
 * @return {number} An index from w
 */
const weightedRandom = w => {
  let total = w.reduce((a, i) => a + i, 0), n = 0;
  const r = Math.random() * total;
  while (total > r) {
    total -= w[n++];
  }
  return n - 1;
};

/**
 * An interpolation function
 * @callback InterpolationFunction
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} The interpolated value in the interval [a, b]
 */

/**
 * Return an interpolated value from an array
 * @param {Array<number>} a An array of values interpolate
 * @param {number} i A number in the interval [0, 1]
 * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use
 * @return {number} An interpolated value in the interval [min(a), max(a)]
 */
const lerpArray = (a, i, f = lerp) => {
  const s = i * (a.length - 1);
  const p = clamp(Math.trunc(s), 0, a.length - 1);
  return f(a[p] || 0, a[p + 1] || 0, frac(s));
};

/**
 * Get the dot product of two vectors
 * @param {Array<number>} a Vector a
 * @param {Array<number>} b Vector b
 * @return {number} a ∙ b
 */
const dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);

/**
 * Get the factorial of a number
 * @param {number} a
 * @return {number} a!
 */
const factorial = a => {
  let result = 1;
  for (let i = 2; i <= a; i++) {
    result *= i;
  }
  return result;
};

/**
 * Get the number of permutations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nPr
 */
const npr = (n, r) => factorial(n) / factorial(n - r);

/**
 * Get the number of combinations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nCr
 */
const ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));

/**
 * Generate all permutations of r elements from an array
 *
 * @example
 * ```js
 * permutations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 1],
 *   [2, 3],
 *   [3, 1],
 *   [3, 2]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each permutation
 * @return {Array<Array<*>>} An array of permutation arrays
 */
const permutations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),
    ],
    []
  );
}

/**
 * Generate all combinations of r elements from an array
 *
 * @example
 * ```js
 * combinations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 3]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each combination
 * @return {Array<Array<*>>} An array of combination arrays
 */
const combinations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),
    ],
    []
  );
};

/**
 * Get a cartesian product of arrays
 *
 * @example
 * ```js
 * cartesian([1, 2, 3], ['a', 'b']);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, "a"],
 *   [1, "b"],
 *   [2, "a"],
 *   [2, "b"],
 *   [3, "a"],
 *   [3, "b"]
 * ]
 * ```
 */
const cartesian = (...arr) =>
  arr.reduce(
    (a, b) => a.flatMap(c => b.map(d => [...c, d])),
    [[]]
  );

/**
 * A function for generating array values
 * @callback TimesFunction
 * @param {number} i The array index
 * @return {*} The array value
 */

/**
 * Return a new array with length n by calling function f(i) on each element
 * @param {TimesFunction} f
 * @param {number} n The size of the array
 * @return {Array<*>}
 */
const times = (f, n) => Array(n).fill(0).map((_, i) => f(i));

/**
 * Return an array containing numbers 0->(n - 1)
 * @param {number} n The size of the array
 * @return {Array<number>} An array of integers 0->(n - 1)
 */
const range = n => times(i => i, n);

/**
 * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]
 * @param {...Array<*>} a The arrays to zip
 * @return {Array<Array<*>>}
 */
const zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));

/**
 * Return array[i] with positive and negative wrapping
 * @param {Array<*>} a The array to access
 * @param {number} i The positively/negatively wrapped array index
 * @return {*} An element from the array
 */
const at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];

/**
 * Return the last element of an array without removing it
 * @param {Array<*>} a
 * @return {*} The last element from the array
 */
const peek = (a) => {
  if (!a.length) {
    return undefined;
  }

  return a[a.length - 1];
};

/**
 * Return the index for a given position in an unrolled 2d array
 * @param {number} x The x position
 * @param {number} y The y position
 * @param {number} w The width of the 2d array
 * @returns {number} The index in the unrolled array
 */
const ind = (x, y, w) => x + y * w;

/**
 * Return the position for a given index in an unrolled 2d array
 * @param {number} i The index
 * @param {number} w The width of the 2d array
 * @returns {Array<number>} The position as a 2-tuple
 */
const pos = (i, w) => [i % w, Math.floor(i / w)];

/**
 * Chop an array into chunks of size n
 * @param {Array<*>} a
 * @param {number} n The chunk size
 * @return {Array<Array<*>>} An array of array chunks
 */
const chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));

/**
 * Randomly shuffle a shallow copy of an array
 * @param {Array<*>} a
 * @return {Array<*>} The shuffled array
 */
const shuffle = a => a.slice().sort(() => Math.random() - 0.5);

/**
 * Flatten an object
 * @param {object} o
 * @param {string} concatenator The string to use for concatenating keys
 * @return {object} A flattened object
 */
const flat = (o, concatenator = '.') => {
  return Object.keys(o).reduce((acc, key) => {
    if (o[key] instanceof Date) {
      return {
        ...acc,
        [key]: o[key].toISOString(),
      };
    }

    if (typeof o[key] !== 'object' || !o[key]) {
      return {
        ...acc,
        [key]: o[key],
      };
    }
    const flattened = flat(o[key], concatenator);

    return {
      ...acc,
      ...Object.keys(flattened).reduce(
        (childAcc, childKey) => ({
          ...childAcc,
          [`${key}${concatenator}${childKey}`]: flattened[childKey],
        }),
        {}
      ),
    };
  }, {});
};

/**
 * Unflatten an object
 * @param {object} o
 * @param {string} concatenator The string to check for in concatenated keys
 * @return {object} An un-flattened object
 */
const unflat = (o, concatenator = '.') => {
  let result = {}, temp, substrings, property, i;

  for (property in o) {
    substrings = property.split(concatenator);
    temp = result;
    for (i = 0; i < substrings.length - 1; i++) {
      if (!(substrings[i] in temp)) {
        if (isFinite(substrings[i + 1])) {
          temp[substrings[i]] = [];
        } else {
          temp[substrings[i]] = {};
        }
      }
      temp = temp[substrings[i]];
    }
    temp[substrings[substrings.length - 1]] = o[property];
  }

  return result;
};

/**
 * A split predicate
 * @callback SplitPredicate
 * @param {any} value The current value
 * @return {boolean} True if the array should split at this index
 */

/**
 * Split an array into sub-arrays based on a predicate
 * @param {Array<*>} array
 * @param {SplitPredicate} predicate
 * @return {Array<Array<*>>} An array of arrays
 */
const split = (array, predicate) => {
  const result = [];
  let current = [];
  for (const value of array) {
    if (predicate(value)) {
      if (current.length) {
        result.push(current);
      }
      current = [value];
    } else {
      current.push(value);
    }
  }
  result.push(current);

  return result;
};

/**
 * Pluck keys from an object
 * @param {object} o
 * @param {...string} keys The keys to pluck from the object
 * @return {object} An object containing the plucked keys
 */
const pluck = (o, ...keys) => {
  return keys.reduce(
    (result, key) => Object.assign(result, { [key]: o[key] }),
    {}
  );
};

/**
 * Exclude keys from an object
 * @param {object} o
 * @param {...string} keys The keys to exclude from the object
 * @return {object} An object containing all keys except excluded keys
 */
const exclude = (o, ...keys) => {
  return Object.fromEntries(
    Object.entries(o).filter(([key]) => !keys.includes(key))
  );
};

if (true) {
  module.exports = {
    memoize,
    floatEquals,
    clamp,
    frac,
    round,
    lerp,
    unlerp,
    blerp,
    remap,
    smoothstep,
    radians,
    degrees,
    randomBetween,
    randomIntBetween,
    cltRandom,
    cltRandomInt,
    weightedRandom,
    lerpArray,
    dot,
    factorial,
    npr,
    ncr,
    permutations,
    combinations,
    cartesian,
    times,
    range,
    zip,
    at,
    peek,
    ind,
    pos,
    chunk,
    shuffle,
    flat,
    unflat,
    split,
    pluck,
    exclude,
  };
}


/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * @overview A small vector and matrix library
 * @author Gordon Larrigan
 */

const _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));
const _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));
const _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);
const _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;
const _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;

/**
 * A 2d vector
 * @typedef {Object} vec2
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 */

/**
 * Create a new 2d vector
 * @param {number|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector
 * @return {vec2} A new 2d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec2(3, 2); // (3, 2)
 * let b = vec2(4);    // (4, 4)
 * let c = vec2(a);    // (3, 2)
 * let d = vec2();     // (0, 0)
 */
const vec2 = (x, y) => {
  if (!x && !y) {
    return { x: 0, y: 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0 };
  }
  return { x: x, y: y ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec2} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec2.components = a => [a.x, a.y];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec2} A new vector
 */
vec2.fromComponents = components => vec2(...components.slice(0, 2));

/**
 * Return a unit vector (1, 0)
 * @return {vec2} A unit vector (1, 0)
 */
vec2.ux = () => vec2(1, 0);

/**
 * Return a unit vector (0, 1)
 * @return {vec2} A unit vector (0, 1)
 */
vec2.uy = () => vec2(0, 1);

/**
 * Add vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a + b
 */
vec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });

/**
 * Subtract vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a - b
 */
vec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });

/**
 * Scale a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a * b
 */
vec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });

/**
 * Scale a vector by a scalar, alias for vec2.mul
 * @param {vec2} a Vector a
 * @param {number} b Scalar b
 * @return {vec2} a * b
 */
vec2.scale = (a, b) => vec2.mul(a, b);

/**
 * Divide a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a / b
 */
vec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });

/**
 * Get the length of a vector
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);

/**
 * Normalise a vector
 * @param {vec2} a The vector to normalise
 * @return {vec2} ^a
 */
vec2.nor = a => {
  let len = vec2.len(a);
  return len ? { x: a.x / len, y: a.y / len } : vec2();
};

/**
 * Get a dot product of vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a ∙ b
 */
vec2.dot = (a, b) => a.x * b.x + a.y * b.y;

/**
 * Rotate a vector by r radians
 * @param {vec2} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec2} A rotated vector
 */
vec2.rot = (a, r) => {
  let s = Math.sin(r),
    c = Math.cos(r);
  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };
};

/**
 * Fast method to rotate a vector by -90, 90 or 180 degrees
 * @param {vec2} a The vector to rotate
 * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees
 * @return {vec2} A rotated vector
 */
vec2.rotf = (a, r) => {
  switch (r) {
    case 1: return vec2(a.y, -a.x);
    case -1: return vec2(-a.y, a.x);
    case 2: case -2: return vec2(-a.x, -a.y);
    default: return a;
  }
};

/**
 * Scalar cross product of two vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a × b
 */
vec2.cross = (a, b) => {
  return a.x * b.y - a.y * b.x;
};

/**
 * Check if two vectors are equal
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec2.eq = (a, b) => a.x === b.x && a.y === b.y;

/**
 * Get the angle of a vector
 * @param {vec2} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec2.rad = a => Math.atan2(a.y, a.x);

/**
 * Copy a vector
 * @param {vec2} a The vector to copy
 * @return {vec2} A copy of vector a
 */
vec2.cpy = a => vec2(a);

/**
 * A function to call on each component of a 2d vector
 * @callback vec2MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y'} label The component label (x or y)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec2} a Vector a
 * @param {vec2MapCallback} f The function to call on each component of the vector
 * @return {vec2} Vector a mapped through f
 */
vec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });

/**
 * Convert a vector into a string
 * @param {vec2} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x` or `y`
 * - `u` or `v` (aliases for `x` and `y`, respectively)
 * - `X`, `Y`, `U`, `V` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec2} a The vector to swizzle
 * @param {string} [s='..'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec2(3, -2);
 * vec2.swiz(a, 'x');    // [3]
 * vec2.swiz(a, 'yx');   // [-2, 3]
 * vec2.swiz(a, 'xY');   // [3, 2]
 * vec2.swiz(a, 'Yy');   // [2, -2]
 * vec2.swiz(a, 'x.x');  // [3, -2, 3]
 * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]
 */
vec2.swiz = (a, s = '..') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': result.push(a.x); break;
      case 'y': case 'v': result.push(a.y); break;
      case 'X': case 'U': result.push(-a.x); break;
      case 'Y': case 'V': result.push(-a.y); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 2d vector
 * @typedef {Object} polarCoordinates2d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec2} a The vector to convert
 * @return {polarCoordinates2d} The magnitude and angle of the vector
 */
vec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The angle of the vector
 * @return {vec2} A vector with the given angle and magnitude
 */
vec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));

/**
 * A 3d vector
 * @typedef {Object} vec3
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 * @property {number} z The z component of the vector
 */

/**
 * Create a new 3d vector
 * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector, or the z component if x is a vec2
 * @param {number} [z] The z component of the vector
 * @return {vec3} A new 3d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec3(3, 2, 1);       // (3, 2, 1)
 * let b = vec3(4, 5);          // (4, 5, 0)
 * let c = vec3(6);             // (6, 6, 6)
 * let d = vec3(a);             // (3, 2, 1)
 * let e = vec3();              // (0, 0, 0)
 * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)
 * let g = vec3(vec2(4, 5));    // (4, 5, 0)
 */
const vec3 = (x, y, z) => {
  if (!x && !y && !z) {
    return { x: 0, y: 0, z: 0 };
  }
  if (_vec_is_vec3(x)) {
    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0, z: y || 0 };
  }
  return { x: x, y: y ?? x, z: z ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec3} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec3.components = a => [a.x, a.y, a.z];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec3} A new vector
 */
vec3.fromComponents = components => vec3(...components.slice(0, 3));

/**
 * Return a unit vector (1, 0, 0)
 * @return {vec3} A unit vector (1, 0, 0)
 */
vec3.ux = () => vec3(1, 0, 0);

/**
 * Return a unit vector (0, 1, 0)
 * @return {vec3} A unit vector (0, 1, 0)
 */
vec3.uy = () => vec3(0, 1, 0);

/**
 * Return a unit vector (0, 0, 1)
 * @return {vec3} A unit vector (0, 0, 1)
 */
vec3.uz = () => vec3(0, 0, 1);

/**
 * Add vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a + b
 */
vec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });

/**
 * Subtract vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a - b
 */
vec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });

/**
 * Scale a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a * b
 */
vec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });

/**
 * Scale a vector by a scalar, alias for vec3.mul
 * @param {vec3} a Vector a
 * @param {number} b Scalar b
 * @return {vec3} a * b
 */
vec3.scale = (a, b) => vec3.mul(a, b);

/**
 * Divide a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a / b
 */
vec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });

/**
 * Get the length of a vector
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);

/**
 * Normalise a vector
 * @param {vec3} a The vector to normalise
 * @return {vec3} ^a
 */
vec3.nor = a => {
  let len = vec3.len(a);
  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();
};

/**
 * Get a dot product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {number} a ∙ b
 */
vec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

/**
 * Rotate a vector using a rotation matrix
 * @param {vec3} a The vector to rotate
 * @param {mat} m The rotation matrix
 * @return {vec3} A rotated vector
 */
vec3.rot = (a, m) => vec3(
  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)
);

/**
 * Rotate a vector by r radians around the x axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotx = (a, r) => vec3(
  a.x,
  a.y * Math.cos(r) - a.z * Math.sin(r),
  a.y * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the y axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.roty = (a, r) => vec3(
  a.x * Math.cos(r) + a.z * Math.sin(r),
  a.y,
  -a.x * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the z axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotz = (a, r) => vec3(
  a.x * Math.cos(r) - a.y * Math.sin(r),
  a.x * Math.sin(r) + a.y * Math.cos(r),
  a.z
);

/**
 * Rotate a vector using a quaternion
 * @param {vec3} a The vector to rotate
 * @param {Array<number>} q The quaternion to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rotq = (v, q) => {
  if (q.length !== 4) {
    return vec3();
  }

  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
  if (d === 0) {
    return vec3();
  }

  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];
  const u = vec3(...uq.slice(0, 3));
  const s = uq[3];
  return vec3.add(
    vec3.add(
      vec3.mul(u, 2 * vec3.dot(u, v)),
      vec3.mul(v, s * s - vec3.dot(u, u))
    ),
    vec3.mul(vec3.cross(u, v), 2 * s)
  );
};

/**
 * Rotate a vector using Euler angles
 * @param {vec3} a The vector to rotate
 * @param {vec3} e The Euler angles to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);

/**
 * Get the cross product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {vec3} a × b
 */
vec3.cross = (a, b) => vec3(
  a.y * b.z - a.z * b.y,
  a.z * b.x - a.x * b.z,
  a.x * b.y - a.y * b.x
);

/**
 * Check if two vectors are equal
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;

/**
 * Get the angle of a vector from the x axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radx = a => Math.atan2(a.z, a.y);

/**
 * Get the angle of a vector from the y axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.rady = a => Math.atan2(a.x, a.y);

/**
 * Get the angle of a vector from the z axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radz = a => Math.atan2(a.y, a.z);

/**
 * Copy a vector
 * @param {vec3} a The vector to copy
 * @return {vec3} A copy of vector a
 */
vec3.cpy = a => vec3(a);

/**
 * A function to call on each component of a 3d vector
 * @callback vec3MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y' | 'z'} label The component label (x, y or z)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec3} a Vector a
 * @param {vec3MapCallback} f The function to call on each component of the vector
 * @return {vec3} Vector a mapped through f
 */
vec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });

/**
 * Convert a vector into a string
 * @param {vec3} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x`, `y` or `z`
 * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)
 * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)
 * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec3} a The vector to swizzle
 * @param {string} [s='...'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec3(3, -2, 1);
 * vec3.swiz(a, 'x');     // [3]
 * vec3.swiz(a, 'zyx');   // [1, -2, 3]
 * vec3.swiz(a, 'xYZ');   // [3, 2, -1]
 * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]
 * vec3.swiz(a, 'x.x');   // [3, -2, 3]
 * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]
 */
vec3.swiz = (a, s = '...') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': case 'r': result.push(a.x); break;
      case 'y': case 'v': case 'g': result.push(a.y); break;
      case 'z': case 'w': case 'b': result.push(a.z); break;
      case 'X': case 'U': case 'R': result.push(-a.x); break;
      case 'Y': case 'V': case 'G': result.push(-a.y); break;
      case 'Z': case 'W': case 'B': result.push(-a.z); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 3d vector
 * @typedef {Object} polarCoordinates3d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The tilt angle of the vector
 * @property {number} phi The pan angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec3} a The vector to convert
 * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector
 */
vec3.polar = a => {
  let r = vec3.len(a),
    theta = Math.acos(a.y / r),
    phi = Math.atan2(a.z, a.x);
  return { r, theta, phi };
};

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The tilt of the vector
 * @param {number} phi The pan of the vector
 * @return {vec3} A vector with the given angle and magnitude
 */
vec3.fromPolar = (r, theta, phi) => {
  const sinTheta = Math.sin(theta);
  return vec3(
    r * sinTheta * Math.cos(phi),
    r * Math.cos(theta),
    r * sinTheta * Math.sin(phi)
  );
};

/**
 * A matrix
 * @typedef {Object} mat
 * @property {number} m The number of rows in the matrix
 * @property {number} n The number of columns in the matrix
 * @property {Array<number>} entries The matrix values
 */

/**
 * Create a new matrix
 * @param {number} [m=4] The number of rows
 * @param {number} [n=4] The number of columns
 * @param {Array<number>} [entries=[]] Matrix values in reading order
 * @return {mat} A new matrix
 */
const mat = (m = 4, n = 4, entries = []) => ({
  m, n,
  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)
});

/**
 * Get an identity matrix of size n
 * @param {number} n The size of the matrix
 * @return {mat} An identity matrix
 */
mat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));

/**
 * Get an entry from a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {number} The value at position (i, j) in matrix a
 */
mat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];

/**
 * Set an entry of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @param {number} v The value to set in matrix a
 */
mat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };

/**
 * Get a row from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} m The row offset
 * @return {Array<number>} Row m from matrix a
 */
mat.row = (a, m) => {
  const s = (m - 1) * a.n;
  return a.entries.slice(s, s + a.n);
};

/**
 * Get a column from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} n The column offset
 * @return {Array<number>} Column n from matrix a
 */
mat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);

/**
 * Add matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a + b
 */
mat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);

/**
 * Subtract matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a - b
 */
mat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);

/**
 * Multiply matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat|false} ab or false if the matrices cannot be multiplied
 */
mat.mul = (a, b) => {
  if (a.n !== b.m) { return false; }
  const result = mat(a.m, b.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= b.n; j++) {
      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));
    }
  }
  return result;
};

/**
 * Multiply a matrix by a vector
 * @param {mat} a Matrix a
 * @param {vec2|vec3|number[]} b Vector b
 * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied
 */
mat.mulv = (a, b) => {
  let n, bb, rt;
  if (_vec_is_vec3(b)) {
    bb = vec3.components(b);
    n = 3;
    rt = vec3.fromComponents;
  } else if (_vec_is_vec2(b)) {
    bb = vec2.components(b);
    n = 2;
    rt = vec2.fromComponents;
  } else {
    bb = b;
    n = b.length ?? 0;
    rt = v => v;
  }
  if (a.n !== n) { return false; }
  const result = [];
  for (let i = 1; i <= a.m; i++) {
    result.push(_vec_dot(mat.row(a, i), bb));
  }
  return rt(result);
}

/**
 * Scale a matrix
 * @param {mat} a Matrix a
 * @param {number} b Scalar b
 * @return {mat} a * b
 */
mat.scale = (a, b) => mat.map(a, v => v * b);

/**
 * Transpose a matrix
 * @param {mat} a The matrix to transpose
 * @return {mat} A transposed matrix
 */
mat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());

/**
 * Get the minor of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square
 */
mat.minor = (a, i, j) => {
  if (a.m !== a.n) { return false; }
  const entries = [];
  for (let ii = 1; ii <= a.m; ii++) {
    if (ii === i) { continue; }
    for (let jj = 1; jj <= a.n; jj++) {
      if (jj === j) { continue; }
      entries.push(mat.get(a, ii, jj));
    }
  }
  return mat(a.m - 1, a.n - 1, entries);
};

/**
 * Get the determinant of a matrix
 * @param {mat} a Matrix a
 * @return {number|false} |a| or false if the matrix is not square
 */
mat.det = a => {
  if (a.m !== a.n) { return false; }
  if (a.m === 1) {
    return a.entries[0];
  }
  if (a.m === 2) {
    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];
  }
  let total = 0, sign = 1;
  for (let j = 1; j <= a.n; j++) {
    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));
    sign *= -1;
  }
  return total;
};

/**
 * Normalise a matrix
 * @param {mat} a The matrix to normalise
 * @return {mat|false} ^a or false if the matrix is not square
 */
mat.nor = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  return mat.map(a, i => i * d);
};

/**
 * Get the adjugate of a matrix
 * @param {mat} a The matrix from which to get the adjugate
 * @return {mat} The adjugate of a
 */
mat.adj = a => {
  const minors = mat(a.m, a.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= a.n; j++) {
      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));
    }
  }
  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));
  return mat.trans(cofactors);
};

/**
 * Get the inverse of a matrix
 * @param {mat} a The matrix to invert
 * @return {mat|false} a^-1 or false if the matrix has no inverse
 */
mat.inv = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  if (d === 0) { return false; }
  return mat.scale(mat.adj(a), 1 / d);
};

/**
 * Check if two matrices are equal
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {boolean} True if matrices a and b are identical, false otherwise
 */
mat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);

/**
 * Copy a matrix
 * @param {mat} a The matrix to copy
 * @return {mat} A copy of matrix a
 */
mat.cpy = a => mat(a.m, a.n, [...a.entries]);

/**
 * A function to call on each entry of a matrix
 * @callback matrixMapCallback
 * @param {number} value The entry value
 * @param {number} index The entry index
 * @param {Array<number>} entries The array of matrix entries
 * @return {number} The mapped entry
 */

/**
 * Call a function on each entry of a matrix and build a new matrix from the results
 * @param {mat} a Matrix a
 * @param {matrixMapCallback} f The function to call on each entry of the matrix
 * @return {mat} Matrix a mapped through f
 */
mat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));

/**
 * Convert a matrix into a string
 * @param {mat} a The matrix to convert
 * @param {string} [ms=', '] The separator string for columns
 * @param {string} [ns='\n'] The separator string for rows
 * @return {string} A string representation of the matrix
 */
mat.str = (a, ms = ', ', ns = '\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);

if (true) {
  module.exports = { vec2, vec3, mat };
}


/***/ }),

/***/ "./node_modules/dat.gui/build/dat.gui.module.js":
/*!******************************************************!*\
  !*** ./node_modules/dat.gui/build/dat.gui.module.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GUI: () => (/* binding */ GUI$1),
/* harmony export */   color: () => (/* binding */ color),
/* harmony export */   controllers: () => (/* binding */ controllers),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   dom: () => (/* binding */ dom$1),
/* harmony export */   gui: () => (/* binding */ gui)
/* harmony export */ });
/**
 * dat-gui JavaScript Controller Library
 * https://github.com/dataarts/dat.gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = 'HEX';
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function () {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function () {
      dom.addClass(this, 'drag').bind(window, 'touchend', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller, {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);
//# sourceMappingURL=dat.gui.module.js.map


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
var max_js_1 = __webpack_require__(/*! ./max.js */ "./node_modules/uuid/dist/cjs-browser/max.js");
Object.defineProperty(exports, "MAX", ({ enumerable: true, get: function () { return max_js_1.default; } }));
var nil_js_1 = __webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/cjs-browser/nil.js");
Object.defineProperty(exports, "NIL", ({ enumerable: true, get: function () { return nil_js_1.default; } }));
var parse_js_1 = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/cjs-browser/parse.js");
Object.defineProperty(exports, "parse", ({ enumerable: true, get: function () { return parse_js_1.default; } }));
var stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_js_1.default; } }));
var v1_js_1 = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/cjs-browser/v1.js");
Object.defineProperty(exports, "v1", ({ enumerable: true, get: function () { return v1_js_1.default; } }));
var v1ToV6_js_1 = __webpack_require__(/*! ./v1ToV6.js */ "./node_modules/uuid/dist/cjs-browser/v1ToV6.js");
Object.defineProperty(exports, "v1ToV6", ({ enumerable: true, get: function () { return v1ToV6_js_1.default; } }));
var v3_js_1 = __webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/cjs-browser/v3.js");
Object.defineProperty(exports, "v3", ({ enumerable: true, get: function () { return v3_js_1.default; } }));
var v4_js_1 = __webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/cjs-browser/v4.js");
Object.defineProperty(exports, "v4", ({ enumerable: true, get: function () { return v4_js_1.default; } }));
var v5_js_1 = __webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/cjs-browser/v5.js");
Object.defineProperty(exports, "v5", ({ enumerable: true, get: function () { return v5_js_1.default; } }));
var v6_js_1 = __webpack_require__(/*! ./v6.js */ "./node_modules/uuid/dist/cjs-browser/v6.js");
Object.defineProperty(exports, "v6", ({ enumerable: true, get: function () { return v6_js_1.default; } }));
var v6ToV1_js_1 = __webpack_require__(/*! ./v6ToV1.js */ "./node_modules/uuid/dist/cjs-browser/v6ToV1.js");
Object.defineProperty(exports, "v6ToV1", ({ enumerable: true, get: function () { return v6ToV1_js_1.default; } }));
var v7_js_1 = __webpack_require__(/*! ./v7.js */ "./node_modules/uuid/dist/cjs-browser/v7.js");
Object.defineProperty(exports, "v7", ({ enumerable: true, get: function () { return v7_js_1.default; } }));
var validate_js_1 = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/cjs-browser/validate.js");
Object.defineProperty(exports, "validate", ({ enumerable: true, get: function () { return validate_js_1.default; } }));
var version_js_1 = __webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/cjs-browser/version.js");
Object.defineProperty(exports, "version", ({ enumerable: true, get: function () { return version_js_1.default; } }));


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/max.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/max.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = 'ffffffff-ffff-ffff-ffff-ffffffffffff';


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function md5(bytes) {
    const words = uint8ToUint32(bytes);
    const md5Bytes = wordsToMd5(words, bytes.length * 8);
    return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
    const bytes = new Uint8Array(input.length * 4);
    for (let i = 0; i < input.length * 4; i++) {
        bytes[i] = (input[i >> 2] >>> ((i % 4) * 8)) & 0xff;
    }
    return bytes;
}
function getOutputLength(inputLength8) {
    return (((inputLength8 + 64) >>> 9) << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
    const xpad = new Uint32Array(getOutputLength(len)).fill(0);
    xpad.set(x);
    xpad[len >> 5] |= 0x80 << len % 32;
    xpad[xpad.length - 1] = len;
    x = xpad;
    let a = 1732584193;
    let b = -271733879;
    let c = -1732584194;
    let d = 271733878;
    for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
    }
    return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
    if (input.length === 0) {
        return new Uint32Array();
    }
    const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
    for (let i = 0; i < input.length; i++) {
        output[i >> 2] |= (input[i] & 0xff) << ((i % 4) * 8);
    }
    return output;
}
function safeAdd(x, y) {
    const lsw = (x & 0xffff) + (y & 0xffff);
    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return (msw << 16) | (lsw & 0xffff);
}
function bitRotateLeft(num, cnt) {
    return (num << cnt) | (num >>> (32 - cnt));
}
function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
    return md5cmn((b & c) | (~b & d), a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
exports["default"] = md5;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports["default"] = { randomUUID };


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = '00000000-0000-0000-0000-000000000000';


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const validate_js_1 = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/cjs-browser/validate.js");
function parse(uuid) {
    if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError('Invalid UUID');
    }
    let v;
    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);
}
exports["default"] = parse;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}
exports["default"] = rng;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function f(s, x, y, z) {
    switch (s) {
        case 0:
            return (x & y) ^ (~x & z);
        case 1:
            return x ^ y ^ z;
        case 2:
            return (x & y) ^ (x & z) ^ (y & z);
        case 3:
            return x ^ y ^ z;
    }
}
function ROTL(x, n) {
    return (x << n) | (x >>> (32 - n));
}
function sha1(bytes) {
    const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
    const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    const newBytes = new Uint8Array(bytes.length + 1);
    newBytes.set(bytes);
    newBytes[bytes.length] = 0x80;
    bytes = newBytes;
    const l = bytes.length / 4 + 2;
    const N = Math.ceil(l / 16);
    const M = new Array(N);
    for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
            arr[j] =
                (bytes[i * 64 + j * 4] << 24) |
                    (bytes[i * 64 + j * 4 + 1] << 16) |
                    (bytes[i * 64 + j * 4 + 2] << 8) |
                    bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
    }
    M[N - 1][14] = ((bytes.length - 1) * 8) / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = ((bytes.length - 1) * 8) & 0xffffffff;
    for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
            W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
            const s = Math.floor(t / 20);
            const T = (ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t]) >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
        }
        H[0] = (H[0] + a) >>> 0;
        H[1] = (H[1] + b) >>> 0;
        H[2] = (H[2] + c) >>> 0;
        H[3] = (H[3] + d) >>> 0;
        H[4] = (H[4] + e) >>> 0;
    }
    return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
exports["default"] = sha1;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unsafeStringify = void 0;
const validate_js_1 = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/cjs-browser/validate.js");
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        '-' +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        '-' +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        '-' +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        '-' +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]).toLowerCase();
}
exports.unsafeStringify = unsafeStringify;
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
exports["default"] = stringify;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateV1State = void 0;
const rng_js_1 = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/cjs-browser/rng.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
const _state = {};
function v1(options, buf, offset) {
    let bytes;
    const isV6 = options?._v6 ?? false;
    if (options) {
        const optionsKeys = Object.keys(options);
        if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {
            options = undefined;
        }
    }
    if (options) {
        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
    }
    else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV1State(_state, now, rnds);
        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);
    }
    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV1State(state, now, rnds) {
    state.msecs ??= -Infinity;
    state.nsecs ??= 0;
    if (now === state.msecs) {
        state.nsecs++;
        if (state.nsecs >= 10000) {
            state.node = undefined;
            state.nsecs = 0;
        }
    }
    else if (now > state.msecs) {
        state.nsecs = 0;
    }
    else if (now < state.msecs) {
        state.node = undefined;
    }
    if (!state.node) {
        state.node = rnds.slice(10, 16);
        state.node[0] |= 0x01;
        state.clockseq = ((rnds[8] << 8) | rnds[9]) & 0x3fff;
    }
    state.msecs = now;
    return state;
}
exports.updateV1State = updateV1State;
function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
    }
    else {
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
    }
    msecs ??= Date.now();
    nsecs ??= 0;
    clockseq ??= ((rnds[8] << 8) | rnds[9]) & 0x3fff;
    node ??= rnds.slice(10, 16);
    msecs += 12219292800000;
    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    buf[offset++] = (tl >>> 24) & 0xff;
    buf[offset++] = (tl >>> 16) & 0xff;
    buf[offset++] = (tl >>> 8) & 0xff;
    buf[offset++] = tl & 0xff;
    const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;
    buf[offset++] = (tmh >>> 8) & 0xff;
    buf[offset++] = tmh & 0xff;
    buf[offset++] = ((tmh >>> 24) & 0xf) | 0x10;
    buf[offset++] = (tmh >>> 16) & 0xff;
    buf[offset++] = (clockseq >>> 8) | 0x80;
    buf[offset++] = clockseq & 0xff;
    for (let n = 0; n < 6; ++n) {
        buf[offset++] = node[n];
    }
    return buf;
}
exports["default"] = v1;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v1ToV6.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v1ToV6.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const parse_js_1 = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/cjs-browser/parse.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
function v1ToV6(uuid) {
    const v1Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
}
exports["default"] = v1ToV6;
function _v1ToV6(v1Bytes) {
    return Uint8Array.of(((v1Bytes[6] & 0x0f) << 4) | ((v1Bytes[7] >> 4) & 0x0f), ((v1Bytes[7] & 0x0f) << 4) | ((v1Bytes[4] & 0xf0) >> 4), ((v1Bytes[4] & 0x0f) << 4) | ((v1Bytes[5] & 0xf0) >> 4), ((v1Bytes[5] & 0x0f) << 4) | ((v1Bytes[0] & 0xf0) >> 4), ((v1Bytes[0] & 0x0f) << 4) | ((v1Bytes[1] & 0xf0) >> 4), ((v1Bytes[1] & 0x0f) << 4) | ((v1Bytes[2] & 0xf0) >> 4), 0x60 | (v1Bytes[2] & 0x0f), v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URL = exports.DNS = void 0;
const md5_js_1 = __webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/cjs-browser/md5.js");
const v35_js_1 = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/cjs-browser/v35.js");
var v35_js_2 = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/cjs-browser/v35.js");
Object.defineProperty(exports, "DNS", ({ enumerable: true, get: function () { return v35_js_2.DNS; } }));
Object.defineProperty(exports, "URL", ({ enumerable: true, get: function () { return v35_js_2.URL; } }));
function v3(value, namespace, buf, offset) {
    return (0, v35_js_1.default)(0x30, md5_js_1.default, value, namespace, buf, offset);
}
v3.DNS = v35_js_1.DNS;
v3.URL = v35_js_1.URL;
exports["default"] = v3;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URL = exports.DNS = exports.stringToBytes = void 0;
const parse_js_1 = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/cjs-browser/parse.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; ++i) {
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
}
exports.stringToBytes = stringToBytes;
exports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(version, hash, value, namespace, buf, offset) {
    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;
    const namespaceBytes = typeof namespace === 'string' ? (0, parse_js_1.default)(namespace) : namespace;
    if (typeof namespace === 'string') {
        namespace = (0, parse_js_1.default)(namespace);
    }
    if (namespace?.length !== 16) {
        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    }
    let bytes = new Uint8Array(16 + valueBytes.length);
    bytes.set(namespaceBytes);
    bytes.set(valueBytes, namespaceBytes.length);
    bytes = hash(bytes);
    bytes[6] = (bytes[6] & 0x0f) | version;
    bytes[8] = (bytes[8] & 0x3f) | 0x80;
    if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
        }
        return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes);
}
exports["default"] = v35;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const native_js_1 = __webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/cjs-browser/native.js");
const rng_js_1 = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/cjs-browser/rng.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
function v4(options, buf, offset) {
    if (native_js_1.default.randomUUID && !buf && !options) {
        return native_js_1.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? (0, rng_js_1.default)();
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    if (buf) {
        offset = offset || 0;
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
        for (let i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(rnds);
}
exports["default"] = v4;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URL = exports.DNS = void 0;
const sha1_js_1 = __webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/cjs-browser/sha1.js");
const v35_js_1 = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/cjs-browser/v35.js");
var v35_js_2 = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/cjs-browser/v35.js");
Object.defineProperty(exports, "DNS", ({ enumerable: true, get: function () { return v35_js_2.DNS; } }));
Object.defineProperty(exports, "URL", ({ enumerable: true, get: function () { return v35_js_2.URL; } }));
function v5(value, namespace, buf, offset) {
    return (0, v35_js_1.default)(0x50, sha1_js_1.default, value, namespace, buf, offset);
}
v5.DNS = v35_js_1.DNS;
v5.URL = v35_js_1.URL;
exports["default"] = v5;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v6.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v6.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
const v1_js_1 = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/cjs-browser/v1.js");
const v1ToV6_js_1 = __webpack_require__(/*! ./v1ToV6.js */ "./node_modules/uuid/dist/cjs-browser/v1ToV6.js");
function v6(options, buf, offset) {
    options ??= {};
    offset ??= 0;
    let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));
    bytes = (0, v1ToV6_js_1.default)(bytes);
    if (buf) {
        for (let i = 0; i < 16; i++) {
            buf[offset + i] = bytes[i];
        }
        return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes);
}
exports["default"] = v6;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v6ToV1.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v6ToV1.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const parse_js_1 = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/cjs-browser/parse.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
function v6ToV1(uuid) {
    const v6Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
}
exports["default"] = v6ToV1;
function _v6ToV1(v6Bytes) {
    return Uint8Array.of(((v6Bytes[3] & 0x0f) << 4) | ((v6Bytes[4] >> 4) & 0x0f), ((v6Bytes[4] & 0x0f) << 4) | ((v6Bytes[5] & 0xf0) >> 4), ((v6Bytes[5] & 0x0f) << 4) | (v6Bytes[6] & 0x0f), v6Bytes[7], ((v6Bytes[1] & 0x0f) << 4) | ((v6Bytes[2] & 0xf0) >> 4), ((v6Bytes[2] & 0x0f) << 4) | ((v6Bytes[3] & 0xf0) >> 4), 0x10 | ((v6Bytes[0] & 0xf0) >> 4), ((v6Bytes[0] & 0x0f) << 4) | ((v6Bytes[1] & 0xf0) >> 4), v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v7.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v7.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateV7State = void 0;
const rng_js_1 = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/cjs-browser/rng.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
const _state = {};
function v7(options, buf, offset) {
    let bytes;
    if (options) {
        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
    }
    else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV7State(_state, now, rnds);
        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
    }
    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV7State(state, now, rnds) {
    state.msecs ??= -Infinity;
    state.seq ??= 0;
    if (now > state.msecs) {
        state.seq = (rnds[6] << 23) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];
        state.msecs = now;
    }
    else {
        state.seq = (state.seq + 1) | 0;
        if (state.seq === 0) {
            state.msecs++;
        }
    }
    return state;
}
exports.updateV7State = updateV7State;
function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
    }
    else {
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
    }
    msecs ??= Date.now();
    seq ??= ((rnds[6] * 0x7f) << 24) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];
    buf[offset++] = (msecs / 0x10000000000) & 0xff;
    buf[offset++] = (msecs / 0x100000000) & 0xff;
    buf[offset++] = (msecs / 0x1000000) & 0xff;
    buf[offset++] = (msecs / 0x10000) & 0xff;
    buf[offset++] = (msecs / 0x100) & 0xff;
    buf[offset++] = msecs & 0xff;
    buf[offset++] = 0x70 | ((seq >>> 28) & 0x0f);
    buf[offset++] = (seq >>> 20) & 0xff;
    buf[offset++] = 0x80 | ((seq >>> 14) & 0x3f);
    buf[offset++] = (seq >>> 6) & 0xff;
    buf[offset++] = ((seq << 2) & 0xff) | (rnds[10] & 0x03);
    buf[offset++] = rnds[11];
    buf[offset++] = rnds[12];
    buf[offset++] = rnds[13];
    buf[offset++] = rnds[14];
    buf[offset++] = rnds[15];
    return buf;
}
exports["default"] = v7;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const regex_js_1 = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/cjs-browser/regex.js");
function validate(uuid) {
    return typeof uuid === 'string' && regex_js_1.default.test(uuid);
}
exports["default"] = validate;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const validate_js_1 = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/cjs-browser/validate.js");
function version(uuid) {
    if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError('Invalid UUID');
    }
    return parseInt(uuid.slice(14, 15), 16);
}
exports["default"] = version;


/***/ }),

/***/ "./src/axes.ts":
/*!*********************!*\
  !*** ./src/axes.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
class Axes {
    static draw(context, camera, screenSize) {
        const origin2d = camera.project((0, vec_1.vec3)(0, 0, 0), screenSize);
        const x2 = camera.project((0, vec_1.vec3)(Axes.AXES_LENGTH, 0, 0), screenSize);
        const y2 = camera.project((0, vec_1.vec3)(0, Axes.AXES_LENGTH, 0), screenSize);
        const z2 = camera.project((0, vec_1.vec3)(0, 0, Axes.AXES_LENGTH), screenSize);
        if (!origin2d || !x2 || !y2 || !z2) {
            return;
        }
        const line = (0, canvas_helpers_1.withContext)(context, canvas_helpers_1.line);
        const style = {
            lineWidth: Axes.AXES_WIDTH,
        };
        line(origin2d, x2, { ...style, strokeColor: Axes.X_COLOR });
        line(origin2d, y2, { ...style, strokeColor: Axes.Y_COLOR });
        line(origin2d, z2, { ...style, strokeColor: Axes.Z_COLOR });
        const markerX2 = camera.project((0, vec_1.vec3)(Axes.MARKER_LENGTH, 0, 0), screenSize);
        const markerY2 = camera.project((0, vec_1.vec3)(0, Axes.MARKER_LENGTH, 0), screenSize);
        const markerZ2 = camera.project((0, vec_1.vec3)(0, 0, Axes.MARKER_LENGTH), screenSize);
        if (!markerX2 || !markerY2 || !markerZ2) {
            return;
        }
        debug_1.default.marker('x', '', markerX2, {
            foregroundColour: Axes.X_COLOR,
            ...Axes.MARKER_OPTIONS,
        });
        debug_1.default.marker('y', '', markerY2, {
            foregroundColour: Axes.Y_COLOR,
            ...Axes.MARKER_OPTIONS,
        });
        debug_1.default.marker('z', '', markerZ2, {
            foregroundColour: Axes.Z_COLOR,
            ...Axes.MARKER_OPTIONS,
        });
    }
}
exports["default"] = Axes;
Axes.AXES_LENGTH = 30;
Axes.AXES_WIDTH = 2;
Axes.X_COLOR = '#f44';
Axes.Y_COLOR = '#4f4';
Axes.Z_COLOR = '#48f';
Axes.MARKER_LENGTH = 35;
Axes.MARKER_OPTIONS = {
    showMarker: false,
    labelOffset: (0, vec_1.vec2)(-4, 0),
    backgroundColour: 'transparent',
    tags: ['panel-3d'],
};


/***/ }),

/***/ "./src/edge.ts":
/*!*********************!*\
  !*** ./src/edge.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/cjs-browser/index.js");
const model_editor_1 = __webpack_require__(/*! ./model-editor */ "./src/model-editor.ts");
const utilities_1 = __webpack_require__(/*! ./utilities */ "./src/utilities.ts");
class Edge {
    constructor(a, b, addFolder = true) {
        this.a = a;
        this.b = b;
        this.id = '';
        this.hovered = false;
        this.selected = false;
        this.folder = null;
        this.id = (0, uuid_1.v4)();
        if (model_editor_1.default.edgesFolder && addFolder) {
            this.folder = model_editor_1.default.edgesFolder.addFolder(`Edge ${this.id}`);
            this.folder.add({ select: () => { var _a; return (_a = model_editor_1.default.instance) === null || _a === void 0 ? void 0 : _a.selectEdge(this, false); } }, 'select');
            this.folder.add({ delete: () => { var _a; return (_a = model_editor_1.default.instance) === null || _a === void 0 ? void 0 : _a.removeEdge(this); } }, 'delete');
        }
    }
    destroy() {
        var _a;
        if (this.folder) {
            (_a = model_editor_1.default.edgesFolder) === null || _a === void 0 ? void 0 : _a.removeFolder(this.folder);
        }
    }
    serialize() {
        return {
            id: this.id,
            a: this.a.id,
            b: this.b.id,
        };
    }
    static deserialize(data, vertices) {
        const a = vertices.get(data.a);
        const b = vertices.get(data.b);
        if (!a || !b) {
            throw new Error(`Edge ${data.id} references non-existent vertices.`);
        }
        const edge = new Edge(a, b);
        if (data.id) {
            edge.id = data.id;
        }
        return edge;
    }
    update(dt) { }
    draw2d(context, components) {
        (0, canvas_helpers_1.line)(context, (0, utilities_1.v32)(this.a.position, components), (0, utilities_1.v32)(this.b.position, components), {
            strokeColor: Edge.COLOUR,
            lineWidth: this.selected
                ? Edge.SELECT_LINE_WIDTH
                : this.hovered
                    ? Edge.HOVER_LINE_WIDTH
                    : Edge.LINE_WIDTH,
            lineStyle: this.hovered && !this.selected ? 'dashed' : 'solid',
        });
    }
    draw3d(context, camera, screen) {
        const a3 = camera.project(this.a.position, screen);
        const b3 = camera.project(this.b.position, screen);
        if (!a3 || !b3) {
            return;
        }
        (0, canvas_helpers_1.line)(context, a3, b3, {
            strokeColor: Edge.COLOUR,
            lineWidth: this.selected
                ? Edge.SELECT_LINE_WIDTH
                : this.hovered
                    ? Edge.HOVER_LINE_WIDTH
                    : Edge.LINE_WIDTH,
            lineStyle: this.hovered && !this.selected ? 'dashed' : 'solid',
        });
    }
    isPointNear2d(point, components, range = Edge.HOVER_RADIUS) {
        return (0, utilities_1.pointNearLine)(point, {
            start: (0, utilities_1.v32)(this.a.position, components),
            end: (0, utilities_1.v32)(this.b.position, components),
        }, range);
    }
    isPointNear3d(point, camera, screen, range = Edge.HOVER_RADIUS) {
        const a3 = camera.project(this.a.position, screen);
        const b3 = camera.project(this.b.position, screen);
        if (!a3 || !b3) {
            return false;
        }
        return (0, utilities_1.pointNearLine)(point, { start: a3, end: b3 }, range);
    }
}
exports["default"] = Edge;
Edge.COLOUR = '#fff';
Edge.LINE_WIDTH = 1;
Edge.HOVER_LINE_WIDTH = 3;
Edge.SELECT_LINE_WIDTH = 3;
Edge.HOVER_RADIUS = 6;


/***/ }),

/***/ "./src/grid.ts":
/*!*********************!*\
  !*** ./src/grid.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
class Grid {
    static draw(context, camera, gridSize, showLabels = false, labelsGap = 0, labelsTag = '') {
        const bounds = camera.bounds;
        const topLeft = vec_1.vec2.mul(vec_1.vec2.map(vec_1.vec2.div((0, vec_1.vec2)(bounds.left, bounds.top), gridSize), Math.floor), gridSize);
        const bottomRight = vec_1.vec2.mul(vec_1.vec2.map(vec_1.vec2.div((0, vec_1.vec2)(bounds.right, bounds.bottom), gridSize), Math.ceil), gridSize);
        for (let x = topLeft.x; x <= bottomRight.x; x += gridSize) {
            const isCenter = Math.abs(x) < gridSize / 2;
            (0, canvas_helpers_1.line)(context, (0, vec_1.vec2)(x, topLeft.y), (0, vec_1.vec2)(x, bottomRight.y), {
                strokeColor: isCenter ? Grid.CENTER_AXIS_COLOUR : Grid.GRID_COLOUR,
                lineWidth: (isCenter ? Grid.CENTER_AXIS_LINE_WIDTH : Grid.GRID_LINE_WIDTH) /
                    camera.actualScale,
            });
        }
        for (let y = topLeft.y; y <= bottomRight.y; y += gridSize) {
            const isCenter = Math.abs(y) < gridSize / 2;
            (0, canvas_helpers_1.line)(context, (0, vec_1.vec2)(topLeft.x, y), (0, vec_1.vec2)(bottomRight.x, y), {
                strokeColor: isCenter ? Grid.CENTER_AXIS_COLOUR : Grid.GRID_COLOUR,
                lineWidth: (isCenter ? Grid.CENTER_AXIS_LINE_WIDTH : Grid.GRID_LINE_WIDTH) /
                    camera.actualScale,
            });
        }
        if (showLabels) {
            const labelsStartX = Math.floor(topLeft.x / (gridSize * labelsGap)) * gridSize * labelsGap;
            const labelsStartY = Math.floor(topLeft.y / (gridSize * labelsGap)) * gridSize * labelsGap;
            for (let x = labelsStartX; x <= bottomRight.x; x += gridSize * labelsGap) {
                for (let y = labelsStartY; y <= bottomRight.y; y += gridSize * labelsGap) {
                    debug_1.default.marker(`grid-${labelsTag}-${x}-${y}`, `${x},${y}`, (0, vec_1.vec2)(x, y), {
                        tags: [labelsTag],
                        ...Grid.MARKER_OPTIONS,
                    });
                }
            }
        }
    }
}
exports["default"] = Grid;
Grid.GRID_COLOUR = '#fff1';
Grid.GRID_LINE_WIDTH = 1;
Grid.CENTER_AXIS_COLOUR = '#fff2';
Grid.CENTER_AXIS_LINE_WIDTH = 2;
Grid.MARKER_OPTIONS = {
    showMarker: true,
    markerStyle: '+',
    labelOffset: (0, vec_1.vec2)(3),
    showLabel: false,
    backgroundColour: 'transparent',
    font: '10px monospace',
    foregroundColour: '#fff5',
};


/***/ }),

/***/ "./src/grid3d.ts":
/*!***********************!*\
  !*** ./src/grid3d.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
const intersection_helpers_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers */ "./node_modules/@basementuniverse/intersection-helpers/build/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const { aabbToRectangle, lineIntersectsRectangle, pointInRectangle } = intersection_helpers_1.intersection2d;
class Grid3d {
    static clipToScreen(a, b, screen) {
        const aInScreen = pointInRectangle(a, aabbToRectangle({ position: (0, vec_1.vec2)(), size: screen }));
        const bInScreen = pointInRectangle(b, aabbToRectangle({ position: (0, vec_1.vec2)(), size: screen }));
        if (aInScreen && bInScreen) {
            return [a, b];
        }
        const intersections = lineIntersectsRectangle({ start: a, end: b }, aabbToRectangle({ position: (0, vec_1.vec2)(), size: screen }));
        if (!intersections.intersects) {
            return [null, null];
        }
        if (intersections.intersectionPoints &&
            intersections.intersectionPoints.length === 1) {
            if (aInScreen) {
                return [a, intersections.intersectionPoints[0]];
            }
            else {
                return [intersections.intersectionPoints[0], b];
            }
        }
        if (intersections.intersectionPoints &&
            intersections.intersectionPoints.length === 2) {
            return intersections.intersectionPoints;
        }
        return [null, null];
    }
    static draw(context, camera, screen, gridSize, gridCount, showLabels = false, labelsGap = 0) {
        const halfCount = gridCount / 2;
        const halfGrid = halfCount * gridSize;
        for (let i = -halfCount; i <= halfCount; i++) {
            const z = i * gridSize;
            const a3 = (0, vec_1.vec3)(-halfGrid, 0, z);
            const b3 = (0, vec_1.vec3)(halfGrid, 0, z);
            let a2 = camera.project(a3, screen);
            let b2 = camera.project(b3, screen);
            if (!a2 || !b2) {
                continue;
            }
            [a2, b2] = this.clipToScreen(a2, b2, screen);
            if (!a2 || !b2) {
                continue;
            }
            const isCenter = Math.abs(z) < gridSize;
            (0, canvas_helpers_1.line)(context, (0, vec_1.vec2)(a2.x, a2.y), (0, vec_1.vec2)(b2.x, b2.y), {
                strokeColor: isCenter ? Grid3d.CENTER_AXIS_COLOR : Grid3d.GRID_COLOR,
                lineWidth: isCenter
                    ? Grid3d.CENTER_AXIS_LINE_WIDTH
                    : Grid3d.GRID_LINE_WIDTH,
            });
        }
        for (let i = -halfCount; i <= halfCount; i++) {
            const x = i * gridSize;
            const a3 = (0, vec_1.vec3)(x, 0, -halfGrid);
            const b3 = (0, vec_1.vec3)(x, 0, halfGrid);
            let a2 = camera.project(a3, screen);
            let b2 = camera.project(b3, screen);
            if (!a2 || !b2) {
                continue;
            }
            [a2, b2] = this.clipToScreen(a2, b2, screen);
            if (!a2 || !b2) {
                continue;
            }
            const isCenter = Math.abs(x) < gridSize;
            (0, canvas_helpers_1.line)(context, (0, vec_1.vec2)(a2.x, a2.y), (0, vec_1.vec2)(b2.x, b2.y), {
                strokeColor: isCenter ? Grid3d.CENTER_AXIS_COLOR : Grid3d.GRID_COLOR,
                lineWidth: isCenter
                    ? Grid3d.CENTER_AXIS_LINE_WIDTH
                    : Grid3d.GRID_LINE_WIDTH,
            });
        }
        if (showLabels) {
            const labelsStartX = Math.floor(-halfGrid / (gridSize * labelsGap)) * gridSize * labelsGap;
            const labelsStartZ = Math.floor(-halfGrid / (gridSize * labelsGap)) * gridSize * labelsGap;
            for (let x = labelsStartX; x <= halfGrid; x += gridSize * labelsGap) {
                for (let z = labelsStartZ; z <= halfGrid; z += gridSize * labelsGap) {
                    if (Math.abs(x) > halfGrid || Math.abs(z) > halfGrid) {
                        continue;
                    }
                    const p2 = camera.project((0, vec_1.vec3)(x, 0, z), screen);
                    if (!p2) {
                        continue;
                    }
                    debug_1.default.marker(`grid-3d-${x}-${z}`, `${x},${z}`, (0, vec_1.vec2)(p2.x, p2.y), Grid3d.MARKER_OPTIONS);
                }
            }
        }
    }
}
exports["default"] = Grid3d;
Grid3d.GRID_COLOR = '#fff1';
Grid3d.GRID_LINE_WIDTH = 1;
Grid3d.CENTER_AXIS_COLOR = '#fff2';
Grid3d.CENTER_AXIS_LINE_WIDTH = 2;
Grid3d.MARKER_OPTIONS = {
    showMarker: true,
    markerStyle: '+',
    labelOffset: (0, vec_1.vec2)(3),
    showLabel: false,
    backgroundColour: 'transparent',
    font: '10px monospace',
    foregroundColour: '#fff5',
    tags: ['panel-3d'],
};


/***/ }),

/***/ "./src/model-editor.ts":
/*!*****************************!*\
  !*** ./src/model-editor.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const camera_1 = __webpack_require__(/*! @basementuniverse/camera */ "./node_modules/@basementuniverse/camera/build/index.js");
const camera_3d_1 = __webpack_require__(/*! @basementuniverse/camera-3d */ "./node_modules/@basementuniverse/camera-3d/build/index.js");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const intersection_helpers_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers */ "./node_modules/@basementuniverse/intersection-helpers/build/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const dat = __webpack_require__(/*! dat.gui */ "./node_modules/dat.gui/build/dat.gui.module.js");
const axes_1 = __webpack_require__(/*! ./axes */ "./src/axes.ts");
const edge_1 = __webpack_require__(/*! ./edge */ "./src/edge.ts");
const grid_1 = __webpack_require__(/*! ./grid */ "./src/grid.ts");
const grid3d_1 = __webpack_require__(/*! ./grid3d */ "./src/grid3d.ts");
const model_1 = __webpack_require__(/*! ./model */ "./src/model.ts");
const surface_1 = __webpack_require__(/*! ./surface */ "./src/surface.ts");
const utilities_1 = __webpack_require__(/*! ./utilities */ "./src/utilities.ts");
const vertex_1 = __webpack_require__(/*! ./vertex */ "./src/vertex.ts");
const { rayIntersectsPlane, meshCentroid } = intersection_helpers_1.intersection3d;
const { vectorAlmostZero } = intersection_helpers_1.intersectionUtilities;
class ModelEditor {
    constructor() {
        var _a;
        this.frameRate = 0;
        this.frameCount = 0;
        this.tool = 'select';
        this.options = {
            modelName: '',
            showVertexLabels: true,
            showAxes: true,
            showGrid: true,
            gridSize: 50,
            showGridLabels: true,
            gridLabelsGap: 5,
            showGroundPlane: true,
            groundPlaneSize: 20,
            showGroundPlaneLabels: true,
            groundPlaneLabelsGap: 5,
            zoomSpeed: 0.2,
            moveSpeed: 0.3,
            rotateSpeed: 0.003,
        };
        this.cameraOptions = {
            maxScale: 10,
            minScale: 0.1,
            moveEaseAmount: 0.75,
            scaleEaseAmount: 0.75,
        };
        this.camera3dOptions = {
            fov: Math.PI / 4,
            positionEaseAmount: 0.75,
            targetEaseAmount: 0.75,
        };
        this.model = null;
        this.history = [];
        this.currentHistoryIndex = -1;
        this.panning = false;
        this.lastPanPosition = null;
        this.lastMousePosition = (0, vec_1.vec2)();
        this.camera3dYaw = 0;
        this.camera3dPitch = 0;
        this.hoveredVertex = null;
        this.hoveredEdge = null;
        this.hoveredSurface = null;
        this.clickedVertex = null;
        this.selectedVertices = [];
        this.selectedEdges = [];
        this.selectedSurfaces = [];
        this.draggingVertex = null;
        this.dragStartMouse = null;
        this.dragStartVertexPositions = null;
        this.verticesMoved = false;
        this.creatingEdge = null;
        this.creatingSurface = null;
        this.previousTool = null;
        this.spacebarPanActive = false;
        this.movementConstraintXActive = false;
        this.movementConstraintYActive = false;
        this.movementConstraintZActive = false;
        this.panelContainer = null;
        this.panelResizeMode = null;
        this.panelVerticalSize = 0.5;
        this.panelHorizontalSize = 0.5;
        this.panelResizeHandleVertical = null;
        this.panelResizeHandleHorizontal = null;
        this.panelResizeHandleCenter = null;
        this.undoButton = null;
        this.redoButton = null;
        this.lastGuiState = {
            vertices: new Set(),
            edges: new Set(),
            surfaces: new Set(),
            historyIndex: -1,
        };
        this.tools = {
            scale: () => {
                if (!this.model) {
                    console.error('No model loaded');
                    return;
                }
                if (this.selectedVertices.length === 0) {
                    console.warn('No vertices selected');
                    return;
                }
                const scaleString = prompt('Amount to scale by:', '1');
                if (scaleString === null) {
                    return;
                }
                const scale = parseFloat(scaleString);
                if (scale === 1) {
                    console.warn('Scale factor 1 does nothing');
                    return;
                }
                const centroid = meshCentroid({
                    vertices: this.selectedVertices.map(v => v.position),
                    indices: [],
                });
                for (const vertex of this.selectedVertices) {
                    const delta = vec_1.vec3.sub(vertex.position, centroid);
                    vertex.position = vec_1.vec3.add(centroid, vec_1.vec3.mul(delta, scale));
                }
                this.model.emitChangeEvent('Vertices scaled');
            },
            rotateX: () => {
                if (!this.model) {
                    console.error('No model loaded');
                    return;
                }
                if (this.selectedVertices.length === 0) {
                    console.warn('No vertices selected');
                    return;
                }
                const thetaString = prompt('Amount to rotate by (in degrees):', '0');
                if (thetaString === null) {
                    return;
                }
                const theta = parseFloat(thetaString);
                if (theta === 0) {
                    console.warn('Rotating by 0 degrees does nothing');
                    return;
                }
                const centroid = meshCentroid({
                    vertices: this.selectedVertices.map(v => v.position),
                    indices: [],
                });
                for (const vertex of this.selectedVertices) {
                    const delta = vec_1.vec3.sub(vertex.position, centroid);
                    vertex.position = vec_1.vec3.add(centroid, vec_1.vec3.rotx(delta, (0, utils_1.radians)(theta)));
                }
                this.model.emitChangeEvent('Vertices rotated');
            },
            rotateY: () => {
                if (!this.model) {
                    console.error('No model loaded');
                    return;
                }
                if (this.selectedVertices.length === 0) {
                    console.warn('No vertices selected');
                    return;
                }
                const thetaString = prompt('Amount to rotate by (in degrees):', '0');
                if (thetaString === null) {
                    return;
                }
                const theta = parseFloat(thetaString);
                if (theta === 0) {
                    console.warn('Rotating by 0 degrees does nothing');
                    return;
                }
                const centroid = meshCentroid({
                    vertices: this.selectedVertices.map(v => v.position),
                    indices: [],
                });
                for (const vertex of this.selectedVertices) {
                    const delta = vec_1.vec3.sub(vertex.position, centroid);
                    vertex.position = vec_1.vec3.add(centroid, vec_1.vec3.roty(delta, (0, utils_1.radians)(theta)));
                }
                this.model.emitChangeEvent('Vertices rotated');
            },
            rotateZ: () => {
                if (!this.model) {
                    console.error('No model loaded');
                    return;
                }
                if (this.selectedVertices.length === 0) {
                    console.warn('No vertices selected');
                    return;
                }
                const thetaString = prompt('Amount to rotate by (in degrees):', '0');
                if (thetaString === null) {
                    return;
                }
                const theta = parseFloat(thetaString);
                if (theta === 0) {
                    console.warn('Rotating by 0 degrees does nothing');
                    return;
                }
                const centroid = meshCentroid({
                    vertices: this.selectedVertices.map(v => v.position),
                    indices: [],
                });
                for (const vertex of this.selectedVertices) {
                    const delta = vec_1.vec3.sub(vertex.position, centroid);
                    vertex.position = vec_1.vec3.add(centroid, vec_1.vec3.rotz(delta, (0, utils_1.radians)(theta)));
                }
                this.model.emitChangeEvent('Vertices rotated');
            },
        };
        ModelEditor.instance = this;
        this.canvasTop = document.getElementById('canvas-top');
        this.contextTop = this.canvasTop.getContext('2d');
        this.canvasFront = document.getElementById('canvas-front');
        this.contextFront = this.canvasFront.getContext('2d');
        this.canvasSide = document.getElementById('canvas-side');
        this.contextSide = this.canvasSide.getContext('2d');
        this.canvas3d = document.getElementById('canvas-3d');
        this.context3d = this.canvas3d.getContext('2d');
        window.addEventListener('resize', () => {
            this.resizePanels();
            this.resizeCanvases();
        });
        this.resizeCanvases();
        document.querySelectorAll('.toolbar button').forEach(button => {
            button.addEventListener('click', event => {
                const target = event.currentTarget;
                if (target.dataset.selectable === 'true') {
                    this.setTool(target.dataset.tool);
                }
                else {
                    switch (target.dataset.tool) {
                        case 'reset':
                            this.reset();
                            break;
                        case 'import':
                            this.import();
                            break;
                        case 'export':
                            this.export();
                            break;
                        case 'undo':
                            this.undo();
                            break;
                        case 'redo':
                            this.redo();
                            break;
                    }
                }
            });
        });
        this.undoButton = document.querySelector('#btn-undo');
        this.redoButton = document.querySelector('#btn-redo');
        document.querySelectorAll('.reset-camera-btn').forEach(button => {
            button.addEventListener('click', event => {
                const panel = event.currentTarget.dataset.panel;
                this.resetCamera(panel);
            });
        });
        document.querySelectorAll('.movement-constraint-btn').forEach(button => {
            button.addEventListener('click', () => {
                this.updateMovementConstraints(button.dataset.axis);
            });
        });
        this.panelContainer = document.querySelector('.panel-container');
        this.panelResizeHandleVertical = document.querySelector('.resize-handle-vertical');
        this.panelResizeHandleHorizontal = document.querySelector('.resize-handle-horizontal');
        this.panelResizeHandleCenter = document.querySelector('.resize-handle-center');
        document.querySelectorAll('.resize-handle').forEach(handle => {
            handle.addEventListener('mousedown', () => {
                var _a, _b, _c;
                switch (handle.dataset.mode) {
                    case 'vertical':
                        this.panelResizeMode = 'vertical';
                        (_a = this.panelResizeHandleVertical) === null || _a === void 0 ? void 0 : _a.classList.add('active');
                        break;
                    case 'horizontal':
                        this.panelResizeMode = 'horizontal';
                        (_b = this.panelResizeHandleHorizontal) === null || _b === void 0 ? void 0 : _b.classList.add('active');
                        break;
                    case 'center':
                        this.panelResizeMode = 'center';
                        (_c = this.panelResizeHandleCenter) === null || _c === void 0 ? void 0 : _c.classList.add('active');
                        break;
                }
            });
            handle.addEventListener('dblclick', () => {
                var _a, _b, _c;
                this.panelResizeMode = null;
                (_a = this.panelResizeHandleVertical) === null || _a === void 0 ? void 0 : _a.classList.remove('active');
                (_b = this.panelResizeHandleHorizontal) === null || _b === void 0 ? void 0 : _b.classList.remove('active');
                (_c = this.panelResizeHandleCenter) === null || _c === void 0 ? void 0 : _c.classList.remove('active');
                this.panelVerticalSize = 0.5;
                this.panelHorizontalSize = 0.5;
                this.resizePanels();
            });
        });
        (_a = this.panelContainer) === null || _a === void 0 ? void 0 : _a.addEventListener('mousemove', (e) => {
            switch (this.panelResizeMode) {
                case 'vertical':
                    this.calculatePanelSizes(e.clientX, null);
                    break;
                case 'horizontal':
                    this.calculatePanelSizes(null, e.clientY - 40);
                    break;
                case 'center':
                    this.calculatePanelSizes(e.clientX, e.clientY - 40);
                    break;
            }
            this.resizePanels();
            this.resizeCanvases();
        });
        window.addEventListener('mouseup', () => {
            var _a, _b, _c;
            this.panelResizeMode = null;
            (_a = this.panelResizeHandleVertical) === null || _a === void 0 ? void 0 : _a.classList.remove('active');
            (_b = this.panelResizeHandleHorizontal) === null || _b === void 0 ? void 0 : _b.classList.remove('active');
            (_c = this.panelResizeHandleCenter) === null || _c === void 0 ? void 0 : _c.classList.remove('active');
        });
        debug_1.default.initialise();
        input_manager_1.default.initialise();
        this.cameraTop = new camera_1.default((0, vec_1.vec2)(), this.cameraOptions);
        this.cameraFront = new camera_1.default((0, vec_1.vec2)(), this.cameraOptions);
        this.cameraSide = new camera_1.default((0, vec_1.vec2)(), this.cameraOptions);
        this.camera3d = new camera_3d_1.default(ModelEditor.DEFAULT_CAMERA3D_POSITION, ModelEditor.DEFAULT_CAMERA3D_TARGET, this.camera3dOptions);
        this.initialiseCameraYawAndPitch();
        ModelEditor.gui = new dat.GUI({ width: 400, closed: true });
        ModelEditor.gui
            .add(this.options, 'modelName')
            .name('Model name')
            .onFinishChange((name) => {
            if (this.model) {
                this.model.name = name;
                this.model.emitChangeEvent('Model name changed');
            }
        })
            .listen();
        ModelEditor.gui
            .add(this.options, 'showVertexLabels')
            .name('Show vertex labels');
        ModelEditor.gui.add(this.options, 'showAxes').name('Show 3d axes');
        const toolsFolder = ModelEditor.gui.addFolder('Tools');
        toolsFolder.add(this.tools, 'scale').name('Scale');
        toolsFolder.add(this.tools, 'rotateX').name('Rotate X');
        toolsFolder.add(this.tools, 'rotateY').name('Rotate Y');
        toolsFolder.add(this.tools, 'rotateZ').name('Rotate Z');
        const gridFolder = ModelEditor.gui.addFolder('2D Grids');
        gridFolder.add(this.options, 'showGrid').name('Show 2d grids');
        gridFolder.add(this.options, 'gridSize', 1, 100, 1).name('Grid size');
        gridFolder.add(this.options, 'showGridLabels').name('Show grid labels');
        gridFolder
            .add(this.options, 'gridLabelsGap', 1, 10, 1)
            .name('Grid labels gap');
        const groundPlaneFolder = ModelEditor.gui.addFolder('3D Ground Plane');
        groundPlaneFolder
            .add(this.options, 'showGroundPlane')
            .name('Show 3d ground plane');
        groundPlaneFolder
            .add(this.options, 'groundPlaneSize', 2, 100, 2)
            .name('Ground plane size');
        groundPlaneFolder
            .add(this.options, 'showGroundPlaneLabels')
            .name('Show ground plane labels');
        groundPlaneFolder
            .add(this.options, 'groundPlaneLabelsGap', 1, 10, 1)
            .name('Ground plane labels gap');
        const cameraFolder = ModelEditor.gui.addFolder('Camera');
        cameraFolder
            .add(this.camera3d, 'fov', Math.PI / 8, Math.PI / 2, 0.01)
            .name('3D camera FOV');
        cameraFolder
            .add(this.options, 'zoomSpeed', 0.1, 10, 0.01)
            .name('Zoom speed');
        cameraFolder
            .add(this.options, 'moveSpeed', 0.1, 10, 0.01)
            .name('Move speed');
        cameraFolder
            .add(this.options, 'rotateSpeed', 0.0001, 0.01)
            .name('Rotate speed');
        ModelEditor.verticesFolder = ModelEditor.gui.addFolder('Vertices');
        ModelEditor.edgesFolder = ModelEditor.gui.addFolder('Edges');
        ModelEditor.surfacesFolder = ModelEditor.gui.addFolder('Surfaces');
        ModelEditor.historyFolder = ModelEditor.gui.addFolder('History');
        this.reset();
        this.helpModal = document.getElementById('help-modal');
        const helpButton = document.getElementById('btn-help');
        const closeButton = this.helpModal.querySelector('.close-btn');
        helpButton === null || helpButton === void 0 ? void 0 : helpButton.addEventListener('click', () => {
            this.helpModal.showModal();
        });
        closeButton === null || closeButton === void 0 ? void 0 : closeButton.addEventListener('click', () => {
            this.helpModal.close();
        });
        this.helpModal.addEventListener('click', event => {
            const rect = this.helpModal.getBoundingClientRect();
            const isInDialog = rect.top <= event.clientY &&
                event.clientY <= rect.bottom &&
                rect.left <= event.clientX &&
                event.clientX <= rect.right;
            if (!isInDialog) {
                this.helpModal.close();
            }
        });
        this.lastFrameTime = this.lastFrameCountTime = performance.now();
        this.loop();
    }
    resizeCanvases() {
        this.canvasTop.width = this.canvasTop.clientWidth;
        this.canvasTop.height = this.canvasTop.clientHeight;
        this.canvasFront.width = this.canvasFront.clientWidth;
        this.canvasFront.height = this.canvasFront.clientHeight;
        this.canvasSide.width = this.canvasSide.clientWidth;
        this.canvasSide.height = this.canvasSide.clientHeight;
        this.canvas3d.width = this.canvas3d.clientWidth;
        this.canvas3d.height = this.canvas3d.clientHeight;
    }
    calculatePanelSizes(x, y) {
        if (!this.panelContainer) {
            return;
        }
        if (x !== null) {
            const clampedX = (0, utils_1.clamp)(x - 2, this.panelContainer.clientWidth * ModelEditor.PANEL_MIN_SIZE, this.panelContainer.clientWidth * (1 - ModelEditor.PANEL_MIN_SIZE));
            this.panelHorizontalSize = (0, utils_1.round)(clampedX / this.panelContainer.clientWidth, 2);
        }
        if (y !== null) {
            const clampedY = (0, utils_1.clamp)(y - 2, this.panelContainer.clientHeight * ModelEditor.PANEL_MIN_SIZE, this.panelContainer.clientHeight * (1 - ModelEditor.PANEL_MIN_SIZE));
            this.panelVerticalSize = (0, utils_1.round)(clampedY / this.panelContainer.clientHeight, 2);
        }
    }
    resizePanels() {
        if (!this.panelContainer) {
            return;
        }
        this.panelContainer.style.gridTemplateColumns = `${this.panelHorizontalSize}fr ${1 - this.panelHorizontalSize}fr`;
        this.panelContainer.style.gridTemplateRows = `${this.panelVerticalSize}fr ${1 - this.panelVerticalSize}fr`;
        const resizeHandleX = this.panelHorizontalSize * this.panelContainer.clientWidth;
        const resizeHandleY = this.panelVerticalSize * this.panelContainer.clientHeight;
        if (this.panelResizeHandleVertical) {
            this.panelResizeHandleVertical.style.left = `${resizeHandleX - 2}px`;
        }
        if (this.panelResizeHandleHorizontal) {
            this.panelResizeHandleHorizontal.style.top = `${resizeHandleY - 2}px`;
        }
        if (this.panelResizeHandleCenter) {
            this.panelResizeHandleCenter.style.left = `${resizeHandleX - 6}px`;
            this.panelResizeHandleCenter.style.top = `${resizeHandleY - 6}px`;
        }
    }
    reset() {
        if (this.model &&
            !confirm('Are you sure you want to reset? This will clear undo history.')) {
            return;
        }
        this.resetCamera('top');
        this.resetCamera('front');
        this.resetCamera('side');
        this.resetCamera('3d');
        if (this.model) {
            this.model.removeEventListener('change', this.modelChanged.bind(this));
            this.model.destroy();
            this.model = null;
        }
        this.model = new model_1.default();
        this.options.modelName = '';
        this.model.addEventListener('change', this.modelChanged.bind(this));
        this.tool = 'select';
        this.hoveredVertex = null;
        if (this.selectedVertices.length > 0) {
            this.selectedVertices.forEach(v => (v.selected = false));
            this.selectedVertices = [];
        }
        if (this.selectedEdges.length > 0) {
            this.selectedEdges.forEach(e => (e.selected = false));
            this.selectedEdges = [];
        }
        if (this.selectedSurfaces.length > 0) {
            this.selectedSurfaces.forEach(s => (s.selected = false));
            this.selectedSurfaces = [];
        }
        this.draggingVertex = null;
        this.dragStartMouse = null;
        this.dragStartVertexPositions = null;
        this.panning = false;
        this.lastPanPosition = null;
        this.lastMousePosition = (0, vec_1.vec2)();
        if (this.creatingEdge) {
            this.creatingEdge.destroy();
            this.creatingEdge = null;
        }
        if (this.creatingSurface) {
            this.creatingSurface.destroy();
            this.creatingSurface = null;
        }
        if (ModelEditor.historyFolder) {
            ModelEditor.historyFolder.__controllers.forEach(controller => controller.remove());
        }
        this.history = [];
        this.currentHistoryIndex = -1;
        this.updateUndoRedoButtons();
    }
    setTool(tool) {
        this.tool = tool;
        const toolbarButtons = document.querySelectorAll('.toolbar button');
        toolbarButtons.forEach((button) => {
            if (button.dataset.tool === tool) {
                button.classList.add('selected');
            }
            else {
                button.classList.remove('selected');
            }
        });
        if (this.panelContainer) {
            this.panelContainer.classList.forEach(c => {
                if (c.startsWith('tool-')) {
                    this.panelContainer.classList.remove(c);
                }
            });
            this.panelContainer.classList.add(`tool-${this.tool}`);
        }
    }
    import() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.addEventListener('change', () => {
            var _a;
            const file = (_a = input.files) === null || _a === void 0 ? void 0 : _a[0];
            if (!file)
                return;
            const reader = new FileReader();
            reader.onload = e => {
                var _a;
                try {
                    const data = JSON.parse((_a = e.target) === null || _a === void 0 ? void 0 : _a.result);
                    if (this.model) {
                        this.model.removeEventListener('change', this.modelChanged.bind(this));
                        this.model.destroy();
                        this.model = null;
                    }
                    this.model = model_1.default.deserialize(data);
                    if (this.model) {
                        this.model.addEventListener('change', this.modelChanged.bind(this));
                        this.options.modelName = this.model.name || '';
                        this.clearHistoryEntries();
                        this.addHistoryEntry('Model imported', this.model.serialize());
                        console.log('Model imported successfully');
                    }
                }
                catch (err) {
                    console.error('Error importing model:', err);
                }
            };
            reader.readAsText(file);
        });
        input.click();
    }
    export() {
        if (!this.model) {
            console.error('No model to export');
            return;
        }
        this.model.name = this.options.modelName;
        const data = JSON.stringify(this.model.serialize(), null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${this.model.name || 'model'}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
    undo() {
        if (this.currentHistoryIndex <= 0) {
            console.warn('No more history to undo');
            return;
        }
        this.currentHistoryIndex--;
        this.jumpToHistoryEntry(this.currentHistoryIndex);
        this.updateUndoRedoButtons();
        console.log('Undo last action:', this.history[this.currentHistoryIndex]);
    }
    redo() {
        if (this.currentHistoryIndex >= this.history.length - 1) {
            console.warn('No more history to redo');
            return;
        }
        this.currentHistoryIndex++;
        this.jumpToHistoryEntry(this.currentHistoryIndex);
        this.updateUndoRedoButtons();
        console.log('Redo last action:', this.history[this.currentHistoryIndex]);
    }
    modelChanged(e) {
        const { action, model } = e.detail;
        if (action) {
            this.addHistoryEntry(action, model);
        }
    }
    jumpToHistoryEntry(index) {
        if (index < 0 || index >= this.history.length) {
            console.warn('Invalid history index:', index);
            return;
        }
        if (this.model) {
            this.model.removeEventListener('change', this.modelChanged.bind(this));
            this.model.destroy();
            this.model = null;
        }
        const entry = this.history[index];
        this.model = model_1.default.deserialize(entry.model);
        this.options.modelName = this.model.name || '';
        this.model.addEventListener('change', this.modelChanged.bind(this));
        this.currentHistoryIndex = index;
        this.updateUndoRedoButtons();
    }
    addHistoryEntry(action, model) {
        let index = -1;
        if (this.currentHistoryIndex < this.history.length - 1) {
            this.clearHistoryEntries(this.currentHistoryIndex + 1);
        }
        index = this.history.length;
        const date = new Date().toISOString();
        let controller = undefined;
        if (ModelEditor.historyFolder) {
            controller = ModelEditor.historyFolder
                .add({ jump: () => this.jumpToHistoryEntry(index) }, 'jump')
                .name(`${date} - ${action}`);
        }
        const entry = {
            action,
            model,
            date,
            controller,
        };
        this.history.push(entry);
        this.currentHistoryIndex = index;
        this.updateUndoRedoButtons();
    }
    clearHistoryEntries(from) {
        from = from !== null && from !== void 0 ? from : 0;
        if (from < 0 || from >= this.history.length) {
            return;
        }
        for (let i = from; i < this.history.length; i++) {
            const entry = this.history[i];
            if (entry.controller && ModelEditor.historyFolder) {
                ModelEditor.historyFolder.remove(entry.controller);
            }
        }
        this.history.splice(from, this.history.length - from);
        this.updateUndoRedoButtons();
    }
    updateUndoRedoButtons() {
        if (this.undoButton) {
            this.undoButton.disabled = this.currentHistoryIndex <= 0;
        }
        if (this.redoButton) {
            this.redoButton.disabled =
                this.currentHistoryIndex >= this.history.length - 1;
        }
    }
    resetCamera(panel) {
        switch (panel) {
            case 'top':
                this.cameraTop.position = (0, vec_1.vec2)(0, 0);
                this.cameraTop.scale = 1;
                break;
            case 'front':
                this.cameraFront.position = (0, vec_1.vec2)(0, 0);
                this.cameraFront.scale = 1;
                break;
            case 'side':
                this.cameraSide.position = (0, vec_1.vec2)(0, 0);
                this.cameraSide.scale = 1;
                break;
            case '3d':
                this.camera3d.position = ModelEditor.DEFAULT_CAMERA3D_POSITION;
                this.camera3d.target = ModelEditor.DEFAULT_CAMERA3D_TARGET;
                this.initialiseCameraYawAndPitch();
                break;
        }
    }
    updateMovementConstraints(axis) {
        document.querySelectorAll('.movement-constraint-btn').forEach(button => {
            button.classList.remove('active');
        });
        const movementConstraintButtonX = document.querySelector('.movement-constraint-btn-x');
        const movementConstraintButtonY = document.querySelector('.movement-constraint-btn-y');
        const movementConstraintButtonZ = document.querySelector('.movement-constraint-btn-z');
        switch (axis) {
            case 'x':
                this.movementConstraintXActive = !this.movementConstraintXActive;
                this.movementConstraintYActive = false;
                this.movementConstraintZActive = false;
                movementConstraintButtonX.classList.toggle('active', this.movementConstraintXActive);
                break;
            case 'y':
                this.movementConstraintXActive = false;
                this.movementConstraintYActive = !this.movementConstraintYActive;
                this.movementConstraintZActive = false;
                movementConstraintButtonY.classList.toggle('active', this.movementConstraintYActive);
                break;
            case 'z':
                this.movementConstraintXActive = false;
                this.movementConstraintYActive = false;
                this.movementConstraintZActive = !this.movementConstraintZActive;
                movementConstraintButtonZ.classList.toggle('active', this.movementConstraintZActive);
                break;
            default:
                this.movementConstraintXActive = false;
                this.movementConstraintYActive = false;
                this.movementConstraintZActive = false;
                break;
        }
    }
    initialiseCameraYawAndPitch() {
        const forward = vec_1.vec3.nor(vec_1.vec3.sub(this.camera3d.target, this.camera3d.position));
        const polar = vec_1.vec3.polar(forward);
        this.camera3dYaw = polar.phi;
        this.camera3dPitch = Math.PI / 2 - polar.theta;
    }
    loop() {
        const now = performance.now();
        const elapsedTime = now - this.lastFrameTime;
        if (now - this.lastFrameCountTime >= 1000) {
            this.lastFrameCountTime = now;
            this.frameRate = this.frameCount;
            this.frameCount = 0;
        }
        this.frameCount++;
        this.lastFrameTime = now;
        debug_1.default.value('FPS', this.frameRate, { align: 'right', tags: ['panel-3d'] });
        this.update(elapsedTime);
        this.draw();
        window.requestAnimationFrame(this.loop.bind(this));
    }
    update(dt) {
        var _a, _b, _c, _d, _e;
        const hoveredElement = (_b = (_a = input_manager_1.default.hoveredElement) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        if (input_manager_1.default.keyPressed('Space') && this.tool !== 'pan') {
            this.previousTool = this.tool;
            this.setTool('pan');
            this.spacebarPanActive = true;
        }
        if (input_manager_1.default.keyReleased('Space') && this.spacebarPanActive) {
            if (this.previousTool && this.tool === 'pan') {
                this.setTool(this.previousTool);
            }
            this.spacebarPanActive = false;
            this.previousTool = null;
        }
        if (input_manager_1.default.keyPressed('KeyX')) {
            this.updateMovementConstraints('x');
        }
        if (input_manager_1.default.keyPressed('KeyY')) {
            this.updateMovementConstraints('y');
        }
        if (input_manager_1.default.keyPressed('KeyZ')) {
            this.updateMovementConstraints('z');
        }
        if (input_manager_1.default.keyReleased('KeyX')) {
            this.updateMovementConstraints(null);
        }
        if (input_manager_1.default.keyReleased('KeyY')) {
            this.updateMovementConstraints(null);
        }
        if (input_manager_1.default.keyReleased('KeyZ')) {
            this.updateMovementConstraints(null);
        }
        if (this.model) {
            this.model.vertices.forEach(v => (v.hovered = false));
            this.model.edges.forEach(e => (e.hovered = false));
            this.model.surfaces.forEach(s => (s.hovered = false));
        }
        this.hoveredVertex = null;
        this.hoveredEdge = null;
        this.hoveredSurface = null;
        if (this.model &&
            ['select', 'create-edge', 'create-surface'].includes(this.tool) &&
            ['canvas-top', 'canvas-front', 'canvas-side'].includes(hoveredElement)) {
            const { camera, components } = (_c = this.getPanel2dInfo(hoveredElement)) !== null && _c !== void 0 ? _c : {};
            const mouseWorld = camera.screenToWorld(input_manager_1.default.mousePosition);
            const hoveredVertices = this.model.vertices.filter(v => v.isPointNear2d(mouseWorld, components));
            if (hoveredVertices.length > 0) {
                switch (hoveredElement) {
                    case 'canvas-top':
                        hoveredVertices.sort((a, b) => a.position.y - b.position.y);
                        break;
                    case 'canvas-front':
                        hoveredVertices.sort((a, b) => a.position.z - b.position.z);
                        break;
                    case 'canvas-side':
                        hoveredVertices.sort((a, b) => a.position.x - b.position.x);
                        break;
                }
                this.hoveredVertex = hoveredVertices[hoveredVertices.length - 1];
                this.hoveredVertex.hovered = true;
            }
            if (this.tool === 'select' && !this.hoveredVertex) {
                const hoveredEdges = this.model.edges
                    .filter(e => e.isPointNear2d(mouseWorld, components))
                    .map(e => ({
                    edge: e,
                    avg: (0, vec_1.vec3)(e.a.position.x + e.b.position.x, e.a.position.y + e.b.position.y, e.a.position.z + e.b.position.z),
                }));
                if (hoveredEdges.length > 0) {
                    switch (hoveredElement) {
                        case 'canvas-top':
                            hoveredEdges.sort((a, b) => a.avg.y - b.avg.y);
                            break;
                        case 'canvas-front':
                            hoveredEdges.sort((a, b) => a.avg.z - b.avg.z);
                            break;
                        case 'canvas-side':
                            hoveredEdges.sort((a, b) => a.avg.x - b.avg.x);
                            break;
                    }
                    this.hoveredEdge = hoveredEdges[hoveredEdges.length - 1].edge;
                    this.hoveredEdge.hovered = true;
                }
            }
            if (this.tool === 'select' && !this.hoveredVertex && !this.hoveredEdge) {
                const hoveredSurfaces = this.model.surfaces
                    .filter(s => s.isPointNear2d(mouseWorld, components))
                    .map(s => ({
                    surface: s,
                    avg: (0, vec_1.vec3)(s.vertices.reduce((sum, v) => sum + v.position.x, 0) /
                        s.vertices.length, s.vertices.reduce((sum, v) => sum + v.position.y, 0) /
                        s.vertices.length, s.vertices.reduce((sum, v) => sum + v.position.z, 0) /
                        s.vertices.length),
                }));
                if (hoveredSurfaces.length > 0) {
                    switch (hoveredElement) {
                        case 'canvas-top':
                            hoveredSurfaces.sort((a, b) => a.avg.y - b.avg.y);
                            break;
                        case 'canvas-front':
                            hoveredSurfaces.sort((a, b) => a.avg.z - b.avg.z);
                            break;
                        case 'canvas-side':
                            hoveredSurfaces.sort((a, b) => a.avg.x - b.avg.x);
                            break;
                    }
                    this.hoveredSurface =
                        hoveredSurfaces[hoveredSurfaces.length - 1].surface;
                    this.hoveredSurface.hovered = true;
                }
            }
        }
        if (this.model &&
            ['select', 'create-edge', 'create-surface'].includes(this.tool) &&
            hoveredElement === 'canvas-3d') {
            let closestVertex = null;
            const intersectingVertices = this.model.vertices.filter(v => v.isPointNear3d(input_manager_1.default.mousePosition, this.camera3d, (0, vec_1.vec2)(this.canvas3d.width, this.canvas3d.height)));
            if (intersectingVertices.length > 0) {
                closestVertex = intersectingVertices
                    .map(v => ({
                    vertex: v,
                    distance: vec_1.vec3.len(vec_1.vec3.sub(v.position, this.camera3d.position)),
                }))
                    .sort((a, b) => a.distance - b.distance)[0].vertex;
            }
            if (closestVertex) {
                this.hoveredVertex = closestVertex;
                this.hoveredVertex.hovered = true;
            }
            if (this.tool === 'select' && !this.hoveredVertex) {
                let closestEdge = null;
                const intersectingEdges = this.model.edges.filter(e => e.isPointNear3d(input_manager_1.default.mousePosition, this.camera3d, (0, vec_1.vec2)(this.canvas3d.width, this.canvas3d.height)));
                if (intersectingEdges.length > 0) {
                    closestEdge = intersectingEdges
                        .map(e => ({
                        edge: e,
                        distance: vec_1.vec3.len(vec_1.vec3.sub(vec_1.vec3.div(vec_1.vec3.add(e.a.position, e.b.position), 2), this.camera3d.position)),
                    }))
                        .sort((a, b) => a.distance - b.distance)[0].edge;
                }
                if (closestEdge) {
                    this.hoveredEdge = closestEdge;
                    this.hoveredEdge.hovered = true;
                }
            }
            if (this.tool === 'select' && !this.hoveredVertex && !this.hoveredEdge) {
                let closestSurface = null;
                const intersectingSurfaces = this.model.surfaces.filter(s => s.isPointNear3d(input_manager_1.default.mousePosition, this.camera3d, (0, vec_1.vec2)(this.canvas3d.width, this.canvas3d.height)));
                if (intersectingSurfaces.length > 0) {
                    closestSurface = intersectingSurfaces
                        .map(s => ({
                        surface: s,
                        distance: vec_1.vec3.len(vec_1.vec3.sub(vec_1.vec3.div(s.vertices.reduce((sum, v) => vec_1.vec3.add(sum, v.position), (0, vec_1.vec3)()), s.vertices.length), this.camera3d.position)),
                    }))
                        .sort((a, b) => a.distance - b.distance)[0].surface;
                }
                if (closestSurface) {
                    this.hoveredSurface = closestSurface;
                    this.hoveredSurface.hovered = true;
                }
            }
        }
        if (this.hoveredVertex &&
            this.hoveredVertex.selected &&
            input_manager_1.default.mousePressed(input_manager_1.MouseButton.Left)) {
            this.clickedVertex = this.hoveredVertex;
        }
        if (!this.hoveredVertex) {
            this.clickedVertex = null;
        }
        if (this.tool === 'select' && input_manager_1.default.mousePressed(input_manager_1.MouseButton.Left)) {
            if (this.hoveredVertex) {
                if (input_manager_1.default.keyDown('ControlLeft') ||
                    input_manager_1.default.keyDown('ControlRight')) {
                    this.selectVertex(this.hoveredVertex);
                }
                else {
                    this.deselectVertex();
                    this.selectVertex(this.hoveredVertex);
                }
                if (this.selectedVertices.length > 0) {
                    this.draggingVertex = this.hoveredVertex;
                    this.dragStartMouse = vec_1.vec2.cpy(input_manager_1.default.mousePosition);
                    this.dragStartVertexPositions = new Map(this.selectedVertices.map(v => [v.id, vec_1.vec3.cpy(v.position)]));
                }
            }
            if (this.hoveredEdge) {
                if (input_manager_1.default.keyDown('ControlLeft') ||
                    input_manager_1.default.keyDown('ControlRight')) {
                    this.selectEdge(this.hoveredEdge);
                }
                else {
                    this.deselectEdge();
                    this.selectEdge(this.hoveredEdge);
                }
            }
            if (this.hoveredSurface) {
                if (input_manager_1.default.keyDown('ControlLeft') ||
                    input_manager_1.default.keyDown('ControlRight')) {
                    this.selectSurface(this.hoveredSurface);
                }
                else {
                    this.deselectSurface();
                    this.selectSurface(this.hoveredSurface);
                }
            }
        }
        if (this.tool === 'select' &&
            this.draggingVertex &&
            this.selectedVertices.length > 0 &&
            ['canvas-top', 'canvas-front', 'canvas-side'].includes(hoveredElement) &&
            input_manager_1.default.mouseDown(input_manager_1.MouseButton.Left)) {
            const mouseNow = vec_1.vec2.cpy(input_manager_1.default.mousePosition);
            const { camera } = (_d = this.getPanel2dInfo(hoveredElement)) !== null && _d !== void 0 ? _d : {};
            const worldStart = camera.screenToWorld(this.dragStartMouse);
            const worldNow = camera.screenToWorld(mouseNow);
            const deltaMouse = vec_1.vec2.sub(worldNow, worldStart);
            const deltaVertexPosition = (0, vec_1.vec3)();
            switch (hoveredElement) {
                case 'canvas-top':
                    deltaVertexPosition.x = deltaMouse.x;
                    deltaVertexPosition.z = deltaMouse.y;
                    break;
                case 'canvas-front':
                    deltaVertexPosition.x = deltaMouse.x;
                    deltaVertexPosition.y = -deltaMouse.y;
                    break;
                case 'canvas-side':
                    deltaVertexPosition.z = -deltaMouse.x;
                    deltaVertexPosition.y = -deltaMouse.y;
                    break;
            }
            const draggingInitialPosition = this.dragStartVertexPositions.get(this.draggingVertex.id);
            const draggingNewPosition = vec_1.vec3.add(draggingInitialPosition, deltaVertexPosition);
            if (input_manager_1.default.keyDown('ShiftLeft') ||
                input_manager_1.default.keyDown('ShiftRight')) {
                const grid = this.options.gridSize;
                draggingNewPosition.x = Math.round(draggingNewPosition.x / grid) * grid;
                draggingNewPosition.y = Math.round(draggingNewPosition.y / grid) * grid;
                draggingNewPosition.z = Math.round(draggingNewPosition.z / grid) * grid;
            }
            const finalDelta = vec_1.vec3.sub(draggingNewPosition, draggingInitialPosition);
            this.selectedVertices.forEach(v => {
                const initialPosition = this.dragStartVertexPositions.get(v.id);
                if (initialPosition) {
                    v.position = vec_1.vec3.add(initialPosition, finalDelta);
                }
            });
            if (!vectorAlmostZero(finalDelta)) {
                this.verticesMoved = true;
            }
        }
        if (this.tool === 'select' &&
            this.draggingVertex &&
            this.selectedVertices.length > 0 &&
            hoveredElement === 'canvas-3d' &&
            input_manager_1.default.mouseDown(input_manager_1.MouseButton.Left)) {
            const mouse = vec_1.vec2.cpy(input_manager_1.default.mousePosition);
            const ray = this.camera3d.raycast(mouse, (0, vec_1.vec2)(this.canvas3d.width, this.canvas3d.height));
            if (ray) {
                let deltaVertexPosition = (0, vec_1.vec3)();
                const draggingInitialPosition = this.dragStartVertexPositions.get(this.draggingVertex.id);
                if (this.movementConstraintXActive ||
                    this.movementConstraintYActive ||
                    this.movementConstraintZActive) {
                    const mouseStartToNow = mouse.y - this.dragStartMouse.y;
                    const movementAmount = -mouseStartToNow;
                    if (this.movementConstraintXActive) {
                        deltaVertexPosition.x += movementAmount;
                    }
                    if (this.movementConstraintYActive) {
                        deltaVertexPosition.y += movementAmount;
                    }
                    if (this.movementConstraintZActive) {
                        deltaVertexPosition.z += movementAmount;
                    }
                    const draggingNewPosition = vec_1.vec3.add(draggingInitialPosition, deltaVertexPosition);
                    if (input_manager_1.default.keyDown('ShiftLeft') ||
                        input_manager_1.default.keyDown('ShiftRight')) {
                        const grid = this.options.gridSize;
                        draggingNewPosition.x =
                            Math.round(draggingNewPosition.x / grid) * grid;
                        draggingNewPosition.y =
                            Math.round(draggingNewPosition.y / grid) * grid;
                        draggingNewPosition.z =
                            Math.round(draggingNewPosition.z / grid) * grid;
                    }
                    deltaVertexPosition = vec_1.vec3.sub(draggingNewPosition, draggingInitialPosition);
                }
                else {
                    const planePoint = (0, vec_1.vec3)(0, this.draggingVertex.position.y, 0);
                    const planeNormal = (0, vec_1.vec3)(0, 1, 0);
                    const intersection = rayIntersectsPlane(ray, {
                        point: planePoint,
                        normal: planeNormal,
                    });
                    if (intersection.intersects) {
                        let draggingNewPosition = vec_1.vec3.cpy(intersection.intersectionPoint);
                        if (input_manager_1.default.keyDown('ShiftLeft') ||
                            input_manager_1.default.keyDown('ShiftRight')) {
                            const grid = this.options.gridSize;
                            draggingNewPosition.x =
                                Math.round(draggingNewPosition.x / grid) * grid;
                            draggingNewPosition.z =
                                Math.round(draggingNewPosition.z / grid) * grid;
                        }
                        deltaVertexPosition = vec_1.vec3.sub(draggingNewPosition, draggingInitialPosition);
                    }
                }
                this.selectedVertices.forEach(v => {
                    const initialPosition = this.dragStartVertexPositions.get(v.id);
                    if (initialPosition) {
                        v.position = vec_1.vec3.add(initialPosition, deltaVertexPosition);
                    }
                });
                if (!vectorAlmostZero(deltaVertexPosition)) {
                    this.verticesMoved = true;
                }
            }
        }
        if (this.tool === 'select' &&
            this.hoveredVertex &&
            input_manager_1.default.mouseReleased(input_manager_1.MouseButton.Left) &&
            this.clickedVertex === this.hoveredVertex &&
            (!this.dragStartMouse ||
                vec_1.vec2.eq(this.dragStartMouse, input_manager_1.default.mousePosition)) &&
            ['canvas-top', 'canvas-front', 'canvas-side', 'canvas-3d'].includes(hoveredElement)) {
            this.deselectVertex(this.hoveredVertex);
            this.clickedVertex = null;
        }
        if (this.draggingVertex && input_manager_1.default.mouseReleased(input_manager_1.MouseButton.Left)) {
            this.draggingVertex = null;
            this.dragStartMouse = null;
            this.dragStartVertexPositions = null;
        }
        if (this.verticesMoved && input_manager_1.default.mouseReleased(input_manager_1.MouseButton.Left)) {
            this.verticesMoved = false;
            if (this.model) {
                this.model.emitChangeEvent('Vertices moved');
            }
        }
        if (this.tool === 'select' &&
            !this.hoveredVertex &&
            input_manager_1.default.mousePressed(input_manager_1.MouseButton.Left) &&
            ['canvas-top', 'canvas-front', 'canvas-side', 'canvas-3d'].includes(hoveredElement)) {
            this.deselectVertex();
        }
        if (this.tool === 'select' &&
            !this.hoveredEdge &&
            input_manager_1.default.mousePressed(input_manager_1.MouseButton.Left) &&
            ['canvas-top', 'canvas-front', 'canvas-side', 'canvas-3d'].includes(hoveredElement)) {
            this.deselectEdge();
        }
        if (this.tool === 'select' &&
            !this.hoveredSurface &&
            input_manager_1.default.mousePressed(input_manager_1.MouseButton.Left) &&
            ['canvas-top', 'canvas-front', 'canvas-side', 'canvas-3d'].includes(hoveredElement)) {
            this.deselectSurface();
        }
        if (this.tool === 'create-vertex' &&
            input_manager_1.default.mousePressed(input_manager_1.MouseButton.Left) &&
            this.model) {
            if (['canvas-top', 'canvas-front', 'canvas-side'].includes(hoveredElement)) {
                const panelInfo = this.getPanel2dInfo(hoveredElement);
                if (panelInfo) {
                    const { camera, components } = panelInfo;
                    const mouseWorld = camera.screenToWorld(input_manager_1.default.mousePosition);
                    let position = (0, vec_1.vec3)();
                    switch (components) {
                        case 'xz':
                            position = (0, vec_1.vec3)(mouseWorld.x, 0, mouseWorld.y);
                            break;
                        case 'xY':
                            position = (0, vec_1.vec3)(mouseWorld.x, -mouseWorld.y, 0);
                            break;
                        case 'ZY':
                            position = (0, vec_1.vec3)(0, -mouseWorld.y, -mouseWorld.x);
                            break;
                    }
                    if (input_manager_1.default.keyDown('ShiftLeft') ||
                        input_manager_1.default.keyDown('ShiftRight')) {
                        const grid = this.options.gridSize;
                        position.x = Math.round(position.x / grid) * grid;
                        position.y = Math.round(position.y / grid) * grid;
                        position.z = Math.round(position.z / grid) * grid;
                    }
                    this.model.addVertex(position);
                }
            }
            if (hoveredElement === 'canvas-3d') {
                const mouse = vec_1.vec2.cpy(input_manager_1.default.mousePosition);
                const ray = this.camera3d.raycast(mouse, (0, vec_1.vec2)(this.canvas3d.width, this.canvas3d.height));
                if (ray) {
                    const planePoint = (0, vec_1.vec3)(0, 0, 0);
                    const planeNormal = (0, vec_1.vec3)(0, 1, 0);
                    const intersection = rayIntersectsPlane(ray, {
                        point: planePoint,
                        normal: planeNormal,
                    });
                    if (intersection.intersects && intersection.intersectionPoint) {
                        let position = intersection.intersectionPoint;
                        if (input_manager_1.default.keyDown('ShiftLeft') ||
                            input_manager_1.default.keyDown('ShiftRight')) {
                            const grid = this.options.gridSize;
                            position.x = Math.round(position.x / grid) * grid;
                            position.y = Math.round(position.y / grid) * grid;
                            position.z = Math.round(position.z / grid) * grid;
                        }
                        this.model.addVertex(position);
                    }
                }
            }
        }
        if (this.model &&
            this.tool === 'create-edge' &&
            this.hoveredVertex &&
            input_manager_1.default.mousePressed(input_manager_1.MouseButton.Left)) {
            if (this.creatingEdge) {
                this.creatingEdge.b = this.hoveredVertex;
                this.model.addEdge(new edge_1.default(this.creatingEdge.a, this.creatingEdge.b));
                this.creatingEdge.destroy();
                this.creatingEdge = null;
            }
            else {
                this.creatingEdge = new edge_1.default(this.hoveredVertex, new vertex_1.default((0, vec_1.vec3)(), false, false), false);
            }
        }
        if (this.creatingEdge) {
            this.creatingEdge.a.hovered = true;
            this.creatingEdge.hovered = true;
            if (this.hoveredVertex) {
                this.creatingEdge.b.position = vec_1.vec3.cpy(this.hoveredVertex.position);
            }
            else if (['canvas-top', 'canvas-front', 'canvas-side'].includes(hoveredElement)) {
                const { camera } = (_e = this.getPanel2dInfo(hoveredElement)) !== null && _e !== void 0 ? _e : {};
                const mouseWorld = camera.screenToWorld(input_manager_1.default.mousePosition);
                switch (hoveredElement) {
                    case 'canvas-top':
                        this.creatingEdge.b.position = (0, vec_1.vec3)(mouseWorld.x, this.creatingEdge.a.position.y, mouseWorld.y);
                        break;
                    case 'canvas-front':
                        this.creatingEdge.b.position = (0, vec_1.vec3)(mouseWorld.x, -mouseWorld.y, this.creatingEdge.a.position.z);
                        break;
                    case 'canvas-side':
                        this.creatingEdge.b.position = (0, vec_1.vec3)(this.creatingEdge.a.position.x, -mouseWorld.y, -mouseWorld.x);
                        break;
                }
            }
            else if (['canvas-3d'].includes(hoveredElement)) {
                const mouse = vec_1.vec2.cpy(input_manager_1.default.mousePosition);
                const ray = this.camera3d.raycast(mouse, (0, vec_1.vec2)(this.canvas3d.width, this.canvas3d.height));
                if (ray) {
                    const planePoint = (0, vec_1.vec3)(0, this.creatingEdge.a.position.y, 0);
                    const planeNormal = (0, vec_1.vec3)(0, 1, 0);
                    const intersection = rayIntersectsPlane(ray, {
                        point: planePoint,
                        normal: planeNormal,
                    });
                    if (intersection.intersects && intersection.intersectionPoint) {
                        this.creatingEdge.b.position = vec_1.vec3.cpy(intersection.intersectionPoint);
                    }
                }
            }
        }
        if (this.tool === 'create-edge' &&
            this.creatingEdge &&
            input_manager_1.default.keyPressed('Escape')) {
            this.creatingEdge.destroy();
            this.creatingEdge = null;
        }
        if (!['create-edge', 'pan'].includes(this.tool) && this.creatingEdge) {
            this.creatingEdge.destroy();
            this.creatingEdge = null;
        }
        if (this.model &&
            this.tool === 'create-surface' &&
            this.hoveredVertex &&
            input_manager_1.default.mousePressed(input_manager_1.MouseButton.Left)) {
            if (this.creatingSurface) {
                if (!this.creatingSurface.vertices.includes(this.hoveredVertex)) {
                    this.creatingSurface.vertices.push(this.hoveredVertex);
                }
                else if (this.creatingSurface.vertices.length >= 3 &&
                    this.creatingSurface.vertices[0] === this.hoveredVertex) {
                    this.model.addSurface(new surface_1.default([...this.creatingSurface.vertices]));
                    this.creatingSurface.destroy();
                    this.creatingSurface = null;
                }
                else {
                    this.creatingSurface.vertices = this.creatingSurface.vertices.filter(v => v !== this.hoveredVertex);
                }
            }
            else {
                this.creatingSurface = new surface_1.default([this.hoveredVertex], false);
            }
        }
        if (this.creatingSurface) {
            this.creatingSurface.vertices.forEach(v => (v.hovered = true));
            this.creatingSurface.hovered = true;
        }
        if (this.tool === 'create-surface' &&
            this.creatingSurface &&
            input_manager_1.default.keyPressed('Escape')) {
            this.creatingSurface.destroy();
            this.creatingSurface = null;
        }
        if (!['create-surface', 'pan'].includes(this.tool) &&
            this.creatingSurface) {
            this.creatingSurface.destroy();
            this.creatingSurface = null;
        }
        if (this.tool === 'select' &&
            input_manager_1.default.keyPressed('Delete') &&
            this.model) {
            if (this.selectedVertices.length) {
                this.selectedVertices.forEach(v => this.model.removeVertex(v));
                this.deselectVertex();
            }
            if (this.selectedEdges.length) {
                this.selectedEdges.forEach(e => this.model.removeEdge(e));
                this.selectedEdges = [];
            }
            if (this.selectedSurfaces.length) {
                this.selectedSurfaces.forEach(s => this.model.removeSurface(s));
                this.selectedSurfaces = [];
            }
        }
        if (hoveredElement === 'canvas-3d') {
            let moved = false;
            let moveDir = (0, vec_1.vec3)();
            const forward = vec_1.vec3.nor(vec_1.vec3.sub(this.camera3d.target, this.camera3d.position));
            const right = vec_1.vec3.nor(vec_1.vec3.cross(forward, (0, vec_1.vec3)(0, 1, 0)));
            const up = (0, vec_1.vec3)(0, 1, 0);
            if (input_manager_1.default.keyDown('KeyW')) {
                moveDir = vec_1.vec3.add(moveDir, forward);
                moved = true;
            }
            if (input_manager_1.default.keyDown('KeyS')) {
                moveDir = vec_1.vec3.sub(moveDir, forward);
                moved = true;
            }
            if (input_manager_1.default.keyDown('KeyA')) {
                moveDir = vec_1.vec3.sub(moveDir, right);
                moved = true;
            }
            if (input_manager_1.default.keyDown('KeyD')) {
                moveDir = vec_1.vec3.add(moveDir, right);
                moved = true;
            }
            if (input_manager_1.default.keyDown('KeyQ')) {
                moveDir = vec_1.vec3.add(moveDir, up);
                moved = true;
            }
            if (input_manager_1.default.keyDown('KeyE')) {
                moveDir = vec_1.vec3.sub(moveDir, up);
                moved = true;
            }
            if (moved) {
                moveDir = vec_1.vec3.nor(moveDir);
                const moveStep = vec_1.vec3.scale(moveDir, this.options.moveSpeed * dt);
                this.camera3d.position = vec_1.vec3.add(this.camera3d.position, moveStep);
                this.camera3d.target = vec_1.vec3.add(this.camera3d.target, moveStep);
            }
        }
        if (this.tool === 'pan' &&
            hoveredElement === 'canvas-3d' &&
            input_manager_1.default.mouseDown(input_manager_1.MouseButton.Left)) {
            const delta = vec_1.vec2.sub(input_manager_1.default.mousePosition, this.lastMousePosition);
            this.camera3dYaw += delta.x * this.options.rotateSpeed;
            this.camera3dPitch -= delta.y * this.options.rotateSpeed;
            const maxPitch = Math.PI / 2 - 0.01;
            this.camera3dPitch = Math.max(-maxPitch, Math.min(maxPitch, this.camera3dPitch));
            const r = vec_1.vec3.len(vec_1.vec3.sub(this.camera3d.position, this.camera3d.target));
            const offset = vec_1.vec3.fromPolar(r, Math.PI / 2 - this.camera3dPitch, this.camera3dYaw);
            this.camera3d.target = vec_1.vec3.add(this.camera3d.position, offset);
        }
        if (['canvas-top', 'canvas-front', 'canvas-side'].includes(hoveredElement)) {
            const camera = this.getPanel2dInfo(hoveredElement).camera;
            if (input_manager_1.default.mouseWheelUp()) {
                camera.scale *= 1 + this.options.zoomSpeed;
            }
            if (input_manager_1.default.mouseWheelDown()) {
                camera.scale *= 1 - this.options.zoomSpeed;
            }
        }
        if (this.tool === 'pan') {
            if (['canvas-top', 'canvas-front', 'canvas-side'].includes(hoveredElement) &&
                input_manager_1.default.mousePressed(input_manager_1.MouseButton.Left)) {
                this.panning = true;
                this.lastPanPosition = vec_1.vec2.cpy(input_manager_1.default.mousePosition);
            }
            if (this.panning &&
                ['canvas-top', 'canvas-front', 'canvas-side'].includes(hoveredElement) &&
                input_manager_1.default.mouseDown(input_manager_1.MouseButton.Left) &&
                this.lastPanPosition) {
                const delta = vec_1.vec2.sub(input_manager_1.default.mousePosition, this.lastPanPosition);
                const camera = this.getPanel2dInfo(hoveredElement).camera;
                if (camera) {
                    camera.position.x -= delta.x / camera.actualScale;
                    camera.position.y -= delta.y / camera.actualScale;
                }
                this.lastPanPosition = vec_1.vec2.cpy(input_manager_1.default.mousePosition);
            }
            if (this.panning && input_manager_1.default.mouseReleased(input_manager_1.MouseButton.Left)) {
                this.panning = false;
                this.lastPanPosition = null;
            }
        }
        else {
            this.panning = false;
            this.lastPanPosition = null;
        }
        this.updateGuiStates();
        if (this.model) {
            this.model.update(dt);
        }
        this.cameraTop.update({
            x: this.canvasTop.width,
            y: this.canvasTop.height,
        });
        this.cameraFront.update({
            x: this.canvasFront.width,
            y: this.canvasFront.height,
        });
        this.cameraSide.update({
            x: this.canvasSide.width,
            y: this.canvasSide.height,
        });
        this.camera3d.update();
        debug_1.default.value('camera-top', `(${vec_1.vec2.str(vec_1.vec2.map(this.cameraTop.position, Math.floor))}) x${(0, utils_1.round)(this.cameraTop.scale, 2)}`, {
            showLabel: false,
            align: 'right',
            tags: ['panel-top'],
        });
        debug_1.default.value('camera-front', `(${vec_1.vec2.str(vec_1.vec2.map(this.cameraFront.position, Math.floor))}) x${(0, utils_1.round)(this.cameraFront.scale, 2)}`, {
            showLabel: false,
            align: 'right',
            tags: ['panel-front'],
        });
        debug_1.default.value('camera-side', `(${vec_1.vec2.str(vec_1.vec2.map(this.cameraSide.position, Math.floor))}) x${(0, utils_1.round)(this.cameraSide.scale, 2)}`, {
            showLabel: false,
            align: 'right',
            tags: ['panel-side'],
        });
        debug_1.default.value('camera-3d', `(${vec_1.vec3.str(vec_1.vec3.map(this.camera3d.position, Math.floor))}) > (${vec_1.vec3.str(vec_1.vec3.map(this.camera3d.target, Math.floor))}) yaw=${(0, utils_1.round)(this.camera3dYaw, 2)} pitch=${(0, utils_1.round)(this.camera3dPitch, 2)}`, {
            showLabel: false,
            align: 'right',
            tags: ['panel-3d'],
        });
        this.lastMousePosition = vec_1.vec2.cpy(input_manager_1.default.mousePosition);
        input_manager_1.default.update();
    }
    updateGuiStates() {
        var _a, _b;
        const currentVertices = new Set(this.selectedVertices.map(v => v.id));
        if (!(0, utilities_1.setsEqual)(this.lastGuiState.vertices, currentVertices)) {
            if (ModelEditor.verticesFolder) {
                Object.values(ModelEditor.verticesFolder.__folders).forEach(folder => {
                    folder.domElement.classList.remove('selected');
                });
                this.selectedVertices.forEach(v => {
                    if (v.folder) {
                        v.folder.domElement.classList.add('selected');
                    }
                });
            }
            this.lastGuiState.vertices = currentVertices;
        }
        const currentEdges = new Set(this.selectedEdges.map(e => e.id));
        if (!(0, utilities_1.setsEqual)(this.lastGuiState.edges, currentEdges)) {
            if (ModelEditor.edgesFolder) {
                Object.values(ModelEditor.edgesFolder.__folders).forEach(folder => {
                    folder.domElement.classList.remove('selected');
                });
                this.selectedEdges.forEach(e => {
                    if (e.folder) {
                        e.folder.domElement.classList.add('selected');
                    }
                });
            }
            this.lastGuiState.edges = currentEdges;
        }
        const currentSurfaces = new Set(this.selectedSurfaces.map(s => s.id));
        if (!(0, utilities_1.setsEqual)(this.lastGuiState.surfaces, currentSurfaces)) {
            if (ModelEditor.surfacesFolder) {
                Object.values(ModelEditor.surfacesFolder.__folders).forEach(folder => {
                    folder.domElement.classList.remove('selected');
                });
                this.selectedSurfaces.forEach(s => {
                    if (s.folder) {
                        s.folder.domElement.classList.add('selected');
                    }
                });
            }
            this.lastGuiState.surfaces = currentSurfaces;
        }
        if (this.currentHistoryIndex !== this.lastGuiState.historyIndex) {
            if (ModelEditor.historyFolder) {
                Object.values(ModelEditor.historyFolder.__controllers).forEach(controller => {
                    var _a, _b;
                    (_b = (_a = controller.domElement.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector('span.property-name')) === null || _b === void 0 ? void 0 : _b.classList.remove('selected');
                });
                if (this.history.length > 0 && this.currentHistoryIndex >= 0) {
                    const currentController = ModelEditor.historyFolder.__controllers[this.currentHistoryIndex];
                    if (currentController) {
                        (_b = (_a = currentController.domElement.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector('span.property-name')) === null || _b === void 0 ? void 0 : _b.classList.add('selected');
                    }
                }
            }
            this.lastGuiState.historyIndex = this.currentHistoryIndex;
        }
    }
    selectVertex(vertex, addToSelection = true) {
        if (!addToSelection) {
            this.deselectVertex();
        }
        vertex.selected = true;
        this.selectedVertices.push(vertex);
        this.draggingVertex = null;
        this.dragStartMouse = null;
        this.dragStartVertexPositions = null;
    }
    selectEdge(edge, addToSelection = true) {
        if (!addToSelection) {
            this.deselectEdge();
        }
        edge.selected = true;
        this.selectedEdges.push(edge);
    }
    selectSurface(surface, addToSelection = true) {
        if (!addToSelection) {
            this.deselectSurface();
        }
        surface.selected = true;
        this.selectedSurfaces.push(surface);
    }
    deselectVertex(vertex) {
        if (vertex) {
            vertex.selected = false;
            this.selectedVertices = this.selectedVertices.filter(v => v !== vertex);
        }
        else {
            this.selectedVertices.forEach(v => (v.selected = false));
            this.selectedVertices = [];
        }
    }
    deselectEdge(edge) {
        if (edge) {
            edge.selected = false;
            this.selectedEdges = this.selectedEdges.filter(e => e !== edge);
        }
        else {
            this.selectedEdges.forEach(e => (e.selected = false));
            this.selectedEdges = [];
        }
    }
    deselectSurface(surface) {
        if (surface) {
            surface.selected = false;
            this.selectedSurfaces = this.selectedSurfaces.filter(s => s !== surface);
        }
        else {
            this.selectedSurfaces.forEach(s => (s.selected = false));
            this.selectedSurfaces = [];
        }
    }
    removeVertex(vertex) {
        if (this.model) {
            this.model.removeVertex(vertex);
        }
        this.deselectVertex(vertex);
    }
    removeEdge(edge) {
        if (this.model) {
            this.model.removeEdge(edge);
        }
        this.deselectEdge(edge);
    }
    removeSurface(surface) {
        if (this.model) {
            this.model.removeSurface(surface);
        }
        this.deselectSurface(surface);
    }
    getPanel2dInfo(panelId) {
        switch (panelId) {
            case 'canvas-top':
                return {
                    camera: this.cameraTop,
                    context: this.contextTop,
                    components: 'xz',
                };
            case 'canvas-front':
                return {
                    camera: this.cameraFront,
                    context: this.contextFront,
                    components: 'xY',
                };
            case 'canvas-side':
                return {
                    camera: this.cameraSide,
                    context: this.contextSide,
                    components: 'ZY',
                };
            default:
                return null;
        }
    }
    draw() {
        this.contextTop.clearRect(0, 0, this.canvasTop.width, this.canvasTop.height);
        this.contextFront.clearRect(0, 0, this.canvasFront.width, this.canvasFront.height);
        this.contextSide.clearRect(0, 0, this.canvasSide.width, this.canvasSide.height);
        this.context3d.clearRect(0, 0, this.canvas3d.width, this.canvas3d.height);
        this.contextTop.save();
        this.contextFront.save();
        this.contextSide.save();
        this.context3d.save();
        this.cameraTop.setTransforms(this.contextTop);
        this.cameraFront.setTransforms(this.contextFront);
        this.cameraSide.setTransforms(this.contextSide);
        this.camera3d.aspect = this.canvas3d.width / this.canvas3d.height;
        const panel3dSize = (0, vec_1.vec2)(this.canvas3d.width, this.canvas3d.height);
        if (this.options.showGrid) {
            grid_1.default.draw(this.contextTop, this.cameraTop, this.options.gridSize, this.options.showGridLabels, this.options.gridLabelsGap, 'panel-top');
            grid_1.default.draw(this.contextFront, this.cameraFront, this.options.gridSize, this.options.showGridLabels, this.options.gridLabelsGap, 'panel-front');
            grid_1.default.draw(this.contextSide, this.cameraSide, this.options.gridSize, this.options.showGridLabels, this.options.gridLabelsGap, 'panel-side');
        }
        if (this.options.showGroundPlane) {
            grid3d_1.default.draw(this.context3d, this.camera3d, panel3dSize, this.options.gridSize, this.options.groundPlaneSize, this.options.showGroundPlaneLabels, this.options.groundPlaneLabelsGap);
        }
        if (this.model) {
            this.model.drawTop(this.contextTop, this.options.showVertexLabels);
            this.model.drawFront(this.contextFront, this.options.showVertexLabels);
            this.model.drawSide(this.contextSide, this.options.showVertexLabels);
            this.model.draw3d(this.context3d, this.camera3d, panel3dSize, this.options.showVertexLabels);
        }
        if (this.creatingEdge) {
            this.creatingEdge.draw2d(this.contextTop, 'xz');
            this.creatingEdge.draw2d(this.contextFront, 'xY');
            this.creatingEdge.draw2d(this.contextSide, 'ZY');
            this.creatingEdge.draw3d(this.context3d, this.camera3d, panel3dSize);
        }
        if (this.creatingSurface) {
            this.creatingSurface.draw2d(this.contextTop, 'xz');
            this.creatingSurface.draw2d(this.contextFront, 'xY');
            this.creatingSurface.draw2d(this.contextSide, 'ZY');
            this.creatingSurface.draw3d(this.context3d, this.camera3d, panel3dSize);
        }
        if (this.options.showAxes) {
            axes_1.default.draw(this.context3d, this.camera3d, panel3dSize);
        }
        debug_1.default.draw(this.contextTop, ['panel-top'], false);
        debug_1.default.draw(this.contextFront, ['panel-front'], false);
        debug_1.default.draw(this.contextSide, ['panel-side'], false);
        debug_1.default.draw(this.context3d, ['panel-3d'], false);
        debug_1.default.clear();
        this.contextTop.restore();
        this.contextFront.restore();
        this.contextSide.restore();
        this.context3d.restore();
    }
}
exports["default"] = ModelEditor;
ModelEditor.DEFAULT_CAMERA3D_POSITION = (0, vec_1.vec3)(300, 400, 500);
ModelEditor.DEFAULT_CAMERA3D_TARGET = (0, vec_1.vec3)(0, 0, 0);
ModelEditor.PANEL_MIN_SIZE = 0.2;
ModelEditor.instance = null;
ModelEditor.verticesFolder = null;
ModelEditor.edgesFolder = null;
ModelEditor.surfacesFolder = null;
ModelEditor.historyFolder = null;


/***/ }),

/***/ "./src/model.ts":
/*!**********************!*\
  !*** ./src/model.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const edge_1 = __webpack_require__(/*! ./edge */ "./src/edge.ts");
const surface_1 = __webpack_require__(/*! ./surface */ "./src/surface.ts");
const vertex_1 = __webpack_require__(/*! ./vertex */ "./src/vertex.ts");
class Model extends EventTarget {
    constructor(name = '') {
        super();
        this.name = name;
        this.vertices = [];
        this.edges = [];
        this.surfaces = [];
    }
    destroy() {
        this.vertices.forEach(v => v.destroy());
        this.edges.forEach(e => e.destroy());
        this.surfaces.forEach(s => s.destroy());
        this.vertices = [];
        this.edges = [];
        this.surfaces = [];
    }
    serialize() {
        return {
            name: this.name,
            vertices: this.vertices.map(v => v.serialize()),
            edges: this.edges.map(e => e.serialize()),
            surfaces: this.surfaces.map(s => s.serialize()),
        };
    }
    static deserialize(data) {
        const model = new Model(data.name);
        model.vertices = data.vertices.map((v) => vertex_1.default.deserialize(v));
        const verticesMap = model.vertices.reduce((map, v) => {
            map.set(v.id, v);
            return map;
        }, new Map());
        model.edges = data.edges.map((e) => edge_1.default.deserialize(e, verticesMap));
        model.surfaces = data.surfaces.map((s) => surface_1.default.deserialize(s, verticesMap));
        return model;
    }
    emitChangeEvent(action = '') {
        this.dispatchEvent(new CustomEvent('change', {
            detail: {
                model: this.serialize(),
                action,
            },
        }));
    }
    addVertex(position) {
        const vertex = new vertex_1.default(position, false);
        this.vertices.push(vertex);
        this.emitChangeEvent('Vertex added');
        return vertex;
    }
    removeVertex(vertex) {
        const index = this.vertices.indexOf(vertex);
        if (index !== -1) {
            this.vertices.splice(index, 1);
            vertex.destroy();
            this.edges = this.edges.filter(e => e.a !== vertex && e.b !== vertex);
            this.surfaces = this.surfaces.filter(s => !s.vertices.includes(vertex));
            this.emitChangeEvent('Vertex removed');
        }
    }
    addEdge(a, b) {
        if (!(a instanceof edge_1.default)) {
            a = new edge_1.default(a, b);
        }
        this.edges.push(a);
        this.emitChangeEvent('Edge added');
        return a;
    }
    removeEdge(edge) {
        const index = this.edges.indexOf(edge);
        if (index !== -1) {
            this.edges.splice(index, 1);
            edge.destroy();
            this.emitChangeEvent('Edge removed');
        }
    }
    addSurface(a) {
        if (!(a instanceof surface_1.default)) {
            a = new surface_1.default(a);
        }
        this.surfaces.push(a);
        this.emitChangeEvent('Surface added');
        return a;
    }
    removeSurface(surface) {
        const index = this.surfaces.indexOf(surface);
        if (index !== -1) {
            this.surfaces.splice(index, 1);
            surface.destroy();
            this.emitChangeEvent('Surface removed');
        }
    }
    update(dt) {
        this.vertices.forEach(v => v.update(dt));
        this.edges.forEach(e => e.update(dt));
        this.surfaces.forEach(s => s.update(dt));
    }
    drawTop(context, showVertexLabels = false) {
        this.vertices.forEach(v => v.draw2d(context, 'xz', showVertexLabels));
        this.edges.forEach(e => e.draw2d(context, 'xz'));
        this.surfaces.forEach(s => s.draw2d(context, 'xz'));
    }
    drawFront(context, showVertexLabels = false) {
        this.vertices.forEach(v => v.draw2d(context, 'xY', showVertexLabels));
        this.edges.forEach(e => e.draw2d(context, 'xY'));
        this.surfaces.forEach(s => s.draw2d(context, 'xY'));
    }
    drawSide(context, showVertexLabels = false) {
        this.vertices.forEach(v => v.draw2d(context, 'ZY', showVertexLabels));
        this.edges.forEach(e => e.draw2d(context, 'ZY'));
        this.surfaces.forEach(s => s.draw2d(context, 'ZY'));
    }
    draw3d(context, camera, screen, showVertexLabels = false) {
        this.vertices.forEach(v => v.draw3d(context, camera, screen, showVertexLabels));
        this.edges.forEach(e => e.draw3d(context, camera, screen));
        this.surfaces.forEach(s => s.draw3d(context, camera, screen));
    }
}
exports["default"] = Model;


/***/ }),

/***/ "./src/surface.ts":
/*!************************!*\
  !*** ./src/surface.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const intersection_helpers_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers */ "./node_modules/@basementuniverse/intersection-helpers/build/index.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/cjs-browser/index.js");
const model_editor_1 = __webpack_require__(/*! ./model-editor */ "./src/model-editor.ts");
const utilities_1 = __webpack_require__(/*! ./utilities */ "./src/utilities.ts");
const { pointInPolygon } = intersection_helpers_1.intersection2d;
class Surface {
    constructor(vertices, addFolder = true) {
        this.vertices = vertices;
        this.id = '';
        this.hovered = false;
        this.selected = false;
        this.folder = null;
        this.id = (0, uuid_1.v4)();
        if (model_editor_1.default.surfacesFolder && addFolder) {
            this.folder = model_editor_1.default.surfacesFolder.addFolder(`Surface ${this.id}`);
            this.folder.add({ select: () => { var _a; return (_a = model_editor_1.default.instance) === null || _a === void 0 ? void 0 : _a.selectSurface(this, false); } }, 'select');
            this.folder.add({ delete: () => { var _a; return (_a = model_editor_1.default.instance) === null || _a === void 0 ? void 0 : _a.removeSurface(this); } }, 'delete');
        }
        if (!Surface.hoverPatternCanvas) {
            Surface.hoverPatternCanvas = document.createElement('canvas');
            Surface.hoverPatternCanvas.width = Surface.HOVER_PATTERN_SIZE;
            Surface.hoverPatternCanvas.height = Surface.HOVER_PATTERN_SIZE;
            Surface.hoverPatternContext = Surface.hoverPatternCanvas.getContext('2d');
            if (Surface.hoverPatternContext) {
                const halfHoverPatternSize = Surface.HOVER_PATTERN_SIZE / 2;
                Surface.hoverPatternContext.fillStyle = Surface.HOVER_COLOUR;
                Surface.hoverPatternContext.fillRect(0, 0, halfHoverPatternSize, halfHoverPatternSize);
                Surface.hoverPatternContext.fillRect(halfHoverPatternSize, halfHoverPatternSize, halfHoverPatternSize, halfHoverPatternSize);
            }
        }
    }
    destroy() {
        var _a;
        if (this.folder) {
            (_a = model_editor_1.default.surfacesFolder) === null || _a === void 0 ? void 0 : _a.removeFolder(this.folder);
        }
    }
    serialize() {
        return {
            id: this.id,
            vertices: this.vertices.map(v => v.id),
        };
    }
    static deserialize(data, vertices) {
        const surfaceVertices = data.vertices.map((id) => {
            const vertex = vertices.get(id);
            if (!vertex) {
                throw new Error(`Surface ${data.id} references non-existent vertex ${id}.`);
            }
            return vertex;
        });
        const surface = new Surface(surfaceVertices);
        if (data.id) {
            surface.id = data.id;
        }
        return surface;
    }
    update(dt) { }
    draw2d(context, components) {
        if (this.hovered && !this.selected && Surface.hoverPatternCanvas) {
            context.beginPath();
            (0, canvas_helpers_1.polygon)(context, this.vertices.map(v => (0, utilities_1.v32)(v.position, components)), {
                batch: true,
            });
            context.fillStyle = context.createPattern(Surface.hoverPatternCanvas, 'repeat');
            context.fill();
        }
        else {
            (0, canvas_helpers_1.polygon)(context, this.vertices.map(v => (0, utilities_1.v32)(v.position, components)), {
                stroke: false,
                fill: true,
                fillColor: this.selected ? Surface.SELECT_COLOUR : Surface.COLOUR,
            });
        }
    }
    draw3d(context, camera, screen) {
        const vertices = this.vertices
            .map(v => camera.project(v.position, screen))
            .filter((v) => !!v);
        if (this.hovered && !this.selected && Surface.hoverPatternCanvas) {
            context.beginPath();
            (0, canvas_helpers_1.polygon)(context, vertices, {
                batch: true,
            });
            context.fillStyle = context.createPattern(Surface.hoverPatternCanvas, 'repeat');
            context.fill();
        }
        else {
            (0, canvas_helpers_1.polygon)(context, vertices, {
                stroke: false,
                fill: true,
                fillColor: this.selected ? Surface.SELECT_COLOUR : Surface.COLOUR,
            });
        }
    }
    isPointNear2d(point, components) {
        var _a;
        return (((_a = pointInPolygon(point, {
            vertices: this.vertices.map(v => (0, utilities_1.v32)(v.position, components)),
        })) === null || _a === void 0 ? void 0 : _a.intersects) || false);
    }
    isPointNear3d(point, camera, screen) {
        var _a;
        const projectedVertices = this.vertices
            .map(v => camera.project(v.position, screen))
            .filter((v) => !!v);
        return (((_a = pointInPolygon(point, {
            vertices: projectedVertices,
        })) === null || _a === void 0 ? void 0 : _a.intersects) || false);
    }
}
exports["default"] = Surface;
Surface.COLOUR = '#fff2';
Surface.HOVER_COLOUR = '#fff4';
Surface.HOVER_PATTERN_SIZE = 6;
Surface.SELECT_COLOUR = '#fff6';
Surface.hoverPatternCanvas = null;
Surface.hoverPatternContext = null;


/***/ }),

/***/ "./src/utilities.ts":
/*!**************************!*\
  !*** ./src/utilities.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setsEqual = exports.dot = exports.pointNearLine = exports.v32 = void 0;
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const intersection_helpers_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers */ "./node_modules/@basementuniverse/intersection-helpers/build/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
function v32(v, components) {
    return vec_1.vec2.fromComponents(vec_1.vec3.swiz(v, components));
}
exports.v32 = v32;
function pointNearLine(point, line, range = 5) {
    return intersection_helpers_1.intersection2d.pointOnLine(point, line).distance <= range;
}
exports.pointNearLine = pointNearLine;
function dot(context, position, radius = 5, colour = '#fff') {
    (0, canvas_helpers_1.circle)(context, position, radius, {
        fill: true,
        fillColor: colour,
    });
}
exports.dot = dot;
function setsEqual(a, b) {
    if (a.size !== b.size)
        return false;
    for (const item of a) {
        if (!b.has(item))
            return false;
    }
    return true;
}
exports.setsEqual = setsEqual;


/***/ }),

/***/ "./src/vertex.ts":
/*!***********************!*\
  !*** ./src/vertex.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/cjs-browser/index.js");
const model_editor_1 = __webpack_require__(/*! ./model-editor */ "./src/model-editor.ts");
const utilities_1 = __webpack_require__(/*! ./utilities */ "./src/utilities.ts");
class Vertex {
    constructor(position, hidden = false, addFolder = true) {
        this.position = position;
        this.hidden = hidden;
        this.id = '';
        this.hovered = false;
        this.selected = false;
        this.folder = null;
        this.internalPosition = (0, vec_1.vec3)();
        this.id = (0, uuid_1.v4)();
        if (model_editor_1.default.verticesFolder && addFolder) {
            this.folder = model_editor_1.default.verticesFolder.addFolder(`Vertex ${this.id}`);
            this.folder.add({ select: () => { var _a; return (_a = model_editor_1.default.instance) === null || _a === void 0 ? void 0 : _a.selectVertex(this, false); } }, 'select');
            this.folder.add({ delete: () => { var _a; return (_a = model_editor_1.default.instance) === null || _a === void 0 ? void 0 : _a.removeVertex(this); } }, 'delete');
            this.folder
                .add(this.internalPosition, 'x')
                .onChange(value => {
                this.position.x = value;
            })
                .listen();
            this.folder
                .add(this.internalPosition, 'y')
                .onChange(value => {
                this.position.y = value;
            })
                .listen();
            this.folder
                .add(this.internalPosition, 'z')
                .onChange(value => {
                this.position.z = value;
            })
                .listen();
            this.folder
                .add(this, 'hidden')
                .onChange(value => {
                var _a, _b;
                this.hidden = value;
                (_b = (_a = model_editor_1.default.instance) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.emitChangeEvent('Vertex visibility changed');
            })
                .listen();
        }
    }
    destroy() {
        var _a;
        if (this.folder) {
            (_a = model_editor_1.default.verticesFolder) === null || _a === void 0 ? void 0 : _a.removeFolder(this.folder);
        }
    }
    serialize() {
        return {
            id: this.id,
            position: vec_1.vec3.components(this.position),
            hidden: this.hidden,
        };
    }
    static deserialize(data) {
        const vertex = new Vertex(vec_1.vec3.fromComponents(data.position), !!data.hidden);
        if (data.id) {
            vertex.id = data.id;
        }
        return vertex;
    }
    update(dt) {
        if (!vec_1.vec3.eq(this.internalPosition, this.position)) {
            this.internalPosition.x = this.position.x;
            this.internalPosition.y = this.position.y;
            this.internalPosition.z = this.position.z;
        }
    }
    draw2d(context, components, showVertexLabels = false) {
        const p2 = (0, utilities_1.v32)(this.position, components);
        (0, utilities_1.dot)(context, p2, Vertex.RADIUS, this.hidden ? Vertex.HIDDEN_COLOUR : Vertex.COLOUR);
        if (showVertexLabels) {
            const tags = { xz: 'panel-top', xY: 'panel-front', ZY: 'panel-side' };
            debug_1.default.marker(`${this.id}-${components}`, this.hovered || this.selected
                ? `${this.id}\n${vec_1.vec3.str(vec_1.vec3.map(this.position, v => (0, utils_1.round)(v, 2)))}`
                : this.id.substring(0, 5), p2, {
                tags: [tags[components]],
                ...Vertex.MARKER_OPTIONS,
                foregroundColour: this.hidden ? Vertex.HIDDEN_COLOUR : Vertex.COLOUR,
            });
        }
        if (this.hovered || this.selected) {
            (0, canvas_helpers_1.circle)(context, p2, Vertex.HOVER_RADIUS, {
                strokeColor: Vertex.COLOUR,
                lineWidth: Vertex.HOVER_LINE_WIDTH,
                lineStyle: this.selected ? 'solid' : 'dashed',
            });
        }
    }
    draw3d(context, camera, screen, showVertexLabels = false) {
        const projected = camera.project(this.position, screen);
        if (!projected) {
            return;
        }
        (0, utilities_1.dot)(context, projected, Vertex.RADIUS, this.hidden ? Vertex.HIDDEN_COLOUR : Vertex.COLOUR);
        if (showVertexLabels) {
            debug_1.default.marker(`${this.id}-3d`, this.hovered || this.selected
                ? `${this.id}\n${vec_1.vec3.str(vec_1.vec3.map(this.position, v => (0, utils_1.round)(v, 2)))}`
                : this.id.substring(0, 5), projected, {
                tags: ['panel-3d'],
                ...Vertex.MARKER_OPTIONS,
                foregroundColour: this.hidden ? Vertex.HIDDEN_COLOUR : Vertex.COLOUR,
            });
        }
        if (this.hovered || this.selected) {
            (0, canvas_helpers_1.circle)(context, projected, Vertex.HOVER_RADIUS, {
                strokeColor: Vertex.COLOUR,
                lineWidth: Vertex.HOVER_LINE_WIDTH,
                lineStyle: this.selected ? 'solid' : 'dashed',
            });
        }
    }
    isPointNear2d(point, components, radius = Vertex.HOVER_RADIUS) {
        return vec_1.vec2.len(vec_1.vec2.sub(point, (0, utilities_1.v32)(this.position, components))) <= radius;
    }
    isPointNear3d(point, camera, screen, radius = Vertex.HOVER_RADIUS) {
        const projected = camera.project(this.position, screen);
        if (!projected) {
            return false;
        }
        return vec_1.vec2.len(vec_1.vec2.sub(point, projected)) <= radius;
    }
}
exports["default"] = Vertex;
Vertex.COLOUR = '#fff';
Vertex.HIDDEN_COLOUR = '#fff6';
Vertex.RADIUS = 3;
Vertex.HOVER_RADIUS = 10;
Vertex.HOVER_LINE_WIDTH = 2;
Vertex.MARKER_OPTIONS = {
    showMarker: false,
    showLabel: false,
    backgroundColour: '#fff2',
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const model_editor_1 = __webpack_require__(/*! ./model-editor */ "./src/model-editor.ts");
window.onload = () => {
    window.editor = new model_editor_1.default();
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztB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QUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixnQkFBZ0Isb0RBQW9EO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaURBQWlEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpREFBaUQsSUFBSSxpREFBaUQ7QUFDOUosd0RB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Q0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBK0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBK0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkYsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25C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R0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0tBQW9LLGdDQUFnQztBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0ZBQWdGLHVFQUF1RTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFD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Ozs7O0FDTkEsMEZBQXlDO0FBRXpDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFO0lBQ2xCLE1BQWMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxzQkFBVyxFQUFFLENBQUM7QUFDN0MsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYS0zZC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycy9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvZGVidWcvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXIvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL2ludGVyc2VjdGlvbi1oZWxwZXJzL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvZGF0Lmd1aS9idWlsZC9kYXQuZ3VpLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL2luZGV4LmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvbWF4LmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvbWQ1LmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvbmF0aXZlLmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvbmlsLmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9janMtYnJvd3Nlci9yZWdleC5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3JuZy5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3NoYTEuanMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9janMtYnJvd3Nlci9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9janMtYnJvd3Nlci92MS5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3YxVG9WNi5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3YzLmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvdjM1LmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvdjQuanMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9janMtYnJvd3Nlci92NS5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3Y2LmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvdjZUb1YxLmpzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvdjcuanMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9janMtYnJvd3Nlci92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vc3JjL2F4ZXMudHMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vc3JjL2VkZ2UudHMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vc3JjL2dyaWQudHMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vc3JjL2dyaWQzZC50cyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9zcmMvbW9kZWwtZWRpdG9yLnRzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL3NyYy9tb2RlbC50cyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9zcmMvc3VyZmFjZS50cyIsIndlYnBhY2s6Ly9tb2RlbC1lZGl0b3IvLi9zcmMvdXRpbGl0aWVzLnRzIiwid2VicGFjazovL21vZGVsLWVkaXRvci8uL3NyYy92ZXJ0ZXgudHMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL21vZGVsLWVkaXRvci93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbW9kZWwtZWRpdG9yLy4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQ2FtZXJhM2RcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQ2FtZXJhM2RcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBzbWFsbCB2ZWN0b3IgYW5kIG1hdHJpeCBsaWJyYXJ5XFxuICogQGF1dGhvciBHb3Jkb24gTGFycmlnYW5cXG4gKi9cXG5cXG5jb25zdCBfdmVjX3RpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5jb25zdCBfdmVjX2NodW5rID0gKGEsIG4pID0+IF92ZWNfdGltZXMoaSA9PiBhLnNsaWNlKGkgKiBuLCBpICogbiArIG4pLCBNYXRoLmNlaWwoYS5sZW5ndGggLyBuKSk7XFxuY29uc3QgX3ZlY19kb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuY29uc3QgX3ZlY19pc192ZWMyID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGE7XFxuY29uc3QgX3ZlY19pc192ZWMzID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGEgJiYgJ3onIGluIGE7XFxuXFxuLyoqXFxuICogQSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMyXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyAyZCB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMyfSBbeF0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIGEgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gQSBuZXcgMmQgdmVjdG9yXFxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMyKDMsIDIpOyAvLyAoMywgMilcXG4gKiBsZXQgYiA9IHZlYzIoNCk7ICAgIC8vICg0LCA0KVxcbiAqIGxldCBjID0gdmVjMihhKTsgICAgLy8gKDMsIDIpXFxuICogbGV0IGQgPSB2ZWMyKCk7ICAgICAvLyAoMCwgMClcXG4gKi9cXG5jb25zdCB2ZWMyID0gKHgsIHkpID0+IHtcXG4gIGlmICgheCAmJiAheSkge1xcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMyKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9O1xcbiAgfVxcbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4IH07XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjMi5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnldO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbXBvbmVudHMgVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IHZlY3RvclxcbiAqL1xcbnZlYzIuZnJvbUNvbXBvbmVudHMgPSBjb21wb25lbnRzID0+IHZlYzIoLi4uY29tcG9uZW50cy5zbGljZSgwLCAyKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMSwgMClcXG4gKi9cXG52ZWMyLnV4ID0gKCkgPT4gdmVjMigxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqL1xcbnZlYzIudXkgPSAoKSA9PiB2ZWMyKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICsgYlxcbiAqL1xcbnZlYzIuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIChiLnggPz8gYiksIHk6IGEueSArIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAtIGJcXG4gKi9cXG52ZWMyLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxcbiAqL1xcbnZlYzIubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMyLm11bFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAqIGJcXG4gKi9cXG52ZWMyLnNjYWxlID0gKGEsIGIpID0+IHZlYzIubXVsKGEsIGIpO1xcblxcbi8qKlxcbiAqIERpdmlkZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAvIGJcXG4gKi9cXG52ZWMyLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMyLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMi5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge3ZlYzJ9IF5hXFxuICovXFxudmVjMi5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMyLmxlbihhKTtcXG4gIHJldHVybiBsZW4gPyB7IHg6IGEueCAvIGxlbiwgeTogYS55IC8gbGVuIH0gOiB2ZWMyKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxudmVjMi5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzIucm90ID0gKGEsIHIpID0+IHtcXG4gIGxldCBzID0gTWF0aC5zaW4ociksXFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcXG4gIHJldHVybiB7IHg6IGMgKiBhLnggLSBzICogYS55LCB5OiBzICogYS54ICsgYyAqIGEueSB9O1xcbn07XFxuXFxuLyoqXFxuICogRmFzdCBtZXRob2QgdG8gcm90YXRlIGEgdmVjdG9yIGJ5IC05MCwgOTAgb3IgMTgwIGRlZ3JlZXNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciAxIGZvciA5MCBkZWdyZWVzIChjdyksIC0xIGZvciAtOTAgZGVncmVlcyAoY2N3KSwgMiBvciAtMiBmb3IgMTgwIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMi5yb3RmID0gKGEsIHIpID0+IHtcXG4gIHN3aXRjaCAocikge1xcbiAgICBjYXNlIDE6IHJldHVybiB2ZWMyKGEueSwgLWEueCk7XFxuICAgIGNhc2UgLTE6IHJldHVybiB2ZWMyKC1hLnksIGEueCk7XFxuICAgIGNhc2UgMjogY2FzZSAtMjogcmV0dXJuIHZlYzIoLWEueCwgLWEueSk7XFxuICAgIGRlZmF1bHQ6IHJldHVybiBhO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogU2NhbGFyIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEgw5cgYlxcbiAqL1xcbnZlYzIuY3Jvc3MgPSAoYSwgYikgPT4ge1xcbiAgcmV0dXJuIGEueCAqIGIueSAtIGEueSAqIGIueDtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjMi5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzIucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYzIuY3B5ID0gYSA9PiB2ZWMyKGEpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDJkIHZlY3RvclxcbiAqIEBjYWxsYmFjayB2ZWMyTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYzIubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMi5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcXG5cXG4vKipcXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xcbiAqXFxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcXG4gKiAtIGB4YCBvciBgeWBcXG4gKiAtIGB1YCBvciBgdmAgKGFsaWFzZXMgZm9yIGB4YCBhbmQgYHlgLCByZXNwZWN0aXZlbHkpXFxuICogLSBgWGAsIGBZYCwgYFVgLCBgVmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXFxuICogLSBgLmAgdG8gcmV0dXJuIHRoZSBjb21wb25lbnQgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBhdCB0aGlzIHBvc2l0aW9uIChvciAwKVxcbiAqXFxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBzd2l6emxlXFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLiddIFRoZSBzd2l6emxlIHN0cmluZ1xcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXFxuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMigzLCAtMik7XFxuICogdmVjMi5zd2l6KGEsICd4Jyk7ICAgIC8vIFszXVxcbiAqIHZlYzIuc3dpeihhLCAneXgnKTsgICAvLyBbLTIsIDNdXFxuICogdmVjMi5zd2l6KGEsICd4WScpOyAgIC8vIFszLCAyXVxcbiAqIHZlYzIuc3dpeihhLCAnWXknKTsgICAvLyBbMiwgLTJdXFxuICogdmVjMi5zd2l6KGEsICd4LngnKTsgIC8vIFszLCAtMiwgM11cXG4gKiB2ZWMyLnN3aXooYSwgJ3kwMXgnKTsgLy8gWy0yLCAwLCAxLCAzXVxcbiAqL1xcbnZlYzIuc3dpeiA9IChhLCBzID0gJy4uJykgPT4ge1xcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XFxuICAgIHN3aXRjaCAoYykge1xcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiByZXN1bHQucHVzaChhLnkpOyBicmVhaztcXG4gICAgICBjYXNlICdYJzogY2FzZSAnVSc6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcXG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcXG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzEnOiByZXN1bHQucHVzaCgxKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueV1baV0gPz8gMCk7IGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzMmRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHJldHVybiB7cG9sYXJDb29yZGluYXRlczJkfSBUaGUgbWFnbml0dWRlIGFuZCBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMi5wb2xhciA9IGEgPT4gKHsgcjogdmVjMi5sZW4oYSksIHRoZXRhOiBNYXRoLmF0YW4yKGEueSwgYS54KSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBhbmdsZSBhbmQgbWFnbml0dWRlXFxuICovXFxudmVjMi5mcm9tUG9sYXIgPSAociwgdGhldGEpID0+IHZlYzIociAqIE1hdGguY29zKHRoZXRhKSwgciAqIE1hdGguc2luKHRoZXRhKSk7XFxuXFxuLyoqXFxuICogQSAzZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMzXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IDNkIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzN8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgdGhlIHogY29tcG9uZW50IGlmIHggaXMgYSB2ZWMyXFxuICogQHBhcmFtIHtudW1iZXJ9IFt6XSBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IDNkIHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMygzLCAyLCAxKTsgICAgICAgLy8gKDMsIDIsIDEpXFxuICogbGV0IGIgPSB2ZWMzKDQsIDUpOyAgICAgICAgICAvLyAoNCwgNSwgMClcXG4gKiBsZXQgYyA9IHZlYzMoNik7ICAgICAgICAgICAgIC8vICg2LCA2LCA2KVxcbiAqIGxldCBkID0gdmVjMyhhKTsgICAgICAgICAgICAgLy8gKDMsIDIsIDEpXFxuICogbGV0IGUgPSB2ZWMzKCk7ICAgICAgICAgICAgICAvLyAoMCwgMCwgMClcXG4gKiBsZXQgZiA9IHZlYzModmVjMigxLCAyKSwgMyk7IC8vICgxLCAyLCAzKVxcbiAqIGxldCBnID0gdmVjMyh2ZWMyKDQsIDUpKTsgICAgLy8gKDQsIDUsIDApXFxuICovXFxuY29uc3QgdmVjMyA9ICh4LCB5LCB6KSA9PiB7XFxuICBpZiAoIXggJiYgIXkgJiYgIXopIHtcXG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgejogMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMyh4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHgueiB8fCAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMyKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCwgejogeSB8fCAwIH07XFxuICB9XFxuICByZXR1cm4geyB4OiB4LCB5OiB5ID8/IHgsIHo6IHogPz8geCB9O1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxcbiAqL1xcbnZlYzMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55LCBhLnpdO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbXBvbmVudHMgVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IHZlY3RvclxcbiAqL1xcbnZlYzMuZnJvbUNvbXBvbmVudHMgPSBjb21wb25lbnRzID0+IHZlYzMoLi4uY29tcG9uZW50cy5zbGljZSgwLCAzKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDAsIDApXFxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMSwgMCwgMClcXG4gKi9cXG52ZWMzLnV4ID0gKCkgPT4gdmVjMygxLCAwLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSwgMClcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxcbiAqL1xcbnZlYzMudXkgPSAoKSA9PiB2ZWMzKDAsIDEsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAwLCAxKVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXFxuICovXFxudmVjMy51eiA9ICgpID0+IHZlYzMoMCwgMCwgMSk7XFxuXFxuLyoqXFxuICogQWRkIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKyBiXFxuICovXFxudmVjMy5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSwgejogYS56ICsgKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC0gYlxcbiAqL1xcbnZlYzMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIChiLnggPz8gYiksIHk6IGEueSAtIChiLnkgPz8gYiksIHo6IGEueiAtIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXFxuICovXFxudmVjMy5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogKGIueCA/PyBiKSwgeTogYS55ICogKGIueSA/PyBiKSwgejogYS56ICogKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvciBieSBhIHNjYWxhciwgYWxpYXMgZm9yIHZlYzMubXVsXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICogYlxcbiAqL1xcbnZlYzMuc2NhbGUgPSAoYSwgYikgPT4gdmVjMy5tdWwoYSwgYik7XFxuXFxuLyoqXFxuICogRGl2aWRlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC8gYlxcbiAqL1xcbnZlYzMuZGl2ID0gKGEsIGIpID0+ICh7IHg6IGEueCAvIChiLnggPz8gYiksIHk6IGEueSAvIChiLnkgPz8gYiksIHo6IGEueiAvIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55ICsgYS56ICogYS56KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMzLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSkgKyBNYXRoLmFicyhhLnopO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge3ZlYzN9IF5hXFxuICovXFxudmVjMy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMzLmxlbihhKTtcXG4gIHJldHVybiBsZW4gPyB7IHg6IGEueCAvIGxlbiwgeTogYS55IC8gbGVuLCB6OiBhLnogLyBsZW4gfSA6IHZlYzMoKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMzLmRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnkgKyBhLnogKiBiLno7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIGEgcm90YXRpb24gbWF0cml4XFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHttYXR9IG0gVGhlIHJvdGF0aW9uIG1hdHJpeFxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdCA9IChhLCBtKSA9PiB2ZWMzKFxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDEpKSwgYSksXFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMikpLCBhKSxcXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAzKSksIGEpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeCBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHggPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCxcXG4gIGEueSAqIE1hdGguY29zKHIpIC0gYS56ICogTWF0aC5zaW4ociksXFxuICBhLnkgKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeSBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHkgPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCAqIE1hdGguY29zKHIpICsgYS56ICogTWF0aC5zaW4ociksXFxuICBhLnksXFxuICAtYS54ICogTWF0aC5zaW4ocikgKyBhLnogKiBNYXRoLmNvcyhyKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHogYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R6ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLnggKiBNYXRoLmNvcyhyKSAtIGEueSAqIE1hdGguc2luKHIpLFxcbiAgYS54ICogTWF0aC5zaW4ocikgKyBhLnkgKiBNYXRoLmNvcyhyKSxcXG4gIGEuelxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIGEgcXVhdGVybmlvblxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcSBUaGUgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3RxID0gKHYsIHEpID0+IHtcXG4gIGlmIChxLmxlbmd0aCAhPT0gNCkge1xcbiAgICByZXR1cm4gdmVjMygpO1xcbiAgfVxcblxcbiAgY29uc3QgZCA9IE1hdGguc3FydChxWzBdICogcVswXSArIHFbMV0gKiBxWzFdICsgcVsyXSAqIHFbMl0gKyBxWzNdICogcVszXSk7XFxuICBpZiAoZCA9PT0gMCkge1xcbiAgICByZXR1cm4gdmVjMygpO1xcbiAgfVxcblxcbiAgY29uc3QgdXEgPSBbcVswXSAvIGQsIHFbMV0gLyBkLCBxWzJdIC8gZCwgcVszXSAvIGRdO1xcbiAgY29uc3QgdSA9IHZlYzMoLi4udXEuc2xpY2UoMCwgMykpO1xcbiAgY29uc3QgcyA9IHVxWzNdO1xcbiAgcmV0dXJuIHZlYzMuYWRkKFxcbiAgICB2ZWMzLmFkZChcXG4gICAgICB2ZWMzLm11bCh1LCAyICogdmVjMy5kb3QodSwgdikpLFxcbiAgICAgIHZlYzMubXVsKHYsIHMgKiBzIC0gdmVjMy5kb3QodSwgdSkpXFxuICAgICksXFxuICAgIHZlYzMubXVsKHZlYzMuY3Jvc3ModSwgdiksIDIgKiBzKVxcbiAgKTtcXG59O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBFdWxlciBhbmdsZXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge3ZlYzN9IGUgVGhlIEV1bGVyIGFuZ2xlcyB0byByb3RhdGUgYnlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3RhID0gKGEsIGUpID0+IHZlYzMucm90eih2ZWMzLnJvdHkodmVjMy5yb3R4KGEsIGUueCksIGUueSksIGUueik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjcm9zcyBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIMOXIGJcXG4gKi9cXG52ZWMzLmNyb3NzID0gKGEsIGIpID0+IHZlYzMoXFxuICBhLnkgKiBiLnogLSBhLnogKiBiLnksXFxuICBhLnogKiBiLnggLSBhLnggKiBiLnosXFxuICBhLnggKiBiLnkgLSBhLnkgKiBiLnhcXG4pO1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjMy5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLnogPT09IGIuejtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHggYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMzLnJhZHggPSBhID0+IE1hdGguYXRhbjIoYS56LCBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeSBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzMucmFkeSA9IGEgPT4gTWF0aC5hdGFuMihhLngsIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB6IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMy5yYWR6ID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS56KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYzMuY3B5ID0gYSA9PiB2ZWMzKGEpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDNkIHZlY3RvclxcbiAqIEBjYWxsYmFjayB2ZWMzTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knIHwgJ3onfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4LCB5IG9yIHopXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzNNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYzMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSwgejogZihhLnosICd6JykgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fSR7c30ke2Euen1gO1xcblxcbi8qKlxcbiAqIFN3aXp6bGUgYSB2ZWN0b3Igd2l0aCBhIHN0cmluZyBvZiBjb21wb25lbnQgbGFiZWxzXFxuICpcXG4gKiBUaGUgc3RyaW5nIGNhbiBjb250YWluOlxcbiAqIC0gYHhgLCBgeWAgb3IgYHpgXFxuICogLSBgdWAsIGB2YCBvciBgd2AgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcXG4gKiAtIGByYCwgYGdgIG9yIGBiYCAoYWxpYXNlcyBmb3IgYHhgLCBgeWAgYW5kIGB6YCwgcmVzcGVjdGl2ZWx5KVxcbiAqIC0gYFhgLCBgWWAsIGBaYCwgYFVgLCBgVmAsIGBXYCwgYFJgLCBgR2AsIGBCYCAobmVnYXRlZCB2ZXJzaW9ucyBvZiB0aGUgYWJvdmUpXFxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXFxuICpcXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9Jy4uLiddIFRoZSBzd2l6emxlIHN0cmluZ1xcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXFxuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMygzLCAtMiwgMSk7XFxuICogdmVjMy5zd2l6KGEsICd4Jyk7ICAgICAvLyBbM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3p5eCcpOyAgIC8vIFsxLCAtMiwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3hZWicpOyAgIC8vIFszLCAyLCAtMV1cXG4gKiB2ZWMzLnN3aXooYSwgJ1p6eCcpOyAgIC8vIFstMSwgMSwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3gueCcpOyAgIC8vIFszLCAtMiwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3kwMXp4Jyk7IC8vIFstMiwgMCwgMSwgMSwgM11cXG4gKi9cXG52ZWMzLnN3aXogPSAoYSwgcyA9ICcuLi4nKSA9PiB7XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcXG4gICAgc3dpdGNoIChjKSB7XFxuICAgICAgY2FzZSAneCc6IGNhc2UgJ3UnOiBjYXNlICdyJzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiBjYXNlICdnJzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneic6IGNhc2UgJ3cnOiBjYXNlICdiJzogcmVzdWx0LnB1c2goYS56KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiBjYXNlICdSJzogcmVzdWx0LnB1c2goLWEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1knOiBjYXNlICdWJzogY2FzZSAnRyc6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcXG4gICAgICBjYXNlICdaJzogY2FzZSAnVyc6IGNhc2UgJ0InOiByZXN1bHQucHVzaCgtYS56KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMCc6IHJlc3VsdC5wdXNoKDApOyBicmVhaztcXG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnksIGEuel1baV0gPz8gMCk7IGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAzZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzM2RcXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIHRpbHQgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIHBvbGFyIGNvb3JkaW5hdGVzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMzZH0gVGhlIG1hZ25pdHVkZSwgdGlsdCBhbmQgcGFuIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMzLnBvbGFyID0gYSA9PiB7XFxuICBsZXQgciA9IHZlYzMubGVuKGEpLFxcbiAgICB0aGV0YSA9IE1hdGguYWNvcyhhLnkgLyByKSxcXG4gICAgcGhpID0gTWF0aC5hdGFuMihhLnosIGEueCk7XFxuICByZXR1cm4geyByLCB0aGV0YSwgcGhpIH07XFxufTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIHRpbHQgb2YgdGhlIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxcbiAqL1xcbnZlYzMuZnJvbVBvbGFyID0gKHIsIHRoZXRhLCBwaGkpID0+IHtcXG4gIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xcbiAgcmV0dXJuIHZlYzMoXFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguY29zKHBoaSksXFxuICAgIHIgKiBNYXRoLmNvcyh0aGV0YSksXFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguc2luKHBoaSlcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBBIG1hdHJpeFxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1hdFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIG1hdHJpeCB2YWx1ZXNcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgbWF0cml4XFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj00XSBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbnRyaWVzPVtdXSBNYXRyaXggdmFsdWVzIGluIHJlYWRpbmcgb3JkZXJcXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxcbiAqL1xcbmNvbnN0IG1hdCA9IChtID0gNCwgbiA9IDQsIGVudHJpZXMgPSBbXSkgPT4gKHtcXG4gIG0sIG4sXFxuICBlbnRyaWVzOiBlbnRyaWVzLmNvbmNhdChBcnJheShtICogbikuZmlsbCgwKSkuc2xpY2UoMCwgbSAqIG4pXFxufSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGlkZW50aXR5IG1hdHJpeCBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBBbiBpZGVudGl0eSBtYXRyaXhcXG4gKi9cXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgYXQgcG9zaXRpb24gKGksIGopIGluIG1hdHJpeCBhXFxuICovXFxubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xcblxcbi8qKlxcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB2YWx1ZSB0byBzZXQgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XFxuXFxuLyoqXFxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtIFRoZSByb3cgb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5yb3cgPSAoYSwgbSkgPT4ge1xcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XFxuICByZXR1cm4gYS5lbnRyaWVzLnNsaWNlKHMsIHMgKyBhLm4pO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgY29sdW1uIGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQ29sdW1uIG4gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5jb2wgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IG1hdC5nZXQoYSwgKGkgKyAxKSwgbiksIGEubSk7XFxuXFxuLyoqXFxuICogQWRkIG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSArIGJcXG4gKi9cXG5tYXQuYWRkID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgKyBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSAtIGJcXG4gKi9cXG5tYXQuc3ViID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgLSBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIE11bHRpcGx5IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpY2VzIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bCA9IChhLCBiKSA9PiB7XFxuICBpZiAoYS5uICE9PSBiLm0pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYi5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgbWF0LmNvbChiLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgYSBtYXRyaXggYnkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7dmVjMnx2ZWMzfG51bWJlcltdfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjMnx2ZWMzfG51bWJlcltdfGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGFuZCB2ZWN0b3IgY2Fubm90IGJlIG11bHRpcGxpZWRcXG4gKi9cXG5tYXQubXVsdiA9IChhLCBiKSA9PiB7XFxuICBsZXQgbiwgYmIsIHJ0O1xcbiAgaWYgKF92ZWNfaXNfdmVjMyhiKSkge1xcbiAgICBiYiA9IHZlYzMuY29tcG9uZW50cyhiKTtcXG4gICAgbiA9IDM7XFxuICAgIHJ0ID0gdmVjMy5mcm9tQ29tcG9uZW50cztcXG4gIH0gZWxzZSBpZiAoX3ZlY19pc192ZWMyKGIpKSB7XFxuICAgIGJiID0gdmVjMi5jb21wb25lbnRzKGIpO1xcbiAgICBuID0gMjtcXG4gICAgcnQgPSB2ZWMyLmZyb21Db21wb25lbnRzO1xcbiAgfSBlbHNlIHtcXG4gICAgYmIgPSBiO1xcbiAgICBuID0gYi5sZW5ndGggPz8gMDtcXG4gICAgcnQgPSB2ID0+IHY7XFxuICB9XFxuICBpZiAoYS5uICE9PSBuKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICByZXN1bHQucHVzaChfdmVjX2RvdChtYXQucm93KGEsIGkpLCBiYikpO1xcbiAgfVxcbiAgcmV0dXJuIHJ0KHJlc3VsdCk7XFxufVxcblxcbi8qKlxcbiAqIFNjYWxlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcXG4gKi9cXG5tYXQuc2NhbGUgPSAoYSwgYikgPT4gbWF0Lm1hcChhLCB2ID0+IHYgKiBiKTtcXG5cXG4vKipcXG4gKiBUcmFuc3Bvc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxcbiAqIEByZXR1cm4ge21hdH0gQSB0cmFuc3Bvc2VkIG1hdHJpeFxcbiAqL1xcbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCBfdmVjX3RpbWVzKGkgPT4gbWF0LmNvbChhLCAoaSArIDEpKSwgYS5uKS5mbGF0KCkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbWlub3Igb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IFRoZSAoaSwgaikgbWlub3Igb2YgbWF0cml4IGEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcXG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XFxuICAgIGlmIChpaSA9PT0gaSkgeyBjb250aW51ZTsgfVxcbiAgICBmb3IgKGxldCBqaiA9IDE7IGpqIDw9IGEubjsgamorKykge1xcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxcbiAgICAgIGVudHJpZXMucHVzaChtYXQuZ2V0KGEsIGlpLCBqaikpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbWF0KGEubSAtIDEsIGEubiAtIDEsIGVudHJpZXMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHJldHVybiB7bnVtYmVyfGZhbHNlfSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBeYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQubm9yID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIHJldHVybiBtYXQubWFwKGEsIGkgPT4gaSAqIGQpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggZnJvbSB3aGljaCB0byBnZXQgdGhlIGFkanVnYXRlXFxuICogQHJldHVybiB7bWF0fSBUaGUgYWRqdWdhdGUgb2YgYVxcbiAqL1xcbm1hdC5hZGogPSBhID0+IHtcXG4gIGNvbnN0IG1pbm9ycyA9IG1hdChhLm0sIGEubik7XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICAgIG1hdC5zZXQobWlub3JzLCBpLCBqLCBtYXQuZGV0KG1hdC5taW5vcihhLCBpLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICBjb25zdCBjb2ZhY3RvcnMgPSBtYXQubWFwKG1pbm9ycywgKHYsIGkpID0+IHYgKiAoaSAlIDIgPyAtMSA6IDEpKTtcXG4gIHJldHVybiBtYXQudHJhbnMoY29mYWN0b3JzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgaW52ZXJzZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gaW52ZXJ0XFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhXi0xIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaGFzIG5vIGludmVyc2VcXG4gKi9cXG5tYXQuaW52ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgcmV0dXJuIG1hdC5zY2FsZShtYXQuYWRqKGEpLCAxIC8gZCk7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gbWF0cmljZXMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWF0cmljZXMgYSBhbmQgYiBhcmUgaWRlbnRpY2FsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG5tYXQuZXEgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0LnN0cihhKSA9PT0gbWF0LnN0cihiKTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb3B5XFxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcXG4gKi9cXG5tYXQuY3B5ID0gYSA9PiBtYXQoYS5tLCBhLm4sIFsuLi5hLmVudHJpZXNdKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZW50cnkgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGVudHJ5IGluZGV4XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBlbnRyeVxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4IGFuZCBidWlsZCBhIG5ldyBtYXRyaXggZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXRyaXhNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IE1hdHJpeCBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG5tYXQubWFwID0gKGEsIGYpID0+IG1hdChhLm0sIGEubiwgYS5lbnRyaWVzLm1hcChmKSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIG1hdHJpeCBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbnM9J1xcXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcXG4gKi9cXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxcXG4nKSA9PiBfdmVjX2NodW5rKGEuZW50cmllcywgYS5uKS5tYXAociA9PiByLmpvaW4obXMpKS5qb2luKG5zKTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IHZlYzIsIHZlYzMsIG1hdCB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9DYW1lcmEzZC8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmNvbnN0IHZlY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdmVjICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXFxcIik7XFxuY2xhc3MgQ2FtZXJhM2Qge1xcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbiwgdGFyZ2V0LCBvcHRpb25zID0ge30pIHtcXG4gICAgICAgIGNvbnN0IGFjdHVhbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBDYW1lcmEzZC5ERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xcbiAgICAgICAgdGhpcy5tb2RlID0gYWN0dWFsT3B0aW9ucy5tb2RlO1xcbiAgICAgICAgdGhpcy51cCA9IHZlY18xLnZlYzMubm9yKGFjdHVhbE9wdGlvbnMudXApO1xcbiAgICAgICAgdGhpcy5mb3YgPSBhY3R1YWxPcHRpb25zLmZvdjtcXG4gICAgICAgIHRoaXMuYXNwZWN0ID0gYWN0dWFsT3B0aW9ucy5hc3BlY3Q7XFxuICAgICAgICB0aGlzLm5lYXIgPSBhY3R1YWxPcHRpb25zLm5lYXI7XFxuICAgICAgICB0aGlzLmZhciA9IGFjdHVhbE9wdGlvbnMuZmFyO1xcbiAgICAgICAgdGhpcy5wb3NpdGlvbkVhc2VBbW91bnQgPSBhY3R1YWxPcHRpb25zLnBvc2l0aW9uRWFzZUFtb3VudDtcXG4gICAgICAgIHRoaXMudGFyZ2V0RWFzZUFtb3VudCA9IGFjdHVhbE9wdGlvbnMudGFyZ2V0RWFzZUFtb3VudDtcXG4gICAgICAgIHRoaXMuX2FjdHVhbFBvc2l0aW9uID0gcG9zaXRpb247XFxuICAgICAgICB0aGlzLl90YXJnZXRQb3NpdGlvbiA9IHBvc2l0aW9uO1xcbiAgICAgICAgdGhpcy5fYWN0dWFsVGFyZ2V0ID0gdGFyZ2V0O1xcbiAgICAgICAgdGhpcy5fdGFyZ2V0VGFyZ2V0ID0gdGFyZ2V0O1xcbiAgICB9XFxuICAgIGdldCBwb3NpdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRQb3NpdGlvbjtcXG4gICAgfVxcbiAgICBzZXQgcG9zaXRpb24odmFsdWUpIHtcXG4gICAgICAgIHRoaXMuX3RhcmdldFBvc2l0aW9uID0gdmFsdWU7XFxuICAgIH1cXG4gICAgc2V0IHBvc2l0aW9uSW1tZWRpYXRlKHZhbHVlKSB7XFxuICAgICAgICB0aGlzLl9hY3R1YWxQb3NpdGlvbiA9IHZhbHVlO1xcbiAgICAgICAgdGhpcy5fdGFyZ2V0UG9zaXRpb24gPSB2YWx1ZTtcXG4gICAgfVxcbiAgICBnZXQgYWN0dWFsUG9zaXRpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsUG9zaXRpb247XFxuICAgIH1cXG4gICAgZ2V0IHRhcmdldCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRUYXJnZXQ7XFxuICAgIH1cXG4gICAgc2V0IHRhcmdldCh2YWx1ZSkge1xcbiAgICAgICAgdGhpcy5fdGFyZ2V0VGFyZ2V0ID0gdmFsdWU7XFxuICAgIH1cXG4gICAgc2V0IHRhcmdldEltbWVkaWF0ZSh2YWx1ZSkge1xcbiAgICAgICAgdGhpcy5fYWN0dWFsVGFyZ2V0ID0gdmFsdWU7XFxuICAgICAgICB0aGlzLl90YXJnZXRUYXJnZXQgPSB2YWx1ZTtcXG4gICAgfVxcbiAgICBnZXQgYWN0dWFsVGFyZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdHVhbFRhcmdldDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVXBkYXRlIHRoZSBjYW1lcmFcXG4gICAgICovXFxuICAgIHVwZGF0ZSgpIHtcXG4gICAgICAgIHRoaXMuX2FjdHVhbFBvc2l0aW9uID0gdmVjXzEudmVjMy5hZGQodGhpcy5fdGFyZ2V0UG9zaXRpb24sIHZlY18xLnZlYzMubXVsKHZlY18xLnZlYzMuc3ViKHRoaXMuX2FjdHVhbFBvc2l0aW9uLCB0aGlzLl90YXJnZXRQb3NpdGlvbiksIHRoaXMucG9zaXRpb25FYXNlQW1vdW50KSk7XFxuICAgICAgICB0aGlzLl9hY3R1YWxUYXJnZXQgPSB2ZWNfMS52ZWMzLmFkZCh0aGlzLl90YXJnZXRUYXJnZXQsIHZlY18xLnZlYzMubXVsKHZlY18xLnZlYzMuc3ViKHRoaXMuX2FjdHVhbFRhcmdldCwgdGhpcy5fdGFyZ2V0VGFyZ2V0KSwgdGhpcy50YXJnZXRFYXNlQW1vdW50KSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCB0aGUgdmlldyBtYXRyaXggZm9yIHRoZSBjYW1lcmFcXG4gICAgICpcXG4gICAgICogVGhlIHZpZXcgbWF0cml4IHRyYW5zZm9ybXMgd29ybGQgY29vcmRpbmF0ZXMgaW50byBjYW1lcmEgY29vcmRpbmF0ZXNcXG4gICAgICovXFxuICAgIGdldFZpZXdNYXRyaXgoKSB7XFxuICAgICAgICBjb25zdCBmb3J3YXJkID0gdmVjXzEudmVjMy5ub3IodmVjXzEudmVjMy5zdWIodGhpcy5fYWN0dWFsVGFyZ2V0LCB0aGlzLl9hY3R1YWxQb3NpdGlvbikpO1xcbiAgICAgICAgY29uc3QgcmlnaHQgPSB2ZWNfMS52ZWMzLm5vcih2ZWNfMS52ZWMzLmNyb3NzKGZvcndhcmQsIHRoaXMudXApKTtcXG4gICAgICAgIGNvbnN0IHVwID0gdmVjXzEudmVjMy5jcm9zcyhyaWdodCwgZm9yd2FyZCk7XFxuICAgICAgICBjb25zdCByb3RhdGlvbiA9ICgwLCB2ZWNfMS5tYXQpKDQsIDQsIFtcXG4gICAgICAgICAgICByaWdodC54LCByaWdodC55LCByaWdodC56LCAwLFxcbiAgICAgICAgICAgIHVwLngsIHVwLnksIHVwLnosIDAsXFxuICAgICAgICAgICAgLWZvcndhcmQueCwgLWZvcndhcmQueSwgLWZvcndhcmQueiwgMCxcXG4gICAgICAgICAgICAwLCAwLCAwLCAxLFxcbiAgICAgICAgXSk7XFxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9ICgwLCB2ZWNfMS5tYXQpKDQsIDQsIFtcXG4gICAgICAgICAgICAxLCAwLCAwLCAtdGhpcy5fYWN0dWFsUG9zaXRpb24ueCxcXG4gICAgICAgICAgICAwLCAxLCAwLCAtdGhpcy5fYWN0dWFsUG9zaXRpb24ueSxcXG4gICAgICAgICAgICAwLCAwLCAxLCAtdGhpcy5fYWN0dWFsUG9zaXRpb24ueixcXG4gICAgICAgICAgICAwLCAwLCAwLCAxLFxcbiAgICAgICAgXSk7XFxuICAgICAgICBjb25zdCB2aWV3TWF0cml4ID0gdmVjXzEubWF0Lm11bChyb3RhdGlvbiwgdHJhbnNsYXRpb24pO1xcbiAgICAgICAgaWYgKCF2aWV3TWF0cml4KSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHZpZXcgbWF0cml4Jyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdmlld01hdHJpeDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0IGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSBjYW1lcmFcXG4gICAgICovXFxuICAgIGdldFBlcnNwZWN0aXZlUHJvamVjdGlvbk1hdHJpeCgpIHtcXG4gICAgICAgIGNvbnN0IGYgPSAxLjAgLyBNYXRoLnRhbih0aGlzLmZvdiAvIDIpO1xcbiAgICAgICAgY29uc3QgbmYgPSAxIC8gKHRoaXMubmVhciAtIHRoaXMuZmFyKTtcXG4gICAgICAgIHJldHVybiAoMCwgdmVjXzEubWF0KSg0LCA0LCBbXFxuICAgICAgICAgICAgZiAvIHRoaXMuYXNwZWN0LCAwLCAwLCAwLFxcbiAgICAgICAgICAgIDAsIGYsIDAsIDAsXFxuICAgICAgICAgICAgMCwgMCwgKHRoaXMuZmFyICsgdGhpcy5uZWFyKSAqIG5mLCAtMSxcXG4gICAgICAgICAgICAwLCAwLCAyICogdGhpcy5mYXIgKiB0aGlzLm5lYXIgKiBuZiwgMCxcXG4gICAgICAgIF0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXQgYW4gb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4IGZvciB0aGUgY2FtZXJhXFxuICAgICAqL1xcbiAgICBnZXRPcnRob2dyYXBoaWNQcm9qZWN0aW9uTWF0cml4KCkge1xcbiAgICAgICAgY29uc3QgbCA9IC10aGlzLmFzcGVjdCAqIHRoaXMuZm92O1xcbiAgICAgICAgY29uc3QgciA9IHRoaXMuYXNwZWN0ICogdGhpcy5mb3Y7XFxuICAgICAgICBjb25zdCBiID0gLXRoaXMuYXNwZWN0ICogdGhpcy5mb3Y7XFxuICAgICAgICBjb25zdCB0ID0gdGhpcy5hc3BlY3QgKiB0aGlzLmZvdjtcXG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLm5lYXI7XFxuICAgICAgICBjb25zdCBmID0gdGhpcy5mYXI7XFxuICAgICAgICByZXR1cm4gKDAsIHZlY18xLm1hdCkoNCwgNCwgW1xcbiAgICAgICAgICAgIDIgLyAociAtIGwpLCAwLCAwLCAtKHIgKyBsKSAvIChyIC0gbCksXFxuICAgICAgICAgICAgMCwgMiAvICh0IC0gYiksIDAsIC0odCArIGIpIC8gKHQgLSBiKSxcXG4gICAgICAgICAgICAwLCAwLCAtMiAvIChmIC0gbiksIC0oZiArIG4pIC8gKGYgLSBuKSxcXG4gICAgICAgICAgICAwLCAwLCAwLCAxLFxcbiAgICAgICAgXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFByb2plY3QgYSAzRCBwb2ludCBpbnRvIDJEIHNjcmVlbiBjb29yZGluYXRlc1xcbiAgICAgKiBAcGFyYW0gdiBUaGUgM0QgcG9pbnQgdG8gcHJvamVjdFxcbiAgICAgKiBAcGFyYW0gc2NyZWVuU2l6ZSBUaGUgc2l6ZSBvZiB0aGUgc2NyZWVuIGluIHBpeGVsc1xcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvamVjdGVkIDJEIGNvb3JkaW5hdGVzLCBvciBudWxsIGlmIHByb2plY3Rpb24gZmFpbHNcXG4gICAgICovXFxuICAgIHByb2plY3Qodiwgc2NyZWVuU2l6ZSkge1xcbiAgICAgICAgY29uc3Qgdmlld01hdHJpeCA9IHRoaXMuZ2V0Vmlld01hdHJpeCgpO1xcbiAgICAgICAgbGV0IHByb2plY3Rpb25NYXRyaXg7XFxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xcbiAgICAgICAgICAgIGNhc2UgJ3BlcnNwZWN0aXZlJzpcXG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeCA9IHRoaXMuZ2V0UGVyc3BlY3RpdmVQcm9qZWN0aW9uTWF0cml4KCk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGNhc2UgJ29ydGhvZ3JhcGhpYyc6XFxuICAgICAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXggPSB0aGlzLmdldE9ydGhvZ3JhcGhpY1Byb2plY3Rpb25NYXRyaXgoKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIDNEIHBvaW50IGludG8gdmlldyBzcGFjZVxcbiAgICAgICAgY29uc3Qgdmlld1BvcyA9IHZlY18xLm1hdC5tdWx2KHZpZXdNYXRyaXgsIFsuLi52ZWNfMS52ZWMzLmNvbXBvbmVudHModiksIDFdKTtcXG4gICAgICAgIGlmICghdmlld1Bvcykge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmlld1Bvc1szXSA9IDE7IC8vIEhvbW9nZW5lb3VzIGNvb3JkaW5hdGVzXFxuICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHBvaW50IGZyb20gdmlldyBzcGFjZSB0byBjbGlwIHNwYWNlXFxuICAgICAgICBjb25zdCBjbGlwUG9zID0gdmVjXzEubWF0Lm11bHYocHJvamVjdGlvbk1hdHJpeCwgdmlld1Bvcyk7XFxuICAgICAgICBpZiAoY2xpcFBvcyA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IGNsaXBQb3NWZWMgPSB2ZWNfMS52ZWMzLmZyb21Db21wb25lbnRzKGNsaXBQb3MpO1xcbiAgICAgICAgLy8gUGVyZm9ybSBwZXJzcGVjdGl2ZSBkaXZpc2lvbiB0byBnZXQgbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMgKE5EQylcXG4gICAgICAgIGNvbnN0IG5kYyA9ICgwLCB2ZWNfMS52ZWMyKShjbGlwUG9zVmVjLnggLyBjbGlwUG9zVmVjLnosIGNsaXBQb3NWZWMueSAvIGNsaXBQb3NWZWMueik7XFxuICAgICAgICByZXR1cm4gKDAsIHZlY18xLnZlYzIpKChuZGMueCAqIDAuNSArIDAuNSkgKiBzY3JlZW5TaXplLngsICgxIC0gKG5kYy55ICogMC41ICsgMC41KSkgKiBzY3JlZW5TaXplLnkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDb252ZXJ0IGEgc2NyZWVuIHBvc2l0aW9uIHRvIGEgd29ybGQgcG9zaXRpb25cXG4gICAgICogQHBhcmFtIHNjcmVlblBvc2l0aW9uIFRoZSAyRCBzY3JlZW4gY29vcmRpbmF0ZXMgdG8gY29udmVydFxcbiAgICAgKiBAcGFyYW0gc2NyZWVuU2l6ZSBUaGUgc2l6ZSBvZiB0aGUgc2NyZWVuIGluIHBpeGVsc1xcbiAgICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIChkaXN0YW5jZSBmcm9tIHRoZSBjYW1lcmEpIHRvIHVzZSBmb3IgY29udmVyc2lvblxcbiAgICAgKiBAcmV0dXJucyBUaGUgY29ycmVzcG9uZGluZyAzRCB3b3JsZCBjb29yZGluYXRlcywgb3IgbnVsbCBpZiBjb252ZXJzaW9uIGZhaWxzXFxuICAgICAqL1xcbiAgICBzY3JlZW5Ub1dvcmxkKHNjcmVlblBvc2l0aW9uLCBzY3JlZW5TaXplLCBkZXB0aCkge1xcbiAgICAgICAgLy8gSWYgZGVwdGggaXMgbm90IHByb3ZpZGVkLCB1c2UgdGhlIG5lYXIgcGxhbmVcXG4gICAgICAgIGlmIChkZXB0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgZGVwdGggPSB0aGlzLm5lYXI7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBDb252ZXJ0IHNjcmVlbiBwb3NpdGlvbiB0byBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlcyAoTkRDKVxcbiAgICAgICAgY29uc3QgbmRjID0gKDAsIHZlY18xLnZlYzIpKDEgLSAoc2NyZWVuUG9zaXRpb24ueCAvIHNjcmVlblNpemUueCkgKiAyLCAxIC0gKHNjcmVlblBvc2l0aW9uLnkgLyBzY3JlZW5TaXplLnkpICogMik7XFxuICAgICAgICAvLyBUcmFuc2Zvcm0gTkRDIGZyb20gdmlldyBzcGFjZSB0byBjbGlwIHNwYWNlXFxuICAgICAgICBjb25zdCB2aWV3TWF0cml4ID0gdGhpcy5nZXRWaWV3TWF0cml4KCk7XFxuICAgICAgICBsZXQgcHJvamVjdGlvbk1hdHJpeDtcXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSAncGVyc3BlY3RpdmUnOlxcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5nZXRQZXJzcGVjdGl2ZVByb2plY3Rpb25NYXRyaXgoKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgY2FzZSAnb3J0aG9ncmFwaGljJzpcXG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeCA9IHRoaXMuZ2V0T3J0aG9ncmFwaGljUHJvamVjdGlvbk1hdHJpeCgpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IGludlByb2plY3Rpb25NYXRyaXggPSB2ZWNfMS5tYXQuaW52KHByb2plY3Rpb25NYXRyaXgpO1xcbiAgICAgICAgaWYgKCFpbnZQcm9qZWN0aW9uTWF0cml4KSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBpbnZWaWV3TWF0cml4ID0gdmVjXzEubWF0Lmludih2aWV3TWF0cml4KTtcXG4gICAgICAgIGlmICghaW52Vmlld01hdHJpeCkge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IGNsaXBQb3MgPSAoMCwgdmVjXzEudmVjMykoKTtcXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSAncGVyc3BlY3RpdmUnOlxcbiAgICAgICAgICAgICAgICAvLyBGb3IgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiwgd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGNsaXAgc3BhY2VcXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb24gYW5kIHNjYWxlIGJ5IHRhbihmb3YvMikgdG8gYWNjb3VudCBmb3IgdGhlIGZpZWxkIG9mIHZpZXdcXG4gICAgICAgICAgICAgICAgY29uc3QgdGFuSGFsZkZvdiA9IE1hdGgudGFuKHRoaXMuZm92IC8gMik7XFxuICAgICAgICAgICAgICAgIGNsaXBQb3MgPSAoMCwgdmVjXzEudmVjMykobmRjLnggKiBkZXB0aCAqIHRhbkhhbGZGb3YgKiB0aGlzLmFzcGVjdCwgbmRjLnkgKiBkZXB0aCAqIHRhbkhhbGZGb3YsIGRlcHRoKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgY2FzZSAnb3J0aG9ncmFwaGljJzpcXG4gICAgICAgICAgICAgICAgLy8gRm9yIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLCB3ZSBjYW4gZGlyZWN0bHkgdXNlIHRoZSBkZXB0aCB2YWx1ZVxcbiAgICAgICAgICAgICAgICBjbGlwUG9zID0gKDAsIHZlY18xLnZlYzMpKG5kYy54ICogKHRoaXMuZmFyIC0gdGhpcy5uZWFyKSAvIDIsIG5kYy55ICogKHRoaXMuZmFyIC0gdGhpcy5uZWFyKSAvIDIsICh0aGlzLmZhciArIHRoaXMubmVhcikgLyAyICsgZGVwdGgpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIFRyYW5zZm9ybSBjbGlwIHNwYWNlIGNvb3JkaW5hdGVzIHRvIHdvcmxkIHNwYWNlXFxuICAgICAgICBjb25zdCB3b3JsZFBvcyA9IHZlY18xLm1hdC5tdWx2KGludlZpZXdNYXRyaXgsIFsuLi52ZWNfMS52ZWMzLmNvbXBvbmVudHMoY2xpcFBvcyksIDFdKTtcXG4gICAgICAgIGlmICghd29ybGRQb3MpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAoMCwgdmVjXzEudmVjMykod29ybGRQb3NbMF0gLyB3b3JsZFBvc1szXSwgd29ybGRQb3NbMV0gLyB3b3JsZFBvc1szXSwgd29ybGRQb3NbMl0gLyB3b3JsZFBvc1szXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENhc3QgYSByYXkgZnJvbSB0aGUgY2FtZXJhIHRocm91Z2ggYSBzY3JlZW4gcG9zaXRpb25cXG4gICAgICogQHBhcmFtIHNjcmVlblBvc2l0aW9uIFRoZSAyRCBzY3JlZW4gY29vcmRpbmF0ZXMgdG8gY2FzdCB0aGUgcmF5IGZyb21cXG4gICAgICogQHBhcmFtIHNjcmVlblNpemUgVGhlIHNpemUgb2YgdGhlIHNjcmVlbiBpbiBwaXhlbHNcXG4gICAgICogQHJldHVybnMgQSByYXkgd2l0aCBvcmlnaW4gYW5kIGRpcmVjdGlvbiwgb3IgbnVsbCBpZiByYXljYXN0aW5nIGZhaWxzXFxuICAgICAqL1xcbiAgICByYXljYXN0KHNjcmVlblBvc2l0aW9uLCBzY3JlZW5TaXplKSB7XFxuICAgICAgICBjb25zdCBuZWFyUGxhbmVQb2ludCA9IHRoaXMuc2NyZWVuVG9Xb3JsZChzY3JlZW5Qb3NpdGlvbiwgc2NyZWVuU2l6ZSwgdGhpcy5uZWFyKTtcXG4gICAgICAgIGNvbnN0IGZhclBsYW5lUG9pbnQgPSB0aGlzLnNjcmVlblRvV29ybGQoc2NyZWVuUG9zaXRpb24sIHNjcmVlblNpemUsIHRoaXMuZmFyKTtcXG4gICAgICAgIGlmICghbmVhclBsYW5lUG9pbnQgfHwgIWZhclBsYW5lUG9pbnQpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHZlY18xLnZlYzMubm9yKHZlY18xLnZlYzMuc3ViKGZhclBsYW5lUG9pbnQsIG5lYXJQbGFuZVBvaW50KSk7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcy5fYWN0dWFsUG9zaXRpb24sXFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXFxuICAgICAgICB9O1xcbiAgICB9XFxufVxcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IENhbWVyYTNkO1xcbkNhbWVyYTNkLkRFRkFVTFRfT1BUSU9OUyA9IHtcXG4gICAgbW9kZTogJ3BlcnNwZWN0aXZlJyxcXG4gICAgdXA6ICgwLCB2ZWNfMS52ZWMzKSgwLCAxLCAwKSxcXG4gICAgZm92OiBNYXRoLlBJIC8gMixcXG4gICAgYXNwZWN0OiAxLFxcbiAgICBuZWFyOiAwLjEsXFxuICAgIGZhcjogMTAwMCxcXG4gICAgcG9zaXRpb25FYXNlQW1vdW50OiAwLjEsXFxuICAgIHRhcmdldEVhc2VBbW91bnQ6IDAuMSxcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0NhbWVyYTNkLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qKlxcbiAqIEBvdmVydmlldyBBIGxpYnJhcnkgb2YgdXNlZnVsIGZ1bmN0aW9uc1xcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXIgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlciBiXFxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBudW1iZXJzIGEgYW5kIGIgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKi9cXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XFxuXFxuLyoqXFxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gY2xhbXBcXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBIGNsYW1wZWQgbnVtYmVyXFxuICovXFxuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBmcmFjdGlvbmFsIHBhcnRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIG51bWJlclxcbiAqL1xcbmNvbnN0IGZyYWMgPSBhID0+IGEgPj0gMCA/IGEgLSBNYXRoLmZsb29yKGEpIDogYSAtIE1hdGguY2VpbChhKTtcXG5cXG4vKipcXG4gKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKi9cXG5jb25zdCBsZXJwID0gKGEsIGIsIGkpID0+IGEgKyAoYiAtIGEpICogaTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcXG4gKi9cXG5jb25zdCB1bmxlcnAgPSAoYSwgYiwgaSkgPT4gKGkgLSBhKSAvIChiIC0gYSk7XFxuXFxuLyoqXFxuICogRG8gYSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTAgVG9wLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMSBCb3R0b20tbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGl4IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeSBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXFxuICovXFxuY29uc3QgYmxlcnAgPSAoYzAwLCBjMTAsIGMwMSwgYzExLCBpeCwgaXkpID0+IGxlcnAobGVycChjMDAsIGMxMCwgaXgpLCBsZXJwKGMwMSwgYzExLCBpeCksIGl5KTtcXG5cXG4vKipcXG4gKiBSZS1tYXAgYSBudW1iZXIgaSBmcm9tIHJhbmdlIGExLi4uYTIgdG8gYjEuLi5iMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXFxuICogQHBhcmFtIHtudW1iZXJ9IGExXFxuICogQHBhcmFtIHtudW1iZXJ9IGEyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIxXFxuICogQHBhcmFtIHtudW1iZXJ9IGIyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmNvbnN0IHJlbWFwID0gKGksIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArIChpIC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xcblxcbi8qKlxcbiAqIERvIGEgc21vb3RoIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3Qgc21vb3Roc3RlcCA9IChhLCBiLCBpKSA9PiBsZXJwKGEsIGIsIDMgKiBNYXRoLnBvdyhpLCAyKSAtIDIgKiBNYXRoLnBvdyhpLCAzKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKi9cXG5jb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiBkZWdyZWVzXFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiBkZWdyZWVzXFxuICovXFxuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEV4Y2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICovXFxuY29uc3QgcmFuZG9tQmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xcblxcbi8qKlxcbiAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICovXFxuY29uc3QgcmFuZG9tSW50QmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IFttdT0wLjVdIFRoZSBtZWFuIHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9Ml0gVGhlIG51bWJlciBvZiBzYW1wbGVzXFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb20gPSAobXUgPSAwLjUsIHNpZ21hID0gMC41LCBzYW1wbGVzID0gMikgPT4ge1xcbiAgbGV0IHRvdGFsID0gMDtcXG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XFxuICAgIHRvdGFsICs9IE1hdGgucmFuZG9tKCk7XFxuICB9XFxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlclxcbiAqL1xcbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdyBBbiBhcnJheSBvZiB3ZWlnaHRzXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbmRleCBmcm9tIHdcXG4gKi9cXG5jb25zdCB3ZWlnaHRlZFJhbmRvbSA9IHcgPT4ge1xcbiAgbGV0IHRvdGFsID0gdy5yZWR1Y2UoKGEsIGkpID0+IGEgKyBpLCAwKSwgbiA9IDA7XFxuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xcbiAgd2hpbGUgKHRvdGFsID4gcikge1xcbiAgICB0b3RhbCAtPSB3W24rK107XFxuICB9XFxuICByZXR1cm4gbiAtIDE7XFxufTtcXG5cXG4vKipcXG4gKiBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXFxuICogQGNhbGxiYWNrIGludGVycG9sYXRpb25DYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmcm9tIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIEEgbnVtYmVyIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcGFyYW0ge2ludGVycG9sYXRpb25DYWxsYmFja30gW2Y9TWF0aC5sZXJwXSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB0byB1c2VcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxcbiAqL1xcbmNvbnN0IGxlcnBBcnJheSA9IChhLCBpLCBmID0gbGVycCkgPT4ge1xcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcXG4gIGNvbnN0IHAgPSBjbGFtcChNYXRoLnRydW5jKHMpLCAwLCBhLmxlbmd0aCAtIDEpO1xcbiAgcmV0dXJuIGYoYVtwXSB8fCAwLCBhW3AgKyAxXSB8fCAwLCBmcmFjKHMpKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG5jb25zdCBkb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmYWN0b3JpYWwgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYVxcbiAqIEByZXR1cm4ge251bWJlcn0gYSFcXG4gKi9cXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcXG4gIGxldCByZXN1bHQgPSAxO1xcbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gYTsgaSsrKSB7XFxuICAgIHJlc3VsdCAqPSBpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxcbiAqL1xcbmNvbnN0IHBlcm11dGF0aW9uID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIGZhY3RvcmlhbChuIC0gcik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcGFyYW0ge251bWJlcn0gclxcbiAqIEByZXR1cm4ge251bWJlcn0gbkNyXFxuICovXFxuY29uc3QgY29tYmluYXRpb24gPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gKGZhY3RvcmlhbChyKSAqIGZhY3RvcmlhbChuIC0gcikpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYXJyYXkgdmFsdWVzXFxuICogQGNhbGxiYWNrIHRpbWVzQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBUaGUgYXJyYXkgdmFsdWVcXG4gKi9cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBsZW5ndGggbiBieSBjYWxsaW5nIGZ1bmN0aW9uIGYoaSkgb24gZWFjaCBlbGVtZW50XFxuICogQHBhcmFtIHt0aW1lc0NhbGxiYWNrfSBmXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIGFycmF5XFxuICogQHJldHVybiB7QXJyYXk8Kj59XFxuICovXFxuY29uc3QgdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIG51bWJlcnMgMC0+KG4gLSAxKVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIGludGVnZXJzIDAtPihuIC0gMSlcXG4gKi9cXG5jb25zdCByYW5nZSA9IG4gPT4gdGltZXMoaSA9PiBpLCBuKTtcXG5cXG4vKipcXG4gKiBaaXAgMiBhcnJheXMgdG9nZXRoZXIsIGkuZS4gKFsxLCAyLCAzXSwgW2EsIGIsIGNdKSA9PiBbWzEsIGFdLCBbMiwgYl0sIFszLCBjXV1cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYlxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn1cXG4gKi9cXG5jb25zdCB6aXAgPSAoYSwgYikgPT4gYS5tYXAoKGssIGkpID0+IFtrLCBiW2ldXSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGFycmF5W2ldIHdpdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHdyYXBwaW5nXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBwb3NpdGl2ZWx5L25lZ2F0aXZlbHkgd3JhcHBlZCBhcnJheSBpbmRleFxcbiAqIEByZXR1cm4geyp9IEFuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcXG4gKi9cXG5jb25zdCBhdCA9IChhLCBpKSA9PiBhW2kgPCAwID8gYS5sZW5ndGggLSAoTWF0aC5hYnMoaSArIDEpICUgYS5sZW5ndGgpIC0gMSA6IGkgJSBhLmxlbmd0aF07XFxuXFxuLyoqXFxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNodW5rIHNpemVcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xcbiAqL1xcbmNvbnN0IGNodW5rID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcblxcbi8qKlxcbiAqIFJhbmRvbWx5IHNodWZmbGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSBzaHVmZmxlZCBhcnJheVxcbiAqL1xcbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHtcXG4gICAgZmxvYXRFcXVhbHMsXFxuICAgIGNsYW1wLFxcbiAgICBmcmFjLFxcbiAgICBsZXJwLFxcbiAgICB1bmxlcnAsXFxuICAgIGJsZXJwLFxcbiAgICByZW1hcCxcXG4gICAgc21vb3Roc3RlcCxcXG4gICAgcmFkaWFucyxcXG4gICAgZGVncmVlcyxcXG4gICAgcmFuZG9tQmV0d2VlbixcXG4gICAgcmFuZG9tSW50QmV0d2VlbixcXG4gICAgY2x0UmFuZG9tLFxcbiAgICBjbHRSYW5kb21JbnQsXFxuICAgIHdlaWdodGVkUmFuZG9tLFxcbiAgICBsZXJwQXJyYXksXFxuICAgIGRvdCxcXG4gICAgZmFjdG9yaWFsLFxcbiAgICBwZXJtdXRhdGlvbixcXG4gICAgY29tYmluYXRpb24sXFxuICAgIHRpbWVzLFxcbiAgICByYW5nZSxcXG4gICAgemlwLFxcbiAgICBhdCxcXG4gICAgY2h1bmssXFxuICAgIHNodWZmbGUsXFxuICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiY29uc3QgeyB0aW1lcywgY2h1bmssIGRvdCB9ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuXFxuLyoqXFxuICogQG92ZXJ2aWV3IEEgc21hbGwgdmVjdG9yIGFuZCBtYXRyaXggbGlicmFyeVxcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuLyoqXFxuICogQSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWNcXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfHZlY30gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlY30gQSBuZXcgdmVjdG9yXFxuICogQGV4YW1wbGUgPGNhcHRpb24+VmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMoMywgMik7ICAvLyAoMywgMilcXG4gKiBsZXQgYiA9IHZlYyg0KTsgICAgIC8vICg0LCA0KVxcbiAqIGxldCBjID0gdmVjKGEpOyAgICAgLy8gKDMsIDIpXFxuICogbGV0IGQgPSB2ZWMoKTsgICAgICAvLyAoMCwgMClcXG4gKi9cXG5jb25zdCB2ZWMgPSAoeCwgeSkgPT4gKCF4ICYmICF5ID9cXG4gIHsgeDogMCwgeTogMCB9IDogKHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/XFxuICAgIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwIH0gOiAoeSA9PT0gbnVsbCB8fCB5ID09PSB1bmRlZmluZWQgP1xcbiAgICAgIHsgeDogeCwgeTogeCB9IDogeyB4OiB4LCB5OiB5IH0pXFxuICApXFxuKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcXG4gKi9cXG52ZWMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55XTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMClcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICovXFxudmVjLnV4ID0gKCkgPT4gdmVjKDEsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqIEByZXR1cm4ge3ZlY30gQSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKi9cXG52ZWMudXkgPSAoKSA9PiB2ZWMoMCwgMSk7XFxuXFxuLyoqXFxuICogQWRkIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjfSBhICsgYlxcbiAqL1xcbnZlYy5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgYi54LCB5OiBhLnkgKyBiLnkgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjfSBhICogYlxcbiAqL1xcbnZlYy5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogYiwgeTogYS55ICogYiB9KTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAtIGJcXG4gKi9cXG52ZWMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIGIueCwgeTogYS55IC0gYi55IH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSk7XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHt2ZWN9IF5hXFxuICovXFxudmVjLm5vciA9IGEgPT4ge1xcbiAgbGV0IGxlbiA9IHZlYy5sZW4oYSk7XFxuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiB9IDogdmVjKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxcbiAqL1xcbnZlYy5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnNcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMucm90ID0gKGEsIHIpID0+IHtcXG4gIGxldCBzID0gTWF0aC5zaW4ociksXFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcXG4gIHJldHVybiB7IHg6IGMgKiBhLnggLSBzICogYS55LCB5OiBzICogYS54ICsgYyAqIGEueSB9O1xcbn1cXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZWN0b3JzIGEgYW5kIGIgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG52ZWMuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYy5yYWQgPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLngpO1xcblxcbi8qKlxcbiAqIENvcHkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYy5jcHkgPSBhID0+IHZlYyhhKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3JcXG4gKiBAY2FsbGJhY2sgdmVjdG9yTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjdG9yTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlY30gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYy5tYXAgPSAoYSwgZikgPT4gKHsgeDogZihhLngsICd4JyksIHk6IGYoYS55LCAneScpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYy5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcXG5cXG4vKipcXG4gKiBBIG1hdHJpeFxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1hdFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIG1hdHJpeCB2YWx1ZXNcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgbWF0cml4XFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj00XSBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbnRyaWVzPVtdXSBNYXRyaXggdmFsdWVzIGluIHJlYWRpbmcgb3JkZXJcXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxcbiAqL1xcbmNvbnN0IG1hdCA9IChtID0gNCwgbiA9IDQsIGVudHJpZXMgPSBbXSkgPT4gKHtcXG4gIG0sIG4sXFxuICBlbnRyaWVzOiBlbnRyaWVzLmNvbmNhdChBcnJheShtICogbikuZmlsbCgwKSkuc2xpY2UoMCwgbSAqIG4pXFxufSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGlkZW50aXR5IG1hdHJpeCBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBBbiBpZGVudGl0eSBtYXRyaXhcXG4gKi9cXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgYXQgcG9zaXRpb24gKGksIGopIGluIG1hdHJpeCBhXFxuICovXFxubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xcblxcbi8qKlxcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB2YWx1ZSB0byBzZXQgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XFxuXFxuLyoqXFxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtIFRoZSByb3cgb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5yb3cgPSAoYSwgbSkgPT4ge1xcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XFxuICByZXR1cm4gYS5lbnRyaWVzLnNsaWNlKHMsIHMgKyBhLm4pO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgY29sdW1uIGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQ29sdW1uIG4gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5jb2wgPSAoYSwgbikgPT4gdGltZXMoaSA9PiBtYXQuZ2V0KGEsIChpICsgMSksIG4pLCBhLm0pO1xcblxcbi8qKlxcbiAqIEFkZCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKyBiXFxuICovXFxubWF0LmFkZCA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2ICsgYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgLSBiXFxuICovXFxubWF0LnN1YiA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2IC0gYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBNdWx0aXBseSBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpY2VzIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bCA9IChhLCBiKSA9PiB7XFxuICBpZiAoYS5uICE9PSBiLm0pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYi5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgZG90KG1hdC5yb3coYSwgaSksIG1hdC5jb2woYiwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcXG4gKi9cXG5tYXQuc2NhbGUgPSAoYSwgYikgPT4gbWF0Lm1hcChhLCB2ID0+IHYgKiBiKTtcXG5cXG4vKipcXG4gKiBUcmFuc3Bvc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxcbiAqIEByZXR1cm4ge21hdH0gQSB0cmFuc3Bvc2VkIG1hdHJpeFxcbiAqL1xcbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCB0aW1lcyhpID0+IG1hdC5jb2woYSwgKGkgKyAxKSksIGEubikuZmxhdCgpKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG1pbm9yIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IFRoZSAoaSwgaikgbWlub3Igb2YgbWF0cml4IGEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcXG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XFxuICAgIGlmIChpaSA9PT0gaSkgeyBjb250aW51ZTsgfVxcbiAgICBmb3IgKGxldCBqaiA9IDE7IGpqIDw9IGEubjsgamorKykge1xcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxcbiAgICAgIGVudHJpZXMucHVzaChtYXQuZ2V0KGEsIGlpLCBqaikpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbWF0KGEubSAtIDEsIGEubiAtIDEsIGVudHJpZXMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59IHxhfCBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQuZGV0ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBpZiAoYS5tID09PSAxKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF07XFxuICB9XFxuICBpZiAoYS5tID09PSAyKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF0gKiBhLmVudHJpZXNbM10gLSBhLmVudHJpZXNbMV0gKiBhLmVudHJpZXNbMl07XFxuICB9XFxuICBsZXQgdG90YWwgPSAwLCBzaWduID0gMTtcXG4gIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgIHRvdGFsICs9IHNpZ24gKiBhLmVudHJpZXNbaiAtIDFdICogbWF0LmRldChtYXQubWlub3IoYSwgMSwgaikpO1xcbiAgICBzaWduICo9IC0xO1xcbiAgfVxcbiAgcmV0dXJuIHRvdGFsO1xcbn07XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gXmEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm5vciA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICByZXR1cm4gbWF0Lm1hcChhLCBpID0+IGkgKiBkKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYWRqdWdhdGUgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxcbiAqIEByZXR1cm4ge21hdH0gVGhlIGFkanVnYXRlIG9mIGFcXG4gKi9cXG5tYXQuYWRqID0gYSA9PiB7XFxuICBjb25zdCBtaW5vcnMgPSBtYXQoYS5tLCBhLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KG1pbm9ycywgaSwgaiwgbWF0LmRldChtYXQubWlub3IoYSwgaSwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgY29uc3QgY29mYWN0b3JzID0gbWF0Lm1hcChtaW5vcnMsICh2LCBpKSA9PiB2ICogKGkgJSAyID8gLTEgOiAxKSk7XFxuICByZXR1cm4gbWF0LnRyYW5zKGNvZmFjdG9ycyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGludmVydFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBhXi0xIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaGFzIG5vIGludmVyc2VcXG4gKi9cXG5tYXQuaW52ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgcmV0dXJuIG1hdC5zY2FsZShtYXQuYWRqKGEpLCAxIC8gZCk7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gbWF0cmljZXMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWF0cmljZXMgYSBhbmQgYiBhcmUgaWRlbnRpY2FsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG5tYXQuZXEgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0LnN0cihhKSA9PT0gbWF0LnN0cihiKTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb3B5XFxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcXG4gKi9cXG5tYXQuY3B5ID0gYSA9PiBtYXQoYS5tLCBhLm4sIFsuLi5hLmVudHJpZXNdKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZW50cnkgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGVudHJ5IGluZGV4XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBlbnRyeVxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4IGFuZCBidWlsZCBhIG5ldyBtYXRyaXggZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXRyaXhNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IE1hdHJpeCBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG5tYXQubWFwID0gKGEsIGYpID0+IG1hdChhLm0sIGEubiwgYS5lbnRyaWVzLm1hcChmKSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIG1hdHJpeCBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbnM9J1xcXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcXG4gKi9cXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxcXG4nKSA9PiBjaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XFxuXFxuaWYgKHRydWUpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0geyB2ZWMsIG1hdCB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5jb25zdCB2ZWNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3ZlYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1xcXCIpO1xcbmZ1bmN0aW9uIGNsYW1wKGEsIG1pbiA9IDAsIG1heCA9IDEpIHtcXG4gICAgcmV0dXJuIGEgPCBtaW4gPyBtaW4gOiAoYSA+IG1heCA/IG1heCA6IGEpO1xcbn1cXG5jbGFzcyBDYW1lcmEge1xcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbiwgb3B0aW9ucykge1xcbiAgICAgICAgdGhpcy5zaXplID0gKDAsIHZlY18xLnZlYykoKTtcXG4gICAgICAgIHRoaXMuX2FjdHVhbFBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoKTtcXG4gICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKSgpO1xcbiAgICAgICAgdGhpcy5fYWN0dWFsU2NhbGUgPSAxO1xcbiAgICAgICAgdGhpcy50YXJnZXRTY2FsZSA9IDE7XFxuICAgICAgICB0aGlzLl9hY3R1YWxQb3NpdGlvbiA9IHBvc2l0aW9uO1xcbiAgICAgICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IHBvc2l0aW9uO1xcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgQ2FtZXJhLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XFxuICAgIH1cXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0UG9zaXRpb247XFxuICAgIH1cXG4gICAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XFxuICAgICAgICB0aGlzLnRhcmdldFBvc2l0aW9uID0gdmFsdWU7XFxuICAgIH1cXG4gICAgc2V0IHBvc2l0aW9uSW1tZWRpYXRlKHZhbHVlKSB7XFxuICAgICAgICB0aGlzLl9hY3R1YWxQb3NpdGlvbiA9IHZhbHVlO1xcbiAgICAgICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IHZhbHVlO1xcbiAgICB9XFxuICAgIGdldCBhY3R1YWxQb3NpdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3R1YWxQb3NpdGlvbjtcXG4gICAgfVxcbiAgICBnZXQgc2NhbGUoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRTY2FsZTtcXG4gICAgfVxcbiAgICBnZXQgYWN0dWFsU2NhbGUoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsU2NhbGU7XFxuICAgIH1cXG4gICAgc2V0IHNjYWxlKHZhbHVlKSB7XFxuICAgICAgICB0aGlzLnRhcmdldFNjYWxlID0gY2xhbXAodmFsdWUsIHRoaXMub3B0aW9ucy5taW5TY2FsZSwgdGhpcy5vcHRpb25zLm1heFNjYWxlKTtcXG4gICAgfVxcbiAgICBzZXQgc2NhbGVJbW1lZGlhdGUodmFsdWUpIHtcXG4gICAgICAgIHRoaXMuX2FjdHVhbFNjYWxlID0gY2xhbXAodmFsdWUsIHRoaXMub3B0aW9ucy5taW5TY2FsZSwgdGhpcy5vcHRpb25zLm1heFNjYWxlKTtcXG4gICAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSB0aGlzLl9hY3R1YWxTY2FsZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0IHNjcmVlbiBib3VuZHMgYmFzZWQgb24gdGhlIGN1cnJlbnQgY2FtZXJhIHBvc2l0aW9uIGFuZCBzY2FsZVxcbiAgICAgKi9cXG4gICAgZ2V0IGJvdW5kcygpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgdG9wOiB0aGlzLl9hY3R1YWxQb3NpdGlvbi55IC0gKHRoaXMuc2l6ZS55IC8gMikgLyB0aGlzLl9hY3R1YWxTY2FsZSxcXG4gICAgICAgICAgICBib3R0b206IHRoaXMuX2FjdHVhbFBvc2l0aW9uLnkgKyAodGhpcy5zaXplLnkgLyAyKSAvIHRoaXMuX2FjdHVhbFNjYWxlLFxcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMuX2FjdHVhbFBvc2l0aW9uLnggLSAodGhpcy5zaXplLnggLyAyKSAvIHRoaXMuX2FjdHVhbFNjYWxlLFxcbiAgICAgICAgICAgIHJpZ2h0OiB0aGlzLl9hY3R1YWxQb3NpdGlvbi54ICsgKHRoaXMuc2l6ZS54IC8gMikgLyB0aGlzLl9hY3R1YWxTY2FsZVxcbiAgICAgICAgfTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ29udmVydCBhIHNjcmVlbiBwb3NpdGlvbiB0byBhIHdvcmxkIHBvc2l0aW9uXFxuICAgICAqL1xcbiAgICBzY3JlZW5Ub1dvcmxkKHBvc2l0aW9uKSB7XFxuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmJvdW5kcztcXG4gICAgICAgIHJldHVybiB2ZWNfMS52ZWMuYWRkKHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy50b3AgfSwgdmVjXzEudmVjLm11bChwb3NpdGlvbiwgMSAvIHRoaXMuYWN0dWFsU2NhbGUpKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ29udmVydCBhIHdvcmxkIHBvc2l0aW9uIHRvIGEgc2NyZWVuIHBvc2l0aW9uXFxuICAgICAqL1xcbiAgICB3b3JsZFRvU2NyZWVuKHBvc2l0aW9uKSB7XFxuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmJvdW5kcztcXG4gICAgICAgIHJldHVybiB2ZWNfMS52ZWMubXVsKHZlY18xLnZlYy5zdWIocG9zaXRpb24sIHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy50b3AgfSksIHRoaXMuYWN0dWFsU2NhbGUpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgdGhlIGNhbWVyYVxcbiAgICAgKi9cXG4gICAgdXBkYXRlKHNjcmVlbikge1xcbiAgICAgICAgdGhpcy5zaXplID0gKDAsIHZlY18xLnZlYykoc2NyZWVuKTtcXG4gICAgICAgIC8vIE1heWJlIGNsYW1wIHBvc2l0aW9uIHRvIGJvdW5kc1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMpIHtcXG4gICAgICAgICAgICBjb25zdCBzY3JlZW5TY2FsZWQgPSB2ZWNfMS52ZWMubWFwKHZlY18xLnZlYy5tdWwodGhpcy5zaXplLCAxIC8gdGhpcy5fYWN0dWFsU2NhbGUpLCBNYXRoLmNlaWwpO1xcbiAgICAgICAgICAgIC8vIElmIHRoZSBzY2FsZWQgc2NyZWVuIHNpemUgaXMgbGFyZ2VyIHRoYW4gYWxsb3dlZCBib3VuZHMsIHdlIHJlc2l6ZVxcbiAgICAgICAgICAgIC8vIHRoZSBib3VuZHMgdG8gcHJldmVudCBqaXR0ZXJpbmdcXG4gICAgICAgICAgICBjb25zdCBhY3R1YWxCb3VuZHMgPSB7XFxuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5ib3VuZHMsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICBpZiAoc2NyZWVuU2NhbGVkLnggPiBhY3R1YWxCb3VuZHMucmlnaHQgLSBhY3R1YWxCb3VuZHMubGVmdCkge1xcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZHNXaWR0aCA9IGFjdHVhbEJvdW5kcy5yaWdodCAtIGFjdHVhbEJvdW5kcy5sZWZ0O1xcbiAgICAgICAgICAgICAgICBjb25zdCBoYWxmRGlmZiA9IChzY3JlZW5TY2FsZWQueCAtIGJvdW5kc1dpZHRoKSAvIDI7XFxuICAgICAgICAgICAgICAgIGFjdHVhbEJvdW5kcy5sZWZ0IC09IGhhbGZEaWZmO1xcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZHMucmlnaHQgKz0gaGFsZkRpZmY7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChzY3JlZW5TY2FsZWQueSA+IGFjdHVhbEJvdW5kcy5ib3R0b20gLSBhY3R1YWxCb3VuZHMudG9wKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IGFjdHVhbEJvdW5kcy5ib3R0b20gLSBhY3R1YWxCb3VuZHMudG9wO1xcbiAgICAgICAgICAgICAgICBjb25zdCBoYWxmRGlmZiA9IChzY3JlZW5TY2FsZWQueSAtIGJvdW5kc0hlaWdodCkgLyAyO1xcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZHMudG9wIC09IGhhbGZEaWZmO1xcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZHMuYm90dG9tICs9IGhhbGZEaWZmO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb25zdCBoYWxmU2NyZWVuU2NhbGVkID0gdmVjXzEudmVjLm1hcCh2ZWNfMS52ZWMubXVsKHNjcmVlblNjYWxlZCwgMSAvIDIpLCBNYXRoLmNlaWwpO1xcbiAgICAgICAgICAgIGNvbnN0IG1pblBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoYWN0dWFsQm91bmRzLmxlZnQgKyBoYWxmU2NyZWVuU2NhbGVkLngsIGFjdHVhbEJvdW5kcy50b3AgKyBoYWxmU2NyZWVuU2NhbGVkLnkpO1xcbiAgICAgICAgICAgIGNvbnN0IG1heFBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoYWN0dWFsQm91bmRzLnJpZ2h0IC0gaGFsZlNjcmVlblNjYWxlZC54LCBhY3R1YWxCb3VuZHMuYm90dG9tIC0gaGFsZlNjcmVlblNjYWxlZC55KTtcXG4gICAgICAgICAgICB0aGlzLnRhcmdldFBvc2l0aW9uLnggPSBjbGFtcCh0aGlzLnRhcmdldFBvc2l0aW9uLngsIG1pblBvc2l0aW9uLngsIG1heFBvc2l0aW9uLngpO1xcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24ueSA9IGNsYW1wKHRoaXMudGFyZ2V0UG9zaXRpb24ueSwgbWluUG9zaXRpb24ueSwgbWF4UG9zaXRpb24ueSk7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBkID0gdmVjXzEudmVjLnN1Yih0aGlzLl9hY3R1YWxQb3NpdGlvbiwgdGhpcy50YXJnZXRQb3NpdGlvbik7XFxuICAgICAgICB0aGlzLl9hY3R1YWxQb3NpdGlvbiA9IHZlY18xLnZlYy5hZGQodGhpcy5wb3NpdGlvbiwgdmVjXzEudmVjLm11bChkLCB0aGlzLm9wdGlvbnMubW92ZUVhc2VBbW91bnQpKTtcXG4gICAgICAgIGNvbnN0IHMgPSBjbGFtcCh0aGlzLnRhcmdldFNjYWxlLCB0aGlzLm9wdGlvbnMubWluU2NhbGUsIHRoaXMub3B0aW9ucy5tYXhTY2FsZSk7XFxuICAgICAgICB0aGlzLl9hY3R1YWxTY2FsZSA9IHMgKyAodGhpcy5fYWN0dWFsU2NhbGUgLSBzKSAqIHRoaXMub3B0aW9ucy5zY2FsZUVhc2VBbW91bnQ7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNldCB0aGUgY2FtZXJhIHRyYW5zZm9ybXMgb24gYSBjYW52YXMgY29udGV4dFxcbiAgICAgKi9cXG4gICAgc2V0VHJhbnNmb3Jtcyhjb250ZXh0KSB7XFxuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCh0aGlzLnNpemUueCAvIDIpIC0gdGhpcy5fYWN0dWFsUG9zaXRpb24ueCAqIHRoaXMuX2FjdHVhbFNjYWxlLCAodGhpcy5zaXplLnkgLyAyKSAtIHRoaXMuX2FjdHVhbFBvc2l0aW9uLnkgKiB0aGlzLl9hY3R1YWxTY2FsZSk7XFxuICAgICAgICBjb250ZXh0LnNjYWxlKHRoaXMuX2FjdHVhbFNjYWxlLCB0aGlzLl9hY3R1YWxTY2FsZSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFVwZGF0ZSB0aGUgY2FtZXJhIGFuZCB0aGVuIHNldCB0cmFuc2Zvcm1zIG9uIGEgY2FudmFzIGNvbnRleHRcXG4gICAgICovXFxuICAgIGRyYXcoY29udGV4dCwgc2NyZWVuKSB7XFxuICAgICAgICB0aGlzLnVwZGF0ZShzY3JlZW4pO1xcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1zKGNvbnRleHQpO1xcbiAgICB9XFxufVxcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IENhbWVyYTtcXG5DYW1lcmEuZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgIGFsbG93U2NhbGU6IHRydWUsXFxuICAgIG1pblNjYWxlOiAwLjUsXFxuICAgIG1heFNjYWxlOiA0LFxcbiAgICBtb3ZlRWFzZUFtb3VudDogMC4xLFxcbiAgICBzY2FsZUVhc2VBbW91bnQ6IDAuMSxcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYS8uL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGNhbid0IGJlIGlubGluZWQgYmVjYXVzZSB0aGUgZXZhbCBkZXZ0b29sIGlzIHVzZWQuXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIE1lbW9pemUgYSBmdW5jdGlvblxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemVcXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbWVtb2l6ZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb25cXG4gKi9cXG5jb25zdCBtZW1vaXplID0gZiA9PiB7XFxuICB2YXIgY2FjaGUgPSB7fTtcXG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XFxuICAgIHJldHVybiBjYWNoZVthcmdzXSA/PyAoY2FjaGVbYXJnc10gPSBmLmFwcGx5KHRoaXMsIGFyZ3MpKTtcXG4gIH07XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlciBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgTnVtYmVyIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gW3A9TnVtYmVyLkVQU0lMT05dIFRoZSBwcmVjaXNpb24gdmFsdWVcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG51bWJlcnMgYSBhbmQgYiBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxcbiAqL1xcbmNvbnN0IGZsb2F0RXF1YWxzID0gKGEsIGIsIHAgPSBOdW1iZXIuRVBTSUxPTikgPT4gTWF0aC5hYnMoYSAtIGIpIDwgcDtcXG5cXG4vKipcXG4gKiBDbGFtcCBhIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4XFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciB0byBjbGFtcFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gdmFsdWVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgY2xhbXBlZCBudW1iZXJcXG4gKi9cXG5jb25zdCBjbGFtcCA9IChhLCBtaW4gPSAwLCBtYXggPSAxKSA9PiBhIDwgbWluID8gbWluIDogKGEgPiBtYXggPyBtYXggOiBhKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGZyYWN0aW9uYWwgcGFydCBvZiBhIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgZnJvbSB3aGljaCB0byBnZXQgdGhlIGZyYWN0aW9uYWwgcGFydFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZyYWN0aW9uYWwgcGFydCBvZiB0aGUgbnVtYmVyXFxuICovXFxuY29uc3QgZnJhYyA9IGEgPT4gYSA+PSAwID8gYSAtIE1hdGguZmxvb3IoYSkgOiBhIC0gTWF0aC5jZWlsKGEpO1xcblxcbi8qKlxcbiAqIFJvdW5kIG4gdG8gZCBkZWNpbWFsIHBsYWNlc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmRcXG4gKiBAcGFyYW0ge251bWJlcn0gW2Q9MF0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byByb3VuZCB0b1xcbiAqIEByZXR1cm4ge251bWJlcn0gQSByb3VuZGVkIG51bWJlclxcbiAqL1xcbmNvbnN0IHJvdW5kID0gKG4sIGQgPSAwKSA9PiB7XFxuICBjb25zdCBwID0gTWF0aC5wb3coMTAsIGQpO1xcbiAgcmV0dXJuIE1hdGgucm91bmQobiAqIHAgKyBOdW1iZXIuRVBTSUxPTikgLyBwO1xcbn1cXG5cXG4vKipcXG4gKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKi9cXG5jb25zdCBsZXJwID0gKGEsIGIsIGkpID0+IGEgKyAoYiAtIGEpICogaTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcXG4gKi9cXG5jb25zdCB1bmxlcnAgPSAoYSwgYiwgaSkgPT4gKGkgLSBhKSAvIChiIC0gYSk7XFxuXFxuLyoqXFxuICogRG8gYSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTAgVG9wLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMSBCb3R0b20tbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGl4IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeSBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXFxuICovXFxuY29uc3QgYmxlcnAgPSAoYzAwLCBjMTAsIGMwMSwgYzExLCBpeCwgaXkpID0+IGxlcnAobGVycChjMDAsIGMxMCwgaXgpLCBsZXJwKGMwMSwgYzExLCBpeCksIGl5KTtcXG5cXG4vKipcXG4gKiBSZS1tYXAgYSBudW1iZXIgaSBmcm9tIHJhbmdlIGExLi4uYTIgdG8gYjEuLi5iMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXFxuICogQHBhcmFtIHtudW1iZXJ9IGExXFxuICogQHBhcmFtIHtudW1iZXJ9IGEyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIxXFxuICogQHBhcmFtIHtudW1iZXJ9IGIyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmNvbnN0IHJlbWFwID0gKGksIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArIChpIC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xcblxcbi8qKlxcbiAqIERvIGEgc21vb3RoIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3Qgc21vb3Roc3RlcCA9IChhLCBiLCBpKSA9PiBsZXJwKGEsIGIsIDMgKiBNYXRoLnBvdyhpLCAyKSAtIDIgKiBNYXRoLnBvdyhpLCAzKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKi9cXG5jb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiBkZWdyZWVzXFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiBkZWdyZWVzXFxuICovXFxuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEV4Y2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICovXFxuY29uc3QgcmFuZG9tQmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xcblxcbi8qKlxcbiAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICovXFxuY29uc3QgcmFuZG9tSW50QmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IFttdT0wLjVdIFRoZSBtZWFuIHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9Ml0gVGhlIG51bWJlciBvZiBzYW1wbGVzXFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb20gPSAobXUgPSAwLjUsIHNpZ21hID0gMC41LCBzYW1wbGVzID0gMikgPT4ge1xcbiAgbGV0IHRvdGFsID0gMDtcXG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XFxuICAgIHRvdGFsICs9IE1hdGgucmFuZG9tKCk7XFxuICB9XFxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlclxcbiAqL1xcbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdyBBbiBhcnJheSBvZiB3ZWlnaHRzXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbmRleCBmcm9tIHdcXG4gKi9cXG5jb25zdCB3ZWlnaHRlZFJhbmRvbSA9IHcgPT4ge1xcbiAgbGV0IHRvdGFsID0gdy5yZWR1Y2UoKGEsIGkpID0+IGEgKyBpLCAwKSwgbiA9IDA7XFxuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xcbiAgd2hpbGUgKHRvdGFsID4gcikge1xcbiAgICB0b3RhbCAtPSB3W24rK107XFxuICB9XFxuICByZXR1cm4gbiAtIDE7XFxufTtcXG5cXG4vKipcXG4gKiBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXFxuICogQGNhbGxiYWNrIEludGVycG9sYXRpb25GdW5jdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmcm9tIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIEEgbnVtYmVyIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcGFyYW0ge0ludGVycG9sYXRpb25GdW5jdGlvbn0gW2Y9TWF0aC5sZXJwXSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB0byB1c2VcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxcbiAqL1xcbmNvbnN0IGxlcnBBcnJheSA9IChhLCBpLCBmID0gbGVycCkgPT4ge1xcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcXG4gIGNvbnN0IHAgPSBjbGFtcChNYXRoLnRydW5jKHMpLCAwLCBhLmxlbmd0aCAtIDEpO1xcbiAgcmV0dXJuIGYoYVtwXSB8fCAwLCBhW3AgKyAxXSB8fCAwLCBmcmFjKHMpKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG5jb25zdCBkb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmYWN0b3JpYWwgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYVxcbiAqIEByZXR1cm4ge251bWJlcn0gYSFcXG4gKi9cXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcXG4gIGxldCByZXN1bHQgPSAxO1xcbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gYTsgaSsrKSB7XFxuICAgIHJlc3VsdCAqPSBpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxcbiAqL1xcbmNvbnN0IG5wciA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyBmYWN0b3JpYWwobiAtIHIpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5DclxcbiAqL1xcbmNvbnN0IG5jciA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyAoZmFjdG9yaWFsKHIpICogZmFjdG9yaWFsKG4gLSByKSk7XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgYWxsIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYW4gYXJyYXlcXG4gKlxcbiAqIEBleGFtcGxlXFxuICogYGBganNcXG4gKiBwZXJtdXRhdGlvbnMoWzEsIDIsIDNdLCAyKTtcXG4gKiBgYGBcXG4gKlxcbiAqIE91dHB1dDpcXG4gKiBgYGBqc29uXFxuICogW1xcbiAqICAgWzEsIDJdLFxcbiAqICAgWzEsIDNdLFxcbiAqICAgWzIsIDFdLFxcbiAqICAgWzIsIDNdLFxcbiAqICAgWzMsIDFdLFxcbiAqICAgWzMsIDJdXFxuICogXVxcbiAqIGBgYFxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGNob29zZSBpbiBlYWNoIHBlcm11dGF0aW9uXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBwZXJtdXRhdGlvbiBhcnJheXNcXG4gKi9cXG5jb25zdCBwZXJtdXRhdGlvbnMgPSAoYSwgcikgPT4ge1xcbiAgaWYgKHIgPT09IDEpIHtcXG4gICAgcmV0dXJuIGEubWFwKGl0ZW0gPT4gW2l0ZW1dKTtcXG4gIH1cXG5cXG4gIHJldHVybiBhLnJlZHVjZShcXG4gICAgKGFjYywgaXRlbSwgaSkgPT4gW1xcbiAgICAgIC4uLmFjYyxcXG4gICAgICAuLi5wZXJtdXRhdGlvbnMoYS5zbGljZSgwLCBpKS5jb25jYXQoYS5zbGljZShpICsgMSkpLCByIC0gMSkubWFwKGMgPT4gW2l0ZW0sIC4uLmNdKSxcXG4gICAgXSxcXG4gICAgW11cXG4gICk7XFxufVxcblxcbi8qKlxcbiAqIEdlbmVyYXRlIGFsbCBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGFuIGFycmF5XFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIGBgYGpzXFxuICogY29tYmluYXRpb25zKFsxLCAyLCAzXSwgMik7XFxuICogYGBgXFxuICpcXG4gKiBPdXRwdXQ6XFxuICogYGBganNvblxcbiAqIFtcXG4gKiAgIFsxLCAyXSxcXG4gKiAgIFsxLCAzXSxcXG4gKiAgIFsyLCAzXVxcbiAqIF1cXG4gKiBgYGBcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBjb21iaW5hdGlvblxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgY29tYmluYXRpb24gYXJyYXlzXFxuICovXFxuY29uc3QgY29tYmluYXRpb25zID0gKGEsIHIpID0+IHtcXG4gIGlmIChyID09PSAxKSB7XFxuICAgIHJldHVybiBhLm1hcChpdGVtID0+IFtpdGVtXSk7XFxuICB9XFxuXFxuICByZXR1cm4gYS5yZWR1Y2UoXFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcXG4gICAgICAuLi5hY2MsXFxuICAgICAgLi4uY29tYmluYXRpb25zKGEuc2xpY2UoaSArIDEpLCByIC0gMSkubWFwKGMgPT4gW2l0ZW0sIC4uLmNdKSxcXG4gICAgXSxcXG4gICAgW11cXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBjYXJ0ZXNpYW4gcHJvZHVjdCBvZiBhcnJheXNcXG4gKlxcbiAqIEBleGFtcGxlXFxuICogYGBganNcXG4gKiBjYXJ0ZXNpYW4oWzEsIDIsIDNdLCBbJ2EnLCAnYiddKTtcXG4gKiBgYGBcXG4gKlxcbiAqIE91dHB1dDpcXG4gKiBgYGBqc29uXFxuICogW1xcbiAqICAgWzEsIFxcXCJhXFxcIl0sXFxuICogICBbMSwgXFxcImJcXFwiXSxcXG4gKiAgIFsyLCBcXFwiYVxcXCJdLFxcbiAqICAgWzIsIFxcXCJiXFxcIl0sXFxuICogICBbMywgXFxcImFcXFwiXSxcXG4gKiAgIFszLCBcXFwiYlxcXCJdXFxuICogXVxcbiAqIGBgYFxcbiAqL1xcbmNvbnN0IGNhcnRlc2lhbiA9ICguLi5hcnIpID0+XFxuICBhcnIucmVkdWNlKFxcbiAgICAoYSwgYikgPT4gYS5mbGF0TWFwKGMgPT4gYi5tYXAoZCA9PiBbLi4uYywgZF0pKSxcXG4gICAgW1tdXVxcbiAgKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFycmF5IHZhbHVlc1xcbiAqIEBjYWxsYmFjayBUaW1lc0Z1bmN0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGFycmF5IGluZGV4XFxuICogQHJldHVybiB7Kn0gVGhlIGFycmF5IHZhbHVlXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxcbiAqIEBwYXJhbSB7VGltZXNGdW5jdGlvbn0gZlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxcbiAqL1xcbmNvbnN0IHRpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBudW1iZXJzIDAtPihuIC0gMSlcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBpbnRlZ2VycyAwLT4obiAtIDEpXFxuICovXFxuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XFxuXFxuLyoqXFxuICogWmlwIG11bHRpcGxlIGFycmF5cyB0b2dldGhlciwgaS5lLiAoWzEsIDIsIDNdLCBbYSwgYiwgY10pID0+IFtbMSwgYV0sIFsyLCBiXSwgWzMsIGNdXVxcbiAqIEBwYXJhbSB7Li4uQXJyYXk8Kj59IGEgVGhlIGFycmF5cyB0byB6aXBcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59XFxuICovXFxuY29uc3QgemlwID0gKC4uLmEpID0+IHRpbWVzKGkgPT4gYS5tYXAoYSA9PiBhW2ldKSwgTWF0aC5tYXgoLi4uYS5tYXAoYSA9PiBhLmxlbmd0aCkpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYXJyYXlbaV0gd2l0aCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgd3JhcHBpbmdcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhIFRoZSBhcnJheSB0byBhY2Nlc3NcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBBbiBlbGVtZW50IGZyb20gdGhlIGFycmF5XFxuICovXFxuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5IHdpdGhvdXQgcmVtb3ZpbmcgaXRcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7Kn0gVGhlIGxhc3QgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxcbiAqL1xcbmNvbnN0IHBlZWsgPSAoYSkgPT4ge1xcbiAgaWYgKCFhLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgfVxcblxcbiAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgaW5kZXggZm9yIGEgZ2l2ZW4gcG9zaXRpb24gaW4gYW4gdW5yb2xsZWQgMmQgYXJyYXlcXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBwb3NpdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSAyZCBhcnJheVxcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBpbiB0aGUgdW5yb2xsZWQgYXJyYXlcXG4gKi9cXG5jb25zdCBpbmQgPSAoeCwgeSwgdykgPT4geCArIHkgKiB3O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgcG9zaXRpb24gZm9yIGEgZ2l2ZW4gaW5kZXggaW4gYW4gdW5yb2xsZWQgMmQgYXJyYXlcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXhcXG4gKiBAcGFyYW0ge251bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIDJkIGFycmF5XFxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSBwb3NpdGlvbiBhcyBhIDItdHVwbGVcXG4gKi9cXG5jb25zdCBwb3MgPSAoaSwgdykgPT4gW2kgJSB3LCBNYXRoLmZsb29yKGkgLyB3KV07XFxuXFxuLyoqXFxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNodW5rIHNpemVcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xcbiAqL1xcbmNvbnN0IGNodW5rID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcblxcbi8qKlxcbiAqIFJhbmRvbWx5IHNodWZmbGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSBzaHVmZmxlZCBhcnJheVxcbiAqL1xcbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xcblxcbi8qKlxcbiAqIEZsYXR0ZW4gYW4gb2JqZWN0XFxuICogQHBhcmFtIHtvYmplY3R9IG9cXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uY2F0ZW5hdG9yIFRoZSBzdHJpbmcgdG8gdXNlIGZvciBjb25jYXRlbmF0aW5nIGtleXNcXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgZmxhdHRlbmVkIG9iamVjdFxcbiAqL1xcbmNvbnN0IGZsYXQgPSAobywgY29uY2F0ZW5hdG9yID0gJy4nKSA9PiB7XFxuICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xcbiAgICBpZiAob1trZXldIGluc3RhbmNlb2YgRGF0ZSkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICAuLi5hY2MsXFxuICAgICAgICBba2V5XTogb1trZXldLnRvSVNPU3RyaW5nKCksXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIG9ba2V5XSAhPT0gJ29iamVjdCcgfHwgIW9ba2V5XSkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICAuLi5hY2MsXFxuICAgICAgICBba2V5XTogb1trZXldLFxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgY29uc3QgZmxhdHRlbmVkID0gZmxhdChvW2tleV0sIGNvbmNhdGVuYXRvcik7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgLi4uYWNjLFxcbiAgICAgIC4uLk9iamVjdC5rZXlzKGZsYXR0ZW5lZCkucmVkdWNlKFxcbiAgICAgICAgKGNoaWxkQWNjLCBjaGlsZEtleSkgPT4gKHtcXG4gICAgICAgICAgLi4uY2hpbGRBY2MsXFxuICAgICAgICAgIFtgJHtrZXl9JHtjb25jYXRlbmF0b3J9JHtjaGlsZEtleX1gXTogZmxhdHRlbmVkW2NoaWxkS2V5XSxcXG4gICAgICAgIH0pLFxcbiAgICAgICAge31cXG4gICAgICApLFxcbiAgICB9O1xcbiAgfSwge30pO1xcbn07XFxuXFxuLyoqXFxuICogVW5mbGF0dGVuIGFuIG9iamVjdFxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmNhdGVuYXRvciBUaGUgc3RyaW5nIHRvIGNoZWNrIGZvciBpbiBjb25jYXRlbmF0ZWQga2V5c1xcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gdW4tZmxhdHRlbmVkIG9iamVjdFxcbiAqL1xcbmNvbnN0IHVuZmxhdCA9IChvLCBjb25jYXRlbmF0b3IgPSAnLicpID0+IHtcXG4gIGxldCByZXN1bHQgPSB7fSwgdGVtcCwgc3Vic3RyaW5ncywgcHJvcGVydHksIGk7XFxuXFxuICBmb3IgKHByb3BlcnR5IGluIG8pIHtcXG4gICAgc3Vic3RyaW5ncyA9IHByb3BlcnR5LnNwbGl0KGNvbmNhdGVuYXRvcik7XFxuICAgIHRlbXAgPSByZXN1bHQ7XFxuICAgIGZvciAoaSA9IDA7IGkgPCBzdWJzdHJpbmdzLmxlbmd0aCAtIDE7IGkrKykge1xcbiAgICAgIGlmICghKHN1YnN0cmluZ3NbaV0gaW4gdGVtcCkpIHtcXG4gICAgICAgIGlmIChpc0Zpbml0ZShzdWJzdHJpbmdzW2kgKyAxXSkpIHtcXG4gICAgICAgICAgdGVtcFtzdWJzdHJpbmdzW2ldXSA9IFtdO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGVtcFtzdWJzdHJpbmdzW2ldXSA9IHt9O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB0ZW1wID0gdGVtcFtzdWJzdHJpbmdzW2ldXTtcXG4gICAgfVxcbiAgICB0ZW1wW3N1YnN0cmluZ3Nbc3Vic3RyaW5ncy5sZW5ndGggLSAxXV0gPSBvW3Byb3BlcnR5XTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBBIHNwbGl0IHByZWRpY2F0ZVxcbiAqIEBjYWxsYmFjayBTcGxpdFByZWRpY2F0ZVxcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZVxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFycmF5IHNob3VsZCBzcGxpdCBhdCB0aGlzIGluZGV4XFxuICovXFxuXFxuLyoqXFxuICogU3BsaXQgYW4gYXJyYXkgaW50byBzdWItYXJyYXlzIGJhc2VkIG9uIGEgcHJlZGljYXRlXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyYXlcXG4gKiBAcGFyYW0ge1NwbGl0UHJlZGljYXRlfSBwcmVkaWNhdGVcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5c1xcbiAqL1xcbmNvbnN0IHNwbGl0ID0gKGFycmF5LCBwcmVkaWNhdGUpID0+IHtcXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgbGV0IGN1cnJlbnQgPSBbXTtcXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkpIHtcXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSkpIHtcXG4gICAgICBpZiAoY3VycmVudC5sZW5ndGgpIHtcXG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xcbiAgICAgIH1cXG4gICAgICBjdXJyZW50ID0gW3ZhbHVlXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjdXJyZW50LnB1c2godmFsdWUpO1xcbiAgICB9XFxuICB9XFxuICByZXN1bHQucHVzaChjdXJyZW50KTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQbHVjayBrZXlzIGZyb20gYW4gb2JqZWN0XFxuICogQHBhcmFtIHtvYmplY3R9IG9cXG4gKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBwbHVjayBmcm9tIHRoZSBvYmplY3RcXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwbHVja2VkIGtleXNcXG4gKi9cXG5jb25zdCBwbHVjayA9IChvLCAuLi5rZXlzKSA9PiB7XFxuICByZXR1cm4ga2V5cy5yZWR1Y2UoXFxuICAgIChyZXN1bHQsIGtleSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2tleV06IG9ba2V5XSB9KSxcXG4gICAge31cXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBFeGNsdWRlIGtleXMgZnJvbSBhbiBvYmplY3RcXG4gKiBAcGFyYW0ge29iamVjdH0gb1xcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBrZXlzIFRoZSBrZXlzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgb2JqZWN0XFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwga2V5cyBleGNlcHQgZXhjbHVkZWQga2V5c1xcbiAqL1xcbmNvbnN0IGV4Y2x1ZGUgPSAobywgLi4ua2V5cykgPT4ge1xcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcXG4gICAgT2JqZWN0LmVudHJpZXMobykuZmlsdGVyKChba2V5XSkgPT4gIWtleXMuaW5jbHVkZXMoa2V5KSlcXG4gICk7XFxufTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgIG1lbW9pemUsXFxuICAgIGZsb2F0RXF1YWxzLFxcbiAgICBjbGFtcCxcXG4gICAgZnJhYyxcXG4gICAgcm91bmQsXFxuICAgIGxlcnAsXFxuICAgIHVubGVycCxcXG4gICAgYmxlcnAsXFxuICAgIHJlbWFwLFxcbiAgICBzbW9vdGhzdGVwLFxcbiAgICByYWRpYW5zLFxcbiAgICBkZWdyZWVzLFxcbiAgICByYW5kb21CZXR3ZWVuLFxcbiAgICByYW5kb21JbnRCZXR3ZWVuLFxcbiAgICBjbHRSYW5kb20sXFxuICAgIGNsdFJhbmRvbUludCxcXG4gICAgd2VpZ2h0ZWRSYW5kb20sXFxuICAgIGxlcnBBcnJheSxcXG4gICAgZG90LFxcbiAgICBmYWN0b3JpYWwsXFxuICAgIG5wcixcXG4gICAgbmNyLFxcbiAgICBwZXJtdXRhdGlvbnMsXFxuICAgIGNvbWJpbmF0aW9ucyxcXG4gICAgY2FydGVzaWFuLFxcbiAgICB0aW1lcyxcXG4gICAgcmFuZ2UsXFxuICAgIHppcCxcXG4gICAgYXQsXFxuICAgIHBlZWssXFxuICAgIGluZCxcXG4gICAgcG9zLFxcbiAgICBjaHVuayxcXG4gICAgc2h1ZmZsZSxcXG4gICAgZmxhdCxcXG4gICAgdW5mbGF0LFxcbiAgICBzcGxpdCxcXG4gICAgcGx1Y2ssXFxuICAgIGV4Y2x1ZGUsXFxuICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycy8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5ldmFsKFwiLyoqXFxuICogQG92ZXJ2aWV3IEEgc21hbGwgdmVjdG9yIGFuZCBtYXRyaXggbGlicmFyeVxcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuY29uc3QgX3ZlY190aW1lcyA9IChmLCBuKSA9PiBBcnJheShuKS5maWxsKDApLm1hcCgoXywgaSkgPT4gZihpKSk7XFxuY29uc3QgX3ZlY19jaHVuayA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcbmNvbnN0IF92ZWNfZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xcbmNvbnN0IF92ZWNfaXNfdmVjMiA9IGEgPT4gdHlwZW9mIGEgPT09ICdvYmplY3QnICYmICd4JyBpbiBhICYmICd5JyBpbiBhO1xcbmNvbnN0IF92ZWNfaXNfdmVjMyA9IGEgPT4gdHlwZW9mIGEgPT09ICdvYmplY3QnICYmICd4JyBpbiBhICYmICd5JyBpbiBhICYmICd6JyBpbiBhO1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjMlxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgMmQgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IDJkIHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMigzLCAyKTsgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMyKDQpOyAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYzIoYSk7ICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjMigpOyAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjMiA9ICh4LCB5KSA9PiB7XFxuICBpZiAoIXggJiYgIXkpIHtcXG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAgfTtcXG4gIH1cXG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCB9O1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxcbiAqL1xcbnZlYzIuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55XTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSB2ZWN0b3IgZnJvbSBhbiBhcnJheSBvZiBjb21wb25lbnRzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIG5ldyB2ZWN0b3JcXG4gKi9cXG52ZWMyLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMyKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMikpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICovXFxudmVjMi51eCA9ICgpID0+IHZlYzIoMSwgMCk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKi9cXG52ZWMyLnV5ID0gKCkgPT4gdmVjMigwLCAxKTtcXG5cXG4vKipcXG4gKiBBZGQgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSArIGJcXG4gKi9cXG52ZWMyLmFkZCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKyAoYi54ID8/IGIpLCB5OiBhLnkgKyAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgLSBiXFxuICovXFxudmVjMi5zdWIgPSAoYSwgYikgPT4gKHsgeDogYS54IC0gKGIueCA/PyBiKSwgeTogYS55IC0gKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAqIGJcXG4gKi9cXG52ZWMyLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMi5tdWxcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKiBiXFxuICovXFxudmVjMi5zY2FsZSA9IChhLCBiKSA9PiB2ZWMyLm11bChhLCBiKTtcXG5cXG4vKipcXG4gKiBEaXZpZGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgLyBiXFxuICovXFxudmVjMi5kaXYgPSAoYSwgYikgPT4gKHsgeDogYS54IC8gKGIueCA/PyBiKSwgeTogYS55IC8gKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMi5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzIubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHt2ZWMyfSBeYVxcbiAqL1xcbnZlYzIubm9yID0gYSA9PiB7XFxuICBsZXQgbGVuID0gdmVjMi5sZW4oYSk7XFxuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiB9IDogdmVjMigpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxcbiAqL1xcbnZlYzIuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMyLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59O1xcblxcbi8qKlxcbiAqIEZhc3QgbWV0aG9kIHRvIHJvdGF0ZSBhIHZlY3RvciBieSAtOTAsIDkwIG9yIDE4MCBkZWdyZWVzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgMSBmb3IgOTAgZGVncmVlcyAoY3cpLCAtMSBmb3IgLTkwIGRlZ3JlZXMgKGNjdyksIDIgb3IgLTIgZm9yIDE4MCBkZWdyZWVzXFxuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzIucm90ZiA9IChhLCByKSA9PiB7XFxuICBzd2l0Y2ggKHIpIHtcXG4gICAgY2FzZSAxOiByZXR1cm4gdmVjMihhLnksIC1hLngpO1xcbiAgICBjYXNlIC0xOiByZXR1cm4gdmVjMigtYS55LCBhLngpO1xcbiAgICBjYXNlIDI6IGNhc2UgLTI6IHJldHVybiB2ZWMyKC1hLngsIC1hLnkpO1xcbiAgICBkZWZhdWx0OiByZXR1cm4gYTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFNjYWxhciBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIMOXIGJcXG4gKi9cXG52ZWMyLmNyb3NzID0gKGEsIGIpID0+IHtcXG4gIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbnZlYzIuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMyLnJhZCA9IGEgPT4gTWF0aC5hdGFuMihhLnksIGEueCk7XFxuXFxuLyoqXFxuICogQ29weSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMyLmNweSA9IGEgPT4gdmVjMihhKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSAyZCB2ZWN0b3JcXG4gKiBAY2FsbGJhY2sgdmVjMk1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMyLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JykgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzIuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogU3dpenpsZSBhIHZlY3RvciB3aXRoIGEgc3RyaW5nIG9mIGNvbXBvbmVudCBsYWJlbHNcXG4gKlxcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XFxuICogLSBgeGAgb3IgYHlgXFxuICogLSBgdWAgb3IgYHZgIChhbGlhc2VzIGZvciBgeGAgYW5kIGB5YCwgcmVzcGVjdGl2ZWx5KVxcbiAqIC0gYFhgLCBgWWAsIGBVYCwgYFZgIChuZWdhdGVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSlcXG4gKiAtIGAwYCBvciBgMWAgKHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdW5jaGFuZ2VkKVxcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcXG4gKlxcbiAqIEFueSBvdGhlciBjaGFyYWN0ZXJzIHdpbGwgZGVmYXVsdCB0byAwXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc3dpenpsZWQgY29tcG9uZW50c1xcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnN3aXp6bGluZyBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzIoMywgLTIpO1xcbiAqIHZlYzIuc3dpeihhLCAneCcpOyAgICAvLyBbM11cXG4gKiB2ZWMyLnN3aXooYSwgJ3l4Jyk7ICAgLy8gWy0yLCAzXVxcbiAqIHZlYzIuc3dpeihhLCAneFknKTsgICAvLyBbMywgMl1cXG4gKiB2ZWMyLnN3aXooYSwgJ1l5Jyk7ICAgLy8gWzIsIC0yXVxcbiAqIHZlYzIuc3dpeihhLCAneC54Jyk7ICAvLyBbMywgLTIsIDNdXFxuICogdmVjMi5zd2l6KGEsICd5MDF4Jyk7IC8vIFstMiwgMCwgMSwgM11cXG4gKi9cXG52ZWMyLnN3aXogPSAoYSwgcyA9ICcuLicpID0+IHtcXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgcy5zcGxpdCgnJykuZm9yRWFjaCgoYywgaSkgPT4ge1xcbiAgICBzd2l0Y2ggKGMpIHtcXG4gICAgICBjYXNlICd4JzogY2FzZSAndSc6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ3knOiBjYXNlICd2JzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWSc6IGNhc2UgJ1YnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMCc6IHJlc3VsdC5wdXNoKDApOyBicmVhaztcXG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnldW2ldID8/IDApOyBicmVhaztcXG4gICAgICBkZWZhdWx0OiByZXN1bHQucHVzaCgwKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gcG9sYXJDb29yZGluYXRlczJkXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIHBvbGFyIGNvb3JkaW5hdGVzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMyZH0gVGhlIG1hZ25pdHVkZSBhbmQgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzIucG9sYXIgPSBhID0+ICh7IHI6IHZlYzIubGVuKGEpLCB0aGV0YTogTWF0aC5hdGFuMihhLnksIGEueCkgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBwb2xhciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxcbiAqL1xcbnZlYzIuZnJvbVBvbGFyID0gKHIsIHRoZXRhKSA9PiB2ZWMyKHIgKiBNYXRoLmNvcyh0aGV0YSksIHIgKiBNYXRoLnNpbih0aGV0YSkpO1xcblxcbi8qKlxcbiAqIEEgM2QgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjM1xcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geiBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyAzZCB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMzfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIHRoZSB6IGNvbXBvbmVudCBpZiB4IGlzIGEgdmVjMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbel0gVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyAzZCB2ZWN0b3JcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj52YXJpb3VzIHdheXMgdG8gaW5pdGlhbGlzZSBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzMoMywgMiwgMSk7ICAgICAgIC8vICgzLCAyLCAxKVxcbiAqIGxldCBiID0gdmVjMyg0LCA1KTsgICAgICAgICAgLy8gKDQsIDUsIDApXFxuICogbGV0IGMgPSB2ZWMzKDYpOyAgICAgICAgICAgICAvLyAoNiwgNiwgNilcXG4gKiBsZXQgZCA9IHZlYzMoYSk7ICAgICAgICAgICAgIC8vICgzLCAyLCAxKVxcbiAqIGxldCBlID0gdmVjMygpOyAgICAgICAgICAgICAgLy8gKDAsIDAsIDApXFxuICogbGV0IGYgPSB2ZWMzKHZlYzIoMSwgMiksIDMpOyAvLyAoMSwgMiwgMylcXG4gKiBsZXQgZyA9IHZlYzModmVjMig0LCA1KSk7ICAgIC8vICg0LCA1LCAwKVxcbiAqL1xcbmNvbnN0IHZlYzMgPSAoeCwgeSwgeikgPT4ge1xcbiAgaWYgKCF4ICYmICF5ICYmICF6KSB7XFxuICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcXG4gIH1cXG4gIGlmIChfdmVjX2lzX3ZlYzMoeCkpIHtcXG4gICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwLCB6OiB4LnogfHwgMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHkgfHwgMCB9O1xcbiAgfVxcbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4LCB6OiB6ID8/IHggfTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcXG4gKi9cXG52ZWMzLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueSwgYS56XTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSB2ZWN0b3IgZnJvbSBhbiBhcnJheSBvZiBjb21wb25lbnRzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyB2ZWN0b3JcXG4gKi9cXG52ZWMzLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMzKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMykpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwLCAwKVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDEsIDAsIDApXFxuICovXFxudmVjMy51eCA9ICgpID0+IHZlYzMoMSwgMCwgMCk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEsIDApXFxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMCwgMSwgMClcXG4gKi9cXG52ZWMzLnV5ID0gKCkgPT4gdmVjMygwLCAxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAwLCAxKVxcbiAqL1xcbnZlYzMudXogPSAoKSA9PiB2ZWMzKDAsIDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICsgYlxcbiAqL1xcbnZlYzMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIChiLnggPz8gYiksIHk6IGEueSArIChiLnkgPz8gYiksIHo6IGEueiArIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAtIGJcXG4gKi9cXG52ZWMzLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpLCB6OiBhLnogLSAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICogYlxcbiAqL1xcbnZlYzMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYiksIHo6IGEueiAqIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMzLm11bFxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAqIGJcXG4gKi9cXG52ZWMzLnNjYWxlID0gKGEsIGIpID0+IHZlYzMubXVsKGEsIGIpO1xcblxcbi8qKlxcbiAqIERpdmlkZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAvIGJcXG4gKi9cXG52ZWMzLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpLCB6OiBhLnogLyAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMzLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSArIGEueiAqIGEueik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpICsgTWF0aC5hYnMoYS56KTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHt2ZWMzfSBeYVxcbiAqL1xcbnZlYzMubm9yID0gYSA9PiB7XFxuICBsZXQgbGVuID0gdmVjMy5sZW4oYSk7XFxuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiwgejogYS56IC8gbGVuIH0gOiB2ZWMzKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxudmVjMy5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55ICsgYS56ICogYi56O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHJvdGF0aW9uIG1hdHJpeFxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bWF0fSBtIFRoZSByb3RhdGlvbiBtYXRyaXhcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3QgPSAoYSwgbSkgPT4gdmVjMyhcXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAxKSksIGEpLFxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDIpKSwgYSksXFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMykpLCBhKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHggYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R4ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLngsXFxuICBhLnkgKiBNYXRoLmNvcyhyKSAtIGEueiAqIE1hdGguc2luKHIpLFxcbiAgYS55ICogTWF0aC5zaW4ocikgKyBhLnogKiBNYXRoLmNvcyhyKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHkgYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R5ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLnggKiBNYXRoLmNvcyhyKSArIGEueiAqIE1hdGguc2luKHIpLFxcbiAgYS55LFxcbiAgLWEueCAqIE1hdGguc2luKHIpICsgYS56ICogTWF0aC5jb3MocilcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB6IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90eiA9IChhLCByKSA9PiB2ZWMzKFxcbiAgYS54ICogTWF0aC5jb3MocikgLSBhLnkgKiBNYXRoLnNpbihyKSxcXG4gIGEueCAqIE1hdGguc2luKHIpICsgYS55ICogTWF0aC5jb3MociksXFxuICBhLnpcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHF1YXRlcm5pb25cXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHEgVGhlIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90cSA9ICh2LCBxKSA9PiB7XFxuICBpZiAocS5sZW5ndGggIT09IDQpIHtcXG4gICAgcmV0dXJuIHZlYzMoKTtcXG4gIH1cXG5cXG4gIGNvbnN0IGQgPSBNYXRoLnNxcnQocVswXSAqIHFbMF0gKyBxWzFdICogcVsxXSArIHFbMl0gKiBxWzJdICsgcVszXSAqIHFbM10pO1xcbiAgaWYgKGQgPT09IDApIHtcXG4gICAgcmV0dXJuIHZlYzMoKTtcXG4gIH1cXG5cXG4gIGNvbnN0IHVxID0gW3FbMF0gLyBkLCBxWzFdIC8gZCwgcVsyXSAvIGQsIHFbM10gLyBkXTtcXG4gIGNvbnN0IHUgPSB2ZWMzKC4uLnVxLnNsaWNlKDAsIDMpKTtcXG4gIGNvbnN0IHMgPSB1cVszXTtcXG4gIHJldHVybiB2ZWMzLmFkZChcXG4gICAgdmVjMy5hZGQoXFxuICAgICAgdmVjMy5tdWwodSwgMiAqIHZlYzMuZG90KHUsIHYpKSxcXG4gICAgICB2ZWMzLm11bCh2LCBzICogcyAtIHZlYzMuZG90KHUsIHUpKVxcbiAgICApLFxcbiAgICB2ZWMzLm11bCh2ZWMzLmNyb3NzKHUsIHYpLCAyICogcylcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgRXVsZXIgYW5nbGVzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHt2ZWMzfSBlIFRoZSBFdWxlciBhbmdsZXMgdG8gcm90YXRlIGJ5XFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90YSA9IChhLCBlKSA9PiB2ZWMzLnJvdHoodmVjMy5yb3R5KHZlYzMucm90eChhLCBlLngpLCBlLnkpLCBlLnopO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjM30gYSDDlyBiXFxuICovXFxudmVjMy5jcm9zcyA9IChhLCBiKSA9PiB2ZWMzKFxcbiAgYS55ICogYi56IC0gYS56ICogYi55LFxcbiAgYS56ICogYi54IC0gYS54ICogYi56LFxcbiAgYS54ICogYi55IC0gYS55ICogYi54XFxuKTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbnZlYzMuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnkgJiYgYS56ID09PSBiLno7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB4IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMy5yYWR4ID0gYSA9PiBNYXRoLmF0YW4yKGEueiwgYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHkgYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMzLnJhZHkgPSBhID0+IE1hdGguYXRhbjIoYS54LCBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeiBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzMucmFkeiA9IGEgPT4gTWF0aC5hdGFuMihhLnksIGEueik7XFxuXFxuLyoqXFxuICogQ29weSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMzLmNweSA9IGEgPT4gdmVjMyhhKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSAzZCB2ZWN0b3JcXG4gKiBAY2FsbGJhY2sgdmVjM01hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5JyB8ICd6J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCwgeSBvciB6KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMzLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JyksIHo6IGYoYS56LCAneicpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMzLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX0ke3N9JHthLnp9YDtcXG5cXG4vKipcXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xcbiAqXFxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcXG4gKiAtIGB4YCwgYHlgIG9yIGB6YFxcbiAqIC0gYHVgLCBgdmAgb3IgYHdgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXFxuICogLSBgcmAsIGBnYCBvciBgYmAgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcXG4gKiAtIGBYYCwgYFlgLCBgWmAsIGBVYCwgYFZgLCBgV2AsIGBSYCwgYEdgLCBgQmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXFxuICogLSBgLmAgdG8gcmV0dXJuIHRoZSBjb21wb25lbnQgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBhdCB0aGlzIHBvc2l0aW9uIChvciAwKVxcbiAqXFxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBzd2l6emxlXFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc3dpenpsZWQgY29tcG9uZW50c1xcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnN3aXp6bGluZyBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzMoMywgLTIsIDEpO1xcbiAqIHZlYzMuc3dpeihhLCAneCcpOyAgICAgLy8gWzNdXFxuICogdmVjMy5zd2l6KGEsICd6eXgnKTsgICAvLyBbMSwgLTIsIDNdXFxuICogdmVjMy5zd2l6KGEsICd4WVonKTsgICAvLyBbMywgMiwgLTFdXFxuICogdmVjMy5zd2l6KGEsICdaengnKTsgICAvLyBbLTEsIDEsIDNdXFxuICogdmVjMy5zd2l6KGEsICd4LngnKTsgICAvLyBbMywgLTIsIDNdXFxuICogdmVjMy5zd2l6KGEsICd5MDF6eCcpOyAvLyBbLTIsIDAsIDEsIDEsIDNdXFxuICovXFxudmVjMy5zd2l6ID0gKGEsIHMgPSAnLi4uJykgPT4ge1xcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XFxuICAgIHN3aXRjaCAoYykge1xcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogY2FzZSAncic6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ3knOiBjYXNlICd2JzogY2FzZSAnZyc6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ3onOiBjYXNlICd3JzogY2FzZSAnYic6IHJlc3VsdC5wdXNoKGEueik7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogY2FzZSAnUic6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcXG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IGNhc2UgJ0cnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWic6IGNhc2UgJ1cnOiBjYXNlICdCJzogcmVzdWx0LnB1c2goLWEueik7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMSc6IHJlc3VsdC5wdXNoKDEpOyBicmVhaztcXG4gICAgICBjYXNlICcuJzogcmVzdWx0LnB1c2goW2EueCwgYS55LCBhLnpdW2ldID8/IDApOyBicmVhaztcXG4gICAgICBkZWZhdWx0OiByZXN1bHQucHVzaCgwKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgM2QgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gcG9sYXJDb29yZGluYXRlczNkXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSB0aWx0IGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGhpIFRoZSBwYW4gYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBwb2xhciBjb29yZGluYXRlc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcmV0dXJuIHtwb2xhckNvb3JkaW5hdGVzM2R9IFRoZSBtYWduaXR1ZGUsIHRpbHQgYW5kIHBhbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMy5wb2xhciA9IGEgPT4ge1xcbiAgbGV0IHIgPSB2ZWMzLmxlbihhKSxcXG4gICAgdGhldGEgPSBNYXRoLmFjb3MoYS55IC8gciksXFxuICAgIHBoaSA9IE1hdGguYXRhbjIoYS56LCBhLngpO1xcbiAgcmV0dXJuIHsgciwgdGhldGEsIHBoaSB9O1xcbn07XFxuXFxuLyoqXFxuICogQ29udmVydCBwb2xhciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFRoZSB0aWx0IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gcGhpIFRoZSBwYW4gb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcXG4gKi9cXG52ZWMzLmZyb21Qb2xhciA9IChyLCB0aGV0YSwgcGhpKSA9PiB7XFxuICBjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcXG4gIHJldHVybiB2ZWMzKFxcbiAgICByICogc2luVGhldGEgKiBNYXRoLmNvcyhwaGkpLFxcbiAgICByICogTWF0aC5jb3ModGhldGEpLFxcbiAgICByICogc2luVGhldGEgKiBNYXRoLnNpbihwaGkpXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IF92ZWNfdGltZXMoaSA9PiBtYXQuZ2V0KGEsIChpICsgMSksIG4pLCBhLm0pO1xcblxcbi8qKlxcbiAqIEFkZCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKyBiXFxuICovXFxubWF0LmFkZCA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2ICsgYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgLSBiXFxuICovXFxubWF0LnN1YiA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2IC0gYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBNdWx0aXBseSBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIF92ZWNfZG90KG1hdC5yb3coYSwgaSksIG1hdC5jb2woYiwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIE11bHRpcGx5IGEgbWF0cml4IGJ5IGEgdmVjdG9yXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge3ZlYzJ8dmVjM3xudW1iZXJbXX0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlYzJ8dmVjM3xudW1iZXJbXXxmYWxzZX0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBhbmQgdmVjdG9yIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bHYgPSAoYSwgYikgPT4ge1xcbiAgbGV0IG4sIGJiLCBydDtcXG4gIGlmIChfdmVjX2lzX3ZlYzMoYikpIHtcXG4gICAgYmIgPSB2ZWMzLmNvbXBvbmVudHMoYik7XFxuICAgIG4gPSAzO1xcbiAgICBydCA9IHZlYzMuZnJvbUNvbXBvbmVudHM7XFxuICB9IGVsc2UgaWYgKF92ZWNfaXNfdmVjMihiKSkge1xcbiAgICBiYiA9IHZlYzIuY29tcG9uZW50cyhiKTtcXG4gICAgbiA9IDI7XFxuICAgIHJ0ID0gdmVjMi5mcm9tQ29tcG9uZW50cztcXG4gIH0gZWxzZSB7XFxuICAgIGJiID0gYjtcXG4gICAgbiA9IGIubGVuZ3RoID8/IDA7XFxuICAgIHJ0ID0gdiA9PiB2O1xcbiAgfVxcbiAgaWYgKGEubiAhPT0gbikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgcmVzdWx0LnB1c2goX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgYmIpKTtcXG4gIH1cXG4gIHJldHVybiBydChyZXN1bHQpO1xcbn1cXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgX3ZlY190aW1lcyhpID0+IG1hdC5jb2woYSwgKGkgKyAxKSksIGEubikuZmxhdCgpKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG1pbm9yIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxmYWxzZX0gfGF8IG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5kZXQgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGlmIChhLm0gPT09IDEpIHtcXG4gICAgcmV0dXJuIGEuZW50cmllc1swXTtcXG4gIH1cXG4gIGlmIChhLm0gPT09IDIpIHtcXG4gICAgcmV0dXJuIGEuZW50cmllc1swXSAqIGEuZW50cmllc1szXSAtIGEuZW50cmllc1sxXSAqIGEuZW50cmllc1syXTtcXG4gIH1cXG4gIGxldCB0b3RhbCA9IDAsIHNpZ24gPSAxO1xcbiAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgdG90YWwgKz0gc2lnbiAqIGEuZW50cmllc1tqIC0gMV0gKiBtYXQuZGV0KG1hdC5taW5vcihhLCAxLCBqKSk7XFxuICAgIHNpZ24gKj0gLTE7XFxuICB9XFxuICByZXR1cm4gdG90YWw7XFxufTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gXmEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm5vciA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICByZXR1cm4gbWF0Lm1hcChhLCBpID0+IGkgKiBkKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYWRqdWdhdGUgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxcbiAqIEByZXR1cm4ge21hdH0gVGhlIGFkanVnYXRlIG9mIGFcXG4gKi9cXG5tYXQuYWRqID0gYSA9PiB7XFxuICBjb25zdCBtaW5vcnMgPSBtYXQoYS5tLCBhLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KG1pbm9ycywgaSwgaiwgbWF0LmRldChtYXQubWlub3IoYSwgaSwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgY29uc3QgY29mYWN0b3JzID0gbWF0Lm1hcChtaW5vcnMsICh2LCBpKSA9PiB2ICogKGkgJSAyID8gLTEgOiAxKSk7XFxuICByZXR1cm4gbWF0LnRyYW5zKGNvZmFjdG9ycyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGludmVydFxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gX3ZlY19jaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XFxuXFxuaWYgKHRydWUpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0geyB2ZWMyLCB2ZWMzLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY2FudmFzLWhlbHBlcnMvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLndpdGhDb250ZXh0ID0gd2l0aENvbnRleHQ7XFxuZXhwb3J0cy5saW5lID0gbGluZTtcXG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XFxuZXhwb3J0cy5hcnJvdyA9IGFycm93O1xcbmV4cG9ydHMuY2lyY2xlID0gY2lyY2xlO1xcbmV4cG9ydHMucmVjdGFuZ2xlID0gcmVjdGFuZ2xlO1xcbmV4cG9ydHMucG9seWdvbiA9IHBvbHlnb247XFxuZXhwb3J0cy5wYXRoID0gcGF0aDtcXG5jb25zdCB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuY29uc3QgdmVjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS92ZWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcXFwiKTtcXG5jb25zdCBERUZBVUxUX1NUWUxFX09QVElPTlMgPSB7XFxuICAgIGJhdGNoOiBmYWxzZSxcXG4gICAgZmlsbDogZmFsc2UsXFxuICAgIGZpbGxDb2xvcjogbnVsbCxcXG4gICAgZ3JhZGllbnQ6IG51bGwsXFxuICAgIHN0cm9rZTogdHJ1ZSxcXG4gICAgc3Ryb2tlQ29sb3I6IG51bGwsXFxuICAgIGxpbmVXaWR0aDogMSxcXG4gICAgbGluZVN0eWxlOiAnc29saWQnLFxcbiAgICBsaW5lRGFzaDogbnVsbCxcXG4gICAgY3Jvc3NTdHlsZTogJ3gnLFxcbiAgICByb3VuZGVkOiBmYWxzZSxcXG4gICAgYXJyb3c6IHtcXG4gICAgICAgIHR5cGU6ICdjYXJldCcsXFxuICAgICAgICBzaXplOiA1LFxcbiAgICB9LFxcbn07XFxuY29uc3QgREVGQVVMVF9MSU5FX0RBU0hFUyA9IHtcXG4gICAgc29saWQ6IFtdLFxcbiAgICBkYXNoZWQ6IFs1LCA1XSxcXG4gICAgZG90dGVkOiBbMSwgM10sXFxufTtcXG5jb25zdCBCRVpJRVJfTUFUUklDRVMgPSB7XFxuICAgIDE6ICgwLCB2ZWNfMS5tYXQpKDIsIDIsIFstMSwgMSwgMSwgMF0pLFxcbiAgICAyOiAoMCwgdmVjXzEubWF0KSgzLCAzLCBbMSwgLTIsIDEsIC0yLCAyLCAwLCAxLCAwLCAwXSksXFxuICAgIDM6ICgwLCB2ZWNfMS5tYXQpKDQsIDQsIFstMSwgMywgLTMsIDEsIDMsIC02LCAzLCAwLCAtMywgMywgMCwgMCwgMSwgMCwgMCwgMF0pLFxcbn07XFxuY29uc3QgQkVaSUVSX0NPRUZGSUNJRU5UUyA9ICh0LCBvcmRlcikgPT4gKHtcXG4gICAgMTogW3QsIDFdLFxcbiAgICAyOiBbdCAqIHQsIHQsIDFdLFxcbiAgICAzOiBbdCAqIHQgKiB0LCB0ICogdCwgdCwgMV0sXFxufVtvcmRlcl0pO1xcbmNvbnN0IENBVE1VTExfUk9NX0JBU0lTX0ZVTkNUSU9OUyA9IFtcXG4gICAgKHQsIHRlbnNpb24pID0+IC10ZW5zaW9uICogTWF0aC5wb3codCwgMykgKyAyICogdGVuc2lvbiAqIE1hdGgucG93KHQsIDIpIC0gdGVuc2lvbiAqIHQsXFxuICAgICh0LCB0ZW5zaW9uKSA9PiAoMiAtIHRlbnNpb24pICogTWF0aC5wb3codCwgMykgKyAodGVuc2lvbiAtIDMpICogTWF0aC5wb3codCwgMikgKyAxLFxcbiAgICAodCwgdGVuc2lvbikgPT4gKHRlbnNpb24gLSAyKSAqIE1hdGgucG93KHQsIDMpICtcXG4gICAgICAgICgzIC0gMiAqIHRlbnNpb24pICogTWF0aC5wb3codCwgMikgK1xcbiAgICAgICAgdGVuc2lvbiAqIHQsXFxuICAgICh0LCB0ZW5zaW9uKSA9PiB0ZW5zaW9uICogTWF0aC5wb3codCwgMykgLSB0ZW5zaW9uICogTWF0aC5wb3codCwgMiksXFxuXTtcXG5jb25zdCBDQVRNVUxMX1JPTV9CQVNJU19WRUNUT1IgPSAodCwgdGVuc2lvbikgPT4gQ0FUTVVMTF9ST01fQkFTSVNfRlVOQ1RJT05TLm1hcChmID0+IGYodCwgdGVuc2lvbikpO1xcbi8qKlxcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIENvbG9yIG9iamVjdFxcbiAqL1xcbmZ1bmN0aW9uIGlzQ29sb3JPYmplY3QoY29sb3IpIHtcXG4gICAgcmV0dXJuICh0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnICYmXFxuICAgICAgICAncicgaW4gY29sb3IgJiZcXG4gICAgICAgICdnJyBpbiBjb2xvciAmJlxcbiAgICAgICAgJ2InIGluIGNvbG9yICYmXFxuICAgICAgICAodHlwZW9mIGNvbG9yLmEgPT09ICdudW1iZXInIHx8ICEoJ2EnIGluIGNvbG9yKSkpO1xcbn1cXG4vKipcXG4gKiBDb252ZXJ0IGEgY29sb3Igb2JqZWN0IHRvIGEgc3RyaW5nIGluIHRoZSBmb3JtYXQgXFxcInJnYmEociwgZywgYiwgYSlcXFwiXFxuICovXFxuZnVuY3Rpb24gY29sb3VyVG9TdHJpbmcoY29sb3IpIHtcXG4gICAgdmFyIF9hO1xcbiAgICByZXR1cm4gYHJnYmEoJHtjb2xvci5yfSwgJHtjb2xvci5nfSwgJHtjb2xvci5ifSwgJHsoX2EgPSBjb2xvci5hKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxfSlgO1xcbn1cXG4vKipcXG4gKiBQcmVwYXJlIGEgY29sb3IgdmFsdWUgKHN0cmluZyBvciBDb2xvciBvYmplY3QpIGZvciB1c2UgaW4gc3R5bGVzXFxuICovXFxuZnVuY3Rpb24gcHJlcGFyZUNvbG9yKGNvbG9yKSB7XFxuICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAvLyBBc3N1bWUgaXQncyBhbHJlYWR5IGEgdmFsaWQgQ1NTIGNvbG9yIHN0cmluZ1xcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xcbiAgICB9XFxuICAgIGVsc2UgaWYgKGlzQ29sb3JPYmplY3QoY29sb3IpKSB7XFxuICAgICAgICAvLyBDb252ZXJ0IENvbG9yIG9iamVjdCB0byBDU1MgY29sb3Igc3RyaW5nXFxuICAgICAgICByZXR1cm4gY29sb3VyVG9TdHJpbmcoY29sb3IpO1xcbiAgICB9XFxuICAgIC8vIElmIGl0J3MgbmVpdGhlciwgZGVmYXVsdCB0byBibGFja1xcbiAgICByZXR1cm4gJ2JsYWNrJztcXG59XFxuLyoqXFxuICogUHJlcGFyZSBhIGdyYWRpZW50IGZvciB1c2UgaW4gc3R5bGVzXFxuICpcXG4gKiBSZXR1cm5zIGEgQ2FudmFzR3JhZGllbnQgb2JqZWN0IG9yIG51bGwgaWYgbm8gZ3JhZGllbnQgaXMgc3BlY2lmaWVkXFxuICovXFxuZnVuY3Rpb24gcHJlcGFyZUdyYWRpZW50KGNvbnRleHQsIHN0eWxlKSB7XFxuICAgIGlmICghc3R5bGUpIHtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIGxldCBncmFkaWVudDtcXG4gICAgaWYgKHN0eWxlLnR5cGUgPT09ICdsaW5lYXInKSB7XFxuICAgICAgICBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoc3R5bGUuc3RhcnQueCwgc3R5bGUuc3RhcnQueSwgc3R5bGUuZW5kLngsIHN0eWxlLmVuZC55KTtcXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICAgIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChzdHlsZS5zdGFydC54LCBzdHlsZS5zdGFydC55LCAwLCBzdHlsZS5zdGFydC54LCBzdHlsZS5zdGFydC55LCB2ZWNfMS52ZWMyLmxlbih2ZWNfMS52ZWMyLnN1YihzdHlsZS5lbmQsIHN0eWxlLnN0YXJ0KSkgLyAyKTtcXG4gICAgfVxcbiAgICBmb3IgKGNvbnN0IHN0b3Agb2Ygc3R5bGUuY29sb3JTdG9wcykge1xcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AucG9zaXRpb24sIHByZXBhcmVDb2xvcihzdG9wLmNvbG9yKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGdyYWRpZW50O1xcbn1cXG4vKipcXG4gKiBHZXQgYSBjb21wbGV0ZSBzdHlsZSBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcyBmaWxsZWQgaW5cXG4gKi9cXG5mdW5jdGlvbiBnZXRTdHlsZShzdHlsZSkge1xcbiAgICB2YXIgX2E7XFxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NUWUxFX09QVElPTlMsIHtcXG4gICAgICAgIC4uLihzdHlsZSAhPT0gbnVsbCAmJiBzdHlsZSAhPT0gdm9pZCAwID8gc3R5bGUgOiB7fSksXFxuICAgICAgICBsaW5lRGFzaDogc3R5bGUgJiYgc3R5bGUubGluZURhc2ggIT09IHVuZGVmaW5lZFxcbiAgICAgICAgICAgID8gc3R5bGUubGluZURhc2hcXG4gICAgICAgICAgICA6IChzdHlsZSA9PT0gbnVsbCB8fCBzdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGUubGluZVN0eWxlKSA9PT0gdW5kZWZpbmVkXFxuICAgICAgICAgICAgICAgID8gW11cXG4gICAgICAgICAgICAgICAgOiBERUZBVUxUX0xJTkVfREFTSEVTWyhfYSA9IHN0eWxlLmxpbmVTdHlsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3NvbGlkJ10sXFxuICAgIH0pO1xcbn1cXG4vKipcXG4gKiBQYXNzIGluIGEgY29udGV4dCBhbmQgc29tZSBudW1iZXIgb2YgZnVuY3Rpb25zIHRoYXQgdGFrZSBhIGNvbnRleHQgYXMgdGhlaXJcXG4gKiBmaXJzdCBhcmd1bWVudCwgYW5kIHJldHVybiBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCBkb24ndCByZXF1aXJlIHRoZVxcbiAqIGNvbnRleHQgYXJndW1lbnRcXG4gKlxcbiAqIElmIG9ubHkgb25lIGZ1bmN0aW9uIGlzIHBhc3NlZCwgdGhpcyB3aWxsIHJldHVybiBhIHNpbmdsZSBmdW5jdGlvblxcbiAqL1xcbmZ1bmN0aW9uIHdpdGhDb250ZXh0KGNvbnRleHQsIC4uLmZ1bmN0aW9ucykge1xcbiAgICBjb25zdCByZXN1bHQgPSBmdW5jdGlvbnMubWFwKGYgPT4ge1xcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XFxuICAgICAgICAgICAgZihjb250ZXh0LCAuLi5hcmdzKTtcXG4gICAgICAgIH07XFxuICAgIH0pO1xcbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcXG59XFxuLyoqXFxuICogRHJhdyBhIHN0cmFpZ2h0IGxpbmUgc2VnbWVudCBiZXR3ZWVuIHR3byBwb2ludHNcXG4gKi9cXG5mdW5jdGlvbiBsaW5lKGNvbnRleHQsIHN0YXJ0LCBlbmQsIHN0eWxlKSB7XFxuICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAvLyBBcHBseSBzdHlsZXNcXG4gICAgY29uc3QgYWN0dWFsU3R5bGUgPSBnZXRTdHlsZShzdHlsZSk7XFxuICAgIGlmIChhY3R1YWxTdHlsZS5zdHJva2VDb2xvciAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHByZXBhcmVDb2xvcihhY3R1YWxTdHlsZS5zdHJva2VDb2xvcik7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVXaWR0aCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBhY3R1YWxTdHlsZS5saW5lV2lkdGg7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVEYXNoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKGFjdHVhbFN0eWxlLmxpbmVEYXNoKTtcXG4gICAgfVxcbiAgICAvLyBJZiB0aGlzIGlzIGEgYmF0Y2ggb3BlcmF0aW9uLCBkb24ndCBiZWdpbiBhIG5ldyBwYXRoIHNvIHdlIGNhbiBhZGQgdG8gYW55XFxuICAgIC8vIGV4aXN0aW5nIHBhdGggYW5kIGRyYXcgbXVsdGlwbGUgbGluZXMgaW4gb25lIGdvXFxuICAgIGlmICghYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgIH1cXG4gICAgY29udGV4dC5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XFxuICAgIGNvbnRleHQubGluZVRvKGVuZC54LCBlbmQueSk7XFxuICAgIC8vIFN0cm9rZSB0aGUgcGF0aCBpZiByZXF1aXJlZFxcbiAgICAvLyBBZGRpdGlvbmFsbHksIGlmIHRoaXMgaXMgYSBiYXRjaCBvcGVyYXRpb24sIHdlIGRvbid0IHN0cm9rZSByaWdodCBhd2F5IHNvXFxuICAgIC8vIHRoYXQgd2UgY2FuIGFkZCBtb3JlIGxpbmVzIHRvIHRoZSBzYW1lIHBhdGggaWYgd2Ugd2FudFxcbiAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlICYmICFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG59XFxuLyoqXFxuICogRHJhdyBhIGNyb3NzIGF0IGEgZ2l2ZW4gcG9zaXRpb24gd2l0aCBhIHNwZWNpZmllZCBzaXplXFxuICovXFxuZnVuY3Rpb24gY3Jvc3MoY29udGV4dCwgcG9zaXRpb24sIHNpemUsIHN0eWxlKSB7XFxuICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAvLyBBcHBseSBzdHlsZXNcXG4gICAgY29uc3QgYWN0dWFsU3R5bGUgPSBnZXRTdHlsZShzdHlsZSk7XFxuICAgIGlmIChhY3R1YWxTdHlsZS5zdHJva2VDb2xvciAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHByZXBhcmVDb2xvcihhY3R1YWxTdHlsZS5zdHJva2VDb2xvcik7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVXaWR0aCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBhY3R1YWxTdHlsZS5saW5lV2lkdGg7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVEYXNoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKGFjdHVhbFN0eWxlLmxpbmVEYXNoKTtcXG4gICAgfVxcbiAgICAvLyBJZiB0aGlzIGlzIGEgYmF0Y2ggb3BlcmF0aW9uLCBkb24ndCBiZWdpbiBhIG5ldyBwYXRoIHNvIHdlIGNhbiBhZGQgdG8gYW55XFxuICAgIC8vIGV4aXN0aW5nIHBhdGggYW5kIGRyYXcgbXVsdGlwbGUgbGluZXMgaW4gb25lIGdvXFxuICAgIGlmICghYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgIH1cXG4gICAgLy8gRHJhdyB0aGUgY3Jvc3NcXG4gICAgY29uc3QgaGFsZlNpemUgPSBzaXplIC8gMjtcXG4gICAgaWYgKGFjdHVhbFN0eWxlLmNyb3NzU3R5bGUgPT09ICcrJykge1xcbiAgICAgICAgLy8gUGx1cyBzaWduIGNyb3NzXFxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3NpdGlvbi54IC0gaGFsZlNpemUsIHBvc2l0aW9uLnkpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55KTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkgLSBoYWxmU2l6ZSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICB9XFxuICAgIGVsc2UgaWYgKGFjdHVhbFN0eWxlLmNyb3NzU3R5bGUgPT09ICd4Jykge1xcbiAgICAgICAgLy8gWCBjcm9zc1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICB9XFxuICAgIC8vIFN0cm9rZSB0aGUgcGF0aCBpZiByZXF1aXJlZFxcbiAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlICYmICFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG59XFxuLyoqXFxuICogRHJhdyBhbiBhcnJvdyBmcm9tIGEgc3RhcnQgcG9pbnQgdG8gYW4gZW5kIHBvaW50IHdpdGggYW4gb3B0aW9uYWwgYXJyb3doZWFkXFxuICogYXQgdGhlIGVuZFxcbiAqXFxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGJhdGNoIGRyYXdpbmcgc2luY2UgaXQgcmVxdWlyZXNcXG4gKiBiZWdpbm5pbmcgYSBuZXcgcGF0aCBmb3IgdGhlIGFycm93aGVhZFxcbiAqL1xcbmZ1bmN0aW9uIGFycm93KGNvbnRleHQsIHN0YXJ0LCBlbmQsIHN0eWxlKSB7XFxuICAgIHZhciBfYTtcXG4gICAgY29udGV4dC5zYXZlKCk7XFxuICAgIC8vIEFwcGx5IHN0eWxlc1xcbiAgICBjb25zdCBhY3R1YWxTdHlsZSA9IGdldFN0eWxlKHN0eWxlKTtcXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZUNvbG9yICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcHJlcGFyZUNvbG9yKGFjdHVhbFN0eWxlLnN0cm9rZUNvbG9yKTtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUubGluZVdpZHRoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGFjdHVhbFN0eWxlLmxpbmVXaWR0aDtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUubGluZURhc2ggIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goYWN0dWFsU3R5bGUubGluZURhc2gpO1xcbiAgICB9XFxuICAgIC8vIEFycm93cyBkb24ndCBzdXBwb3J0IGJhdGNoIGRyYXdpbmcgc2luY2Ugd2UgaGF2ZSB0byBiZWdpbiBhIG5ldyBwYXRoXFxuICAgIC8vIHdoZW4gZHJhd2luZyB0aGUgYXJyb3doZWFkXFxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgIC8vIERyYXcgdGhlIGxpbmUgc2VnbWVudFxcbiAgICBjb250ZXh0Lm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcXG4gICAgY29udGV4dC5saW5lVG8oZW5kLngsIGVuZC55KTtcXG4gICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgLy8gRHJhdyB0aGUgYXJyb3doZWFkIGlmIHNwZWNpZmllZFxcbiAgICBpZiAoYWN0dWFsU3R5bGUuYXJyb3cpIHtcXG4gICAgICAgIGNvbnN0IGFycm93U2l6ZSA9IChfYSA9IGFjdHVhbFN0eWxlLmFycm93LnNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEwO1xcbiAgICAgICAgY29uc3QgaGFsZlNpemUgPSBhcnJvd1NpemUgLyAyO1xcbiAgICAgICAgY29uc3QgYW5nbGUgPSB2ZWNfMS52ZWMyLnJhZCh2ZWNfMS52ZWMyLnN1YihlbmQsIHN0YXJ0KSk7XFxuICAgICAgICBjb25zdCBhcnJvd1R5cGUgPSBhY3R1YWxTdHlsZS5hcnJvdy50eXBlO1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShlbmQueCwgZW5kLnkpO1xcbiAgICAgICAgY29udGV4dC5yb3RhdGUoYW5nbGUpO1xcbiAgICAgICAgaWYgKHR5cGVvZiBhcnJvd1R5cGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBhcnJvd1R5cGUoY29udGV4dCwgYXJyb3dTaXplKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGFycm93VHlwZSA9PT0gJ2NhcmV0Jykge1xcbiAgICAgICAgICAgIGlmIChhY3R1YWxTdHlsZS5zdHJva2VDb2xvciAhPT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHByZXBhcmVDb2xvcihhY3R1YWxTdHlsZS5zdHJva2VDb2xvcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLWhhbGZTaXplKTtcXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhhcnJvd1NpemUsIDApO1xcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIGhhbGZTaXplKTtcXG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoYXJyb3dUeXBlID09PSAnY2hldnJvbicpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKC1oYWxmU2l6ZSwgLWhhbGZTaXplKTtcXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAwKTtcXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygtaGFsZlNpemUsIGhhbGZTaXplKTtcXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgIH1cXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XFxufVxcbi8qKlxcbiAqIERyYXcgYSBjaXJjbGUgYXQgYSBzcGVjaWZpZWQgY2VudGVyIHBvaW50IHdpdGggYSBnaXZlbiByYWRpdXNcXG4gKi9cXG5mdW5jdGlvbiBjaXJjbGUoY29udGV4dCwgY2VudGVyLCByYWRpdXMsIHN0eWxlKSB7XFxuICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAvLyBBcHBseSBzdHlsZXNcXG4gICAgY29uc3QgYWN0dWFsU3R5bGUgPSBnZXRTdHlsZShzdHlsZSk7XFxuICAgIGlmIChhY3R1YWxTdHlsZS5maWxsQ29sb3IgIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcHJlcGFyZUNvbG9yKGFjdHVhbFN0eWxlLmZpbGxDb2xvcik7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmdyYWRpZW50KSB7XFxuICAgICAgICBjb25zdCBncmFkaWVudCA9IHByZXBhcmVHcmFkaWVudChjb250ZXh0LCBhY3R1YWxTdHlsZS5ncmFkaWVudCk7XFxuICAgICAgICBpZiAoZ3JhZGllbnQpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5zdHJva2VDb2xvciAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHByZXBhcmVDb2xvcihhY3R1YWxTdHlsZS5zdHJva2VDb2xvcik7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVXaWR0aCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBhY3R1YWxTdHlsZS5saW5lV2lkdGg7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVEYXNoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKGFjdHVhbFN0eWxlLmxpbmVEYXNoKTtcXG4gICAgfVxcbiAgICAvLyBJZiB0aGlzIGlzIGEgYmF0Y2ggb3BlcmF0aW9uLCBkb24ndCBiZWdpbiBhIG5ldyBwYXRoIHNvIHdlIGNhbiBhZGQgdG8gYW55XFxuICAgIC8vIGV4aXN0aW5nIHBhdGggYW5kIGRyYXcgbXVsdGlwbGUgc2hhcGVzIGluIG9uZSBnb1xcbiAgICBpZiAoIWFjdHVhbFN0eWxlLmJhdGNoKSB7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICB9XFxuICAgIC8vIERyYXcgdGhlIGNpcmNsZVxcbiAgICBjb250ZXh0LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xcbiAgICAvLyBGaWxsIHRoZSBjaXJjbGUgaWYgcmVxdWlyZWRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLmZpbGwgJiYgIWFjdHVhbFN0eWxlLmJhdGNoKSB7XFxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcXG4gICAgfVxcbiAgICAvLyBTdHJva2UgdGhlIGNpcmNsZSBpZiByZXF1aXJlZFxcbiAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlICYmICFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG59XFxuLyoqXFxuICogRHJhdyBhIHJlY3RhbmdsZSBhdCBhIHNwZWNpZmllZCBwb3NpdGlvbiB3aXRoIGEgZ2l2ZW4gc2l6ZVxcbiAqL1xcbmZ1bmN0aW9uIHJlY3RhbmdsZShjb250ZXh0LCBwb3NpdGlvbiwgc2l6ZSwgc3R5bGUpIHtcXG4gICAgdmFyIF9hO1xcbiAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgLy8gQXBwbHkgc3R5bGVzXFxuICAgIGNvbnN0IGFjdHVhbFN0eWxlID0gZ2V0U3R5bGUoc3R5bGUpO1xcbiAgICBpZiAoYWN0dWFsU3R5bGUuZmlsbENvbG9yICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHByZXBhcmVDb2xvcihhY3R1YWxTdHlsZS5maWxsQ29sb3IpO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5ncmFkaWVudCkge1xcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBwcmVwYXJlR3JhZGllbnQoY29udGV4dCwgYWN0dWFsU3R5bGUuZ3JhZGllbnQpO1xcbiAgICAgICAgaWYgKGdyYWRpZW50KSB7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudDtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IgIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBwcmVwYXJlQ29sb3IoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IpO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5saW5lV2lkdGggIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYWN0dWFsU3R5bGUubGluZVdpZHRoO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5saW5lRGFzaCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChhY3R1YWxTdHlsZS5saW5lRGFzaCk7XFxuICAgIH1cXG4gICAgLy8gSWYgdGhpcyBpcyBhIGJhdGNoIG9wZXJhdGlvbiwgZG9uJ3QgYmVnaW4gYSBuZXcgcGF0aCBzbyB3ZSBjYW4gYWRkIHRvIGFueVxcbiAgICAvLyBleGlzdGluZyBwYXRoIGFuZCBkcmF3IG11bHRpcGxlIHNoYXBlcyBpbiBvbmUgZ29cXG4gICAgaWYgKCFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgfVxcbiAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGVcXG4gICAgaWYgKGFjdHVhbFN0eWxlLnJvdW5kZWQpIHtcXG4gICAgICAgIGNvbnRleHQucm91bmRSZWN0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHNpemUueCwgc2l6ZS55LCAoX2EgPSBhY3R1YWxTdHlsZS5ib3JkZXJSYWRpdXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpO1xcbiAgICB9XFxuICAgIGVsc2Uge1xcbiAgICAgICAgY29udGV4dC5yZWN0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHNpemUueCwgc2l6ZS55KTtcXG4gICAgfVxcbiAgICAvLyBGaWxsIHRoZSByZWN0YW5nbGUgaWYgcmVxdWlyZWRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLmZpbGwgJiYgIWFjdHVhbFN0eWxlLmJhdGNoKSB7XFxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcXG4gICAgfVxcbiAgICAvLyBTdHJva2UgdGhlIHJlY3RhbmdsZSBpZiByZXF1aXJlZFxcbiAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlICYmICFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG59XFxuLyoqXFxuICogRHJhdyBhIHBvbHlnb24gZGVmaW5lZCBieSBhbiBhcnJheSBvZiB2ZXJ0aWNlc1xcbiAqL1xcbmZ1bmN0aW9uIHBvbHlnb24oY29udGV4dCwgdmVydGljZXMsIHN0eWxlKSB7XFxuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgY29udGV4dC5zYXZlKCk7XFxuICAgIC8vIEFwcGx5IHN0eWxlc1xcbiAgICBjb25zdCBhY3R1YWxTdHlsZSA9IGdldFN0eWxlKHN0eWxlKTtcXG4gICAgaWYgKGFjdHVhbFN0eWxlLmZpbGxDb2xvciAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBwcmVwYXJlQ29sb3IoYWN0dWFsU3R5bGUuZmlsbENvbG9yKTtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUuZ3JhZGllbnQpIHtcXG4gICAgICAgIGNvbnN0IGdyYWRpZW50ID0gcHJlcGFyZUdyYWRpZW50KGNvbnRleHQsIGFjdHVhbFN0eWxlLmdyYWRpZW50KTtcXG4gICAgICAgIGlmIChncmFkaWVudCkge1xcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnQ7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZUNvbG9yICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcHJlcGFyZUNvbG9yKGFjdHVhbFN0eWxlLnN0cm9rZUNvbG9yKTtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUubGluZVdpZHRoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGFjdHVhbFN0eWxlLmxpbmVXaWR0aDtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUubGluZURhc2ggIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goYWN0dWFsU3R5bGUubGluZURhc2gpO1xcbiAgICB9XFxuICAgIC8vIElmIHRoaXMgaXMgYSBiYXRjaCBvcGVyYXRpb24sIGRvbid0IGJlZ2luIGEgbmV3IHBhdGggc28gd2UgY2FuIGFkZCB0byBhbnlcXG4gICAgLy8gZXhpc3RpbmcgcGF0aCBhbmQgZHJhdyBtdWx0aXBsZSBzaGFwZXMgaW4gb25lIGdvXFxuICAgIGlmICghYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgIH1cXG4gICAgLy8gRHJhdyB0aGUgcG9seWdvbiBwYXRoXFxuICAgIGNvbnRleHQubW92ZVRvKHZlcnRpY2VzWzBdLngsIHZlcnRpY2VzWzBdLnkpO1xcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyh2ZXJ0aWNlc1tpXS54LCB2ZXJ0aWNlc1tpXS55KTtcXG4gICAgfVxcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xcbiAgICAvLyBGaWxsIHRoZSByZWN0YW5nbGUgaWYgcmVxdWlyZWRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLmZpbGwgJiYgIWFjdHVhbFN0eWxlLmJhdGNoKSB7XFxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcXG4gICAgfVxcbiAgICAvLyBTdHJva2UgdGhlIHJlY3RhbmdsZSBpZiByZXF1aXJlZFxcbiAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlICYmICFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG59XFxuLyoqXFxuICogRHJhdyBhIHBhdGggZGVmaW5lZCBieSBhbiBhcnJheSBvZiB2ZXJ0aWNlc1xcbiAqL1xcbmZ1bmN0aW9uIHBhdGgoY29udGV4dCwgdmVydGljZXMsIHN0eWxlKSB7XFxuICAgIHZhciBfYSwgX2IsIF9jO1xcbiAgICBpZiAodmVydGljZXMubGVuZ3RoIDwgMilcXG4gICAgICAgIHJldHVybjtcXG4gICAgY29udGV4dC5zYXZlKCk7XFxuICAgIC8vIEFwcGx5IHN0eWxlc1xcbiAgICBjb25zdCBhY3R1YWxTdHlsZSA9IGdldFN0eWxlKHN0eWxlKTtcXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZUNvbG9yICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcHJlcGFyZUNvbG9yKGFjdHVhbFN0eWxlLnN0cm9rZUNvbG9yKTtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUubGluZVdpZHRoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGFjdHVhbFN0eWxlLmxpbmVXaWR0aDtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUubGluZURhc2ggIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goYWN0dWFsU3R5bGUubGluZURhc2gpO1xcbiAgICB9XFxuICAgIC8vIElmIHRoaXMgaXMgYSBiYXRjaCBvcGVyYXRpb24sIGRvbid0IGJlZ2luIGEgbmV3IHBhdGhcXG4gICAgaWYgKCFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgfVxcbiAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHBhdGggdHlwZXNcXG4gICAgY29uc3QgcGF0aFR5cGUgPSAoX2EgPSBhY3R1YWxTdHlsZS5wYXRoVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2xpbmVhcic7XFxuICAgIGlmIChwYXRoVHlwZSA9PT0gJ2xpbmVhcicpIHtcXG4gICAgICAgIC8vIFNpbXBsZSBsaW5lYXIgcGF0aFxcbiAgICAgICAgY29udGV4dC5tb3ZlVG8odmVydGljZXNbMF0ueCwgdmVydGljZXNbMF0ueSk7XFxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odmVydGljZXNbaV0ueCwgdmVydGljZXNbaV0ueSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZWxzZSBpZiAocGF0aFR5cGUgPT09ICdiZXppZXInKSB7XFxuICAgICAgICBjb25zdCBvcmRlciA9ICgwLCB1dGlsc18xLmNsYW1wKSgoX2IgPSBhY3R1YWxTdHlsZS5iZXppZXJPcmRlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMywgMSwgMyk7XFxuICAgICAgICAvLyBEcmF3IGJlemllciBjdXJ2ZSBzZWdtZW50c1xcbiAgICAgICAgY29uc3Qgc2VnbWVudFNpemUgPSBvcmRlciArIDE7XFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSArIHNlZ21lbnRTaXplIDw9IHZlcnRpY2VzLmxlbmd0aDsgaSArPSBvcmRlcikge1xcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRQb2ludHMgPSB2ZXJ0aWNlcy5zbGljZShpLCBpICsgc2VnbWVudFNpemUpO1xcbiAgICAgICAgICAgIC8vIERyYXcgZmlyc3QgcG9pbnQgb2Ygc2VnbWVudFxcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHNlZ21lbnRQb2ludHNbMF0ueCwgc2VnbWVudFBvaW50c1swXS55KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gRHJhdyBiZXppZXIgY3VydmUgdGhyb3VnaCBwb2ludHNcXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgcSA9IHZlY18xLm1hdC5tdWx2KEJFWklFUl9NQVRSSUNFU1tvcmRlcl0sIEJFWklFUl9DT0VGRklDSUVOVFModCwgb3JkZXIpKTtcXG4gICAgICAgICAgICAgICAgaWYgKHEgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBsZXQgcCA9ICgwLCB2ZWNfMS52ZWMyKSgpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlZ21lbnRTaXplOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIHAueCArPSBzZWdtZW50UG9pbnRzW2pdLnggKiBxW2pdO1xcbiAgICAgICAgICAgICAgICAgICAgcC55ICs9IHNlZ21lbnRQb2ludHNbal0ueSAqIHFbal07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocC54LCBwLnkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBlbHNlIGlmIChwYXRoVHlwZSA9PT0gJ2NhdG11bGwtcm9tJykge1xcbiAgICAgICAgY29uc3QgdGVuc2lvbiA9IChfYyA9IGFjdHVhbFN0eWxlLmNhdG11bGxSb21UZW5zaW9uKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwLjU7XFxuICAgICAgICAvLyBOZWVkIGF0IGxlYXN0IDQgcG9pbnRzIGZvciBDYXRtdWxsLVJvbVxcbiAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+PSA0KSB7XFxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odmVydGljZXNbMV0ueCwgdmVydGljZXNbMV0ueSk7XFxuICAgICAgICAgICAgLy8gRHJhdyBjdXJ2ZSBzZWdtZW50c1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmVydGljZXMubGVuZ3RoIC0gMjsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtcXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW2kgLSAxXSxcXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldLFxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbaSArIDFdLFxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbaSArIDJdLFxcbiAgICAgICAgICAgICAgICBdO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSAoMCwgdXRpbHNfMS5kb3QpKHBvaW50cy5tYXAocCA9PiBwLngpLCBDQVRNVUxMX1JPTV9CQVNJU19WRUNUT1IodCwgdGVuc2lvbikpO1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9ICgwLCB1dGlsc18xLmRvdCkocG9pbnRzLm1hcChwID0+IHAueSksIENBVE1VTExfUk9NX0JBU0lTX1ZFQ1RPUih0LCB0ZW5zaW9uKSk7XFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBsaW5lYXIgaWYgbm90IGVub3VnaCBwb2ludHNcXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh2ZXJ0aWNlc1swXS54LCB2ZXJ0aWNlc1swXS55KTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHZlcnRpY2VzW2ldLngsIHZlcnRpY2VzW2ldLnkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvLyBTdHJva2UgdGhlIHBhdGggaWYgcmVxdWlyZWRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZSAmJiAhYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIH1cXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NhbnZhcy1oZWxwZXJzLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qKlxcbiAqIEBvdmVydmlldyBBIGxpYnJhcnkgb2YgdXNlZnVsIGZ1bmN0aW9uc1xcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXIgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlciBiXFxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBudW1iZXJzIGEgYW5kIGIgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKi9cXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XFxuXFxuLyoqXFxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gY2xhbXBcXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBIGNsYW1wZWQgbnVtYmVyXFxuICovXFxuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBmcmFjdGlvbmFsIHBhcnRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIG51bWJlclxcbiAqL1xcbmNvbnN0IGZyYWMgPSBhID0+IGEgPj0gMCA/IGEgLSBNYXRoLmZsb29yKGEpIDogYSAtIE1hdGguY2VpbChhKTtcXG5cXG4vKipcXG4gKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKi9cXG5jb25zdCBsZXJwID0gKGEsIGIsIGkpID0+IGEgKyAoYiAtIGEpICogaTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcXG4gKi9cXG5jb25zdCB1bmxlcnAgPSAoYSwgYiwgaSkgPT4gKGkgLSBhKSAvIChiIC0gYSk7XFxuXFxuLyoqXFxuICogRG8gYSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTAgVG9wLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMSBCb3R0b20tbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGl4IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeSBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXFxuICovXFxuY29uc3QgYmxlcnAgPSAoYzAwLCBjMTAsIGMwMSwgYzExLCBpeCwgaXkpID0+IGxlcnAobGVycChjMDAsIGMxMCwgaXgpLCBsZXJwKGMwMSwgYzExLCBpeCksIGl5KTtcXG5cXG4vKipcXG4gKiBSZS1tYXAgYSBudW1iZXIgaSBmcm9tIHJhbmdlIGExLi4uYTIgdG8gYjEuLi5iMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXFxuICogQHBhcmFtIHtudW1iZXJ9IGExXFxuICogQHBhcmFtIHtudW1iZXJ9IGEyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIxXFxuICogQHBhcmFtIHtudW1iZXJ9IGIyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmNvbnN0IHJlbWFwID0gKGksIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArIChpIC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xcblxcbi8qKlxcbiAqIERvIGEgc21vb3RoIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3Qgc21vb3Roc3RlcCA9IChhLCBiLCBpKSA9PiBsZXJwKGEsIGIsIDMgKiBNYXRoLnBvdyhpLCAyKSAtIDIgKiBNYXRoLnBvdyhpLCAzKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKi9cXG5jb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiBkZWdyZWVzXFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiBkZWdyZWVzXFxuICovXFxuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEV4Y2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICovXFxuY29uc3QgcmFuZG9tQmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xcblxcbi8qKlxcbiAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICovXFxuY29uc3QgcmFuZG9tSW50QmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IFttdT0wLjVdIFRoZSBtZWFuIHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9Ml0gVGhlIG51bWJlciBvZiBzYW1wbGVzXFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb20gPSAobXUgPSAwLjUsIHNpZ21hID0gMC41LCBzYW1wbGVzID0gMikgPT4ge1xcbiAgbGV0IHRvdGFsID0gMDtcXG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XFxuICAgIHRvdGFsICs9IE1hdGgucmFuZG9tKCk7XFxuICB9XFxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlclxcbiAqL1xcbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdyBBbiBhcnJheSBvZiB3ZWlnaHRzXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbmRleCBmcm9tIHdcXG4gKi9cXG5jb25zdCB3ZWlnaHRlZFJhbmRvbSA9IHcgPT4ge1xcbiAgbGV0IHRvdGFsID0gdy5yZWR1Y2UoKGEsIGkpID0+IGEgKyBpLCAwKSwgbiA9IDA7XFxuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xcbiAgd2hpbGUgKHRvdGFsID4gcikge1xcbiAgICB0b3RhbCAtPSB3W24rK107XFxuICB9XFxuICByZXR1cm4gbiAtIDE7XFxufTtcXG5cXG4vKipcXG4gKiBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXFxuICogQGNhbGxiYWNrIGludGVycG9sYXRpb25DYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmcm9tIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIEEgbnVtYmVyIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcGFyYW0ge2ludGVycG9sYXRpb25DYWxsYmFja30gW2Y9TWF0aC5sZXJwXSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB0byB1c2VcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxcbiAqL1xcbmNvbnN0IGxlcnBBcnJheSA9IChhLCBpLCBmID0gbGVycCkgPT4ge1xcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcXG4gIGNvbnN0IHAgPSBjbGFtcChNYXRoLnRydW5jKHMpLCAwLCBhLmxlbmd0aCAtIDEpO1xcbiAgcmV0dXJuIGYoYVtwXSB8fCAwLCBhW3AgKyAxXSB8fCAwLCBmcmFjKHMpKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG5jb25zdCBkb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmYWN0b3JpYWwgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYVxcbiAqIEByZXR1cm4ge251bWJlcn0gYSFcXG4gKi9cXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcXG4gIGxldCByZXN1bHQgPSAxO1xcbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gYTsgaSsrKSB7XFxuICAgIHJlc3VsdCAqPSBpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxcbiAqL1xcbmNvbnN0IHBlcm11dGF0aW9uID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIGZhY3RvcmlhbChuIC0gcik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcGFyYW0ge251bWJlcn0gclxcbiAqIEByZXR1cm4ge251bWJlcn0gbkNyXFxuICovXFxuY29uc3QgY29tYmluYXRpb24gPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gKGZhY3RvcmlhbChyKSAqIGZhY3RvcmlhbChuIC0gcikpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYXJyYXkgdmFsdWVzXFxuICogQGNhbGxiYWNrIHRpbWVzQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBUaGUgYXJyYXkgdmFsdWVcXG4gKi9cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBsZW5ndGggbiBieSBjYWxsaW5nIGZ1bmN0aW9uIGYoaSkgb24gZWFjaCBlbGVtZW50XFxuICogQHBhcmFtIHt0aW1lc0NhbGxiYWNrfSBmXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIGFycmF5XFxuICogQHJldHVybiB7QXJyYXk8Kj59XFxuICovXFxuY29uc3QgdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIG51bWJlcnMgMC0+KG4gLSAxKVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIGludGVnZXJzIDAtPihuIC0gMSlcXG4gKi9cXG5jb25zdCByYW5nZSA9IG4gPT4gdGltZXMoaSA9PiBpLCBuKTtcXG5cXG4vKipcXG4gKiBaaXAgMiBhcnJheXMgdG9nZXRoZXIsIGkuZS4gKFsxLCAyLCAzXSwgW2EsIGIsIGNdKSA9PiBbWzEsIGFdLCBbMiwgYl0sIFszLCBjXV1cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYlxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn1cXG4gKi9cXG5jb25zdCB6aXAgPSAoYSwgYikgPT4gYS5tYXAoKGssIGkpID0+IFtrLCBiW2ldXSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGFycmF5W2ldIHdpdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHdyYXBwaW5nXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBwb3NpdGl2ZWx5L25lZ2F0aXZlbHkgd3JhcHBlZCBhcnJheSBpbmRleFxcbiAqIEByZXR1cm4geyp9IEFuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcXG4gKi9cXG5jb25zdCBhdCA9IChhLCBpKSA9PiBhW2kgPCAwID8gYS5sZW5ndGggLSAoTWF0aC5hYnMoaSArIDEpICUgYS5sZW5ndGgpIC0gMSA6IGkgJSBhLmxlbmd0aF07XFxuXFxuLyoqXFxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNodW5rIHNpemVcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xcbiAqL1xcbmNvbnN0IGNodW5rID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcblxcbi8qKlxcbiAqIFJhbmRvbWx5IHNodWZmbGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSBzaHVmZmxlZCBhcnJheVxcbiAqL1xcbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHtcXG4gICAgZmxvYXRFcXVhbHMsXFxuICAgIGNsYW1wLFxcbiAgICBmcmFjLFxcbiAgICBsZXJwLFxcbiAgICB1bmxlcnAsXFxuICAgIGJsZXJwLFxcbiAgICByZW1hcCxcXG4gICAgc21vb3Roc3RlcCxcXG4gICAgcmFkaWFucyxcXG4gICAgZGVncmVlcyxcXG4gICAgcmFuZG9tQmV0d2VlbixcXG4gICAgcmFuZG9tSW50QmV0d2VlbixcXG4gICAgY2x0UmFuZG9tLFxcbiAgICBjbHRSYW5kb21JbnQsXFxuICAgIHdlaWdodGVkUmFuZG9tLFxcbiAgICBsZXJwQXJyYXksXFxuICAgIGRvdCxcXG4gICAgZmFjdG9yaWFsLFxcbiAgICBwZXJtdXRhdGlvbixcXG4gICAgY29tYmluYXRpb24sXFxuICAgIHRpbWVzLFxcbiAgICByYW5nZSxcXG4gICAgemlwLFxcbiAgICBhdCxcXG4gICAgY2h1bmssXFxuICAgIHNodWZmbGUsXFxuICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9kZWJ1Zy8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJjb25zdCB7IHRpbWVzLCBjaHVuaywgZG90IH0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanNcXFwiKTtcXG5cXG4vKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWN9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgbmV3IHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjKDMsIDIpOyAgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMoNCk7ICAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYyhhKTsgICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjKCk7ICAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjID0gKHgsIHkpID0+ICgheCAmJiAheSA/XFxuICB7IHg6IDAsIHk6IDAgfSA6ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgP1xcbiAgICB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9IDogKHkgPT09IG51bGwgfHwgeSA9PT0gdW5kZWZpbmVkID9cXG4gICAgICB7IHg6IHgsIHk6IHggfSA6IHsgeDogeCwgeTogeSB9KVxcbiAgKVxcbik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjfSBBIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqL1xcbnZlYy51eCA9ICgpID0+IHZlYygxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICovXFxudmVjLnV5ID0gKCkgPT4gdmVjKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSArIGJcXG4gKi9cXG52ZWMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAqIGJcXG4gKi9cXG52ZWMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIGIsIHk6IGEueSAqIGIgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWN9IGEgLSBiXFxuICovXFxudmVjLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjfSBeYVxcbiAqL1xcbnZlYy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYygpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMuY3B5ID0gYSA9PiB2ZWMoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlY3Rvck1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY3Rvck1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcXG5cXG4vKipcXG4gKiBBZGQgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhICsgYlxcbiAqL1xcbm1hdC5hZGQgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiArIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhIC0gYlxcbiAqL1xcbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIGRvdChtYXQucm93KGEsIGkpLCBtYXQuY29sKGIsIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgdGltZXMoaSA9PiBtYXQuY29sKGEsIChpICsgMSkpLCBhLm4pLmZsYXQoKSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBtaW5vciBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5ub3IgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgcmV0dXJuIG1hdC5tYXAoYSwgaSA9PiBpICogZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcXG4gKiBAcmV0dXJuIHttYXR9IFRoZSBhZGp1Z2F0ZSBvZiBhXFxuICovXFxubWF0LmFkaiA9IGEgPT4ge1xcbiAgY29uc3QgbWlub3JzID0gbWF0KGEubSwgYS5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChtaW5vcnMsIGksIGosIG1hdC5kZXQobWF0Lm1pbm9yKGEsIGksIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IGNvZmFjdG9ycyA9IG1hdC5tYXAobWlub3JzLCAodiwgaSkgPT4gdiAqIChpICUgMiA/IC0xIDogMSkpO1xcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBpbnZlcnRcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZGVidWcvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5jb25zdCB2ZWNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3ZlYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1xcXCIpO1xcbmNsYXNzIERlYnVnIHtcXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWZhdWx0VmFsdWUpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRWYWx1ZSA9IE9iamVjdC5hc3NpZ24oe30sIERlYnVnLmRlZmF1bHRPcHRpb25zLmRlZmF1bHRWYWx1ZSwgb3B0aW9ucy5kZWZhdWx0VmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWZhdWx0Q2hhcnQpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRDaGFydCA9IE9iamVjdC5hc3NpZ24oe30sIERlYnVnLmRlZmF1bHRPcHRpb25zLmRlZmF1bHRDaGFydCwgb3B0aW9ucy5kZWZhdWx0Q2hhcnQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWZhdWx0TWFya2VyKSB7XFxuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0TWFya2VyID0gT2JqZWN0LmFzc2lnbih7fSwgRGVidWcuZGVmYXVsdE9wdGlvbnMuZGVmYXVsdE1hcmtlciwgb3B0aW9ucy5kZWZhdWx0TWFya2VyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVmYXVsdEJvcmRlcikge1xcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEJvcmRlciA9IE9iamVjdC5hc3NpZ24oe30sIERlYnVnLmRlZmF1bHRPcHRpb25zLmRlZmF1bHRCb3JkZXIsIG9wdGlvbnMuZGVmYXVsdEJvcmRlcik7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBEZWJ1Zy5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKCk7XFxuICAgICAgICB0aGlzLmNoYXJ0cyA9IG5ldyBNYXAoKTtcXG4gICAgICAgIHRoaXMubWFya2VycyA9IG5ldyBNYXAoKTtcXG4gICAgICAgIHRoaXMuYm9yZGVycyA9IG5ldyBNYXAoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGlzZSB0aGUgZGVidWcgcmVuZGVyZXIgZm9yIGRpc3BsYXlpbmcgdmFsdWVzIGFuZCBtYXJrZXJzXFxuICAgICAqL1xcbiAgICBzdGF0aWMgaW5pdGlhbGlzZShvcHRpb25zID0ge30pIHtcXG4gICAgICAgIGlmIChEZWJ1Zy5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWJ1ZyBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpc2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICBEZWJ1Zy5pbnN0YW5jZSA9IG5ldyBEZWJ1ZyhvcHRpb25zKTtcXG4gICAgfVxcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XFxuICAgICAgICBpZiAoRGVidWcuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVidWcgbm90IHByb3Blcmx5IGluaXRpYWxpc2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gRGVidWcuaW5zdGFuY2U7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNob3cgYSBkZWJ1ZyB2YWx1ZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIHZhbHVlKGxhYmVsLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UudmFsdWVzLnNldChsYWJlbCwgT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2Uub3B0aW9ucy5kZWZhdWx0VmFsdWUsIChfYSA9IGluc3RhbmNlLnZhbHVlcy5nZXQobGFiZWwpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSwgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIHsgbGFiZWwsIHZhbHVlIH0pKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2hvdyBhIGRlYnVnIGNoYXJ0XFxuICAgICAqL1xcbiAgICBzdGF0aWMgY2hhcnQobGFiZWwsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgICB2YXIgX2EsIF9iO1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgY29uc3QgY3VycmVudENoYXJ0ID0gaW5zdGFuY2UuY2hhcnRzLmdldChsYWJlbCk7XFxuICAgICAgICBpbnN0YW5jZS5jaGFydHMuc2V0KGxhYmVsLCBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZS5vcHRpb25zLmRlZmF1bHRDaGFydCwgY3VycmVudENoYXJ0ICE9PSBudWxsICYmIGN1cnJlbnRDaGFydCAhPT0gdm9pZCAwID8gY3VycmVudENoYXJ0IDoge30sIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCB7XFxuICAgICAgICAgICAgbGFiZWwsXFxuICAgICAgICAgICAgdmFsdWVzOiBbLi4uKF9hID0gY3VycmVudENoYXJ0ID09PSBudWxsIHx8IGN1cnJlbnRDaGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudENoYXJ0LnZhbHVlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIHZhbHVlXS5zbGljZSgtKChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52YWx1ZUJ1ZmZlclNpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGluc3RhbmNlLm9wdGlvbnMuZGVmYXVsdENoYXJ0LnZhbHVlQnVmZmVyU2l6ZSkpLFxcbiAgICAgICAgfSkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmUgYSBkZWJ1ZyBjaGFydFxcbiAgICAgKi9cXG4gICAgc3RhdGljIHJlbW92ZUNoYXJ0KGxhYmVsKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpbnN0YW5jZS5jaGFydHMuZGVsZXRlKGxhYmVsKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2hvdyBhIG1hcmtlciBpbiB3b3JsZCBvciBzY3JlZW4gc3BhY2VcXG4gICAgICovXFxuICAgIHN0YXRpYyBtYXJrZXIobGFiZWwsIHZhbHVlLCBwb3NpdGlvbiwgb3B0aW9ucykge1xcbiAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UubWFya2Vycy5zZXQobGFiZWwsIE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlLm9wdGlvbnMuZGVmYXVsdE1hcmtlciwgKF9hID0gaW5zdGFuY2UubWFya2Vycy5nZXQobGFiZWwpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSwgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIHsgbGFiZWwsIHZhbHVlLCBwb3NpdGlvbiB9KSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNob3cgYSBib3JkZXIgaW4gd29ybGQgb3Igc2NyZWVuIHNwYWNlXFxuICAgICAqL1xcbiAgICBzdGF0aWMgYm9yZGVyKGxhYmVsLCB2YWx1ZSwgcG9zaXRpb24sIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJvcmRlclNoYXBlKSA9PT0gJ2NpcmNsZScgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yYWRpdXMpID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgdGhlIGJvcmRlciBpZiBpdCdzIGNpcmN1bGFyIGJ1dCB3ZSBkb24ndCBoYXZlIGEgcmFkaXVzXFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9yZGVyU2hhcGUpICE9PSAnY2lyY2xlJyAmJiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpemUpID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgdGhlIGJvcmRlciBpZiBpdCdzIHJlY3Rhbmd1bGFyIChkZWZhdWx0IGlzIHJlY3Rhbmd1bGFyKSBidXRcXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGEgc2l6ZVxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gRGVidWcuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLmJvcmRlcnMuc2V0KGxhYmVsLCBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZS5vcHRpb25zLmRlZmF1bHRCb3JkZXIsIChfYSA9IGluc3RhbmNlLmJvcmRlcnMuZ2V0KGxhYmVsKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCB7IGxhYmVsLCB2YWx1ZSwgcG9zaXRpb24gfSkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW5kZXIgdGhlIGRlYnVnIHZhbHVlcyBhbmQgbWFya2VycyBvbnRvIGEgY2FudmFzXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZHJhdyhjb250ZXh0LCB0YWdzLCBjbGVhciA9IHRydWUpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gRGVidWcuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIERyYXcgd29ybGQtc3BhY2UgbWFya2VycyAmIGJvcmRlcnNcXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgaW5zdGFuY2UubWFya2Vycy5mb3JFYWNoKG1hcmtlciA9PiB7XFxuICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgIGlmICh0YWdzICYmICEoKF9hID0gbWFya2VyLnRhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKHRhZyA9PiB0YWdzLmluY2x1ZGVzKHRhZykpKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChtYXJrZXIuc3BhY2UgPT09ICd3b3JsZCcpIHtcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZHJhd01hcmtlcihjb250ZXh0LCBtYXJrZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW5zdGFuY2UuYm9yZGVycy5mb3JFYWNoKGJvcmRlciA9PiB7XFxuICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgIGlmICh0YWdzICYmICEoKF9hID0gYm9yZGVyLnRhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKHRhZyA9PiB0YWdzLmluY2x1ZGVzKHRhZykpKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChib3JkZXIuc3BhY2UgPT09ICd3b3JsZCcpIHtcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZHJhd0JvcmRlcihjb250ZXh0LCBib3JkZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgICAgICAvLyBEcmF3IHZhbHVlcywgY2hhcnRzIGFuZCBzY3JlZW4tc3BhY2UgbWFya2VycyAmIGJvcmRlcnNcXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XFxuICAgICAgICBsZXQgcG9zaXRpb247XFxuICAgICAgICBsZXQgbGVmdFkgPSBpbnN0YW5jZS5vcHRpb25zLm1hcmdpbjtcXG4gICAgICAgIGxldCByaWdodFkgPSBpbnN0YW5jZS5vcHRpb25zLm1hcmdpbjtcXG4gICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSAoaW5zdGFuY2Uub3B0aW9ucy5saW5lSGVpZ2h0ICtcXG4gICAgICAgICAgICBpbnN0YW5jZS5vcHRpb25zLnBhZGRpbmcgKiAyKTtcXG4gICAgICAgIGluc3RhbmNlLnZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XFxuICAgICAgICAgICAgaWYgKHRhZ3MgJiYgISgoX2EgPSB2YWx1ZS50YWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSh0YWcgPT4gdGFncy5pbmNsdWRlcyh0YWcpKSkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmFsaWduKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKShpbnN0YW5jZS5vcHRpb25zLm1hcmdpbiwgbGVmdFkpO1xcbiAgICAgICAgICAgICAgICAgICAgbGVmdFkgKz0gbGluZUhlaWdodCArIGluc3RhbmNlLm9wdGlvbnMubGluZU1hcmdpbjtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKGNvbnRleHQuY2FudmFzLmNsaWVudFdpZHRoIC0gaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW4sIHJpZ2h0WSk7XFxuICAgICAgICAgICAgICAgICAgICByaWdodFkgKz0gbGluZUhlaWdodCArIGluc3RhbmNlLm9wdGlvbnMubGluZU1hcmdpbjtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnN0YW5jZS5kcmF3TGFiZWwoY29udGV4dCwgRGVidWcucHJlcGFyZUxhYmVsKChfYiA9IHZhbHVlLmxhYmVsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgKF9jID0gdmFsdWUudmFsdWUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnLCB2YWx1ZS5zaG93TGFiZWwsIHRydWUpLCBwb3NpdGlvbiwgdmFsdWUuYWxpZ24sIChfZCA9IHZhbHVlLnBhZGRpbmcpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGluc3RhbmNlLm9wdGlvbnMucGFkZGluZywgKF9lID0gdmFsdWUuZm9udCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogaW5zdGFuY2Uub3B0aW9ucy5mb250LCAoX2YgPSB2YWx1ZS5mb3JlZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBpbnN0YW5jZS5vcHRpb25zLmZvcmVncm91bmRDb2xvdXIsIChfZyA9IHZhbHVlLmJhY2tncm91bmRDb2xvdXIpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IGluc3RhbmNlLm9wdGlvbnMuYmFja2dyb3VuZENvbG91cik7XFxuICAgICAgICB9KTtcXG4gICAgICAgIGluc3RhbmNlLmNoYXJ0cy5mb3JFYWNoKGNoYXJ0ID0+IHtcXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcXG4gICAgICAgICAgICBpZiAodGFncyAmJiAhKChfYSA9IGNoYXJ0LnRhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKHRhZyA9PiB0YWdzLmluY2x1ZGVzKHRhZykpKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhcnQuYWxpZ24pIHtcXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKGluc3RhbmNlLm9wdGlvbnMubWFyZ2luLCBsZWZ0WSk7XFxuICAgICAgICAgICAgICAgICAgICBsZWZ0WSArPSBsaW5lSGVpZ2h0ICsgaW5zdGFuY2Uub3B0aW9ucy5saW5lTWFyZ2luO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoY29udGV4dC5jYW52YXMuY2xpZW50V2lkdGggLSBpbnN0YW5jZS5vcHRpb25zLm1hcmdpbiwgcmlnaHRZKTtcXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0WSArPSBsaW5lSGVpZ2h0ICsgaW5zdGFuY2Uub3B0aW9ucy5saW5lTWFyZ2luO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGluc3RhbmNlLmRyYXdDaGFydChjb250ZXh0LCBEZWJ1Zy5wcmVwYXJlTGFiZWwoKF9iID0gY2hhcnQubGFiZWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCAnJywgY2hhcnQuc2hvd0xhYmVsLCBmYWxzZSksIHBvc2l0aW9uLCBjaGFydC5hbGlnbiwgKF9jID0gY2hhcnQucGFkZGluZykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogaW5zdGFuY2Uub3B0aW9ucy5wYWRkaW5nLCAoX2QgPSBjaGFydC5mb250KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBpbnN0YW5jZS5vcHRpb25zLmZvbnQsIChfZSA9IGNoYXJ0LmZvcmVncm91bmRDb2xvdXIpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGluc3RhbmNlLm9wdGlvbnMuZm9yZWdyb3VuZENvbG91ciwgKF9mID0gY2hhcnQuYmFja2dyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogaW5zdGFuY2Uub3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3VyLCBjaGFydC5jaGFydEJhY2tncm91bmRDb2xvdXIsIGNoYXJ0LnZhbHVlcywgY2hhcnQudmFsdWVCdWZmZXJTaXplLCBjaGFydC52YWx1ZUJ1ZmZlclN0cmlkZSwgY2hhcnQubWluVmFsdWUsIGNoYXJ0Lm1heFZhbHVlLCBjaGFydC5iYXJXaWR0aCwgY2hhcnQuYmFyQ29sb3Vycyk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIGluc3RhbmNlLm1hcmtlcnMuZm9yRWFjaChtYXJrZXIgPT4ge1xcbiAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICBpZiAodGFncyAmJiAhKChfYSA9IG1hcmtlci50YWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSh0YWcgPT4gdGFncy5pbmNsdWRlcyh0YWcpKSkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAobWFya2VyLnNwYWNlID09PSAnc2NyZWVuJykge1xcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kcmF3TWFya2VyKGNvbnRleHQsIG1hcmtlcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBpbnN0YW5jZS5ib3JkZXJzLmZvckVhY2goYm9yZGVyID0+IHtcXG4gICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgaWYgKHRhZ3MgJiYgISgoX2EgPSBib3JkZXIudGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUodGFnID0+IHRhZ3MuaW5jbHVkZXModGFnKSkpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGJvcmRlci5zcGFjZSA9PT0gJ3NjcmVlbicpIHtcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZHJhd0JvcmRlcihjb250ZXh0LCBib3JkZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgICAgICAvLyBDbGVhciB2YWx1ZXMsIG1hcmtlcnMgJiBib3JkZXJzIHJlYWR5IGZvciBuZXh0IGZyYW1lXFxuICAgICAgICBpZiAoY2xlYXIpIHtcXG4gICAgICAgICAgICBpbnN0YW5jZS52YWx1ZXMuY2xlYXIoKTtcXG4gICAgICAgICAgICBpbnN0YW5jZS5tYXJrZXJzLmNsZWFyKCk7XFxuICAgICAgICAgICAgaW5zdGFuY2UuYm9yZGVycy5jbGVhcigpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHN0YXRpYyBjbGVhcihjbGVhckNoYXJ0cyA9IGZhbHNlKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpbnN0YW5jZS52YWx1ZXMuY2xlYXIoKTtcXG4gICAgICAgIGluc3RhbmNlLm1hcmtlcnMuY2xlYXIoKTtcXG4gICAgICAgIGlmIChjbGVhckNoYXJ0cykge1xcbiAgICAgICAgICAgIGluc3RhbmNlLmNoYXJ0cy5jbGVhcigpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5zdGFuY2UuYm9yZGVycy5jbGVhcigpO1xcbiAgICB9XFxuICAgIHN0YXRpYyBwcmVwYXJlTGFiZWwobGFiZWwsIHZhbHVlLCBzaG93TGFiZWwsIHNob3dWYWx1ZSkge1xcbiAgICAgICAgY29uc3QgYWN0dWFsTGFiZWwgPSAoc2hvd0xhYmVsICYmIGxhYmVsKSA/IGxhYmVsIDogJyc7XFxuICAgICAgICBjb25zdCBhY3R1YWxWYWx1ZSA9ICghIXNob3dWYWx1ZSAmJiB2YWx1ZSAhPT0gJycpID8gdmFsdWUudG9TdHJpbmcoKSA6ICcnO1xcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gKGFjdHVhbExhYmVsICYmIGFjdHVhbFZhbHVlKSA/ICc6ICcgOiAnJztcXG4gICAgICAgIHJldHVybiBgJHthY3R1YWxMYWJlbH0ke3NlcGFyYXRvcn0ke2FjdHVhbFZhbHVlfWA7XFxuICAgIH1cXG4gICAgZHJhd0xhYmVsKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uLCBhbGlnbiwgcGFkZGluZywgZm9udCwgZm9yZWdyb3VuZENvbG91ciwgYmFja2dyb3VuZENvbG91cikge1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250O1xcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAndG9wJztcXG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRTaXplID0ge1xcbiAgICAgICAgICAgIHdpZHRoOiBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoICsgcGFkZGluZyAqIDIsXFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMubGluZUhlaWdodCArIHBhZGRpbmcgKiAyLFxcbiAgICAgICAgfTtcXG4gICAgICAgIGNvbnN0IHggPSBhbGlnbiA9PT0gJ3JpZ2h0J1xcbiAgICAgICAgICAgID8gKHBvc2l0aW9uLnggLSBiYWNrZ3JvdW5kU2l6ZS53aWR0aClcXG4gICAgICAgICAgICA6IHBvc2l0aW9uLng7XFxuICAgICAgICAvLyBEcmF3IGJhY2tncm91bmRcXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG91cjtcXG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoeCAtIHBhZGRpbmcsIHBvc2l0aW9uLnkgLSBwYWRkaW5nLCBiYWNrZ3JvdW5kU2l6ZS53aWR0aCwgYmFja2dyb3VuZFNpemUuaGVpZ2h0KTtcXG4gICAgICAgIC8vIERyYXcgdGV4dFxcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBmb3JlZ3JvdW5kQ29sb3VyO1xcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCBwb3NpdGlvbi55KTtcXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxuICAgIGRyYXdDaGFydChjb250ZXh0LCBsYWJlbCwgcG9zaXRpb24sIGFsaWduLCBwYWRkaW5nLCBmb250LCBmb3JlZ3JvdW5kQ29sb3VyLCBiYWNrZ3JvdW5kQ29sb3VyLCBjaGFydEJhY2tncm91bmRDb2xvdXIsIHZhbHVlcywgdmFsdWVCdWZmZXJTaXplLCB2YWx1ZUJ1ZmZlclN0cmlkZSwgbWluVmFsdWUsIG1heFZhbHVlLCBiYXJXaWR0aCwgYmFyQ29sb3Vycykge1xcbiAgICAgICAgdmFyIF9hLCBfYjtcXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcXG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XFxuICAgICAgICBjb25zdCBjaGFydFNpemUgPSB7XFxuICAgICAgICAgICAgd2lkdGg6IGJhcldpZHRoICogTWF0aC5jZWlsKHZhbHVlQnVmZmVyU2l6ZSAvIE1hdGgubWF4KHZhbHVlQnVmZmVyU3RyaWRlLCAxKSksXFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMubGluZUhlaWdodCArIHBhZGRpbmcgKiAyLFxcbiAgICAgICAgfTtcXG4gICAgICAgIGNvbnN0IGxhYmVsU2l6ZSA9IHtcXG4gICAgICAgICAgICB3aWR0aDogY29udGV4dC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGgsXFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMubGluZUhlaWdodCxcXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kU2l6ZSA9IHtcXG4gICAgICAgICAgICB3aWR0aDogKGxhYmVsU2l6ZS53aWR0aCArXFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgK1xcbiAgICAgICAgICAgICAgICBjaGFydFNpemUud2lkdGgpICsgcGFkZGluZyAqIDIsXFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMubGluZUhlaWdodCArIHBhZGRpbmcgKiAyLFxcbiAgICAgICAgfTtcXG4gICAgICAgIGNvbnN0IHggPSBhbGlnbiA9PT0gJ3JpZ2h0J1xcbiAgICAgICAgICAgID8gKHBvc2l0aW9uLnggLSBiYWNrZ3JvdW5kU2l6ZS53aWR0aClcXG4gICAgICAgICAgICA6IHBvc2l0aW9uLng7XFxuICAgICAgICAvLyBEcmF3IGJhY2tncm91bmRcXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG91cjtcXG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoeCAtIHBhZGRpbmcsIHBvc2l0aW9uLnkgLSBwYWRkaW5nLCBiYWNrZ3JvdW5kU2l6ZS53aWR0aCwgYmFja2dyb3VuZFNpemUuaGVpZ2h0KTtcXG4gICAgICAgIC8vIERyYXcgbGFiZWxcXG4gICAgICAgIGlmIChsYWJlbCkge1xcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZm9yZWdyb3VuZENvbG91cjtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCB4LCBwb3NpdGlvbi55KTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIERyYXcgY2hhcnRcXG4gICAgICAgIGlmIChjaGFydEJhY2tncm91bmRDb2xvdXIpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNoYXJ0QmFja2dyb3VuZENvbG91cjtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHggKyBwYWRkaW5nICsgbGFiZWxTaXplLndpZHRoICsgcGFkZGluZywgcG9zaXRpb24ueSAtIHBhZGRpbmcsIGNoYXJ0U2l6ZS53aWR0aCwgY2hhcnRTaXplLmhlaWdodCk7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCByYW5nZSA9IG1heFZhbHVlIC0gbWluVmFsdWU7XFxuICAgICAgICBjb25zdCBiYXJPZmZzZXQgPSAoMCwgdmVjXzEudmVjKSh4ICsgcGFkZGluZyArIGxhYmVsU2l6ZS53aWR0aCArIHBhZGRpbmcsIHBvc2l0aW9uLnkgLSBwYWRkaW5nKTtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5jZWlsKHZhbHVlcy5sZW5ndGggLyBNYXRoLm1heCh2YWx1ZUJ1ZmZlclN0cmlkZSwgMSkpOyBpKyspIHtcXG4gICAgICAgICAgICBsZXQgdmFsdWU7XFxuICAgICAgICAgICAgaWYgKHZhbHVlQnVmZmVyU3RyaWRlIDw9IDEpIHtcXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1xcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGkgKiB2YWx1ZUJ1ZmZlclN0cmlkZSwgKGkgKyAxKSAqIHZhbHVlQnVmZmVyU3RyaWRlKVxcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gdmFsdWVCdWZmZXJTdHJpZGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGJhclNpemUgPSAoMCwgdmVjXzEudmVjKShiYXJXaWR0aCwgTWF0aC5yb3VuZChjaGFydFNpemUuaGVpZ2h0ICogKHZhbHVlIC0gbWluVmFsdWUpIC8gcmFuZ2UpKTtcXG4gICAgICAgICAgICBjb25zdCBiYXJQb3NpdGlvbiA9IHZlY18xLnZlYy5hZGQoYmFyT2Zmc2V0LCAoMCwgdmVjXzEudmVjKSgodmFsdWVzLmxlbmd0aCA8IHZhbHVlQnVmZmVyU2l6ZVxcbiAgICAgICAgICAgICAgICA/IE1hdGguY2VpbCgodmFsdWVCdWZmZXJTaXplIC0gdmFsdWVzLmxlbmd0aCkgLyB2YWx1ZUJ1ZmZlclN0cmlkZSkgKiBiYXJXaWR0aFxcbiAgICAgICAgICAgICAgICA6IDApICsgaSAqIGJhcldpZHRoLCBjaGFydFNpemUuaGVpZ2h0IC0gYmFyU2l6ZS55KSk7XFxuICAgICAgICAgICAgY29uc3QgYmFyQ29sb3VyID0gKF9iID0gKGJhckNvbG91cnNcXG4gICAgICAgICAgICAgICAgPyAoX2EgPSBbLi4uYmFyQ29sb3Vyc10ucmV2ZXJzZSgpLmZpbmQoYyA9PiB2YWx1ZXNbaV0gPj0gYy5vZmZzZXQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3VyXFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZm9yZWdyb3VuZENvbG91cjtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGJhckNvbG91cjtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KGJhclBvc2l0aW9uLngsIGJhclBvc2l0aW9uLnksIGJhclNpemUueCwgYmFyU2l6ZS55KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxuICAgIGRyYXdNYXJrZXIoY29udGV4dCwgbWFya2VyKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gKF9hID0gbWFya2VyLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgdmVjXzEudmVjKSgpO1xcbiAgICAgICAgaWYgKG1hcmtlci5zaG93TGFiZWwgfHwgbWFya2VyLnNob3dWYWx1ZSkge1xcbiAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVsKGNvbnRleHQsIERlYnVnLnByZXBhcmVMYWJlbCgoX2IgPSBtYXJrZXIubGFiZWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCAoX2MgPSBtYXJrZXIudmFsdWUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnLCBtYXJrZXIuc2hvd0xhYmVsLCBtYXJrZXIuc2hvd1ZhbHVlKSwgdmVjXzEudmVjLmFkZChwb3NpdGlvbiAhPT0gbnVsbCAmJiBwb3NpdGlvbiAhPT0gdm9pZCAwID8gcG9zaXRpb24gOiAoMCwgdmVjXzEudmVjKSgpLCBtYXJrZXIubGFiZWxPZmZzZXQpLCAnbGVmdCcsIChfZCA9IG1hcmtlci5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLm9wdGlvbnMucGFkZGluZywgKF9lID0gbWFya2VyLmZvbnQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMub3B0aW9ucy5mb250LCAoX2YgPSBtYXJrZXIuZm9yZWdyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5vcHRpb25zLmZvcmVncm91bmRDb2xvdXIsIChfZyA9IG1hcmtlci5iYWNrZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG91cik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobWFya2VyLnNob3dNYXJrZXIpIHtcXG4gICAgICAgICAgICBpZiAobWFya2VyLm1hcmtlckltYWdlKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG1hcmtlci5tYXJrZXJJbWFnZSwgcG9zaXRpb24ueCAtIG1hcmtlci5tYXJrZXJJbWFnZS53aWR0aCAvIDIsIHBvc2l0aW9uLnkgLSBtYXJrZXIubWFya2VySW1hZ2UuaGVpZ2h0IC8gMik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IG1hcmtlci5tYXJrZXJMaW5lV2lkdGg7XFxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb250ZXh0LmZpbGxTdHlsZSA9IG1hcmtlci5tYXJrZXJDb2xvdXI7XFxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWFya2VyLm1hcmtlclN0eWxlKSB7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDcm9zcyhjb250ZXh0LCBwb3NpdGlvbiwgbWFya2VyLm1hcmtlclNpemUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UGx1cyhjb250ZXh0LCBwb3NpdGlvbiwgbWFya2VyLm1hcmtlclNpemUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLic6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3RG90KGNvbnRleHQsIHBvc2l0aW9uLCBtYXJrZXIubWFya2VyU2l6ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3Q3Jvc3MoY29udGV4dCwgcG9zaXRpb24sIHNpemUpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgICAgICBjb25zdCBoYWxmU2l6ZSA9IHNpemUgLyAyO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBkcmF3UGx1cyhjb250ZXh0LCBwb3NpdGlvbiwgc2l6ZSkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnN0IGhhbGZTaXplID0gc2l6ZSAvIDI7XFxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb3NpdGlvbi54ICsgaGFsZlNpemUsIHBvc2l0aW9uLnkpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBkcmF3RG90KGNvbnRleHQsIHBvc2l0aW9uLCBzaXplKSB7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5hcmMocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgc2l6ZSAvIDIsIDAsIE1hdGguUEkgKiAyKTtcXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xcbiAgICB9XFxuICAgIGRyYXdCb3JkZXIoY29udGV4dCwgYm9yZGVyKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gKF9hID0gYm9yZGVyLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgdmVjXzEudmVjKSgpO1xcbiAgICAgICAgaWYgKGJvcmRlci5zaG93TGFiZWwgfHwgYm9yZGVyLnNob3dWYWx1ZSkge1xcbiAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVsKGNvbnRleHQsIERlYnVnLnByZXBhcmVMYWJlbCgoX2IgPSBib3JkZXIubGFiZWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCAoX2MgPSBib3JkZXIudmFsdWUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnLCBib3JkZXIuc2hvd0xhYmVsLCBib3JkZXIuc2hvd1ZhbHVlKSwgdmVjXzEudmVjLmFkZChwb3NpdGlvbiAhPT0gbnVsbCAmJiBwb3NpdGlvbiAhPT0gdm9pZCAwID8gcG9zaXRpb24gOiAoMCwgdmVjXzEudmVjKSgpLCBib3JkZXIubGFiZWxPZmZzZXQpLCAnbGVmdCcsIChfZCA9IGJvcmRlci5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLm9wdGlvbnMucGFkZGluZywgKF9lID0gYm9yZGVyLmZvbnQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMub3B0aW9ucy5mb250LCAoX2YgPSBib3JkZXIuZm9yZWdyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5vcHRpb25zLmZvcmVncm91bmRDb2xvdXIsIChfZyA9IGJvcmRlci5iYWNrZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG91cik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYm9yZGVyLnNob3dCb3JkZXIpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlci5ib3JkZXJXaWR0aDtcXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29udGV4dC5maWxsU3R5bGUgPSBib3JkZXIuYm9yZGVyQ29sb3VyO1xcbiAgICAgICAgICAgIHN3aXRjaCAoYm9yZGVyLmJvcmRlclN0eWxlKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtib3JkZXIuYm9yZGVyRGFzaFNpemUsIGJvcmRlci5ib3JkZXJEYXNoU2l6ZV0pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtib3JkZXIuYm9yZGVyV2lkdGgsIGJvcmRlci5ib3JkZXJXaWR0aF0pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHN3aXRjaCAoYm9yZGVyLmJvcmRlclNoYXBlKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlY3RhbmdsZSc6XFxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9yZGVyLnNpemUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoY29udGV4dCwgcG9zaXRpb24sIGJvcmRlci5zaXplKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlICdjaXJjbGUnOlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvcmRlci5yYWRpdXMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDaXJjbGUoY29udGV4dCwgcG9zaXRpb24sIGJvcmRlci5yYWRpdXMpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgIH1cXG4gICAgZHJhd1JlY3RhbmdsZShjb250ZXh0LCBwb3NpdGlvbiwgc2l6ZSkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnRleHQucmVjdChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBzaXplLngsIHNpemUueSk7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICB9XFxuICAgIGRyYXdDaXJjbGUoY29udGV4dCwgcG9zaXRpb24sIHJhZGl1cykge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnRleHQuYXJjKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbn1cXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBEZWJ1ZztcXG5EZWJ1Zy5kZWZhdWx0T3B0aW9ucyA9IHtcXG4gICAgbWFyZ2luOiAxMCxcXG4gICAgcGFkZGluZzogNCxcXG4gICAgZm9udDogJzEwcHQgTHVjaWRhIENvbnNvbGUsIG1vbm9zcGFjZScsXFxuICAgIGxpbmVIZWlnaHQ6IDEyLFxcbiAgICBsaW5lTWFyZ2luOiAwLFxcbiAgICBmb3JlZ3JvdW5kQ29sb3VyOiAnI2ZmZicsXFxuICAgIGJhY2tncm91bmRDb2xvdXI6ICcjMzMzJyxcXG4gICAgZGVmYXVsdFZhbHVlOiB7XFxuICAgICAgICBhbGlnbjogJ2xlZnQnLFxcbiAgICAgICAgc2hvd0xhYmVsOiB0cnVlLFxcbiAgICB9LFxcbiAgICBkZWZhdWx0Q2hhcnQ6IHtcXG4gICAgICAgIHZhbHVlczogW10sXFxuICAgICAgICB2YWx1ZUJ1ZmZlclNpemU6IDYwLFxcbiAgICAgICAgdmFsdWVCdWZmZXJTdHJpZGU6IDEsXFxuICAgICAgICBtaW5WYWx1ZTogMCxcXG4gICAgICAgIG1heFZhbHVlOiAxMDAsXFxuICAgICAgICBiYXJXaWR0aDogMixcXG4gICAgICAgIGFsaWduOiAnbGVmdCcsXFxuICAgICAgICBzaG93TGFiZWw6IHRydWUsXFxuICAgICAgICBjaGFydEJhY2tncm91bmRDb2xvdXI6ICcjMjIyJyxcXG4gICAgfSxcXG4gICAgZGVmYXVsdE1hcmtlcjoge1xcbiAgICAgICAgc2hvd0xhYmVsOiB0cnVlLFxcbiAgICAgICAgc2hvd1ZhbHVlOiB0cnVlLFxcbiAgICAgICAgc2hvd01hcmtlcjogdHJ1ZSxcXG4gICAgICAgIG1hcmtlclNpemU6IDYsXFxuICAgICAgICBtYXJrZXJMaW5lV2lkdGg6IDIsXFxuICAgICAgICBtYXJrZXJTdHlsZTogJ3gnLFxcbiAgICAgICAgbWFya2VyQ29sb3VyOiAnI2NjYycsXFxuICAgICAgICBzcGFjZTogJ3dvcmxkJyxcXG4gICAgICAgIGxhYmVsT2Zmc2V0OiAoMCwgdmVjXzEudmVjKSgxMCksXFxuICAgIH0sXFxuICAgIGRlZmF1bHRCb3JkZXI6IHtcXG4gICAgICAgIHNob3dMYWJlbDogdHJ1ZSxcXG4gICAgICAgIHNob3dWYWx1ZTogdHJ1ZSxcXG4gICAgICAgIHNob3dCb3JkZXI6IHRydWUsXFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcXG4gICAgICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxcbiAgICAgICAgYm9yZGVyU2hhcGU6ICdyZWN0YW5nbGUnLFxcbiAgICAgICAgYm9yZGVyQ29sb3VyOiAnI2NjYycsXFxuICAgICAgICBib3JkZXJEYXNoU2l6ZTogNSxcXG4gICAgICAgIHNwYWNlOiAnd29ybGQnLFxcbiAgICAgICAgbGFiZWxPZmZzZXQ6ICgwLCB2ZWNfMS52ZWMpKDEwKSxcXG4gICAgfSxcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qKlxcbiAqIEBvdmVydmlldyBBIGxpYnJhcnkgb2YgdXNlZnVsIGZ1bmN0aW9uc1xcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXIgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlciBiXFxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBudW1iZXJzIGEgYW5kIGIgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKi9cXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XFxuXFxuLyoqXFxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gY2xhbXBcXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBIGNsYW1wZWQgbnVtYmVyXFxuICovXFxuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBmcmFjdGlvbmFsIHBhcnRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIG51bWJlclxcbiAqL1xcbmNvbnN0IGZyYWMgPSBhID0+IGEgPj0gMCA/IGEgLSBNYXRoLmZsb29yKGEpIDogYSAtIE1hdGguY2VpbChhKTtcXG5cXG4vKipcXG4gKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKi9cXG5jb25zdCBsZXJwID0gKGEsIGIsIGkpID0+IGEgKyAoYiAtIGEpICogaTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcXG4gKi9cXG5jb25zdCB1bmxlcnAgPSAoYSwgYiwgaSkgPT4gKGkgLSBhKSAvIChiIC0gYSk7XFxuXFxuLyoqXFxuICogRG8gYSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTAgVG9wLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMSBCb3R0b20tbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGl4IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeSBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXFxuICovXFxuY29uc3QgYmxlcnAgPSAoYzAwLCBjMTAsIGMwMSwgYzExLCBpeCwgaXkpID0+IGxlcnAobGVycChjMDAsIGMxMCwgaXgpLCBsZXJwKGMwMSwgYzExLCBpeCksIGl5KTtcXG5cXG4vKipcXG4gKiBSZS1tYXAgYSBudW1iZXIgaSBmcm9tIHJhbmdlIGExLi4uYTIgdG8gYjEuLi5iMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXFxuICogQHBhcmFtIHtudW1iZXJ9IGExXFxuICogQHBhcmFtIHtudW1iZXJ9IGEyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIxXFxuICogQHBhcmFtIHtudW1iZXJ9IGIyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmNvbnN0IHJlbWFwID0gKGksIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArIChpIC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xcblxcbi8qKlxcbiAqIERvIGEgc21vb3RoIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3Qgc21vb3Roc3RlcCA9IChhLCBiLCBpKSA9PiBsZXJwKGEsIGIsIDMgKiBNYXRoLnBvdyhpLCAyKSAtIDIgKiBNYXRoLnBvdyhpLCAzKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKi9cXG5jb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiBkZWdyZWVzXFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiBkZWdyZWVzXFxuICovXFxuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEV4Y2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICovXFxuY29uc3QgcmFuZG9tQmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xcblxcbi8qKlxcbiAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICovXFxuY29uc3QgcmFuZG9tSW50QmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IFttdT0wLjVdIFRoZSBtZWFuIHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9Ml0gVGhlIG51bWJlciBvZiBzYW1wbGVzXFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb20gPSAobXUgPSAwLjUsIHNpZ21hID0gMC41LCBzYW1wbGVzID0gMikgPT4ge1xcbiAgbGV0IHRvdGFsID0gMDtcXG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XFxuICAgIHRvdGFsICs9IE1hdGgucmFuZG9tKCk7XFxuICB9XFxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlclxcbiAqL1xcbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdyBBbiBhcnJheSBvZiB3ZWlnaHRzXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbmRleCBmcm9tIHdcXG4gKi9cXG5jb25zdCB3ZWlnaHRlZFJhbmRvbSA9IHcgPT4ge1xcbiAgbGV0IHRvdGFsID0gdy5yZWR1Y2UoKGEsIGkpID0+IGEgKyBpLCAwKSwgbiA9IDA7XFxuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xcbiAgd2hpbGUgKHRvdGFsID4gcikge1xcbiAgICB0b3RhbCAtPSB3W24rK107XFxuICB9XFxuICByZXR1cm4gbiAtIDE7XFxufTtcXG5cXG4vKipcXG4gKiBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXFxuICogQGNhbGxiYWNrIGludGVycG9sYXRpb25DYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmcm9tIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIEEgbnVtYmVyIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcGFyYW0ge2ludGVycG9sYXRpb25DYWxsYmFja30gW2Y9TWF0aC5sZXJwXSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB0byB1c2VcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxcbiAqL1xcbmNvbnN0IGxlcnBBcnJheSA9IChhLCBpLCBmID0gbGVycCkgPT4ge1xcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcXG4gIGNvbnN0IHAgPSBjbGFtcChNYXRoLnRydW5jKHMpLCAwLCBhLmxlbmd0aCAtIDEpO1xcbiAgcmV0dXJuIGYoYVtwXSB8fCAwLCBhW3AgKyAxXSB8fCAwLCBmcmFjKHMpKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG5jb25zdCBkb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmYWN0b3JpYWwgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYVxcbiAqIEByZXR1cm4ge251bWJlcn0gYSFcXG4gKi9cXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcXG4gIGxldCByZXN1bHQgPSAxO1xcbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gYTsgaSsrKSB7XFxuICAgIHJlc3VsdCAqPSBpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxcbiAqL1xcbmNvbnN0IHBlcm11dGF0aW9uID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIGZhY3RvcmlhbChuIC0gcik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcGFyYW0ge251bWJlcn0gclxcbiAqIEByZXR1cm4ge251bWJlcn0gbkNyXFxuICovXFxuY29uc3QgY29tYmluYXRpb24gPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gKGZhY3RvcmlhbChyKSAqIGZhY3RvcmlhbChuIC0gcikpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYXJyYXkgdmFsdWVzXFxuICogQGNhbGxiYWNrIHRpbWVzQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBUaGUgYXJyYXkgdmFsdWVcXG4gKi9cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBsZW5ndGggbiBieSBjYWxsaW5nIGZ1bmN0aW9uIGYoaSkgb24gZWFjaCBlbGVtZW50XFxuICogQHBhcmFtIHt0aW1lc0NhbGxiYWNrfSBmXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIGFycmF5XFxuICogQHJldHVybiB7QXJyYXk8Kj59XFxuICovXFxuY29uc3QgdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIG51bWJlcnMgMC0+KG4gLSAxKVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIGludGVnZXJzIDAtPihuIC0gMSlcXG4gKi9cXG5jb25zdCByYW5nZSA9IG4gPT4gdGltZXMoaSA9PiBpLCBuKTtcXG5cXG4vKipcXG4gKiBaaXAgMiBhcnJheXMgdG9nZXRoZXIsIGkuZS4gKFsxLCAyLCAzXSwgW2EsIGIsIGNdKSA9PiBbWzEsIGFdLCBbMiwgYl0sIFszLCBjXV1cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYlxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn1cXG4gKi9cXG5jb25zdCB6aXAgPSAoYSwgYikgPT4gYS5tYXAoKGssIGkpID0+IFtrLCBiW2ldXSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGFycmF5W2ldIHdpdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHdyYXBwaW5nXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBwb3NpdGl2ZWx5L25lZ2F0aXZlbHkgd3JhcHBlZCBhcnJheSBpbmRleFxcbiAqIEByZXR1cm4geyp9IEFuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcXG4gKi9cXG5jb25zdCBhdCA9IChhLCBpKSA9PiBhW2kgPCAwID8gYS5sZW5ndGggLSAoTWF0aC5hYnMoaSArIDEpICUgYS5sZW5ndGgpIC0gMSA6IGkgJSBhLmxlbmd0aF07XFxuXFxuLyoqXFxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNodW5rIHNpemVcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xcbiAqL1xcbmNvbnN0IGNodW5rID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcblxcbi8qKlxcbiAqIFJhbmRvbWx5IHNodWZmbGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSBzaHVmZmxlZCBhcnJheVxcbiAqL1xcbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHtcXG4gICAgZmxvYXRFcXVhbHMsXFxuICAgIGNsYW1wLFxcbiAgICBmcmFjLFxcbiAgICBsZXJwLFxcbiAgICB1bmxlcnAsXFxuICAgIGJsZXJwLFxcbiAgICByZW1hcCxcXG4gICAgc21vb3Roc3RlcCxcXG4gICAgcmFkaWFucyxcXG4gICAgZGVncmVlcyxcXG4gICAgcmFuZG9tQmV0d2VlbixcXG4gICAgcmFuZG9tSW50QmV0d2VlbixcXG4gICAgY2x0UmFuZG9tLFxcbiAgICBjbHRSYW5kb21JbnQsXFxuICAgIHdlaWdodGVkUmFuZG9tLFxcbiAgICBsZXJwQXJyYXksXFxuICAgIGRvdCxcXG4gICAgZmFjdG9yaWFsLFxcbiAgICBwZXJtdXRhdGlvbixcXG4gICAgY29tYmluYXRpb24sXFxuICAgIHRpbWVzLFxcbiAgICByYW5nZSxcXG4gICAgemlwLFxcbiAgICBhdCxcXG4gICAgY2h1bmssXFxuICAgIHNodWZmbGUsXFxuICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcImNvbnN0IHsgdGltZXMsIGNodW5rLCBkb3QgfSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIEBvdmVydmlldyBBIGxpYnJhcnkgb2YgdXNlZnVsIGZ1bmN0aW9uc1xcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuLyoqXFxuICogQSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWNcXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfHZlY30gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlY30gQSBuZXcgdmVjdG9yXFxuICogQGV4YW1wbGUgPGNhcHRpb24+VmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMoMywgMik7ICAvLyAoMywgMilcXG4gKiBsZXQgYiA9IHZlYyg0KTsgICAgIC8vICg0LCA0KVxcbiAqIGxldCBjID0gdmVjKGEpOyAgICAgLy8gKDMsIDIpXFxuICogbGV0IGQgPSB2ZWMoKTsgICAgICAvLyAoMCwgMClcXG4gKi9cXG5jb25zdCB2ZWMgPSAoeCwgeSkgPT4gKCF4ICYmICF5ID9cXG4gIHsgeDogMCwgeTogMCB9IDogKHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/XFxuICAgIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwIH0gOiAoeSA9PT0gbnVsbCB8fCB5ID09PSB1bmRlZmluZWQgP1xcbiAgICAgIHsgeDogeCwgeTogeCB9IDogeyB4OiB4LCB5OiB5IH0pXFxuICApXFxuKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcXG4gKi9cXG52ZWMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55XTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMClcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICovXFxudmVjLnV4ID0gKCkgPT4gdmVjKDEsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqIEByZXR1cm4ge3ZlY30gQSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKi9cXG52ZWMudXkgPSAoKSA9PiB2ZWMoMCwgMSk7XFxuXFxuLyoqXFxuICogQWRkIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjfSBhICsgYlxcbiAqL1xcbnZlYy5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgYi54LCB5OiBhLnkgKyBiLnkgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjfSBhICogYlxcbiAqL1xcbnZlYy5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogYiwgeTogYS55ICogYiB9KTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAtIGJcXG4gKi9cXG52ZWMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIGIueCwgeTogYS55IC0gYi55IH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSk7XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHt2ZWN9IF5hXFxuICovXFxudmVjLm5vciA9IGEgPT4ge1xcbiAgbGV0IGxlbiA9IHZlYy5sZW4oYSk7XFxuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiB9IDogdmVjKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxcbiAqL1xcbnZlYy5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnNcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMucm90ID0gKGEsIHIpID0+IHtcXG4gIGxldCBzID0gTWF0aC5zaW4ociksXFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcXG4gIHJldHVybiB7IHg6IGMgKiBhLnggLSBzICogYS55LCB5OiBzICogYS54ICsgYyAqIGEueSB9O1xcbn1cXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZWN0b3JzIGEgYW5kIGIgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG52ZWMuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYy5yYWQgPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLngpO1xcblxcbi8qKlxcbiAqIENvcHkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYy5jcHkgPSBhID0+IHZlYyhhKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3JcXG4gKiBAY2FsbGJhY2sgdmVjdG9yTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjdG9yTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlY30gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYy5tYXAgPSAoYSwgZikgPT4gKHsgeDogZihhLngsICd4JyksIHk6IGYoYS55LCAneScpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYy5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcXG5cXG4vKipcXG4gKiBBIG1hdHJpeFxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1hdFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIG1hdHJpeCB2YWx1ZXNcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgbWF0cml4XFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj00XSBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbnRyaWVzPVtdXSBNYXRyaXggdmFsdWVzIGluIHJlYWRpbmcgb3JkZXJcXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxcbiAqL1xcbmNvbnN0IG1hdCA9IChtID0gNCwgbiA9IDQsIGVudHJpZXMgPSBbXSkgPT4gKHtcXG4gIG0sIG4sXFxuICBlbnRyaWVzOiBlbnRyaWVzLmNvbmNhdChBcnJheShtICogbikuZmlsbCgwKSkuc2xpY2UoMCwgbSAqIG4pXFxufSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGlkZW50aXR5IG1hdHJpeCBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBBbiBpZGVudGl0eSBtYXRyaXhcXG4gKi9cXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgYXQgcG9zaXRpb24gKGksIGopIGluIG1hdHJpeCBhXFxuICovXFxubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xcblxcbi8qKlxcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB2YWx1ZSB0byBzZXQgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XFxuXFxuLyoqXFxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtIFRoZSByb3cgb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5yb3cgPSAoYSwgbSkgPT4ge1xcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XFxuICByZXR1cm4gYS5lbnRyaWVzLnNsaWNlKHMsIHMgKyBhLm4pO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgY29sdW1uIGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQ29sdW1uIG4gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5jb2wgPSAoYSwgbikgPT4gdGltZXMoaSA9PiBtYXQuZ2V0KGEsIChpICsgMSksIG4pLCBhLm0pO1xcblxcbi8qKlxcbiAqIEFkZCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKyBiXFxuICovXFxubWF0LmFkZCA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2ICsgYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgLSBiXFxuICovXFxubWF0LnN1YiA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2IC0gYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBNdWx0aXBseSBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpY2VzIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bCA9IChhLCBiKSA9PiB7XFxuICBpZiAoYS5uICE9PSBiLm0pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYi5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgZG90KG1hdC5yb3coYSwgaSksIG1hdC5jb2woYiwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcXG4gKi9cXG5tYXQuc2NhbGUgPSAoYSwgYikgPT4gbWF0Lm1hcChhLCB2ID0+IHYgKiBiKTtcXG5cXG4vKipcXG4gKiBUcmFuc3Bvc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxcbiAqIEByZXR1cm4ge21hdH0gQSB0cmFuc3Bvc2VkIG1hdHJpeFxcbiAqL1xcbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCB0aW1lcyhpID0+IG1hdC5jb2woYSwgKGkgKyAxKSksIGEubikuZmxhdCgpKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG1pbm9yIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IFRoZSAoaSwgaikgbWlub3Igb2YgbWF0cml4IGEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcXG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XFxuICAgIGlmIChpaSA9PT0gaSkgeyBjb250aW51ZTsgfVxcbiAgICBmb3IgKGxldCBqaiA9IDE7IGpqIDw9IGEubjsgamorKykge1xcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxcbiAgICAgIGVudHJpZXMucHVzaChtYXQuZ2V0KGEsIGlpLCBqaikpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbWF0KGEubSAtIDEsIGEubiAtIDEsIGVudHJpZXMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59IHxhfCBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQuZGV0ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBpZiAoYS5tID09PSAxKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF07XFxuICB9XFxuICBpZiAoYS5tID09PSAyKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF0gKiBhLmVudHJpZXNbM10gLSBhLmVudHJpZXNbMV0gKiBhLmVudHJpZXNbMl07XFxuICB9XFxuICBsZXQgdG90YWwgPSAwLCBzaWduID0gMTtcXG4gIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgIHRvdGFsICs9IHNpZ24gKiBhLmVudHJpZXNbaiAtIDFdICogbWF0LmRldChtYXQubWlub3IoYSwgMSwgaikpO1xcbiAgICBzaWduICo9IC0xO1xcbiAgfVxcbiAgcmV0dXJuIHRvdGFsO1xcbn07XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gXmEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm5vciA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICByZXR1cm4gbWF0Lm1hcChhLCBpID0+IGkgKiBkKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYWRqdWdhdGUgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxcbiAqIEByZXR1cm4ge21hdH0gVGhlIGFkanVnYXRlIG9mIGFcXG4gKi9cXG5tYXQuYWRqID0gYSA9PiB7XFxuICBjb25zdCBtaW5vcnMgPSBtYXQoYS5tLCBhLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KG1pbm9ycywgaSwgaiwgbWF0LmRldChtYXQubWlub3IoYSwgaSwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgY29uc3QgY29mYWN0b3JzID0gbWF0Lm1hcChtaW5vcnMsICh2LCBpKSA9PiB2ICogKGkgJSAyID8gLTEgOiAxKSk7XFxuICByZXR1cm4gbWF0LnRyYW5zKGNvZmFjdG9ycyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGludmVydFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBhXi0xIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaGFzIG5vIGludmVyc2VcXG4gKi9cXG5tYXQuaW52ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgcmV0dXJuIG1hdC5zY2FsZShtYXQuYWRqKGEpLCAxIC8gZCk7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gbWF0cmljZXMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWF0cmljZXMgYSBhbmQgYiBhcmUgaWRlbnRpY2FsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG5tYXQuZXEgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0LnN0cihhKSA9PT0gbWF0LnN0cihiKTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb3B5XFxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcXG4gKi9cXG5tYXQuY3B5ID0gYSA9PiBtYXQoYS5tLCBhLm4sIFsuLi5hLmVudHJpZXNdKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZW50cnkgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGVudHJ5IGluZGV4XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBlbnRyeVxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4IGFuZCBidWlsZCBhIG5ldyBtYXRyaXggZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXRyaXhNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IE1hdHJpeCBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG5tYXQubWFwID0gKGEsIGYpID0+IG1hdChhLm0sIGEubiwgYS5lbnRyaWVzLm1hcChmKSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIG1hdHJpeCBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbnM9J1xcXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcXG4gKi9cXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxcXG4nKSA9PiBjaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XFxuXFxuaWYgKHRydWUpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0geyB2ZWMsIG1hdCB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5Nb3VzZUJ1dHRvbiA9IHZvaWQgMDtcXG5jb25zdCB2ZWNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3ZlYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1xcXCIpO1xcbnZhciBNb3VzZUJ1dHRvbjtcXG4oZnVuY3Rpb24gKE1vdXNlQnV0dG9uKSB7XFxuICAgIE1vdXNlQnV0dG9uW01vdXNlQnV0dG9uW1xcXCJMZWZ0XFxcIl0gPSAwXSA9IFxcXCJMZWZ0XFxcIjtcXG4gICAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXFxcIk1pZGRsZVxcXCJdID0gMV0gPSBcXFwiTWlkZGxlXFxcIjtcXG4gICAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXFxcIlJpZ2h0XFxcIl0gPSAyXSA9IFxcXCJSaWdodFxcXCI7XFxufSkoTW91c2VCdXR0b24gPSBleHBvcnRzLk1vdXNlQnV0dG9uIHx8IChleHBvcnRzLk1vdXNlQnV0dG9uID0ge30pKTtcXG5jbGFzcyBJbnB1dE1hbmFnZXIge1xcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XFxuICAgICAgICB0aGlzLmtleWJvYXJkU3RhdGUgPSBJbnB1dE1hbmFnZXIuaW5pdGlhbEtleWJvYXJkU3RhdGUoKTtcXG4gICAgICAgIHRoaXMucHJldmlvdXNLZXlib2FyZFN0YXRlID0gSW5wdXRNYW5hZ2VyLmluaXRpYWxLZXlib2FyZFN0YXRlKCk7XFxuICAgICAgICB0aGlzLm1vdXNlU3RhdGUgPSBJbnB1dE1hbmFnZXIuaW5pdGlhbE1vdXNlU3RhdGUoKTtcXG4gICAgICAgIHRoaXMucHJldmlvdXNNb3VzZVN0YXRlID0gSW5wdXRNYW5hZ2VyLmluaXRpYWxNb3VzZVN0YXRlKCk7XFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBJbnB1dE1hbmFnZXIuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcXG4gICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyc1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tb3VzZSkge1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGUgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUuYnV0dG9uc1tlLmJ1dHRvbl0gPSB0cnVlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBlID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLmJ1dHRvbnNbZS5idXR0b25dID0gZmFsc2U7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsICgpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLmJ1dHRvbnNbMF0gPSB0cnVlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKCkgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUuYnV0dG9uc1swXSA9IGZhbHNlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGUgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUucG9zaXRpb24ueCA9IGUub2Zmc2V0WDtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLnBvc2l0aW9uLnkgPSBlLm9mZnNldFk7XFxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VTdGF0ZS5ob3ZlcmVkRWxlbWVudCA9IGUudGFyZ2V0O1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubW91c2VXaGVlbCkge1xcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBlID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW91c2VTdGF0ZS53aGVlbCA9IGUuZGVsdGFZID4gMCA/IDEgOiAtMTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZCkge1xcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRTdGF0ZVtlLmNvZGVdID0gdHJ1ZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBlID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlib2FyZFN0YXRlW2UuY29kZV0gPSBmYWxzZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIFByZXZlbnQgdGhlIGNvbnRleHQgbWVudSBmcm9tIGFwcGVhcmluZyBvbiByaWdodC1jbGlja1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50Q29udGV4dE1lbnUpIHtcXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGUgPT4ge1xcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpc2UgdGhlIGlucHV0IG1hbmFnZXIgZm9yIG1hbmFnaW5nIG1vdXNlIGFuZCBrZXlib2FyZCBpbnB1dFxcbiAgICAgKi9cXG4gICAgc3RhdGljIGluaXRpYWxpc2Uob3B0aW9ucykge1xcbiAgICAgICAgaWYgKElucHV0TWFuYWdlci5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIElucHV0TWFuYWdlci5pbnN0YW5jZSA9IG5ldyBJbnB1dE1hbmFnZXIob3B0aW9ucyk7XFxuICAgIH1cXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xcbiAgICAgICAgaWYgKElucHV0TWFuYWdlci5pbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtYW5hZ2VyIG5vdCBwcm9wZXJseSBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIElucHV0TWFuYWdlci5pbnN0YW5jZTtcXG4gICAgfVxcbiAgICBzdGF0aWMgaW5pdGlhbEtleWJvYXJkU3RhdGUoKSB7XFxuICAgICAgICByZXR1cm4ge307XFxuICAgIH1cXG4gICAgc3RhdGljIGluaXRpYWxNb3VzZVN0YXRlKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBidXR0b25zOiB7XFxuICAgICAgICAgICAgICAgIFtNb3VzZUJ1dHRvbi5MZWZ0XTogZmFsc2UsXFxuICAgICAgICAgICAgICAgIFtNb3VzZUJ1dHRvbi5NaWRkbGVdOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgW01vdXNlQnV0dG9uLlJpZ2h0XTogZmFsc2UsXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBwb3NpdGlvbjogKDAsIHZlY18xLnZlYykoKSxcXG4gICAgICAgICAgICB3aGVlbDogMCxcXG4gICAgICAgICAgICBob3ZlcmVkRWxlbWVudDogbnVsbCxcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgc3RhdGljIGNvcHlLZXlib2FyZFN0YXRlKHN0YXRlKSB7XFxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xcbiAgICB9XFxuICAgIHN0YXRpYyBjb3B5TW91c2VTdGF0ZShzdGF0ZSkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBidXR0b25zOiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5idXR0b25zKSxcXG4gICAgICAgICAgICBwb3NpdGlvbjogdmVjXzEudmVjLmNweShzdGF0ZS5wb3NpdGlvbiksXFxuICAgICAgICAgICAgd2hlZWw6IHN0YXRlLndoZWVsLFxcbiAgICAgICAgICAgIGhvdmVyZWRFbGVtZW50OiBzdGF0ZS5ob3ZlcmVkRWxlbWVudCxcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIGlucHV0IGRldmljZXNcXG4gICAgICovXFxuICAgIHN0YXRpYyB1cGRhdGUoKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlID0gdGhpcy5jb3B5S2V5Ym9hcmRTdGF0ZShpbnN0YW5jZS5rZXlib2FyZFN0YXRlKTtcXG4gICAgICAgIGluc3RhbmNlLnByZXZpb3VzTW91c2VTdGF0ZSA9IHRoaXMuY29weU1vdXNlU3RhdGUoaW5zdGFuY2UubW91c2VTdGF0ZSk7XFxuICAgICAgICBpbnN0YW5jZS5tb3VzZVN0YXRlLndoZWVsID0gMDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBrZXkgaXMgY3VycmVudGx5IHByZXNzZWQgZG93blxcbiAgICAgKi9cXG4gICAgc3RhdGljIGtleURvd24oY29kZSkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBrZXkgaXMgZG93blxcbiAgICAgICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBpbnN0YW5jZS5rZXlib2FyZFN0YXRlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2tdKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gISFpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2NvZGVdO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiBhIGtleSBoYXMgYmVlbiBwcmVzc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBzdGF0aWMga2V5UHJlc3NlZChjb2RlKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGtleSB3YXMgcHJlc3NlZFxcbiAgICAgICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBpbnN0YW5jZS5rZXlib2FyZFN0YXRlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2tdICYmXFxuICAgICAgICAgICAgICAgICAgICAoIShrIGluIGluc3RhbmNlLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZSkgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2tdKSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICghIWluc3RhbmNlLmtleWJvYXJkU3RhdGVbY29kZV0gJiZcXG4gICAgICAgICAgICAhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2NvZGVdKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBrZXkgaGFzIGJlZW4gcmVsZWFzZWQgc2luY2UgdGhlIGxhc3QgZnJhbWVcXG4gICAgICovXFxuICAgIHN0YXRpYyBrZXlSZWxlYXNlZChjb2RlKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGtleSB3YXMgcmVsZWFzZWRcXG4gICAgICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZSkge1xcbiAgICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmtleWJvYXJkU3RhdGVba10gJiZcXG4gICAgICAgICAgICAgICAgICAgICEhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2tdKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKCFpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2NvZGVdICYmXFxuICAgICAgICAgICAgISFpbnN0YW5jZS5wcmV2aW91c0tleWJvYXJkU3RhdGVbY29kZV0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiBhIG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgcHJlc3NlZCBkb3duXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VEb3duKGJ1dHRvbikge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBidXR0b24gaXMgZG93blxcbiAgICAgICAgaWYgKGJ1dHRvbiA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgZm9yIChjb25zdCBiIGluIGluc3RhbmNlLm1vdXNlU3RhdGUuYnV0dG9ucykge1xcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QnV0dG9uID0gK2I7XFxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnNbY3VycmVudEJ1dHRvbl0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAhIWluc3RhbmNlLm1vdXNlU3RhdGUuYnV0dG9uc1tidXR0b25dO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiBhIG1vdXNlIGJ1dHRvbiBoYXMgYmVlbiBwcmVzc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VQcmVzc2VkKGJ1dHRvbikge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBidXR0b24gd2FzIHByZXNzZWRcXG4gICAgICAgIGlmIChidXR0b24gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgYiBpbiBpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnMpIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJ1dHRvbiA9ICtiO1xcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zW2N1cnJlbnRCdXR0b25dICYmXFxuICAgICAgICAgICAgICAgICAgICAoIShiIGluIGluc3RhbmNlLnByZXZpb3VzTW91c2VTdGF0ZS5idXR0b25zKSB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICFpbnN0YW5jZS5wcmV2aW91c01vdXNlU3RhdGUuYnV0dG9uc1tjdXJyZW50QnV0dG9uXSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAoISFpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnNbYnV0dG9uXSAmJlxcbiAgICAgICAgICAgICFpbnN0YW5jZS5wcmV2aW91c01vdXNlU3RhdGUuYnV0dG9uc1tidXR0b25dKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBtb3VzZSBidXR0b24gaGFzIGJlZW4gcmVsZWFzZWQgc2luY2UgdGhlIGxhc3QgZnJhbWVcXG4gICAgICovXFxuICAgIHN0YXRpYyBtb3VzZVJlbGVhc2VkKGJ1dHRvbikge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBidXR0b24gd2FzIHJlbGVhc2VkXFxuICAgICAgICBpZiAoYnV0dG9uID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGIgaW4gaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCdXR0b24gPSArYjtcXG4gICAgICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnNbY3VycmVudEJ1dHRvbl0gJiZcXG4gICAgICAgICAgICAgICAgICAgICEhaW5zdGFuY2UucHJldmlvdXNNb3VzZVN0YXRlLmJ1dHRvbnNbY3VycmVudEJ1dHRvbl0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAoIWluc3RhbmNlLm1vdXNlU3RhdGUuYnV0dG9uc1tidXR0b25dICYmXFxuICAgICAgICAgICAgISFpbnN0YW5jZS5wcmV2aW91c01vdXNlU3RhdGUuYnV0dG9uc1tidXR0b25dKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgdGhlIG1vdXNld2hlZWwgaXMgc2Nyb2xsaW5nIHVwXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VXaGVlbFVwKCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5tb3VzZVN0YXRlLndoZWVsID4gMDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgdGhlIG1vdXNld2hlZWwgaXMgc2Nyb2xsaW5nIGRvd25cXG4gICAgICovXFxuICAgIHN0YXRpYyBtb3VzZVdoZWVsRG93bigpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2UubW91c2VTdGF0ZS53aGVlbCA8IDA7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvbiBpbiBzY3JlZW4tc3BhY2VcXG4gICAgICovXFxuICAgIHN0YXRpYyBnZXQgbW91c2VQb3NpdGlvbigpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2UubW91c2VTdGF0ZS5wb3NpdGlvbjtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0IHRoZSBjdXJyZW50bHkgaG92ZXJlZCBlbGVtZW50XFxuICAgICAqL1xcbiAgICBzdGF0aWMgZ2V0IGhvdmVyZWRFbGVtZW50KCkge1xcbiAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIHJldHVybiAoX2EgPSBpbnN0YW5jZS5tb3VzZVN0YXRlLmhvdmVyZWRFbGVtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xcbiAgICB9XFxufVxcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IElucHV0TWFuYWdlcjtcXG5JbnB1dE1hbmFnZXIuZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgIGVsZW1lbnQ6IHdpbmRvdyxcXG4gICAgbW91c2U6IHRydWUsXFxuICAgIG1vdXNlV2hlZWw6IHRydWUsXFxuICAgIGtleWJvYXJkOiB0cnVlLFxcbiAgICBwcmV2ZW50Q29udGV4dE1lbnU6IGZhbHNlLFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvaW5wdXQtbWFuYWdlci8uL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vKipcbiAqIEBvdmVydmlldyBBIGxpYnJhcnkgb2YgdXNlZnVsIGZ1bmN0aW9uc1xuICogQGF1dGhvciBHb3Jkb24gTGFycmlnYW5cbiAqL1xuXG4vKipcbiAqIE1lbW9pemUgYSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgZnVuY3Rpb24gdG8gbWVtb2l6ZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG1lbW9pemVkIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uXG4gKi9cbmNvbnN0IG1lbW9pemUgPSBmID0+IHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNhY2hlW2FyZ3NdID8/IChjYWNoZVthcmdzXSA9IGYuYXBwbHkodGhpcywgYXJncykpO1xuICB9O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICogQHBhcmFtIHtudW1iZXJ9IGEgTnVtYmVyIGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlciBiXG4gKiBAcGFyYW0ge251bWJlcn0gW3A9TnVtYmVyLkVQU0lMT05dIFRoZSBwcmVjaXNpb24gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbnVtYmVycyBhIGFuZCBiIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gKi9cbmNvbnN0IGZsb2F0RXF1YWxzID0gKGEsIGIsIHAgPSBOdW1iZXIuRVBTSUxPTikgPT4gTWF0aC5hYnMoYSAtIGIpIDwgcDtcblxuLyoqXG4gKiBDbGFtcCBhIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIHRvIGNsYW1wXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn0gQSBjbGFtcGVkIG51bWJlclxuICovXG5jb25zdCBjbGFtcCA9IChhLCBtaW4gPSAwLCBtYXggPSAxKSA9PiBhIDwgbWluID8gbWluIDogKGEgPiBtYXggPyBtYXggOiBhKTtcblxuLyoqXG4gKiBHZXQgdGhlIGZyYWN0aW9uYWwgcGFydCBvZiBhIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciBmcm9tIHdoaWNoIHRvIGdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIG51bWJlclxuICovXG5jb25zdCBmcmFjID0gYSA9PiBhID49IDAgPyBhIC0gTWF0aC5mbG9vcihhKSA6IGEgLSBNYXRoLmNlaWwoYSk7XG5cbi8qKlxuICogUm91bmQgbiB0byBkIGRlY2ltYWwgcGxhY2VzXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIHJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gW2Q9MF0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byByb3VuZCB0b1xuICogQHJldHVybiB7bnVtYmVyfSBBIHJvdW5kZWQgbnVtYmVyXG4gKi9cbmNvbnN0IHJvdW5kID0gKG4sIGQgPSAwKSA9PiB7XG4gIGNvbnN0IHAgPSBNYXRoLnBvdygxMCwgZCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKG4gKiBwICsgTnVtYmVyLkVQU0lMT04pIC8gcDtcbn1cblxuLyoqXG4gKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICovXG5jb25zdCBsZXJwID0gKGEsIGIsIGkpID0+IGEgKyAoYiAtIGEpICogaTtcblxuLyoqXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxuICovXG5jb25zdCB1bmxlcnAgPSAoYSwgYiwgaSkgPT4gKGkgLSBhKSAvIChiIC0gYSk7XG5cbi8qKlxuICogRG8gYSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYzAwIFRvcC1sZWZ0IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gYzEwIFRvcC1yaWdodCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGMwMSBCb3R0b20tbGVmdCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGMxMSBCb3R0b20tcmlnaHQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeCBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeSBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHlcbiAqIEByZXR1cm4ge251bWJlcn0gQSBiaWxpbmVhciBpbnRlcnBvbGF0ZWQgdmFsdWVcbiAqL1xuY29uc3QgYmxlcnAgPSAoYzAwLCBjMTAsIGMwMSwgYzExLCBpeCwgaXkpID0+IGxlcnAobGVycChjMDAsIGMxMCwgaXgpLCBsZXJwKGMwMSwgYzExLCBpeCksIGl5KTtcblxuLyoqXG4gKiBSZS1tYXAgYSBudW1iZXIgaSBmcm9tIHJhbmdlIGExLi4uYTIgdG8gYjEuLi5iMlxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIG51bWJlciB0byByZS1tYXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMVxuICogQHBhcmFtIHtudW1iZXJ9IGEyXG4gKiBAcGFyYW0ge251bWJlcn0gYjFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCByZW1hcCA9IChpLCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoaSAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcblxuLyoqXG4gKiBEbyBhIHNtb290aCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXG4gKi9cbmNvbnN0IHNtb290aHN0ZXAgPSAoYSwgYiwgaSkgPT4gbGVycChhLCBiLCAzICogTWF0aC5wb3coaSwgMikgLSAyICogTWF0aC5wb3coaSwgMykpO1xuXG4vKipcbiAqIEdldCBhbiBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5jb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xuXG4vKipcbiAqIEdldCBhbiBhbmdsZSBpbiBkZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gZGVncmVlc1xuICovXG5jb25zdCBkZWdyZWVzID0gcmFkaWFucyA9PiAoMTgwIC8gTWF0aC5QSSkgKiByYWRpYW5zO1xuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEV4Y2x1c2l2ZSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcbiAqL1xuY29uc3QgcmFuZG9tQmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXG4gKi9cbmNvbnN0IHJhbmRvbUludEJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG5cbi8qKlxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IFttdT0wLjVdIFRoZSBtZWFuIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpZ21hPTAuNV0gVGhlIHN0YW5kYXJkIGRldmlhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGVzPTJdIFRoZSBudW1iZXIgb2Ygc2FtcGxlc1xuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcbiAqL1xuY29uc3QgY2x0UmFuZG9tID0gKG11ID0gMC41LCBzaWdtYSA9IDAuNSwgc2FtcGxlcyA9IDIpID0+IHtcbiAgbGV0IHRvdGFsID0gMDtcbiAgZm9yIChsZXQgaSA9IHNhbXBsZXM7IGktLTspIHtcbiAgICB0b3RhbCArPSBNYXRoLnJhbmRvbSgpO1xuICB9XG4gIHJldHVybiBtdSArICh0b3RhbCAtIHNhbXBsZXMgLyAyKSAvIChzYW1wbGVzIC8gMikgKiBzaWdtYTtcbn07XG5cbi8qKlxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXJcbiAqL1xuY29uc3QgY2x0UmFuZG9tSW50ID0gKG1pbiwgbWF4KSA9PiBNYXRoLmZsb29yKG1pbiArIGNsdFJhbmRvbSgwLjUsIDAuNSwgMikgKiAobWF4ICsgMSAtIG1pbikpO1xuXG4vKipcbiAqIFJldHVybiBhIHdlaWdodGVkIHJhbmRvbSBpbnRlZ2VyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHcgQW4gYXJyYXkgb2Ygd2VpZ2h0c1xuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbmRleCBmcm9tIHdcbiAqL1xuY29uc3Qgd2VpZ2h0ZWRSYW5kb20gPSB3ID0+IHtcbiAgbGV0IHRvdGFsID0gdy5yZWR1Y2UoKGEsIGkpID0+IGEgKyBpLCAwKSwgbiA9IDA7XG4gIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogdG90YWw7XG4gIHdoaWxlICh0b3RhbCA+IHIpIHtcbiAgICB0b3RhbCAtPSB3W24rK107XG4gIH1cbiAgcmV0dXJuIG4gLSAxO1xufTtcblxuLyoqXG4gKiBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXG4gKiBAY2FsbGJhY2sgSW50ZXJwb2xhdGlvbkZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWUsIHNob3VsZCBiZSBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICovXG5cbi8qKlxuICogUmV0dXJuIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmcm9tIGFuIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgQW4gYXJyYXkgb2YgdmFsdWVzIGludGVycG9sYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaSBBIG51bWJlciBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXG4gKiBAcGFyYW0ge0ludGVycG9sYXRpb25GdW5jdGlvbn0gW2Y9TWF0aC5sZXJwXSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB0byB1c2VcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbbWluKGEpLCBtYXgoYSldXG4gKi9cbmNvbnN0IGxlcnBBcnJheSA9IChhLCBpLCBmID0gbGVycCkgPT4ge1xuICBjb25zdCBzID0gaSAqIChhLmxlbmd0aCAtIDEpO1xuICBjb25zdCBwID0gY2xhbXAoTWF0aC50cnVuYyhzKSwgMCwgYS5sZW5ndGggLSAxKTtcbiAgcmV0dXJuIGYoYVtwXSB8fCAwLCBhW3AgKyAxXSB8fCAwLCBmcmFjKHMpKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxuICovXG5jb25zdCBkb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XG5cbi8qKlxuICogR2V0IHRoZSBmYWN0b3JpYWwgb2YgYSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEhXG4gKi9cbmNvbnN0IGZhY3RvcmlhbCA9IGEgPT4ge1xuICBsZXQgcmVzdWx0ID0gMTtcbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gYTsgaSsrKSB7XG4gICAgcmVzdWx0ICo9IGk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBudW1iZXIgb2YgcGVybXV0YXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHBhcmFtIHtudW1iZXJ9IHJcbiAqIEByZXR1cm4ge251bWJlcn0gblByXG4gKi9cbmNvbnN0IG5wciA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyBmYWN0b3JpYWwobiAtIHIpO1xuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEBwYXJhbSB7bnVtYmVyfSByXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5DclxuICovXG5jb25zdCBuY3IgPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gKGZhY3RvcmlhbChyKSAqIGZhY3RvcmlhbChuIC0gcikpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFsbCBwZXJtdXRhdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGFuIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBwZXJtdXRhdGlvbnMoWzEsIDIsIDNdLCAyKTtcbiAqIGBgYFxuICpcbiAqIE91dHB1dDpcbiAqIGBgYGpzb25cbiAqIFtcbiAqICAgWzEsIDJdLFxuICogICBbMSwgM10sXG4gKiAgIFsyLCAxXSxcbiAqICAgWzIsIDNdLFxuICogICBbMywgMV0sXG4gKiAgIFszLCAyXVxuICogXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGNob29zZSBpbiBlYWNoIHBlcm11dGF0aW9uXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIHBlcm11dGF0aW9uIGFycmF5c1xuICovXG5jb25zdCBwZXJtdXRhdGlvbnMgPSAoYSwgcikgPT4ge1xuICBpZiAociA9PT0gMSkge1xuICAgIHJldHVybiBhLm1hcChpdGVtID0+IFtpdGVtXSk7XG4gIH1cblxuICByZXR1cm4gYS5yZWR1Y2UoXG4gICAgKGFjYywgaXRlbSwgaSkgPT4gW1xuICAgICAgLi4uYWNjLFxuICAgICAgLi4ucGVybXV0YXRpb25zKGEuc2xpY2UoMCwgaSkuY29uY2F0KGEuc2xpY2UoaSArIDEpKSwgciAtIDEpLm1hcChjID0+IFtpdGVtLCAuLi5jXSksXG4gICAgXSxcbiAgICBbXVxuICApO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGFsbCBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGFuIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb21iaW5hdGlvbnMoWzEsIDIsIDNdLCAyKTtcbiAqIGBgYFxuICpcbiAqIE91dHB1dDpcbiAqIGBgYGpzb25cbiAqIFtcbiAqICAgWzEsIDJdLFxuICogICBbMSwgM10sXG4gKiAgIFsyLCAzXVxuICogXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGNob29zZSBpbiBlYWNoIGNvbWJpbmF0aW9uXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGNvbWJpbmF0aW9uIGFycmF5c1xuICovXG5jb25zdCBjb21iaW5hdGlvbnMgPSAoYSwgcikgPT4ge1xuICBpZiAociA9PT0gMSkge1xuICAgIHJldHVybiBhLm1hcChpdGVtID0+IFtpdGVtXSk7XG4gIH1cblxuICByZXR1cm4gYS5yZWR1Y2UoXG4gICAgKGFjYywgaXRlbSwgaSkgPT4gW1xuICAgICAgLi4uYWNjLFxuICAgICAgLi4uY29tYmluYXRpb25zKGEuc2xpY2UoaSArIDEpLCByIC0gMSkubWFwKGMgPT4gW2l0ZW0sIC4uLmNdKSxcbiAgICBdLFxuICAgIFtdXG4gICk7XG59O1xuXG4vKipcbiAqIEdldCBhIGNhcnRlc2lhbiBwcm9kdWN0IG9mIGFycmF5c1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY2FydGVzaWFuKFsxLCAyLCAzXSwgWydhJywgJ2InXSk7XG4gKiBgYGBcbiAqXG4gKiBPdXRwdXQ6XG4gKiBgYGBqc29uXG4gKiBbXG4gKiAgIFsxLCBcImFcIl0sXG4gKiAgIFsxLCBcImJcIl0sXG4gKiAgIFsyLCBcImFcIl0sXG4gKiAgIFsyLCBcImJcIl0sXG4gKiAgIFszLCBcImFcIl0sXG4gKiAgIFszLCBcImJcIl1cbiAqIF1cbiAqIGBgYFxuICovXG5jb25zdCBjYXJ0ZXNpYW4gPSAoLi4uYXJyKSA9PlxuICBhcnIucmVkdWNlKFxuICAgIChhLCBiKSA9PiBhLmZsYXRNYXAoYyA9PiBiLm1hcChkID0+IFsuLi5jLCBkXSkpLFxuICAgIFtbXV1cbiAgKTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFycmF5IHZhbHVlc1xuICogQGNhbGxiYWNrIFRpbWVzRnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBhcnJheSBpbmRleFxuICogQHJldHVybiB7Kn0gVGhlIGFycmF5IHZhbHVlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBsZW5ndGggbiBieSBjYWxsaW5nIGZ1bmN0aW9uIGYoaSkgb24gZWFjaCBlbGVtZW50XG4gKiBAcGFyYW0ge1RpbWVzRnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxuICogQHJldHVybiB7QXJyYXk8Kj59XG4gKi9cbmNvbnN0IHRpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBudW1iZXJzIDAtPihuIC0gMSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW4gYXJyYXkgb2YgaW50ZWdlcnMgMC0+KG4gLSAxKVxuICovXG5jb25zdCByYW5nZSA9IG4gPT4gdGltZXMoaSA9PiBpLCBuKTtcblxuLyoqXG4gKiBaaXAgbXVsdGlwbGUgYXJyYXlzIHRvZ2V0aGVyLCBpLmUuIChbMSwgMiwgM10sIFthLCBiLCBjXSkgPT4gW1sxLCBhXSwgWzIsIGJdLCBbMywgY11dXG4gKiBAcGFyYW0gey4uLkFycmF5PCo+fSBhIFRoZSBhcnJheXMgdG8gemlwXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59XG4gKi9cbmNvbnN0IHppcCA9ICguLi5hKSA9PiB0aW1lcyhpID0+IGEubWFwKGEgPT4gYVtpXSksIE1hdGgubWF4KC4uLmEubWFwKGEgPT4gYS5sZW5ndGgpKSk7XG5cbi8qKlxuICogUmV0dXJuIGFycmF5W2ldIHdpdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHdyYXBwaW5nXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhIFRoZSBhcnJheSB0byBhY2Nlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBwb3NpdGl2ZWx5L25lZ2F0aXZlbHkgd3JhcHBlZCBhcnJheSBpbmRleFxuICogQHJldHVybiB7Kn0gQW4gZWxlbWVudCBmcm9tIHRoZSBhcnJheVxuICovXG5jb25zdCBhdCA9IChhLCBpKSA9PiBhW2kgPCAwID8gYS5sZW5ndGggLSAoTWF0aC5hYnMoaSArIDEpICUgYS5sZW5ndGgpIC0gMSA6IGkgJSBhLmxlbmd0aF07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkgd2l0aG91dCByZW1vdmluZyBpdFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHJldHVybiB7Kn0gVGhlIGxhc3QgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxuICovXG5jb25zdCBwZWVrID0gKGEpID0+IHtcbiAgaWYgKCFhLmxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gYVthLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IGZvciBhIGdpdmVuIHBvc2l0aW9uIGluIGFuIHVucm9sbGVkIDJkIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBwb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHkgcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB3IFRoZSB3aWR0aCBvZiB0aGUgMmQgYXJyYXlcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBpbiB0aGUgdW5yb2xsZWQgYXJyYXlcbiAqL1xuY29uc3QgaW5kID0gKHgsIHksIHcpID0+IHggKyB5ICogdztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBvc2l0aW9uIGZvciBhIGdpdmVuIGluZGV4IGluIGFuIHVucm9sbGVkIDJkIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSB3IFRoZSB3aWR0aCBvZiB0aGUgMmQgYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgcG9zaXRpb24gYXMgYSAyLXR1cGxlXG4gKi9cbmNvbnN0IHBvcyA9IChpLCB3KSA9PiBbaSAlIHcsIE1hdGguZmxvb3IoaSAvIHcpXTtcblxuLyoqXG4gKiBDaG9wIGFuIGFycmF5IGludG8gY2h1bmtzIG9mIHNpemUgblxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNodW5rIHNpemVcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgYXJyYXkgY2h1bmtzXG4gKi9cbmNvbnN0IGNodW5rID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xuXG4vKipcbiAqIFJhbmRvbWx5IHNodWZmbGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBUaGUgc2h1ZmZsZWQgYXJyYXlcbiAqL1xuY29uc3Qgc2h1ZmZsZSA9IGEgPT4gYS5zbGljZSgpLnNvcnQoKCkgPT4gTWF0aC5yYW5kb20oKSAtIDAuNSk7XG5cbi8qKlxuICogRmxhdHRlbiBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uY2F0ZW5hdG9yIFRoZSBzdHJpbmcgdG8gdXNlIGZvciBjb25jYXRlbmF0aW5nIGtleXNcbiAqIEByZXR1cm4ge29iamVjdH0gQSBmbGF0dGVuZWQgb2JqZWN0XG4gKi9cbmNvbnN0IGZsYXQgPSAobywgY29uY2F0ZW5hdG9yID0gJy4nKSA9PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgaWYgKG9ba2V5XSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2tleV06IG9ba2V5XS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9ba2V5XSAhPT0gJ29iamVjdCcgfHwgIW9ba2V5XSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBba2V5XTogb1trZXldLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZmxhdHRlbmVkID0gZmxhdChvW2tleV0sIGNvbmNhdGVuYXRvcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjLFxuICAgICAgLi4uT2JqZWN0LmtleXMoZmxhdHRlbmVkKS5yZWR1Y2UoXG4gICAgICAgIChjaGlsZEFjYywgY2hpbGRLZXkpID0+ICh7XG4gICAgICAgICAgLi4uY2hpbGRBY2MsXG4gICAgICAgICAgW2Ake2tleX0ke2NvbmNhdGVuYXRvcn0ke2NoaWxkS2V5fWBdOiBmbGF0dGVuZWRbY2hpbGRLZXldLFxuICAgICAgICB9KSxcbiAgICAgICAge31cbiAgICAgICksXG4gICAgfTtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBVbmZsYXR0ZW4gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gb1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbmNhdGVuYXRvciBUaGUgc3RyaW5nIHRvIGNoZWNrIGZvciBpbiBjb25jYXRlbmF0ZWQga2V5c1xuICogQHJldHVybiB7b2JqZWN0fSBBbiB1bi1mbGF0dGVuZWQgb2JqZWN0XG4gKi9cbmNvbnN0IHVuZmxhdCA9IChvLCBjb25jYXRlbmF0b3IgPSAnLicpID0+IHtcbiAgbGV0IHJlc3VsdCA9IHt9LCB0ZW1wLCBzdWJzdHJpbmdzLCBwcm9wZXJ0eSwgaTtcblxuICBmb3IgKHByb3BlcnR5IGluIG8pIHtcbiAgICBzdWJzdHJpbmdzID0gcHJvcGVydHkuc3BsaXQoY29uY2F0ZW5hdG9yKTtcbiAgICB0ZW1wID0gcmVzdWx0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdWJzdHJpbmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKCEoc3Vic3RyaW5nc1tpXSBpbiB0ZW1wKSkge1xuICAgICAgICBpZiAoaXNGaW5pdGUoc3Vic3RyaW5nc1tpICsgMV0pKSB7XG4gICAgICAgICAgdGVtcFtzdWJzdHJpbmdzW2ldXSA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBbc3Vic3RyaW5nc1tpXV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcCA9IHRlbXBbc3Vic3RyaW5nc1tpXV07XG4gICAgfVxuICAgIHRlbXBbc3Vic3RyaW5nc1tzdWJzdHJpbmdzLmxlbmd0aCAtIDFdXSA9IG9bcHJvcGVydHldO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQSBzcGxpdCBwcmVkaWNhdGVcbiAqIEBjYWxsYmFjayBTcGxpdFByZWRpY2F0ZVxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSBjdXJyZW50IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcnJheSBzaG91bGQgc3BsaXQgYXQgdGhpcyBpbmRleFxuICovXG5cbi8qKlxuICogU3BsaXQgYW4gYXJyYXkgaW50byBzdWItYXJyYXlzIGJhc2VkIG9uIGEgcHJlZGljYXRlXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheVxuICogQHBhcmFtIHtTcGxpdFByZWRpY2F0ZX0gcHJlZGljYXRlXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5c1xuICovXG5jb25zdCBzcGxpdCA9IChhcnJheSwgcHJlZGljYXRlKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgY3VycmVudCA9IFtdO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycmF5KSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBbdmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaChjdXJyZW50KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQbHVjayBrZXlzIGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gb1xuICogQHBhcmFtIHsuLi5zdHJpbmd9IGtleXMgVGhlIGtleXMgdG8gcGx1Y2sgZnJvbSB0aGUgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwbHVja2VkIGtleXNcbiAqL1xuY29uc3QgcGx1Y2sgPSAobywgLi4ua2V5cykgPT4ge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoXG4gICAgKHJlc3VsdCwga2V5KSA9PiBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBba2V5XTogb1trZXldIH0pLFxuICAgIHt9XG4gICk7XG59O1xuXG4vKipcbiAqIEV4Y2x1ZGUga2V5cyBmcm9tIGFuIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBrZXlzIFRoZSBrZXlzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBrZXlzIGV4Y2VwdCBleGNsdWRlZCBrZXlzXG4gKi9cbmNvbnN0IGV4Y2x1ZGUgPSAobywgLi4ua2V5cykgPT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG8pLmZpbHRlcigoW2tleV0pID0+ICFrZXlzLmluY2x1ZGVzKGtleSkpXG4gICk7XG59O1xuXG5pZiAodHJ1ZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtZW1vaXplLFxuICAgIGZsb2F0RXF1YWxzLFxuICAgIGNsYW1wLFxuICAgIGZyYWMsXG4gICAgcm91bmQsXG4gICAgbGVycCxcbiAgICB1bmxlcnAsXG4gICAgYmxlcnAsXG4gICAgcmVtYXAsXG4gICAgc21vb3Roc3RlcCxcbiAgICByYWRpYW5zLFxuICAgIGRlZ3JlZXMsXG4gICAgcmFuZG9tQmV0d2VlbixcbiAgICByYW5kb21JbnRCZXR3ZWVuLFxuICAgIGNsdFJhbmRvbSxcbiAgICBjbHRSYW5kb21JbnQsXG4gICAgd2VpZ2h0ZWRSYW5kb20sXG4gICAgbGVycEFycmF5LFxuICAgIGRvdCxcbiAgICBmYWN0b3JpYWwsXG4gICAgbnByLFxuICAgIG5jcixcbiAgICBwZXJtdXRhdGlvbnMsXG4gICAgY29tYmluYXRpb25zLFxuICAgIGNhcnRlc2lhbixcbiAgICB0aW1lcyxcbiAgICByYW5nZSxcbiAgICB6aXAsXG4gICAgYXQsXG4gICAgcGVlayxcbiAgICBpbmQsXG4gICAgcG9zLFxuICAgIGNodW5rLFxuICAgIHNodWZmbGUsXG4gICAgZmxhdCxcbiAgICB1bmZsYXQsXG4gICAgc3BsaXQsXG4gICAgcGx1Y2ssXG4gICAgZXhjbHVkZSxcbiAgfTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLyoqXG4gKiBAb3ZlcnZpZXcgQSBzbWFsbCB2ZWN0b3IgYW5kIG1hdHJpeCBsaWJyYXJ5XG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxuICovXG5cbmNvbnN0IF92ZWNfdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xuY29uc3QgX3ZlY19jaHVuayA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xuY29uc3QgX3ZlY19kb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XG5jb25zdCBfdmVjX2lzX3ZlYzIgPSBhID0+IHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAneCcgaW4gYSAmJiAneScgaW4gYTtcbmNvbnN0IF92ZWNfaXNfdmVjMyA9IGEgPT4gdHlwZW9mIGEgPT09ICdvYmplY3QnICYmICd4JyBpbiBhICYmICd5JyBpbiBhICYmICd6JyBpbiBhO1xuXG4vKipcbiAqIEEgMmQgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMyXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyAyZCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjMn0gQSBuZXcgMmQgdmVjdG9yXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj52YXJpb3VzIHdheXMgdG8gaW5pdGlhbGlzZSBhIHZlY3RvcjwvY2FwdGlvbj5cbiAqIGxldCBhID0gdmVjMigzLCAyKTsgLy8gKDMsIDIpXG4gKiBsZXQgYiA9IHZlYzIoNCk7ICAgIC8vICg0LCA0KVxuICogbGV0IGMgPSB2ZWMyKGEpOyAgICAvLyAoMywgMilcbiAqIGxldCBkID0gdmVjMigpOyAgICAgLy8gKDAsIDApXG4gKi9cbmNvbnN0IHZlYzIgPSAoeCwgeSkgPT4ge1xuICBpZiAoIXggJiYgIXkpIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9O1xuICB9XG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCB9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxuICovXG52ZWMyLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XG5cbi8qKlxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IHZlY3RvclxuICovXG52ZWMyLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMyKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMikpO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwKVxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMSwgMClcbiAqL1xudmVjMi51eCA9ICgpID0+IHZlYzIoMSwgMCk7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEpXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHVuaXQgdmVjdG9yICgwLCAxKVxuICovXG52ZWMyLnV5ID0gKCkgPT4gdmVjMigwLCAxKTtcblxuLyoqXG4gKiBBZGQgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjMn0gYSArIGJcbiAqL1xudmVjMi5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSB9KTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC0gYlxuICovXG52ZWMyLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxuICovXG52ZWMyLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMi5tdWxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKiBiXG4gKi9cbnZlYzIuc2NhbGUgPSAoYSwgYikgPT4gdmVjMi5tdWwoYSwgYik7XG5cbi8qKlxuICogRGl2aWRlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC8gYlxuICovXG52ZWMyLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpIH0pO1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzIubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzIubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KTtcblxuLyoqXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxuICogQHJldHVybiB7dmVjMn0gXmFcbiAqL1xudmVjMi5ub3IgPSBhID0+IHtcbiAgbGV0IGxlbiA9IHZlYzIubGVuKGEpO1xuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiB9IDogdmVjMigpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXG4gKi9cbnZlYzIuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcbiAqL1xudmVjMi5yb3QgPSAoYSwgcikgPT4ge1xuICBsZXQgcyA9IE1hdGguc2luKHIpLFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcbiAgcmV0dXJuIHsgeDogYyAqIGEueCAtIHMgKiBhLnksIHk6IHMgKiBhLnggKyBjICogYS55IH07XG59O1xuXG4vKipcbiAqIEZhc3QgbWV0aG9kIHRvIHJvdGF0ZSBhIHZlY3RvciBieSAtOTAsIDkwIG9yIDE4MCBkZWdyZWVzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByIDEgZm9yIDkwIGRlZ3JlZXMgKGN3KSwgLTEgZm9yIC05MCBkZWdyZWVzIChjY3cpLCAyIG9yIC0yIGZvciAxODAgZGVncmVlc1xuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMyLnJvdGYgPSAoYSwgcikgPT4ge1xuICBzd2l0Y2ggKHIpIHtcbiAgICBjYXNlIDE6IHJldHVybiB2ZWMyKGEueSwgLWEueCk7XG4gICAgY2FzZSAtMTogcmV0dXJuIHZlYzIoLWEueSwgYS54KTtcbiAgICBjYXNlIDI6IGNhc2UgLTI6IHJldHVybiB2ZWMyKC1hLngsIC1hLnkpO1xuICAgIGRlZmF1bHQ6IHJldHVybiBhO1xuICB9XG59O1xuXG4vKipcbiAqIFNjYWxhciBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxuICogQHJldHVybiB7bnVtYmVyfSBhIMOXIGJcbiAqL1xudmVjMi5jcm9zcyA9IChhLCBiKSA9PiB7XG4gIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbnZlYzIuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXG4gKi9cbnZlYzIucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcblxuLyoqXG4gKiBDb3B5IGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb3B5XG4gKiBAcmV0dXJuIHt2ZWMyfSBBIGNvcHkgb2YgdmVjdG9yIGFcbiAqL1xudmVjMi5jcHkgPSBhID0+IHZlYzIoYSk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgMmQgdmVjdG9yXG4gKiBAY2FsbGJhY2sgdmVjMk1hcENhbGxiYWNrXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICogQHBhcmFtIHsneCcgfCAneSd9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHggb3IgeSlcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcbiAqL1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMyTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjMn0gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxuICovXG52ZWMyLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JykgfSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX1gO1xuXG4vKipcbiAqIFN3aXp6bGUgYSB2ZWN0b3Igd2l0aCBhIHN0cmluZyBvZiBjb21wb25lbnQgbGFiZWxzXG4gKlxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcbiAqIC0gYHhgIG9yIGB5YFxuICogLSBgdWAgb3IgYHZgIChhbGlhc2VzIGZvciBgeGAgYW5kIGB5YCwgcmVzcGVjdGl2ZWx5KVxuICogLSBgWGAsIGBZYCwgYFVgLCBgVmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcbiAqXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLiddIFRoZSBzd2l6emxlIHN0cmluZ1xuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHN3aXp6bGVkIGNvbXBvbmVudHNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnN3aXp6bGluZyBhIHZlY3RvcjwvY2FwdGlvbj5cbiAqIGxldCBhID0gdmVjMigzLCAtMik7XG4gKiB2ZWMyLnN3aXooYSwgJ3gnKTsgICAgLy8gWzNdXG4gKiB2ZWMyLnN3aXooYSwgJ3l4Jyk7ICAgLy8gWy0yLCAzXVxuICogdmVjMi5zd2l6KGEsICd4WScpOyAgIC8vIFszLCAyXVxuICogdmVjMi5zd2l6KGEsICdZeScpOyAgIC8vIFsyLCAtMl1cbiAqIHZlYzIuc3dpeihhLCAneC54Jyk7ICAvLyBbMywgLTIsIDNdXG4gKiB2ZWMyLnN3aXooYSwgJ3kwMXgnKTsgLy8gWy0yLCAwLCAxLCAzXVxuICovXG52ZWMyLnN3aXogPSAoYSwgcyA9ICcuLicpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XG4gICAgICBjYXNlICd5JzogY2FzZSAndic6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueV1baV0gPz8gMCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmVzdWx0LnB1c2goMCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgMmQgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzMmRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMyZH0gVGhlIG1hZ25pdHVkZSBhbmQgYW5nbGUgb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnBvbGFyID0gYSA9PiAoeyByOiB2ZWMyLmxlbihhKSwgdGhldGE6IE1hdGguYXRhbjIoYS55LCBhLngpIH0pO1xuXG4vKipcbiAqIENvbnZlcnQgcG9sYXIgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcbiAqL1xudmVjMi5mcm9tUG9sYXIgPSAociwgdGhldGEpID0+IHZlYzIociAqIE1hdGguY29zKHRoZXRhKSwgciAqIE1hdGguc2luKHRoZXRhKSk7XG5cbi8qKlxuICogQSAzZCB2ZWN0b3JcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZlYzNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHogVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyAzZCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzN8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciB0aGUgeiBjb21wb25lbnQgaWYgeCBpcyBhIHZlYzJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbel0gVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IDNkIHZlY3RvclxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzMoMywgMiwgMSk7ICAgICAgIC8vICgzLCAyLCAxKVxuICogbGV0IGIgPSB2ZWMzKDQsIDUpOyAgICAgICAgICAvLyAoNCwgNSwgMClcbiAqIGxldCBjID0gdmVjMyg2KTsgICAgICAgICAgICAgLy8gKDYsIDYsIDYpXG4gKiBsZXQgZCA9IHZlYzMoYSk7ICAgICAgICAgICAgIC8vICgzLCAyLCAxKVxuICogbGV0IGUgPSB2ZWMzKCk7ICAgICAgICAgICAgICAvLyAoMCwgMCwgMClcbiAqIGxldCBmID0gdmVjMyh2ZWMyKDEsIDIpLCAzKTsgLy8gKDEsIDIsIDMpXG4gKiBsZXQgZyA9IHZlYzModmVjMig0LCA1KSk7ICAgIC8vICg0LCA1LCAwKVxuICovXG5jb25zdCB2ZWMzID0gKHgsIHksIHopID0+IHtcbiAgaWYgKCF4ICYmICF5ICYmICF6KSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgejogMCB9O1xuICB9XG4gIGlmIChfdmVjX2lzX3ZlYzMoeCkpIHtcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHgueiB8fCAwIH07XG4gIH1cbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCwgejogeSB8fCAwIH07XG4gIH1cbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4LCB6OiB6ID8/IHggfTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcbiAqL1xudmVjMy5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnksIGEuel07XG5cbi8qKlxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IHZlY3RvclxuICovXG52ZWMzLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMzKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMykpO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwLCAwKVxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMSwgMCwgMClcbiAqL1xudmVjMy51eCA9ICgpID0+IHZlYzMoMSwgMCwgMCk7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEsIDApXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxuICovXG52ZWMzLnV5ID0gKCkgPT4gdmVjMygwLCAxLCAwKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMCwgMSlcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXG4gKi9cbnZlYzMudXogPSAoKSA9PiB2ZWMzKDAsIDAsIDEpO1xuXG4vKipcbiAqIEFkZCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICsgYlxuICovXG52ZWMzLmFkZCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKyAoYi54ID8/IGIpLCB5OiBhLnkgKyAoYi55ID8/IGIpLCB6OiBhLnogKyAoYi56ID8/IGIpIH0pO1xuXG4vKipcbiAqIFN1YnRyYWN0IHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLSBiXG4gKi9cbnZlYzMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIChiLnggPz8gYiksIHk6IGEueSAtIChiLnkgPz8gYiksIHo6IGEueiAtIChiLnogPz8gYikgfSk7XG5cbi8qKlxuICogU2NhbGUgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXG4gKi9cbnZlYzMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYiksIHo6IGEueiAqIChiLnogPz8gYikgfSk7XG5cbi8qKlxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMzLm11bFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxuICogQHJldHVybiB7dmVjM30gYSAqIGJcbiAqL1xudmVjMy5zY2FsZSA9IChhLCBiKSA9PiB2ZWMzLm11bChhLCBiKTtcblxuLyoqXG4gKiBEaXZpZGUgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLyBiXG4gKi9cbnZlYzMuZGl2ID0gKGEsIGIpID0+ICh7IHg6IGEueCAvIChiLnggPz8gYiksIHk6IGEueSAvIChiLnkgPz8gYiksIHo6IGEueiAvIChiLnogPz8gYikgfSk7XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcbiAqL1xudmVjMy5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkgKyBhLnogKiBhLnopO1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcbiAqL1xudmVjMy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpICsgTWF0aC5hYnMoYS56KTtcblxuLyoqXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxuICogQHJldHVybiB7dmVjM30gXmFcbiAqL1xudmVjMy5ub3IgPSBhID0+IHtcbiAgbGV0IGxlbiA9IHZlYzMubGVuKGEpO1xuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiwgejogYS56IC8gbGVuIH0gOiB2ZWMzKCk7XG59O1xuXG4vKipcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcbiAqL1xudmVjMy5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55ICsgYS56ICogYi56O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHJvdGF0aW9uIG1hdHJpeFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge21hdH0gbSBUaGUgcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90ID0gKGEsIG0pID0+IHZlYzMoXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAxKSksIGEpLFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMikpLCBhKSxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDMpKSwgYSlcbik7XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHggYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90eCA9IChhLCByKSA9PiB2ZWMzKFxuICBhLngsXG4gIGEueSAqIE1hdGguY29zKHIpIC0gYS56ICogTWF0aC5zaW4ociksXG4gIGEueSAqIE1hdGguc2luKHIpICsgYS56ICogTWF0aC5jb3Mocilcbik7XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHkgYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90eSA9IChhLCByKSA9PiB2ZWMzKFxuICBhLnggKiBNYXRoLmNvcyhyKSArIGEueiAqIE1hdGguc2luKHIpLFxuICBhLnksXG4gIC1hLnggKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB6IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHogPSAoYSwgcikgPT4gdmVjMyhcbiAgYS54ICogTWF0aC5jb3MocikgLSBhLnkgKiBNYXRoLnNpbihyKSxcbiAgYS54ICogTWF0aC5zaW4ocikgKyBhLnkgKiBNYXRoLmNvcyhyKSxcbiAgYS56XG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBxIFRoZSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZSBieVxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHEgPSAodiwgcSkgPT4ge1xuICBpZiAocS5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gdmVjMygpO1xuICB9XG5cbiAgY29uc3QgZCA9IE1hdGguc3FydChxWzBdICogcVswXSArIHFbMV0gKiBxWzFdICsgcVsyXSAqIHFbMl0gKyBxWzNdICogcVszXSk7XG4gIGlmIChkID09PSAwKSB7XG4gICAgcmV0dXJuIHZlYzMoKTtcbiAgfVxuXG4gIGNvbnN0IHVxID0gW3FbMF0gLyBkLCBxWzFdIC8gZCwgcVsyXSAvIGQsIHFbM10gLyBkXTtcbiAgY29uc3QgdSA9IHZlYzMoLi4udXEuc2xpY2UoMCwgMykpO1xuICBjb25zdCBzID0gdXFbM107XG4gIHJldHVybiB2ZWMzLmFkZChcbiAgICB2ZWMzLmFkZChcbiAgICAgIHZlYzMubXVsKHUsIDIgKiB2ZWMzLmRvdCh1LCB2KSksXG4gICAgICB2ZWMzLm11bCh2LCBzICogcyAtIHZlYzMuZG90KHUsIHUpKVxuICAgICksXG4gICAgdmVjMy5tdWwodmVjMy5jcm9zcyh1LCB2KSwgMiAqIHMpXG4gICk7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBFdWxlciBhbmdsZXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBlIFRoZSBFdWxlciBhbmdsZXMgdG8gcm90YXRlIGJ5XG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90YSA9IChhLCBlKSA9PiB2ZWMzLnJvdHoodmVjMy5yb3R5KHZlYzMucm90eChhLCBlLngpLCBlLnkpLCBlLnopO1xuXG4vKipcbiAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxuICogQHJldHVybiB7dmVjM30gYSDDlyBiXG4gKi9cbnZlYzMuY3Jvc3MgPSAoYSwgYikgPT4gdmVjMyhcbiAgYS55ICogYi56IC0gYS56ICogYi55LFxuICBhLnogKiBiLnggLSBhLnggKiBiLnosXG4gIGEueCAqIGIueSAtIGEueSAqIGIueFxuKTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG52ZWMzLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIGEueiA9PT0gYi56O1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeCBheGlzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcbiAqL1xudmVjMy5yYWR4ID0gYSA9PiBNYXRoLmF0YW4yKGEueiwgYS55KTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHkgYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXG4gKi9cbnZlYzMucmFkeSA9IGEgPT4gTWF0aC5hdGFuMihhLngsIGEueSk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB6IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xuICovXG52ZWMzLnJhZHogPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLnopO1xuXG4vKipcbiAqIENvcHkgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcbiAqIEByZXR1cm4ge3ZlYzN9IEEgY29weSBvZiB2ZWN0b3IgYVxuICovXG52ZWMzLmNweSA9IGEgPT4gdmVjMyhhKTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSAzZCB2ZWN0b3JcbiAqIEBjYWxsYmFjayB2ZWMzTWFwQ2FsbGJhY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgY29tcG9uZW50IHZhbHVlXG4gKiBAcGFyYW0geyd4JyB8ICd5JyB8ICd6J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCwgeSBvciB6KVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxuICovXG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yIGFuZCBidWlsZCBhIG5ldyB2ZWN0b3IgZnJvbSB0aGUgcmVzdWx0c1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzNNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMzfSBWZWN0b3IgYSBtYXBwZWQgdGhyb3VnaCBmXG4gKi9cbnZlYzMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSwgejogZihhLnosICd6JykgfSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX0ke3N9JHthLnp9YDtcblxuLyoqXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xuICpcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XG4gKiAtIGB4YCwgYHlgIG9yIGB6YFxuICogLSBgdWAsIGB2YCBvciBgd2AgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcbiAqIC0gYHJgLCBgZ2Agb3IgYGJgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXG4gKiAtIGBYYCwgYFlgLCBgWmAsIGBVYCwgYFZgLCBgV2AsIGBSYCwgYEdgLCBgQmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcbiAqXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zd2l6emxpbmcgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzMoMywgLTIsIDEpO1xuICogdmVjMy5zd2l6KGEsICd4Jyk7ICAgICAvLyBbM11cbiAqIHZlYzMuc3dpeihhLCAnenl4Jyk7ICAgLy8gWzEsIC0yLCAzXVxuICogdmVjMy5zd2l6KGEsICd4WVonKTsgICAvLyBbMywgMiwgLTFdXG4gKiB2ZWMzLnN3aXooYSwgJ1p6eCcpOyAgIC8vIFstMSwgMSwgM11cbiAqIHZlYzMuc3dpeihhLCAneC54Jyk7ICAgLy8gWzMsIC0yLCAzXVxuICogdmVjMy5zd2l6KGEsICd5MDF6eCcpOyAvLyBbLTIsIDAsIDEsIDEsIDNdXG4gKi9cbnZlYzMuc3dpeiA9IChhLCBzID0gJy4uLicpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogY2FzZSAncic6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiBjYXNlICdnJzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XG4gICAgICBjYXNlICd6JzogY2FzZSAndyc6IGNhc2UgJ2InOiByZXN1bHQucHVzaChhLnopOyBicmVhaztcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogY2FzZSAnUic6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcbiAgICAgIGNhc2UgJ1knOiBjYXNlICdWJzogY2FzZSAnRyc6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcbiAgICAgIGNhc2UgJ1onOiBjYXNlICdXJzogY2FzZSAnQic6IHJlc3VsdC5wdXNoKC1hLnopOyBicmVhaztcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueSwgYS56XVtpXSA/PyAwKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiByZXN1bHQucHVzaCgwKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAzZCB2ZWN0b3JcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHBvbGFyQ29vcmRpbmF0ZXMzZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIHRpbHQgYW5nbGUgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBoaSBUaGUgcGFuIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBwb2xhciBjb29yZGluYXRlc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxuICogQHJldHVybiB7cG9sYXJDb29yZGluYXRlczNkfSBUaGUgbWFnbml0dWRlLCB0aWx0IGFuZCBwYW4gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnBvbGFyID0gYSA9PiB7XG4gIGxldCByID0gdmVjMy5sZW4oYSksXG4gICAgdGhldGEgPSBNYXRoLmFjb3MoYS55IC8gciksXG4gICAgcGhpID0gTWF0aC5hdGFuMihhLnosIGEueCk7XG4gIHJldHVybiB7IHIsIHRoZXRhLCBwaGkgfTtcbn07XG5cbi8qKlxuICogQ29udmVydCBwb2xhciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSBUaGUgdGlsdCBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gcGhpIFRoZSBwYW4gb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjM30gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxuICovXG52ZWMzLmZyb21Qb2xhciA9IChyLCB0aGV0YSwgcGhpKSA9PiB7XG4gIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICByZXR1cm4gdmVjMyhcbiAgICByICogc2luVGhldGEgKiBNYXRoLmNvcyhwaGkpLFxuICAgIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgciAqIHNpblRoZXRhICogTWF0aC5zaW4ocGhpKVxuICApO1xufTtcblxuLyoqXG4gKiBBIG1hdHJpeFxuICogQHR5cGVkZWYge09iamVjdH0gbWF0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgbWF0cml4IHZhbHVlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xuICogQHBhcmFtIHtudW1iZXJ9IFtuPTRdIFRoZSBudW1iZXIgb2YgY29sdW1uc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxuICovXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XG4gIG0sIG4sXG4gIGVudHJpZXM6IGVudHJpZXMuY29uY2F0KEFycmF5KG0gKiBuKS5maWxsKDApKS5zbGljZSgwLCBtICogbilcbn0pO1xuXG4vKipcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XG4gKiBAcmV0dXJuIHttYXR9IEFuIGlkZW50aXR5IG1hdHJpeFxuICovXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xuXG4vKipcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAoaSwgaikgaW4gbWF0cml4IGFcbiAqL1xubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xuXG4vKipcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHZhbHVlIHRvIHNldCBpbiBtYXRyaXggYVxuICovXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XG5cbi8qKlxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxuICovXG5tYXQucm93ID0gKGEsIG0pID0+IHtcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XG4gIHJldHVybiBhLmVudHJpZXMuc2xpY2UocywgcyArIGEubik7XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcbiAqL1xubWF0LmNvbCA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcblxuLyoqXG4gKiBBZGQgbWF0cmljZXNcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxuICogQHJldHVybiB7bWF0fSBhICsgYlxuICovXG5tYXQuYWRkID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgKyBiLmVudHJpZXNbaV0pO1xuXG4vKipcbiAqIFN1YnRyYWN0IG1hdHJpY2VzXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcbiAqIEByZXR1cm4ge21hdH0gYSAtIGJcbiAqL1xubWF0LnN1YiA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2IC0gYi5lbnRyaWVzW2ldKTtcblxuLyoqXG4gKiBNdWx0aXBseSBtYXRyaWNlc1xuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxuICovXG5tYXQubXVsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgbWF0LmNvbChiLCBqKSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBhIG1hdHJpeCBieSBhIHZlY3RvclxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7dmVjMnx2ZWMzfG51bWJlcltdfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHt2ZWMyfHZlYzN8bnVtYmVyW118ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggYW5kIHZlY3RvciBjYW5ub3QgYmUgbXVsdGlwbGllZFxuICovXG5tYXQubXVsdiA9IChhLCBiKSA9PiB7XG4gIGxldCBuLCBiYiwgcnQ7XG4gIGlmIChfdmVjX2lzX3ZlYzMoYikpIHtcbiAgICBiYiA9IHZlYzMuY29tcG9uZW50cyhiKTtcbiAgICBuID0gMztcbiAgICBydCA9IHZlYzMuZnJvbUNvbXBvbmVudHM7XG4gIH0gZWxzZSBpZiAoX3ZlY19pc192ZWMyKGIpKSB7XG4gICAgYmIgPSB2ZWMyLmNvbXBvbmVudHMoYik7XG4gICAgbiA9IDI7XG4gICAgcnQgPSB2ZWMyLmZyb21Db21wb25lbnRzO1xuICB9IGVsc2Uge1xuICAgIGJiID0gYjtcbiAgICBuID0gYi5sZW5ndGggPz8gMDtcbiAgICBydCA9IHYgPT4gdjtcbiAgfVxuICBpZiAoYS5uICE9PSBuKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChfdmVjX2RvdChtYXQucm93KGEsIGkpLCBiYikpO1xuICB9XG4gIHJldHVybiBydChyZXN1bHQpO1xufVxuXG4vKipcbiAqIFNjYWxlIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcbiAqL1xubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XG5cbi8qKlxuICogVHJhbnNwb3NlIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxuICogQHJldHVybiB7bWF0fSBBIHRyYW5zcG9zZWQgbWF0cml4XG4gKi9cbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCBfdmVjX3RpbWVzKGkgPT4gbWF0LmNvbChhLCAoaSArIDEpKSwgYS5uKS5mbGF0KCkpO1xuXG4vKipcbiAqIEdldCB0aGUgbWlub3Igb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gVGhlIChpLCBqKSBtaW5vciBvZiBtYXRyaXggYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcbiAqL1xubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XG4gICAgaWYgKGlpID09PSBpKSB7IGNvbnRpbnVlOyB9XG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxuICAgICAgZW50cmllcy5wdXNoKG1hdC5nZXQoYSwgaWksIGpqKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXQoYS5tIC0gMSwgYS5uIC0gMSwgZW50cmllcyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcmV0dXJuIHtudW1iZXJ8ZmFsc2V9IHxhfCBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcbiAqL1xubWF0LmRldCA9IGEgPT4ge1xuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChhLm0gPT09IDEpIHtcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xuICB9XG4gIGlmIChhLm0gPT09IDIpIHtcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xuICB9XG4gIGxldCB0b3RhbCA9IDAsIHNpZ24gPSAxO1xuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xuICAgIHRvdGFsICs9IHNpZ24gKiBhLmVudHJpZXNbaiAtIDFdICogbWF0LmRldChtYXQubWlub3IoYSwgMSwgaikpO1xuICAgIHNpZ24gKj0gLTE7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpc2UgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxuICovXG5tYXQubm9yID0gYSA9PiB7XG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XG4gIHJldHVybiBtYXQubWFwKGEsIGkgPT4gaSAqIGQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxuICogQHJldHVybiB7bWF0fSBUaGUgYWRqdWdhdGUgb2YgYVxuICovXG5tYXQuYWRqID0gYSA9PiB7XG4gIGNvbnN0IG1pbm9ycyA9IG1hdChhLm0sIGEubik7XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcbiAgICAgIG1hdC5zZXQobWlub3JzLCBpLCBqLCBtYXQuZGV0KG1hdC5taW5vcihhLCBpLCBqKSkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb2ZhY3RvcnMgPSBtYXQubWFwKG1pbm9ycywgKHYsIGkpID0+IHYgKiAoaSAlIDIgPyAtMSA6IDEpKTtcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gaW52ZXJ0XG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFeLTEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBoYXMgbm8gaW52ZXJzZVxuICovXG5tYXQuaW52ID0gYSA9PiB7XG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gbWF0LnNjYWxlKG1hdC5hZGooYSksIDEgLyBkKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbm1hdC5lcSA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQuc3RyKGEpID09PSBtYXQuc3RyKGIpO1xuXG4vKipcbiAqIENvcHkgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcbiAqL1xubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBlbnRyeSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGVudHJ5XG4gKi9cblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdHJpeE1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXG4gKi9cbm1hdC5tYXAgPSAoYSwgZikgPT4gbWF0KGEubSwgYS5uLCBhLmVudHJpZXMubWFwKGYpKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbWF0cml4IGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtucz0nXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxuJykgPT4gX3ZlY19jaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XG5cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyB2ZWMyLCB2ZWMzLCBtYXQgfTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9wb2x5LWRlY29tcC9zcmMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3BvbHktZGVjb21wL3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZWNvbXA6IHBvbHlnb25EZWNvbXAsXG4gICAgcXVpY2tEZWNvbXA6IHBvbHlnb25RdWlja0RlY29tcCxcbiAgICBpc1NpbXBsZTogcG9seWdvbklzU2ltcGxlLFxuICAgIHJlbW92ZUNvbGxpbmVhclBvaW50czogcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyxcbiAgICByZW1vdmVEdXBsaWNhdGVQb2ludHM6IHBvbHlnb25SZW1vdmVEdXBsaWNhdGVQb2ludHMsXG4gICAgbWFrZUNDVzogcG9seWdvbk1ha2VDQ1dcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsaW5lSW50XG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBQcmVjaXNpb24gdG8gdXNlIHdoZW4gY2hlY2tpbmcgaWYgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuICovXG5mdW5jdGlvbiBsaW5lSW50KGwxLGwyLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMiwgZGV0OyAvLyBzY2FsYXJzXG4gICAgYTEgPSBsMVsxXVsxXSAtIGwxWzBdWzFdO1xuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcbiAgICBjMSA9IGExICogbDFbMF1bMF0gKyBiMSAqIGwxWzBdWzFdO1xuICAgIGEyID0gbDJbMV1bMV0gLSBsMlswXVsxXTtcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XG4gICAgYzIgPSBhMiAqIGwyWzBdWzBdICsgYjIgKiBsMlswXVsxXTtcbiAgICBkZXQgPSBhMSAqIGIyIC0gYTIqYjE7XG4gICAgaWYgKCFzY2FsYXJfZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcbiAgICAgICAgaVswXSA9IChiMiAqIGMxIC0gYjEgKiBjMikgLyBkZXQ7XG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0cy5cbiAqIEBtZXRob2Qgc2VnbWVudHNJbnRlcnNlY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHAxIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHAyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RcbiAqL1xuZnVuY3Rpb24gbGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgcTEsIHEyKXtcblx0dmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcblx0dmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcblx0dmFyIGRhID0gcTJbMF0gLSBxMVswXTtcblx0dmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcblxuXHQvLyBzZWdtZW50cyBhcmUgcGFyYWxsZWxcblx0aWYoKGRhKmR5IC0gZGIqZHgpID09PSAwKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgcyA9IChkeCAqIChxMVsxXSAtIHAxWzFdKSArIGR5ICogKHAxWzBdIC0gcTFbMF0pKSAvIChkYSAqIGR5IC0gZGIgKiBkeCk7XG5cdHZhciB0ID0gKGRhICogKHAxWzFdIC0gcTFbMV0pICsgZGIgKiAocTFbMF0gLSBwMVswXSkpIC8gKGRiICogZHggLSBkYSAqIGR5KTtcblxuXHRyZXR1cm4gKHM+PTAgJiYgczw9MSAmJiB0Pj0wICYmIHQ8PTEpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIGdpdmVuIHBvaW50cy4gTm90ZSB0aGF0IHRoZSBhcmVhIHdpbGwgYmUgbmVnYXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgbm90IGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBhcmVhXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSk7XG59XG5cbmZ1bmN0aW9uIGlzTGVmdChhLGIsYyl7XG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLGIsYykgPiAwO1xufVxuXG5mdW5jdGlvbiBpc0xlZnRPbihhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPj0gMDtcbn1cblxuZnVuY3Rpb24gaXNSaWdodChhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPCAwO1xufVxuXG5mdW5jdGlvbiBpc1JpZ2h0T24oYSxiLGMpIHtcbiAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpIDw9IDA7XG59XG5cbnZhciB0bXBQb2ludDEgPSBbXSxcbiAgICB0bXBQb2ludDIgPSBbXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICogQG1ldGhvZCBjb2xsaW5lYXJcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSxiLGMsdGhyZXNob2xkQW5nbGUpIHtcbiAgICBpZighdGhyZXNob2xkQW5nbGUpe1xuICAgICAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpID09PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhYiA9IHRtcFBvaW50MSxcbiAgICAgICAgICAgIGJjID0gdG1wUG9pbnQyO1xuXG4gICAgICAgIGFiWzBdID0gYlswXS1hWzBdO1xuICAgICAgICBhYlsxXSA9IGJbMV0tYVsxXTtcbiAgICAgICAgYmNbMF0gPSBjWzBdLWJbMF07XG4gICAgICAgIGJjWzFdID0gY1sxXS1iWzFdO1xuXG4gICAgICAgIHZhciBkb3QgPSBhYlswXSpiY1swXSArIGFiWzFdKmJjWzFdLFxuICAgICAgICAgICAgbWFnQSA9IE1hdGguc3FydChhYlswXSphYlswXSArIGFiWzFdKmFiWzFdKSxcbiAgICAgICAgICAgIG1hZ0IgPSBNYXRoLnNxcnQoYmNbMF0qYmNbMF0gKyBiY1sxXSpiY1sxXSksXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhkb3QvKG1hZ0EqbWFnQikpO1xuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNxZGlzdChhLGIpe1xuICAgIHZhciBkeCA9IGJbMF0gLSBhWzBdO1xuICAgIHZhciBkeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggYXQgcG9zaXRpb24gaS4gSXQgZG9lcyBub3QgbWF0dGVyIGlmIGkgaXMgb3V0IG9mIGJvdW5kcywgdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgY3ljbGUuXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uQXQocG9seWdvbiwgaSl7XG4gICAgdmFyIHMgPSBwb2x5Z29uLmxlbmd0aDtcbiAgICByZXR1cm4gcG9seWdvbltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNsZWFyKHBvbHlnb24pe1xuICAgIHBvbHlnb24ubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBBcHBlbmQgcG9pbnRzIFwiZnJvbVwiIHRvIFwidG9cIi0xIGZyb20gYW4gb3RoZXIgcG9seWdvbiBcInBvbHlcIiBvbnRvIHRoaXMgb25lLlxuICogQG1ldGhvZCBhcHBlbmRcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXG4gKiBAcGFyYW0ge051bWJlcn0gIGZyb20gVGhlIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgdG8gVGhlIGVuZCB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuIE5vdGUgdGhhdCB0aGlzIHZlcnRleCBpcyBOT1QgaW5jbHVkZWQgd2hlbiBhcHBlbmRpbmcuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkFwcGVuZChwb2x5Z29uLCBwb2x5LCBmcm9tLCB0byl7XG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XG4gICAgICAgIHBvbHlnb24ucHVzaChwb2x5W2ldKTtcbiAgICB9XG59XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXG4gKiBAbWV0aG9kIG1ha2VDQ1dcbiAqL1xuZnVuY3Rpb24gcG9seWdvbk1ha2VDQ1cocG9seWdvbil7XG4gICAgdmFyIGJyID0gMCxcbiAgICAgICAgdiA9IHBvbHlnb247XG5cbiAgICAvLyBmaW5kIGJvdHRvbSByaWdodCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodltpXVsxXSA8IHZbYnJdWzFdIHx8ICh2W2ldWzFdID09PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XG4gICAgICAgICAgICBiciA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIHBvbHkgaWYgY2xvY2t3aXNlXG4gICAgaWYgKCFpc0xlZnQocG9seWdvbkF0KHBvbHlnb24sIGJyIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBiciksIHBvbHlnb25BdChwb2x5Z29uLCBiciArIDEpKSkge1xuICAgICAgICBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXZlcnNlIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvblxuICogQG1ldGhvZCByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25SZXZlcnNlKHBvbHlnb24pe1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICB2YXIgTiA9IHBvbHlnb24ubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdG1wLnB1c2gocG9seWdvbi5wb3AoKSk7XG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcblx0XHRwb2x5Z29uW2ldID0gdG1wW2ldO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGluIHRoZSBwb2x5Z29uIGlzIGEgcmVmbGV4IHBvaW50XG4gKiBAbWV0aG9kIGlzUmVmbGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSl7XG4gICAgcmV0dXJuIGlzUmlnaHQocG9seWdvbkF0KHBvbHlnb24sIGkgLSAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpKTtcbn1cblxudmFyIHRtcExpbmUxPVtdLFxuICAgIHRtcExpbmUyPVtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcbiAqIEBtZXRob2QgY2FuU2VlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGEgVmVydGV4IGluZGV4IDFcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNhblNlZShwb2x5Z29uLCBhLGIpIHtcbiAgICB2YXIgcCwgZGlzdCwgbDE9dG1wTGluZTEsIGwyPXRtcExpbmUyO1xuXG4gICAgaWYgKGlzTGVmdE9uKHBvbHlnb25BdChwb2x5Z29uLCBhICsgMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSAmJiBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHlnb24sIGEgLSAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGlzdCA9IHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHBvbHlnb24ubGVuZ3RoOyArK2kpIHsgLy8gZm9yIGVhY2ggZWRnZVxuICAgICAgICBpZiAoKGkgKyAxKSAlIHBvbHlnb24ubGVuZ3RoID09PSBhIHx8IGkgPT09IGEpeyAvLyBpZ25vcmUgaW5jaWRlbnQgZWRnZXNcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpLCBwb2x5Z29uQXQocG9seWdvbiwgaSkpKSB7IC8vIGlmIGRpYWcgaW50ZXJzZWN0cyBhbiBlZGdlXG4gICAgICAgICAgICBsMVswXSA9IHBvbHlnb25BdChwb2x5Z29uLCBhKTtcbiAgICAgICAgICAgIGwxWzFdID0gcG9seWdvbkF0KHBvbHlnb24sIGIpO1xuICAgICAgICAgICAgbDJbMF0gPSBwb2x5Z29uQXQocG9seWdvbiwgaSk7XG4gICAgICAgICAgICBsMlsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSk7XG4gICAgICAgICAgICBwID0gbGluZUludChsMSxsMik7XG4gICAgICAgICAgICBpZiAoc3FkaXN0KHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcCkgPCBkaXN0KSB7IC8vIGlmIGVkZ2UgaXMgYmxvY2tpbmcgdmlzaWJpbGl0eSB0byBiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZlcnRpY2VzIGluIHRoZSBwb2x5Z29uIGNhbiBzZWUgZWFjaCBvdGhlclxuICogQG1ldGhvZCBjYW5TZWUyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGEgVmVydGV4IGluZGV4IDFcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNhblNlZTIocG9seWdvbiwgYSxiKSB7XG4gICAgLy8gZm9yIGVhY2ggZWRnZVxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBpbmNpZGVudCBlZGdlc1xuICAgICAgICBpZiAoaSA9PT0gYSB8fCBpID09PSBiIHx8IChpICsgMSkgJSBwb2x5Z29uLmxlbmd0aCA9PT0gYSB8fCAoaSArIDEpICUgcG9seWdvbi5sZW5ndGggPT09IGIpe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIGxpbmVTZWdtZW50c0ludGVyc2VjdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaSsxKSkgKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSBwb2x5Z29uIGZyb20gdmVydGV4IGkgdG8gdmVydGV4IGouXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcGFyYW0gIHtQb2x5Z29ufSBbdGFyZ2V0UG9seV0gICBPcHRpb25hbCB0YXJnZXQgcG9seWdvbiB0byBzYXZlIGluLlxuICogQHJldHVybiB7UG9seWdvbn0gICAgICAgICAgICAgICAgVGhlIHJlc3VsdGluZyBjb3B5LlxuICovXG5mdW5jdGlvbiBwb2x5Z29uQ29weShwb2x5Z29uLCBpLGosdGFyZ2V0UG9seSl7XG4gICAgdmFyIHAgPSB0YXJnZXRQb2x5IHx8IFtdO1xuICAgIHBvbHlnb25DbGVhcihwKTtcbiAgICBpZiAoaSA8IGopIHtcbiAgICAgICAgLy8gSW5zZXJ0IGFsbCB2ZXJ0aWNlcyBmcm9tIGkgdG8galxuICAgICAgICBmb3IodmFyIGs9aTsgazw9ajsgaysrKXtcbiAgICAgICAgICAgIHAucHVzaChwb2x5Z29uW2tdKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgMCB0byBqXG4gICAgICAgIGZvcih2YXIgaz0wOyBrPD1qOyBrKyspe1xuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIGkgdG8gZW5kXG4gICAgICAgIGZvcih2YXIgaz1pOyBrPHBvbHlnb24ubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIGNvbnZleCBwaWVjZXMuIFJldHVybnMgYSBsaXN0IG9mIGVkZ2VzIFtbcDEscDJdLFtwMixwM10sLi4uXSB0aGF0IGN1dHMgdGhlIHBvbHlnb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBhbGdvcml0aG0gaGFzIGNvbXBsZXhpdHkgTyhOXjQpIGFuZCB3aWxsIGJlIHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtYW55IHZlcnRpY2VzLlxuICogQG1ldGhvZCBnZXRDdXRFZGdlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uKSB7XG4gICAgdmFyIG1pbj1bXSwgdG1wMT1bXSwgdG1wMj1bXSwgdG1wUG9seSA9IFtdO1xuICAgIHZhciBuRGlhZ3MgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seWdvbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uQ2FuU2VlKHBvbHlnb24sIGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaSwgaiwgdG1wUG9seSkpO1xuICAgICAgICAgICAgICAgICAgICB0bXAyID0gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb25Db3B5KHBvbHlnb24sIGosIGksIHRtcFBvbHkpKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgazx0bXAyLmxlbmd0aDsgaysrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcDEucHVzaCh0bXAyW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXAxLmxlbmd0aCA8IG5EaWFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdG1wMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5EaWFncyA9IHRtcDEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluLnB1c2goW3BvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGopXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBvbmUgb3IgbW9yZSBjb252ZXggc3ViLVBvbHlnb25zLlxuICogQG1ldGhvZCBkZWNvbXBcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvciBQb2x5Z29uIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25EZWNvbXAocG9seWdvbil7XG4gICAgdmFyIGVkZ2VzID0gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pO1xuICAgIGlmKGVkZ2VzLmxlbmd0aCA+IDApe1xuICAgICAgICByZXR1cm4gcG9seWdvblNsaWNlKHBvbHlnb24sIGVkZ2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3BvbHlnb25dO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTbGljZXMgdGhlIHBvbHlnb24gZ2l2ZW4gb25lIG9yIG1vcmUgY3V0IGVkZ2VzLiBJZiBnaXZlbiBvbmUsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHdvIHBvbHlnb25zIChmYWxzZSBvbiBmYWlsdXJlKS4gSWYgbWFueSwgYW4gYXJyYXkgb2YgcG9seWdvbnMuXG4gKiBAbWV0aG9kIHNsaWNlXG4gKiBAcGFyYW0ge0FycmF5fSBjdXRFZGdlcyBBIGxpc3Qgb2YgZWRnZXMsIGFzIHJldHVybmVkIGJ5IC5nZXRDdXRFZGdlcygpXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvblNsaWNlKHBvbHlnb24sIGN1dEVkZ2VzKXtcbiAgICBpZihjdXRFZGdlcy5sZW5ndGggPT09IDApe1xuXHRcdHJldHVybiBbcG9seWdvbl07XG4gICAgfVxuICAgIGlmKGN1dEVkZ2VzIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXMubGVuZ3RoICYmIGN1dEVkZ2VzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXNbMF0ubGVuZ3RoPT09MiAmJiBjdXRFZGdlc1swXVswXSBpbnN0YW5jZW9mIEFycmF5KXtcblxuICAgICAgICB2YXIgcG9seXMgPSBbcG9seWdvbl07XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8Y3V0RWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlc1tpXTtcbiAgICAgICAgICAgIC8vIEN1dCBhbGwgcG9seXNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBvbHlzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICB2YXIgcG9seSA9IHBvbHlzW2pdO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwb2x5Z29uU2xpY2UocG9seSwgY3V0RWRnZSk7XG4gICAgICAgICAgICAgICAgaWYocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgcG9seSEgQ3V0IGFuZCBxdWl0XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHJlc3VsdFswXSxyZXN1bHRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seXM7XG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcbiAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlcztcbiAgICAgICAgdmFyIGkgPSBwb2x5Z29uLmluZGV4T2YoY3V0RWRnZVswXSk7XG4gICAgICAgIHZhciBqID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMV0pO1xuXG4gICAgICAgIGlmKGkgIT09IC0xICYmIGogIT09IC0xKXtcbiAgICAgICAgICAgIHJldHVybiBbcG9seWdvbkNvcHkocG9seWdvbiwgaSxqKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkNvcHkocG9seWdvbiwgaixpKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgdGhlIGxpbmUgc2VnbWVudHMgb2YgdGhpcyBwb2x5Z29uIGRvIG5vdCBpbnRlcnNlY3QgZWFjaCBvdGhlci5cbiAqIEBtZXRob2QgaXNTaW1wbGVcbiAqIEBwYXJhbSAge0FycmF5fSBwYXRoIEFuIGFycmF5IG9mIHZlcnRpY2VzIGUuZy4gW1swLDBdLFswLDFdLC4uLl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAdG9kbyBTaG91bGQgaXQgY2hlY2sgYWxsIHNlZ21lbnRzIHdpdGggYWxsIG90aGVycz9cbiAqL1xuZnVuY3Rpb24gcG9seWdvbklzU2ltcGxlKHBvbHlnb24pe1xuICAgIHZhciBwYXRoID0gcG9seWdvbiwgaTtcbiAgICAvLyBDaGVja1xuICAgIGZvcihpPTA7IGk8cGF0aC5sZW5ndGgtMTsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aS0xOyBqKyspe1xuICAgICAgICAgICAgaWYobGluZVNlZ21lbnRzSW50ZXJzZWN0KHBhdGhbaV0sIHBhdGhbaSsxXSwgcGF0aFtqXSwgcGF0aFtqKzFdICkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBzZWdtZW50IGJldHdlZW4gdGhlIGxhc3QgYW5kIHRoZSBmaXJzdCBwb2ludCB0byBhbGwgb3RoZXJzXG4gICAgZm9yKGk9MTsgaTxwYXRoLmxlbmd0aC0yOyBpKyspe1xuICAgICAgICBpZihsaW5lU2VnbWVudHNJbnRlcnNlY3QocGF0aFswXSwgcGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aFtpXSwgcGF0aFtpKzFdICkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50KHAxLCBwMiwgcTEsIHEyLCBkZWx0YSl7XG5cdGRlbHRhID0gZGVsdGEgfHwgMDtcblx0dmFyIGExID0gcDJbMV0gLSBwMVsxXTtcblx0dmFyIGIxID0gcDFbMF0gLSBwMlswXTtcblx0dmFyIGMxID0gKGExICogcDFbMF0pICsgKGIxICogcDFbMV0pO1xuXHR2YXIgYTIgPSBxMlsxXSAtIHExWzFdO1xuXHR2YXIgYjIgPSBxMVswXSAtIHEyWzBdO1xuXHR2YXIgYzIgPSAoYTIgKiBxMVswXSkgKyAoYjIgKiBxMVsxXSk7XG5cdHZhciBkZXQgPSAoYTEgKiBiMikgLSAoYTIgKiBiMSk7XG5cblx0aWYoIXNjYWxhcl9lcShkZXQsMCxkZWx0YSkpe1xuXHRcdHJldHVybiBbKChiMiAqIGMxKSAtIChiMSAqIGMyKSkgLyBkZXQsICgoYTEgKiBjMikgLSAoYTIgKiBjMSkpIC8gZGV0XTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gWzAsMF07XG4gICAgfVxufVxuXG4vKipcbiAqIFF1aWNrbHkgZGVjb21wb3NlIHRoZSBQb2x5Z29uIGludG8gY29udmV4IHN1Yi1wb2x5Z29ucy5cbiAqIEBtZXRob2QgcXVpY2tEZWNvbXBcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcbiAqIEBwYXJhbSAge0FycmF5fSBbcmVmbGV4VmVydGljZXNdXG4gKiBAcGFyYW0gIHtBcnJheX0gW3N0ZWluZXJQb2ludHNdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtkZWx0YV1cbiAqIEBwYXJhbSAge051bWJlcn0gW21heGxldmVsXVxuICogQHBhcmFtICB7TnVtYmVyfSBbbGV2ZWxdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvblF1aWNrRGVjb21wKHBvbHlnb24sIHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKXtcbiAgICBtYXhsZXZlbCA9IG1heGxldmVsIHx8IDEwMDtcbiAgICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAyNTtcbiAgICByZXN1bHQgPSB0eXBlb2YocmVzdWx0KSE9PVwidW5kZWZpbmVkXCIgPyByZXN1bHQgOiBbXTtcbiAgICByZWZsZXhWZXJ0aWNlcyA9IHJlZmxleFZlcnRpY2VzIHx8IFtdO1xuICAgIHN0ZWluZXJQb2ludHMgPSBzdGVpbmVyUG9pbnRzIHx8IFtdO1xuXG4gICAgdmFyIHVwcGVySW50PVswLDBdLCBsb3dlckludD1bMCwwXSwgcD1bMCwwXTsgLy8gUG9pbnRzXG4gICAgdmFyIHVwcGVyRGlzdD0wLCBsb3dlckRpc3Q9MCwgZD0wLCBjbG9zZXN0RGlzdD0wOyAvLyBzY2FsYXJzXG4gICAgdmFyIHVwcGVySW5kZXg9MCwgbG93ZXJJbmRleD0wLCBjbG9zZXN0SW5kZXg9MDsgLy8gSW50ZWdlcnNcbiAgICB2YXIgbG93ZXJQb2x5PVtdLCB1cHBlclBvbHk9W107IC8vIHBvbHlnb25zXG4gICAgdmFyIHBvbHkgPSBwb2x5Z29uLFxuICAgICAgICB2ID0gcG9seWdvbjtcblxuICAgIGlmKHYubGVuZ3RoIDwgMyl7XG5cdFx0cmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXZlbCsrO1xuICAgIGlmKGxldmVsID4gbWF4bGV2ZWwpe1xuICAgICAgICBjb25zb2xlLndhcm4oXCJxdWlja0RlY29tcDogbWF4IGxldmVsIChcIittYXhsZXZlbCtcIikgcmVhY2hlZC5cIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seSwgaSkpIHtcbiAgICAgICAgICAgIHJlZmxleFZlcnRpY2VzLnB1c2gocG9seVtpXSk7XG4gICAgICAgICAgICB1cHBlckRpc3QgPSBsb3dlckRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seWdvbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpKSB7IC8vIGlmIGxpbmUgaW50ZXJzZWN0cyB3aXRoIGFuIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopLCBwb2x5Z29uQXQocG9seSwgaiAtIDEpKTsgLy8gZmluZCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcCkpIHsgLy8gbWFrZSBzdXJlIGl0J3MgaW5zaWRlIHRoZSBwb2x5XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBsb3dlckRpc3QpIHsgLy8ga2VlcCBvbmx5IHRoZSBjbG9zZXN0IGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiArIDEpKSAmJiBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSwgcG9seWdvbkF0KHBvbHksIGogKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHNxZGlzdChwb2x5W2ldLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgdXBwZXJEaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJEaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckludCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB2ZXJ0aWNlcyB0byBjb25uZWN0IHRvLCBjaG9vc2UgYSBwb2ludCBpbiB0aGUgbWlkZGxlXG4gICAgICAgICAgICBpZiAobG93ZXJJbmRleCA9PT0gKHVwcGVySW5kZXggKyAxKSAlIHBvbHlnb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMTogVmVydGV4KFwiK2krXCIpLCBsb3dlckluZGV4KFwiK2xvd2VySW5kZXgrXCIpLCB1cHBlckluZGV4KFwiK3VwcGVySW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrcG9seWdvbi5sZW5ndGgrXCIpXCIpO1xuICAgICAgICAgICAgICAgIHBbMF0gPSAobG93ZXJJbnRbMF0gKyB1cHBlckludFswXSkgLyAyO1xuICAgICAgICAgICAgICAgIHBbMV0gPSAobG93ZXJJbnRbMV0gKyB1cHBlckludFsxXSkgLyAyO1xuICAgICAgICAgICAgICAgIHN0ZWluZXJQb2ludHMucHVzaChwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpIDwgdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LCBpLCB1cHBlckluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksbG93ZXJJbmRleCxwb2x5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmVuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LGkscG9seS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwwLHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxsb3dlckluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRvIHRoZSBjbG9zZXN0IHBvaW50IHdpdGhpbiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FzZSAyOiBWZXJ0ZXgoXCIraStcIiksIGNsb3Nlc3RJbmRleChcIitjbG9zZXN0SW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrcG9seWdvbi5sZW5ndGgrXCIpXFxuXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPiB1cHBlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggKz0gcG9seWdvbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICAgICAgICAgIGlmKHVwcGVySW5kZXggPCBsb3dlckluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gbG93ZXJJbmRleDsgaiA8PSB1cHBlckluZGV4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWZ0T24ocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHNxZGlzdChwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGNsb3Nlc3REaXN0ICYmIHBvbHlnb25DYW5TZWUyKHBvbHksIGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGogJSBwb2x5Z29uLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgY2xvc2VzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LGksY2xvc2VzdEluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdEluZGV4ICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGNsb3Nlc3RJbmRleCx2Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LGksdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LDAsY2xvc2VzdEluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxjbG9zZXN0SW5kZXgsaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNvbHZlIHNtYWxsZXN0IHBvbHkgZmlyc3RcbiAgICAgICAgICAgIGlmIChsb3dlclBvbHkubGVuZ3RoIDwgdXBwZXJQb2x5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvbHlnb25RdWlja0RlY29tcChsb3dlclBvbHkscmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgICAgIHBvbHlnb25RdWlja0RlY29tcCh1cHBlclBvbHkscmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAodXBwZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQucHVzaChwb2x5Z29uKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmVtb3ZlIGNvbGxpbmVhciBwb2ludHMgaW4gdGhlIHBvbHlnb24uXG4gKiBAbWV0aG9kIHJlbW92ZUNvbGxpbmVhclBvaW50c1xuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXSBUaGUgdGhyZXNob2xkIGFuZ2xlIHRvIHVzZSB3aGVuIGRldGVybWluaW5nIHdoZXRoZXIgdHdvIGVkZ2VzIGFyZSBjb2xsaW5lYXIuIFVzZSB6ZXJvIGZvciBmaW5lc3QgcHJlY2lzaW9uLlxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVtb3ZlZFxuICovXG5mdW5jdGlvbiBwb2x5Z29uUmVtb3ZlQ29sbGluZWFyUG9pbnRzKHBvbHlnb24sIHByZWNpc2lvbil7XG4gICAgdmFyIG51bSA9IDA7XG4gICAgZm9yKHZhciBpPXBvbHlnb24ubGVuZ3RoLTE7IHBvbHlnb24ubGVuZ3RoPjMgJiYgaT49MDsgLS1pKXtcbiAgICAgICAgaWYoY29sbGluZWFyKHBvbHlnb25BdChwb2x5Z29uLCBpLTEpLHBvbHlnb25BdChwb2x5Z29uLCBpKSxwb2x5Z29uQXQocG9seWdvbiwgaSsxKSxwcmVjaXNpb24pKXtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWlkZGxlIHBvaW50XG4gICAgICAgICAgICBwb2x5Z29uLnNwbGljZShpJXBvbHlnb24ubGVuZ3RoLDEpO1xuICAgICAgICAgICAgbnVtKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgZHVwbGljYXRlIHBvaW50cyBpbiB0aGUgcG9seWdvbi5cbiAqIEBtZXRob2QgcmVtb3ZlRHVwbGljYXRlUG9pbnRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dIFRoZSB0aHJlc2hvbGQgdG8gdXNlIHdoZW4gZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gcG9pbnRzIGFyZSB0aGUgc2FtZS4gVXNlIHplcm8gZm9yIGJlc3QgcHJlY2lzaW9uLlxuICovXG5mdW5jdGlvbiBwb2x5Z29uUmVtb3ZlRHVwbGljYXRlUG9pbnRzKHBvbHlnb24sIHByZWNpc2lvbil7XG4gICAgZm9yKHZhciBpPXBvbHlnb24ubGVuZ3RoLTE7IGk+PTE7IC0taSl7XG4gICAgICAgIHZhciBwaSA9IHBvbHlnb25baV07XG4gICAgICAgIGZvcih2YXIgaj1pLTE7IGo+PTA7IC0tail7XG4gICAgICAgICAgICBpZihwb2ludHNfZXEocGksIHBvbHlnb25bal0sIHByZWNpc2lvbikpe1xuICAgICAgICAgICAgICAgIHBvbHlnb24uc3BsaWNlKGksMSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGVxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc2NhbGFyX2VxKGEsYixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHJldHVybiBNYXRoLmFicyhhLWIpIDw9IHByZWNpc2lvbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBwb2ludHNfZXFcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9pbnRzX2VxKGEsYixwcmVjaXNpb24pe1xuICAgIHJldHVybiBzY2FsYXJfZXEoYVswXSxiWzBdLHByZWNpc2lvbikgJiYgc2NhbGFyX2VxKGFbMV0sYlsxXSxwcmVjaXNpb24pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjLzJkL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjLzJkL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuYW5nbGUgPSBhbmdsZTtcbmV4cG9ydHMuYW5nbGVCZXR3ZWVuID0gYW5nbGVCZXR3ZWVuO1xuZXhwb3J0cy5wb2ludHNBcmVDb2xsaW5lYXIgPSBwb2ludHNBcmVDb2xsaW5lYXI7XG5leHBvcnRzLmxpbmVUb1JheSA9IGxpbmVUb1JheTtcbmV4cG9ydHMucmF5VG9MaW5lID0gcmF5VG9MaW5lO1xuZXhwb3J0cy5hYWJiID0gYWFiYjtcbmV4cG9ydHMuYWFiYlRvUmVjdGFuZ2xlID0gYWFiYlRvUmVjdGFuZ2xlO1xuZXhwb3J0cy5hYWJic092ZXJsYXAgPSBhYWJic092ZXJsYXA7XG5leHBvcnRzLnBvaW50SW5BQUJCID0gcG9pbnRJbkFBQkI7XG5leHBvcnRzLnJlY3RhbmdsZUlzUm90YXRlZCA9IHJlY3RhbmdsZUlzUm90YXRlZDtcbmV4cG9ydHMucmVjdGFuZ2xlVmVydGljZXMgPSByZWN0YW5nbGVWZXJ0aWNlcztcbmV4cG9ydHMudmVydGljZXNUb0VkZ2VzID0gdmVydGljZXNUb0VkZ2VzO1xuZXhwb3J0cy5wb2x5Z29uSXNDb252ZXggPSBwb2x5Z29uSXNDb252ZXg7XG5leHBvcnRzLnBvbHlnb25TZWxmSW50ZXJzZWN0cyA9IHBvbHlnb25TZWxmSW50ZXJzZWN0cztcbmV4cG9ydHMucG9seWdvbklzVmFsaWQgPSBwb2x5Z29uSXNWYWxpZDtcbmV4cG9ydHMucG9seWdvbldpbmRpbmdPcmRlciA9IHBvbHlnb25XaW5kaW5nT3JkZXI7XG5leHBvcnRzLnBvbHlnb25BcmVhID0gcG9seWdvbkFyZWE7XG5leHBvcnRzLnBvbHlnb25DZW50cm9pZCA9IHBvbHlnb25DZW50cm9pZDtcbmV4cG9ydHMucG9seWdvbkNvbnZleEh1bGwgPSBwb2x5Z29uQ29udmV4SHVsbDtcbmV4cG9ydHMub3B0aW1pc2VQb2x5Z29uID0gb3B0aW1pc2VQb2x5Z29uO1xuZXhwb3J0cy5kZWNvbXBvc2VQb2x5Z29uID0gZGVjb21wb3NlUG9seWdvbjtcbmV4cG9ydHMucG9pbnRPblJheSA9IHBvaW50T25SYXk7XG5leHBvcnRzLnBvaW50T25MaW5lID0gcG9pbnRPbkxpbmU7XG5leHBvcnRzLnBvaW50SW5DaXJjbGUgPSBwb2ludEluQ2lyY2xlO1xuZXhwb3J0cy5wb2ludEluUmVjdGFuZ2xlID0gcG9pbnRJblJlY3RhbmdsZTtcbmV4cG9ydHMucG9pbnRJblBvbHlnb24gPSBwb2ludEluUG9seWdvbjtcbmV4cG9ydHMucmF5VHJhdmVyc2VHcmlkID0gcmF5VHJhdmVyc2VHcmlkO1xuZXhwb3J0cy5yYXlJbnRlcnNlY3RzUmF5ID0gcmF5SW50ZXJzZWN0c1JheTtcbmV4cG9ydHMucmF5SW50ZXJzZWN0c0xpbmUgPSByYXlJbnRlcnNlY3RzTGluZTtcbmV4cG9ydHMucmF5SW50ZXJzZWN0c0NpcmNsZSA9IHJheUludGVyc2VjdHNDaXJjbGU7XG5leHBvcnRzLnJheUludGVyc2VjdHNSZWN0YW5nbGUgPSByYXlJbnRlcnNlY3RzUmVjdGFuZ2xlO1xuZXhwb3J0cy5yYXlJbnRlcnNlY3RzUG9seWdvbiA9IHJheUludGVyc2VjdHNQb2x5Z29uO1xuZXhwb3J0cy5saW5lSW50ZXJzZWN0c1JheSA9IGxpbmVJbnRlcnNlY3RzUmF5O1xuZXhwb3J0cy5saW5lSW50ZXJzZWN0c0xpbmUgPSBsaW5lSW50ZXJzZWN0c0xpbmU7XG5leHBvcnRzLmxpbmVJbnRlcnNlY3RzQ2lyY2xlID0gbGluZUludGVyc2VjdHNDaXJjbGU7XG5leHBvcnRzLmxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlID0gbGluZUludGVyc2VjdHNSZWN0YW5nbGU7XG5leHBvcnRzLmxpbmVJbnRlcnNlY3RzUG9seWdvbiA9IGxpbmVJbnRlcnNlY3RzUG9seWdvbjtcbmV4cG9ydHMuY2lyY2xlSW50ZXJzZWN0c0NpcmNsZSA9IGNpcmNsZUludGVyc2VjdHNDaXJjbGU7XG5leHBvcnRzLmNpcmNsZUludGVyc2VjdHNSZWN0YW5nbGUgPSBjaXJjbGVJbnRlcnNlY3RzUmVjdGFuZ2xlO1xuZXhwb3J0cy5jaXJjbGVJbnRlcnNlY3RzUG9seWdvbiA9IGNpcmNsZUludGVyc2VjdHNQb2x5Z29uO1xuZXhwb3J0cy5yZWN0YW5nbGVJbnRlcnNlY3RzUmVjdGFuZ2xlID0gcmVjdGFuZ2xlSW50ZXJzZWN0c1JlY3RhbmdsZTtcbmV4cG9ydHMucmVjdGFuZ2xlSW50ZXJzZWN0c1BvbHlnb24gPSByZWN0YW5nbGVJbnRlcnNlY3RzUG9seWdvbjtcbmV4cG9ydHMucG9seWdvbkludGVyc2VjdHNQb2x5Z29uID0gcG9seWdvbkludGVyc2VjdHNQb2x5Z29uO1xuY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanNcIik7XG5jb25zdCB2ZWNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3ZlYyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcIik7XG5jb25zdCBkZWNvbXAgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcG9seS1kZWNvbXAgKi8gXCIuL25vZGVfbW9kdWxlcy9wb2x5LWRlY29tcC9zcmMvaW5kZXguanNcIikpO1xuY29uc3QgdXRpbGl0aWVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsaXRpZXMgKi8gXCIuL3NyYy91dGlsaXRpZXMvaW5kZXgudHNcIik7XG5jb25zdCBjb25zdGFudHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbGl0aWVzL2NvbnN0YW50cyAqLyBcIi4vc3JjL3V0aWxpdGllcy9jb25zdGFudHMudHNcIikpO1xuY29uc3QgdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHlwZXMgKi8gXCIuL3NyYy8yZC90eXBlcy50c1wiKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVzICovIFwiLi9zcmMvMmQvdHlwZXMudHNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBDb250ZW50c1xuICpcbiAqIFV0aWxpdGllc1xuICogQHNlZSBkaXN0YW5jZVxuICogQHNlZSBhbmdsZVxuICogQHNlZSBhbmdsZUJldHdlZW5cbiAqIEBzZWUgcG9pbnRzQXJlQ29sbGluZWFyXG4gKlxuICogTGluZSBhbmQgcmF5IHV0aWxpdGllc1xuICogQHNlZSBsaW5lVG9SYXlcbiAqIEBzZWUgcmF5VG9MaW5lXG4gKlxuICogQUFCQnNcbiAqIEBzZWUgYWFiYlxuICogQHNlZSBhYWJiVG9SZWN0YW5nbGVcbiAqIEBzZWUgYWFiYnNPdmVybGFwXG4gKiBAc2VlIHBvaW50SW5BQUJCXG4gKlxuICogUmVjdGFuZ2xlIHV0aWxpdGllc1xuICogQHNlZSByZWN0YW5nbGVJc1JvdGF0ZWRcbiAqIEBzZWUgcmVjdGFuZ2xlVmVydGljZXNcbiAqXG4gKiBQb2x5Z29uIHV0aWxpdGllc1xuICogQHNlZSB2ZXJ0aWNlc1RvRWRnZXNcbiAqIEBzZWUgZmluZE91dGVyRWRnZXMgKG5vdCBleHBvcnRlZClcbiAqIEBzZWUgcG9seWdvbklzQ29udmV4XG4gKiBAc2VlIHBvbHlnb25TZWxmSW50ZXJzZWN0c1xuICogQHNlZSBwb2x5Z29uSXNWYWxpZFxuICogQHNlZSBwb2x5Z29uV2luZGluZ09yZGVyXG4gKiBAc2VlIHBvbHlnb25BcmVhXG4gKiBAc2VlIHBvbHlnb25DZW50cm9pZFxuICogQHNlZSBwb2x5Z29uQ29udmV4SHVsbFxuICogQHNlZSByZW1vdmVEdXBsaWNhdGVWZXJ0aWNlcyAobm90IGV4cG9ydGVkKVxuICogQHNlZSByZW1vdmVEdXBsaWNhdGVBZGphY2VudFZlcnRpY2VzIChub3QgZXhwb3J0ZWQpXG4gKiBAc2VlIHJlbW92ZUNvbGxpbmVhclZlcnRpY2VzIChub3QgZXhwb3J0ZWQpXG4gKiBAc2VlIG9wdGltaXNlUG9seWdvblxuICogQHNlZSBkZWNvbXBvc2VQb2x5Z29uXG4gKlxuICogUG9pbnRzXG4gKiBAc2VlIHBvaW50T25SYXlcbiAqIEBzZWUgcG9pbnRPbkxpbmVcbiAqIEBzZWUgcG9pbnRJbkNpcmNsZVxuICogQHNlZSBwb2ludEluUmVjdGFuZ2xlXG4gKiBAc2VlIHBvaW50SW5Qb2x5Z29uXG4gKlxuICogUmF5c1xuICogQHNlZSByYXlUcmF2ZXJzZUdyaWRcbiAqIEBzZWUgcmF5SW50ZXJzZWN0c1JheVxuICogQHNlZSByYXlJbnRlcnNlY3RzTGluZVxuICogQHNlZSByYXlJbnRlcnNlY3RzQ2lyY2xlXG4gKiBAc2VlIHJheUludGVyc2VjdHNSZWN0YW5nbGVcbiAqIEBzZWUgcmF5SW50ZXJzZWN0c1ZhbGlkQ29udmV4UG9seWdvbkVkZ2VzIChub3QgZXhwb3J0ZWQpXG4gKiBAc2VlIHJheUludGVyc2VjdHNQb2x5Z29uXG4gKlxuICogTGluZXNcbiAqIEBzZWUgbGluZUludGVyc2VjdHNSYXlcbiAqIEBzZWUgbGluZUludGVyc2VjdHNMaW5lXG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzQ2lyY2xlXG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlXG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzVmFsaWRDb252ZXhQb2x5Z29uRWRnZXMgKG5vdCBleHBvcnRlZClcbiAqIEBzZWUgbGluZUludGVyc2VjdHNQb2x5Z29uXG4gKlxuICogQ2lyY2xlc1xuICogQHNlZSBjaXJjbGVJbnRlcnNlY3RzQ2lyY2xlXG4gKiBAc2VlIGNpcmNsZUludGVyc2VjdHNSZWN0YW5nbGVcbiAqIEBzZWUgY2lyY2xlSW50ZXJzZWN0c1ZhbGlkQ29udmV4UG9seWdvbkVkZ2VzIChub3QgZXhwb3J0ZWQpXG4gKiBAc2VlIGNpcmNsZUludGVyc2VjdHNQb2x5Z29uXG4gKlxuICogUmVjdGFuZ2xlc1xuICogQHNlZSBwcm9qZWN0VmVydGljZXNUb0F4aXMgKG5vdCBleHBvcnRlZClcbiAqIEBzZWUgcmVjdGFuZ2xlSW50ZXJzZWN0c1JlY3RhbmdsZVxuICogQHNlZSByZWN0YW5nbGVJbnRlcnNlY3RzUG9seWdvblxuICpcbiAqIFBvbHlnb25zXG4gKiBAc2VlIHBvbHlnb25JbnRlcnNlY3RzUG9seWdvblxuICovXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIoYSwgYikpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGNsb2Nrd2lzZSBhbmdsZSBmcm9tIHBvaW50IGEgdG8gcG9pbnQgYlxuICpcbiAqIFRoZSByZXN1bHQgaXMgaW4gcmFkaWFucyBhbmQgcmFuZ2VzIGZyb20gMCB0byAyz4AgKDM2MCBkZWdyZWVzKVxuICpcbiAqIFJldHVybnMgMCBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWxcbiAqL1xuZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICAgIGlmICgoMCwgdXRpbGl0aWVzXzEudmVjdG9yc0FsbW9zdEVxdWFsKShhLCBiKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGhldGEgPSB2ZWNfMS52ZWMyLnJhZCh2ZWNfMS52ZWMyLnN1YihiLCBhKSkgJSAoMiAqIE1hdGguUEkpO1xuICAgIGlmICh0aGV0YSA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRoZXRhICsgMiAqIE1hdGguUEk7IC8vIEVuc3VyZSBhbmdsZSBpcyBwb3NpdGl2ZVxuICAgIH1cbiAgICByZXR1cm4gdGhldGE7XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgY2xvY2t3aXNlIGFuZ2xlIGJldHdlZW4gdHdvIGxpbmVzIG9yIHJheXNcbiAqXG4gKiBSZXR1cm5zIDAgaWYgZWl0aGVyIGxpbmUgaXMgemVyby1sZW5ndGhcbiAqL1xuZnVuY3Rpb24gYW5nbGVCZXR3ZWVuKGEsIGIpIHtcbiAgICBsZXQgYUxpbmUgPSAoMCwgdHlwZXNfMS5pc1JheSkoYSkgPyByYXlUb0xpbmUoYSwgMSkgOiBhO1xuICAgIGxldCBiTGluZSA9ICgwLCB0eXBlc18xLmlzUmF5KShiKSA/IHJheVRvTGluZShiLCAxKSA6IGI7XG4gICAgaWYgKCgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKSh2ZWNfMS52ZWMyLnN1YihhTGluZS5lbmQsIGFMaW5lLnN0YXJ0KSkgfHxcbiAgICAgICAgKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKHZlY18xLnZlYzIuc3ViKGJMaW5lLmVuZCwgYkxpbmUuc3RhcnQpKSkge1xuICAgICAgICByZXR1cm4gMDsgLy8gWmVyby1sZW5ndGggbGluZVxuICAgIH1cbiAgICBjb25zdCBkaXJBID0gdmVjXzEudmVjMi5ub3IodmVjXzEudmVjMi5zdWIoYUxpbmUuZW5kLCBhTGluZS5zdGFydCkpO1xuICAgIGNvbnN0IGRpckIgPSB2ZWNfMS52ZWMyLm5vcih2ZWNfMS52ZWMyLnN1YihiTGluZS5lbmQsIGJMaW5lLnN0YXJ0KSk7XG4gICAgLy8gQ2xhbXAgZG90IHByb2R1Y3QgdG8gWy0xLCAxXSB0byBhdm9pZCBOYU4gZHVlIHRvIGZsb2F0aW5nLXBvaW50IGVycm9yc1xuICAgIGNvbnN0IGRvdCA9ICgwLCB1dGlsc18xLmNsYW1wKSh2ZWNfMS52ZWMyLmRvdChkaXJBLCBkaXJCKSwgLTEsIDEpO1xuICAgIGNvbnN0IGNyb3NzID0gdmVjXzEudmVjMi5jcm9zcyhkaXJBLCBkaXJCKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoY3Jvc3MsIGRvdCk7XG4gICAgcmV0dXJuIGFuZ2xlIDwgMCA/IGFuZ2xlICsgMiAqIE1hdGguUEkgOiBhbmdsZTsgLy8gRW5zdXJlIGFuZ2xlIGlzIHBvc2l0aXZlXG59XG4vKipcbiAqIENoZWNrIGlmIHRocmVlIHBvaW50cyBpbiAyRCBzcGFjZSBhcmUgY29sbGluZWFyXG4gKi9cbmZ1bmN0aW9uIHBvaW50c0FyZUNvbGxpbmVhcihhLCBiLCBjKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGFyZWEgb2YgdGhlIHRyaWFuZ2xlIGZvcm1lZCBieSB0aGUgcG9pbnRzIGlzIHplcm9cbiAgICBjb25zdCBhcmVhID0gMC41ICogTWF0aC5hYnMoYS54ICogKGIueSAtIGMueSkgKyBiLnggKiAoYy55IC0gYS55KSArIGMueCAqIChhLnkgLSBiLnkpKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoYXJlYSkgPCBjb25zdGFudHMuRVBTSUxPTjtcbn1cbi8qKlxuICogQ29udmVydCBhIGxpbmUgc2VnbWVudCB0byBhIHJheVxuICovXG5mdW5jdGlvbiBsaW5lVG9SYXkobGluZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbjogbGluZS5zdGFydCxcbiAgICAgICAgZGlyZWN0aW9uOiB2ZWNfMS52ZWMyLm5vcih2ZWNfMS52ZWMyLnN1YihsaW5lLmVuZCwgbGluZS5zdGFydCkpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSByYXkgdG8gYSBsaW5lIHNlZ21lbnRcbiAqL1xuZnVuY3Rpb24gcmF5VG9MaW5lKHJheSwgbGVuZ3RoID0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiByYXkub3JpZ2luLFxuICAgICAgICBlbmQ6IHZlY18xLnZlYzIuYWRkKHJheS5vcmlnaW4sIHZlY18xLnZlYzIubXVsKHJheS5kaXJlY3Rpb24sIGxlbmd0aCkpLFxuICAgIH07XG59XG4vKipcbiAqIEdldCB0aGUgYm91bmRpbmcgYm94IChBQUJCKSBvZiBhIGdlb21ldHJpYyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYWFiYihvKSB7XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzTGluZSkobykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAoMCwgdmVjXzEudmVjMikoTWF0aC5taW4oby5zdGFydC54LCBvLmVuZC54KSwgTWF0aC5taW4oby5zdGFydC55LCBvLmVuZC55KSksXG4gICAgICAgICAgICBzaXplOiAoMCwgdmVjXzEudmVjMikoTWF0aC5hYnMoby5lbmQueCAtIG8uc3RhcnQueCksIE1hdGguYWJzKG8uZW5kLnkgLSBvLnN0YXJ0LnkpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzUmVjdGFuZ2xlKShvKSkge1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IHJlY3RhbmdsZVZlcnRpY2VzKG8pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKShNYXRoLm1pbiguLi52ZXJ0aWNlcy5tYXAodiA9PiB2LngpKSwgTWF0aC5taW4oLi4udmVydGljZXMubWFwKHYgPT4gdi55KSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBzaXplOiAoMCwgdmVjXzEudmVjMikoTWF0aC5tYXgoLi4udmVydGljZXMubWFwKHYgPT4gdi54KSkgLSBwb3NpdGlvbi54LCBNYXRoLm1heCguLi52ZXJ0aWNlcy5tYXAodiA9PiB2LnkpKSAtIHBvc2l0aW9uLnkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNDaXJjbGUpKG8pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogdmVjXzEudmVjMi5zdWIoby5wb3NpdGlvbiwgKDAsIHZlY18xLnZlYzIpKG8ucmFkaXVzLCBvLnJhZGl1cykpLFxuICAgICAgICAgICAgc2l6ZTogKDAsIHZlY18xLnZlYzIpKG8ucmFkaXVzICogMiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgoMCwgdHlwZXNfMS5pc1BvbHlnb24pKG8pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIHZlY18xLnZlYzIpKE1hdGgubWluKC4uLm8udmVydGljZXMubWFwKHYgPT4gdi54KSksIE1hdGgubWluKC4uLm8udmVydGljZXMubWFwKHYgPT4gdi55KSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBzaXplOiAoMCwgdmVjXzEudmVjMikoTWF0aC5tYXgoLi4uby52ZXJ0aWNlcy5tYXAodiA9PiB2LngpKSAtIHBvc2l0aW9uLngsIE1hdGgubWF4KC4uLm8udmVydGljZXMubWFwKHYgPT4gdi55KSkgLSBwb3NpdGlvbi55KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIENvbnZlcnQgYW4gQUFCQiB0byBhIHJlY3RhbmdsZVxuICovXG5mdW5jdGlvbiBhYWJiVG9SZWN0YW5nbGUoYWFiYikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiB2ZWNfMS52ZWMyLmFkZChhYWJiLnBvc2l0aW9uLCB2ZWNfMS52ZWMyLmRpdihhYWJiLnNpemUsIDIpKSxcbiAgICAgICAgc2l6ZTogYWFiYi5zaXplLFxuICAgICAgICByb3RhdGlvbjogMCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiB0d28gQUFCQnMgb3ZlcmxhcCBhbmQgcmV0dXJuIHRoZSBvdmVybGFwcGluZyBhcmVhIGlmIHNvXG4gKi9cbmZ1bmN0aW9uIGFhYmJzT3ZlcmxhcChhLCBiKSB7XG4gICAgY29uc3Qgb3ZlcmxhcFggPSAoMCwgdXRpbGl0aWVzXzEub3ZlcmxhcEludGVydmFsKSh7IG1pbjogYS5wb3NpdGlvbi54LCBtYXg6IGEucG9zaXRpb24ueCArIGEuc2l6ZS54IH0sIHsgbWluOiBiLnBvc2l0aW9uLngsIG1heDogYi5wb3NpdGlvbi54ICsgYi5zaXplLnggfSk7XG4gICAgY29uc3Qgb3ZlcmxhcFkgPSAoMCwgdXRpbGl0aWVzXzEub3ZlcmxhcEludGVydmFsKSh7IG1pbjogYS5wb3NpdGlvbi55LCBtYXg6IGEucG9zaXRpb24ueSArIGEuc2l6ZS55IH0sIHsgbWluOiBiLnBvc2l0aW9uLnksIG1heDogYi5wb3NpdGlvbi55ICsgYi5zaXplLnkgfSk7XG4gICAgLy8gSWYgdGhlIEFBQkJzIGRvbid0IG92ZXJsYXAgb24gb25lIG9yIG1vcmUgYXhlcywgdGhleSBkb24ndCBvdmVybGFwIGF0IGFsbFxuICAgIGlmICghb3ZlcmxhcFggfHwgIW92ZXJsYXBZKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgIG92ZXJsYXA6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAoMCwgdmVjXzEudmVjMikob3ZlcmxhcFgubWluLCBvdmVybGFwWS5taW4pLFxuICAgICAgICAgICAgc2l6ZTogKDAsIHZlY18xLnZlYzIpKG92ZXJsYXBYLm1heCAtIG92ZXJsYXBYLm1pbiwgb3ZlcmxhcFkubWF4IC0gb3ZlcmxhcFkubWluKSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGlzIGluc2lkZSBhbiBBQUJCXG4gKlxuICogVGhpcyBzaG91bGQgYmUgZmFzdGVyIHRoYW4gcG9pbnRJblJlY3RhbmdsZSBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyXG4gKiByb3RhdGlvblxuICovXG5mdW5jdGlvbiBwb2ludEluQUFCQihwb2ludCwgYWFiYikge1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIHNpemUgfSA9IGFhYmI7XG4gICAgY29uc3QgbWluID0gcG9zaXRpb247XG4gICAgY29uc3QgbWF4ID0gdmVjXzEudmVjMi5hZGQocG9zaXRpb24sIHNpemUpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIEFBQkJcbiAgICBjb25zdCBpbnRlcnNlY3RzID0gKDAsIHV0aWxpdGllc18xLnZhbHVlSW5JbnRlcnZhbCkocG9pbnQueCwgeyBtaW46IG1pbi54LCBtYXg6IG1heC54IH0pICYmXG4gICAgICAgICgwLCB1dGlsaXRpZXNfMS52YWx1ZUluSW50ZXJ2YWwpKHBvaW50LnksIHsgbWluOiBtaW4ueSwgbWF4OiBtYXgueSB9KTtcbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBBQUJCIHBlcmltZXRlciB0byB0aGUgZ2l2ZW4gcG9pbnRcbiAgICBsZXQgY2xvc2VzdFBvaW50O1xuICAgIGlmICghaW50ZXJzZWN0cykge1xuICAgICAgICAvLyBJZiB0aGUgcG9pbnQgaXMgb3V0c2lkZSwgY2xhbXAgdG8gdGhlIGJveFxuICAgICAgICBjbG9zZXN0UG9pbnQgPSAoMCwgdmVjXzEudmVjMikoKDAsIHV0aWxzXzEuY2xhbXApKHBvaW50LngsIG1pbi54LCBtYXgueCksICgwLCB1dGlsc18xLmNsYW1wKShwb2ludC55LCBtaW4ueSwgbWF4LnkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBwb2ludCBpcyBpbnNpZGUsIHByb2plY3QgdG8gdGhlIG5lYXJlc3QgZWRnZVxuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBbXG4gICAgICAgICAgICB7IHg6IG1pbi54LCB5OiBwb2ludC55LCBkOiBNYXRoLmFicyhwb2ludC54IC0gbWluLngpIH0sIC8vIGxlZnRcbiAgICAgICAgICAgIHsgeDogbWF4LngsIHk6IHBvaW50LnksIGQ6IE1hdGguYWJzKHBvaW50LnggLSBtYXgueCkgfSwgLy8gcmlnaHRcbiAgICAgICAgICAgIHsgeDogcG9pbnQueCwgeTogbWluLnksIGQ6IE1hdGguYWJzKHBvaW50LnkgLSBtaW4ueSkgfSwgLy8gdG9wXG4gICAgICAgICAgICB7IHg6IHBvaW50LngsIHk6IG1heC55LCBkOiBNYXRoLmFicyhwb2ludC55IC0gbWF4LnkpIH0sIC8vIGJvdHRvbVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBuZWFyZXN0ID0gZGlzdGFuY2VzLnJlZHVjZSgoYSwgYikgPT4gKGEuZCA8IGIuZCA/IGEgOiBiKSk7XG4gICAgICAgIGNsb3Nlc3RQb2ludCA9ICgwLCB2ZWNfMS52ZWMyKShuZWFyZXN0LngsIG5lYXJlc3QueSk7XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGNsb3Nlc3QgcG9pbnRcbiAgICBjb25zdCBkaXN0YW5jZSA9IHZlY18xLnZlYzIubGVuKHZlY18xLnZlYzIuc3ViKHBvaW50LCBjbG9zZXN0UG9pbnQpKTtcbiAgICAvLyBJZiB0aGUgcG9pbnQgaXMgaW5zaWRlLCBkaXN0YW5jZSBzaG91bGQgYmUgbmVnYXRpdmVcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzLFxuICAgICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICAgIGRpc3RhbmNlOiBpbnRlcnNlY3RzID8gLWRpc3RhbmNlIDogZGlzdGFuY2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSByZWN0YW5nbGUgaXMgcm90YXRlZFxuICovXG5mdW5jdGlvbiByZWN0YW5nbGVJc1JvdGF0ZWQocmVjdGFuZ2xlKSB7XG4gICAgcmV0dXJuIChyZWN0YW5nbGUucm90YXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBNYXRoLmFicyhyZWN0YW5nbGUucm90YXRpb24pID4gY29uc3RhbnRzLkVQU0lMT04pO1xufVxuLyoqXG4gKiBHZXQgdGhlIHZlcnRpY2VzIG9mIGEgcmVjdGFuZ2xlXG4gKlxuICogVmVydGljZXMgd2lsbCBiZSByZXR1cm5lZCBpbiBjbG9ja3dpc2Ugb3JkZXIgc3RhcnRpbmcgYXQgdGhlIHRvcC1sZWZ0OlxuICogLSBUb3AtbGVmdFxuICogLSBUb3AtcmlnaHRcbiAqIC0gQm90dG9tLXJpZ2h0XG4gKiAtIEJvdHRvbS1sZWZ0XG4gKi9cbmZ1bmN0aW9uIHJlY3RhbmdsZVZlcnRpY2VzKHJlY3RhbmdsZSkge1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIHNpemUsIHJvdGF0aW9uID0gMCB9ID0gcmVjdGFuZ2xlO1xuICAgIGNvbnN0IGhhbGZTaXplID0gdmVjXzEudmVjMi5kaXYoc2l6ZSwgMik7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBmb3VyIGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZVxuICAgIGxldCB0b3BMZWZ0T2Zmc2V0ID0gdmVjXzEudmVjMi5mcm9tQ29tcG9uZW50cyh2ZWNfMS52ZWMyLnN3aXooaGFsZlNpemUsICdYWScpKTtcbiAgICBsZXQgdG9wUmlnaHRPZmZzZXQgPSB2ZWNfMS52ZWMyLmZyb21Db21wb25lbnRzKHZlY18xLnZlYzIuc3dpeihoYWxmU2l6ZSwgJ3hZJykpO1xuICAgIGxldCBib3R0b21SaWdodE9mZnNldCA9IHZlY18xLnZlYzIuZnJvbUNvbXBvbmVudHModmVjXzEudmVjMi5zd2l6KGhhbGZTaXplLCAneHknKSk7XG4gICAgbGV0IGJvdHRvbUxlZnRPZmZzZXQgPSB2ZWNfMS52ZWMyLmZyb21Db21wb25lbnRzKHZlY18xLnZlYzIuc3dpeihoYWxmU2l6ZSwgJ1h5JykpO1xuICAgIC8vIFJvdGF0ZSB0aGUgb2Zmc2V0cyBpZiB0aGUgcmVjdGFuZ2xlIGlzIHJvdGF0ZWRcbiAgICBpZiAocmVjdGFuZ2xlSXNSb3RhdGVkKHJlY3RhbmdsZSkpIHtcbiAgICAgICAgdG9wTGVmdE9mZnNldCA9IHZlY18xLnZlYzIucm90KHRvcExlZnRPZmZzZXQsIHJvdGF0aW9uKTtcbiAgICAgICAgdG9wUmlnaHRPZmZzZXQgPSB2ZWNfMS52ZWMyLnJvdCh0b3BSaWdodE9mZnNldCwgcm90YXRpb24pO1xuICAgICAgICBib3R0b21SaWdodE9mZnNldCA9IHZlY18xLnZlYzIucm90KGJvdHRvbVJpZ2h0T2Zmc2V0LCByb3RhdGlvbik7XG4gICAgICAgIGJvdHRvbUxlZnRPZmZzZXQgPSB2ZWNfMS52ZWMyLnJvdChib3R0b21MZWZ0T2Zmc2V0LCByb3RhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHZlY18xLnZlYzIuYWRkKHBvc2l0aW9uLCB0b3BMZWZ0T2Zmc2V0KSxcbiAgICAgICAgdmVjXzEudmVjMi5hZGQocG9zaXRpb24sIHRvcFJpZ2h0T2Zmc2V0KSxcbiAgICAgICAgdmVjXzEudmVjMi5hZGQocG9zaXRpb24sIGJvdHRvbVJpZ2h0T2Zmc2V0KSxcbiAgICAgICAgdmVjXzEudmVjMi5hZGQocG9zaXRpb24sIGJvdHRvbUxlZnRPZmZzZXQpLFxuICAgIF07XG59XG4vKipcbiAqIENvbnZlcnQgYSBsaXN0IG9mIHZlcnRpY2VzIHRvIGEgbGlzdCBvZiBlZGdlc1xuICovXG5mdW5jdGlvbiB2ZXJ0aWNlc1RvRWRnZXModmVydGljZXMpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgY29uc3QgZW5kID0gKDAsIHV0aWxzXzEuYXQpKHZlcnRpY2VzLCBpICsgMSk7XG4gICAgICAgIGVkZ2VzLnB1c2goeyBzdGFydCwgZW5kIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZXM7XG59XG4vKipcbiAqIEZpbmQgb3V0ZXIgZWRnZXMgaW4gYSBsaXN0IG9mIHBvbHlnb25zXG4gKlxuICogV2UgYXNzdW1lIHRoYXQgdGhlIHBvbHlnb25zIHdlcmUgdGhlIHJlc3VsdCBvZiBkZWNvbXBvc2luZyBhIGNvbmNhdmUgcG9seWdvblxuICogaW50byBhIHNldCBvZiBjb252ZXggcG9seWdvbnMsIGFuZCBhcyBzdWNoIHRoZXkgYXJlIGFsbCBjb252ZXggYW5kIHNoYXJlXG4gKiBvbmUgb3IgbW9yZSBlZGdlc1xuICpcbiAqIFRoaXMgbWVhbnMgd2UgY2FuIGlkZW50aWZ5IG91dGVyIGVkZ2VzIGJlY2F1c2UgdGhleSdsbCBvbmx5IGFwcGVhciBvbmNlXG4gKiBpbiB0aGUgbGlzdCBvZiBlZGdlcywgd2hpbGUgaW5uZXIgZWRnZXMgd2lsbCBhcHBlYXIgdHdpY2UgKG9uY2UgZm9yIGVhY2hcbiAqIHBvbHlnb24gdGhhdCBzaGFyZXMgdGhlbSlcbiAqL1xuZnVuY3Rpb24gZmluZE91dGVyRWRnZXMocG9seWdvbnMpIHtcbiAgICBjb25zdCBhbGxFZGdlcyA9IHBvbHlnb25zLmZsYXRNYXAocG9seWdvbiA9PiB2ZXJ0aWNlc1RvRWRnZXMocG9seWdvbi52ZXJ0aWNlcykpO1xuICAgIC8vIEVkZ2VzIGFyZSB0aGUgZHVwbGljYXRlcyBpZiB0aGV5IG92ZXJsYXAgYnV0IGhhdmUgbm8gaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgLy8gKHRoaXMgaW1wbGllcyB0aGF0IHRoZXkgaGF2ZSBpbmZpbml0ZWx5IG1hbnkgaW50ZXJzZWN0aW9uIHBvaW50cylcbiAgICBjb25zdCBlZGdlc092ZXJsYXAgPSAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBsaW5lSW50ZXJzZWN0c0xpbmUoYSwgYik7XG4gICAgICAgIGlmIChyZXN1bHQuaW50ZXJzZWN0cyAmJiAhcmVzdWx0LmludGVyc2VjdGlvblBvaW50KSB7XG4gICAgICAgICAgICAvLyBFZGdlIGNhc2U6IGlmIHRoZSBlZGdlcyBpbnRlcnNlY3QgYW5kIGhhdmUgbm8gaW50ZXJzZWN0IHBvaW50LCBidXRcbiAgICAgICAgICAgIC8vIHNoYXJlIG9ubHkgb25lIGVuZHBvaW50LCB0aGVuIHRoZXkgYXJlbid0IGNvbnNpZGVyZWQgb3ZlcmxhcHBpbmdcbiAgICAgICAgICAgIGlmICgoKDAsIHV0aWxpdGllc18xLnZlY3RvcnNBbG1vc3RFcXVhbCkoYS5lbmQsIGIuc3RhcnQpICYmXG4gICAgICAgICAgICAgICAgISgwLCB1dGlsaXRpZXNfMS52ZWN0b3JzQWxtb3N0RXF1YWwpKGEuc3RhcnQsIGIuZW5kKSkgfHxcbiAgICAgICAgICAgICAgICAoKDAsIHV0aWxpdGllc18xLnZlY3RvcnNBbG1vc3RFcXVhbCkoYS5zdGFydCwgYi5lbmQpICYmXG4gICAgICAgICAgICAgICAgICAgICEoMCwgdXRpbGl0aWVzXzEudmVjdG9yc0FsbW9zdEVxdWFsKShhLmVuZCwgYi5zdGFydCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gRmlsdGVyIG91dCB0aGUgZWRnZXMgdGhhdCBhcHBlYXIgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgYWxsRWRnZXMpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQuc29tZShlID0+IGVkZ2VzT3ZlcmxhcChlLCBlZGdlKSkgJiZcbiAgICAgICAgICAgICFhbGxFZGdlcy5zb21lKGUgPT4gZSAhPT0gZWRnZSAmJiBlZGdlc092ZXJsYXAoZSwgZWRnZSkpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlZGdlKTsgLy8gVGhpcyBlZGdlIGlzIGFuIG91dGVyIGVkZ2VcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvbHlnb24gaXMgY29udmV4XG4gKlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBwb2x5Z29uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvbklzQ29udmV4KHBvbHlnb24pIHtcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc2lnbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBwb2x5Z29uLnZlcnRpY2VzW2ldO1xuICAgICAgICBjb25zdCBiID0gKDAsIHV0aWxzXzEuYXQpKHBvbHlnb24udmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgY29uc3QgYyA9ICgwLCB1dGlsc18xLmF0KShwb2x5Z29uLnZlcnRpY2VzLCBpICsgMik7XG4gICAgICAgIGNvbnN0IGNyb3NzUHJvZHVjdCA9IChiLnggLSBhLngpICogKGMueSAtIGEueSkgLSAoYi55IC0gYS55KSAqIChjLnggLSBhLngpO1xuICAgICAgICBpZiAoY3Jvc3NQcm9kdWN0ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2lnbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNpZ24gPSBNYXRoLnNpZ24oY3Jvc3NQcm9kdWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguc2lnbihjcm9zc1Byb2R1Y3QpICE9PSBzaWduKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBGb3VuZCBhIGNoYW5nZSBpbiBzaWduLCBwb2x5Z29uIGlzIG5vdCBjb252ZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTsgLy8gQWxsIGNyb3NzIHByb2R1Y3RzIGhhdmUgdGhlIHNhbWUgc2lnbiwgcG9seWdvbiBpcyBjb252ZXhcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2x5Z29uIHNlbGYtaW50ZXJzZWN0c1xuICovXG5mdW5jdGlvbiBwb2x5Z29uU2VsZkludGVyc2VjdHMocG9seWdvbikge1xuICAgIGlmIChwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBBIHBvbHlnb24gbXVzdCBoYXZlIGF0IGxlYXN0IDMgdmVydGljZXNcbiAgICB9XG4gICAgY29uc3QgbiA9IHBvbHlnb24udmVydGljZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBwb2x5Z29uLnZlcnRpY2VzW2ldO1xuICAgICAgICBjb25zdCBiID0gKDAsIHV0aWxzXzEuYXQpKHBvbHlnb24udmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAyOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gcG9seWdvbi52ZXJ0aWNlc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IGQgPSAoMCwgdXRpbHNfMS5hdCkocG9seWdvbi52ZXJ0aWNlcywgaiArIDEpO1xuICAgICAgICAgICAgLy8gU2tpcCBhZGphY2VudCBlZGdlc1xuICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgaiA9PT0gbiAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBzZWdtZW50cyAoYSwgYikgYW5kIChjLCBkKSBpbnRlcnNlY3RcbiAgICAgICAgICAgIGNvbnN0IHsgaW50ZXJzZWN0cyB9ID0gbGluZUludGVyc2VjdHNMaW5lKHsgc3RhcnQ6IGEsIGVuZDogYiB9LCB7IHN0YXJ0OiBjLCBlbmQ6IGQgfSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBGb3VuZCBhbiBpbnRlcnNlY3Rpb24sIHBvbHlnb24gc2VsZi1pbnRlcnNlY3RzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBObyBpbnRlcnNlY3Rpb25zIGZvdW5kLCBwb2x5Z29uIGRvZXMgbm90IHNlbGYtaW50ZXJzZWN0XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcG9seWdvbiBpcyB2YWxpZFxuICpcbiAqIEEgcG9seWdvbiBpcyB2YWxpZCBpZiBpdCBoYXMgYXQgbGVhc3QgMyB2ZXJ0aWNlcyBhbmQgZG9lcyBub3RcbiAqIHNlbGYtaW50ZXJzZWN0XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pIHtcbiAgICByZXR1cm4gcG9seWdvbi52ZXJ0aWNlcy5sZW5ndGggPj0gMyAmJiAhcG9seWdvblNlbGZJbnRlcnNlY3RzKHBvbHlnb24pO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHdpbmRpbmcgb3JkZXIgb2YgYSBwb2x5Z29uJ3MgdmVydGljZXNcbiAqXG4gKiBSZXR1cm5zICdjbG9ja3dpc2UnIG9yICdjb3VudGVyLWNsb2Nrd2lzZScgZGVwZW5kaW5nIG9uIHRoZSBjaG9zZW5cbiAqIGNvb3JkaW5hdGUgc3lzdGVtXG4gKlxuICogQnkgZGVmYXVsdCB3ZSB1c2UgdGhlICdzY3JlZW4nIGNvb3JkaW5hdGUgc3lzdGVtICh5IGluY3JlYXNlcyBkb3dud2FyZHMpXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBwb2x5Z29uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvbldpbmRpbmdPcmRlcihwb2x5Z29uLCBvcHRpb25zKSB7XG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBwb2x5Z29uLnZlcnRpY2VzW2ldO1xuICAgICAgICBjb25zdCBiID0gKDAsIHV0aWxzXzEuYXQpKHBvbHlnb24udmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgc3VtICs9IChiLnggLSBhLngpICogKGIueSArIGEueSk7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkaW5hdGVTeXN0ZW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvb3JkaW5hdGVTeXN0ZW0pIHx8ICdzY3JlZW4nO1xuICAgIHN3aXRjaCAoY29vcmRpbmF0ZVN5c3RlbSkge1xuICAgICAgICBjYXNlICdjYXJ0ZXNpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHN1bSA+IDAgPyAnY2xvY2t3aXNlJyA6ICdjb3VudGVyLWNsb2Nrd2lzZSc7XG4gICAgICAgIGNhc2UgJ3NjcmVlbic6XG4gICAgICAgICAgICByZXR1cm4gc3VtID4gMCA/ICdjb3VudGVyLWNsb2Nrd2lzZScgOiAnY2xvY2t3aXNlJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgcG9seWdvblxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgcG9seWdvbiBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25BcmVhKHBvbHlnb24pIHtcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgYXJlYSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBwb2x5Z29uLnZlcnRpY2VzW2ldO1xuICAgICAgICBjb25zdCBiID0gKDAsIHV0aWxzXzEuYXQpKHBvbHlnb24udmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgYXJlYSArPSB2ZWNfMS52ZWMyLmNyb3NzKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hYnMoYXJlYSkgLyAyO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGNlbnRyb2lkIG9mIGEgcG9seWdvblxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgcG9seWdvbiBpcyBpbnZhbGlkIG9yIGRlZ2VuZXJhdGUgKGkuZS4gYWxsIHZlcnRpY2VzIGFyZVxuICogY29sbGluZWFyKVxuICovXG5mdW5jdGlvbiBwb2x5Z29uQ2VudHJvaWQocG9seWdvbikge1xuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb2x5Z29uLnZlcnRpY2VzLmV2ZXJ5KCh2LCBpLCBhKSA9PiBwb2ludHNBcmVDb2xsaW5lYXIodiwgKDAsIHV0aWxzXzEuYXQpKGEsIGkgKyAxKSwgKDAsIHV0aWxzXzEuYXQpKGEsIGkgKyAyKSkpKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBBbGwgdmVydGljZXMgYXJlIGNvbGxpbmVhclxuICAgIH1cbiAgICByZXR1cm4gdmVjXzEudmVjMi5kaXYoWy4uLnBvbHlnb24udmVydGljZXNdLnJlZHVjZSgoYSwgYykgPT4gdmVjXzEudmVjMi5hZGQoYSwgYyksICgwLCB2ZWNfMS52ZWMyKSgpKSwgcG9seWdvbi52ZXJ0aWNlcy5sZW5ndGgpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGNvbnZleCBodWxsIG9mIGEgcG9seWdvblxuICovXG5mdW5jdGlvbiBwb2x5Z29uQ29udmV4SHVsbChwb2x5Z29uLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb2x5Z29uSXNDb252ZXgocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIHBvbHlnb247IC8vIFRoZSBwb2x5Z29uIGlzIGFscmVhZHkgY29udmV4XG4gICAgfVxuICAgIGNvbnN0IGtlZXBXaW5kaW5nT3JkZXIgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMua2VlcFdpbmRpbmdPcmRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICBjb25zdCBvcmlnaW5hbFdpbmRpbmdPcmRlciA9IHBvbHlnb25XaW5kaW5nT3JkZXIocG9seWdvbik7XG4gICAgLy8gQW5kcmV3J3MgbW9ub3RvbmUgY2hhaW4gYWxnb3JpdGhtIGZvciBjb252ZXggaHVsbFxuICAgIC8vIFNvcnQgdmVydGljZXMgbGV4aWNvZ3JhcGhpY2FsbHkgKGZpcnN0IGJ5IHgsIHRoZW4gYnkgeSlcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4ucG9seWdvbi52ZXJ0aWNlc10uc29ydCgoYSwgYikgPT4gYS54ICE9PSBiLnggPyBhLnggLSBiLnggOiBhLnkgLSBiLnkpO1xuICAgIGNvbnN0IGxvd2VyID0gW107XG4gICAgZm9yIChjb25zdCBwIG9mIHNvcnRlZCkge1xuICAgICAgICB3aGlsZSAobG93ZXIubGVuZ3RoID49IDIgJiZcbiAgICAgICAgICAgIHZlY18xLnZlYzIuY3Jvc3ModmVjXzEudmVjMi5zdWIobG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0sIGxvd2VyW2xvd2VyLmxlbmd0aCAtIDJdKSwgdmVjXzEudmVjMi5zdWIocCwgbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0pKSA8PSAwKSB7XG4gICAgICAgICAgICBsb3dlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBsb3dlci5wdXNoKHApO1xuICAgIH1cbiAgICBjb25zdCB1cHBlciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBzb3J0ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgcCA9IHNvcnRlZFtpXTtcbiAgICAgICAgd2hpbGUgKHVwcGVyLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgICB2ZWNfMS52ZWMyLmNyb3NzKHZlY18xLnZlYzIuc3ViKHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCB1cHBlclt1cHBlci5sZW5ndGggLSAyXSksIHZlY18xLnZlYzIuc3ViKHAsIHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdKSkgPD0gMCkge1xuICAgICAgICAgICAgdXBwZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBwZXIucHVzaChwKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBsYXN0IHBvaW50IG9mIGVhY2ggaGFsZiBiZWNhdXNlIGl0J3MgcmVwZWF0ZWQgYXQgdGhlIHN0YXJ0IG9mXG4gICAgLy8gdGhlIG90aGVyXG4gICAgbG93ZXIucG9wKCk7XG4gICAgdXBwZXIucG9wKCk7XG4gICAgY29uc3QgaHVsbCA9IGxvd2VyLmNvbmNhdCh1cHBlcik7XG4gICAgaWYgKGh1bGwubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gT3B0aW9uYWxseSBlbnN1cmUgdGhlIHdpbmRpbmcgb3JkZXIgaXMgcHJlc2VydmVkXG4gICAgaWYgKGtlZXBXaW5kaW5nT3JkZXIgJiZcbiAgICAgICAgcG9seWdvbldpbmRpbmdPcmRlcih7IHZlcnRpY2VzOiBodWxsIH0pICE9PSBvcmlnaW5hbFdpbmRpbmdPcmRlcikge1xuICAgICAgICBodWxsLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGljZXM6IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGh1bGwpLFxuICAgIH07XG59XG4vKipcbiAqIFJlbW92ZSBkdXBsaWNhdGUgdmVydGljZXMgZnJvbSBhIGxpc3Qgb2YgdmVydGljZXNcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlVmVydGljZXModmVydGljZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBuID0gdmVydGljZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc29tZSh2ID0+ICgwLCB1dGlsaXRpZXNfMS52ZWN0b3JzQWxtb3N0RXF1YWwpKGN1cnJlbnQsIHYpKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVtb3ZlIGR1cGxpY2F0ZSBhZGphY2VudCB2ZXJ0aWNlcyBmcm9tIGEgbGlzdCBvZiB2ZXJ0aWNlc1xuICovXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVBZGphY2VudFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgbiA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdmVydGljZXNbaV07XG4gICAgICAgIGNvbnN0IG5leHQgPSAoMCwgdXRpbHNfMS5hdCkodmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgaWYgKCEoMCwgdXRpbGl0aWVzXzEudmVjdG9yc0FsbW9zdEVxdWFsKShjdXJyZW50LCBuZXh0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVtb3ZlIGNvbGxpbmVhciB2ZXJ0aWNlcyBmcm9tIGEgbGlzdCBvZiB2ZXJ0aWNlc1xuICovXG5mdW5jdGlvbiByZW1vdmVDb2xsaW5lYXJWZXJ0aWNlcyh2ZXJ0aWNlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IG4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9ICgwLCB1dGlsc18xLmF0KSh2ZXJ0aWNlcywgaSAtIDEpO1xuICAgICAgICBjb25zdCBiID0gdmVydGljZXNbaV07XG4gICAgICAgIGNvbnN0IGMgPSAoMCwgdXRpbHNfMS5hdCkodmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgLy8gU2tpcCBjb2xsaW5lYXIgcG9pbnRzXG4gICAgICAgIGlmIChwb2ludHNBcmVDb2xsaW5lYXIoYSwgYiwgYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBPcHRpbWlzZSBhIHBvbHlnb24gYnkgcmVtb3ZpbmcgY29sbGluZWFyIHZlcnRpY2VzIGFuZCBkdXBsaWNhdGUgYWRqYWNlbnRcbiAqIHZlcnRpY2VzXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXNlUG9seWdvbihwb2x5Z29uKSB7XG4gICAgLy8gRHVwbGljYXRlIGFkamFjZW50IHZlcnRpY2VzIHdpbGwgY291bnQgdGhlIHBvbHlnb24gYXMgc2VsZi1pbnRlcnNlY3RpbmcsXG4gICAgLy8gc28gc2tpcCB0aGF0IGNoZWNrIGZvciBub3cgYW5kIG9ubHkgY2hlY2sgdGhlIG51bWJlciBvZiB2ZXJ0aWNlc1xuICAgIGlmIChwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9wdGltaXNlZFZlcnRpY2VzID0gcmVtb3ZlQ29sbGluZWFyVmVydGljZXMocmVtb3ZlRHVwbGljYXRlQWRqYWNlbnRWZXJ0aWNlcyhwb2x5Z29uLnZlcnRpY2VzKSk7XG4gICAgLy8gSWYgd2UgaGF2ZSBsZXNzIHRoYW4gMyB2ZXJ0aWNlcyBhZnRlciBvcHRpbWlzYXRpb24sIHJldHVybiBudWxsXG4gICAgaWYgKG9wdGltaXNlZFZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHZlcnRpY2VzOiBvcHRpbWlzZWRWZXJ0aWNlcyB9O1xufVxuLyoqXG4gKiBEZWNvbXBvc2UgYSBwb2x5Z29uIGludG8gYSBzZXQgb2YgY29udmV4IHBvbHlnb25zIHVzaW5nIHRoZSBCYXlheml0XG4gKiBhbGdvcml0aG1cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlIHBvbHlnb24gaXMgaW52YWxpZCBvciBjYW5ub3QgYmUgZGVjb21wb3NlZFxuICovXG5mdW5jdGlvbiBkZWNvbXBvc2VQb2x5Z29uKHBvbHlnb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBvbHlnb25Jc0NvbnZleChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gW3BvbHlnb25dOyAvLyBUaGUgcG9seWdvbiBpcyBhbHJlYWR5IGNvbnZleFxuICAgIH1cbiAgICBjb25zdCBtb2RlID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlKSB8fCAnZmFzdCc7XG4gICAgY29uc3Qga2VlcFdpbmRpbmdPcmRlciA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5rZWVwV2luZGluZ09yZGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgIGNvbnN0IG9yaWdpbmFsV2luZGluZ09yZGVyID0gcG9seWdvbldpbmRpbmdPcmRlcihwb2x5Z29uKTtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHBvbHlnb24udmVydGljZXMubWFwKHYgPT4gW3YueCwgdi55XSk7XG4gICAgaWYgKG9yaWdpbmFsV2luZGluZ09yZGVyID09PSAnY291bnRlci1jbG9ja3dpc2UnKSB7XG4gICAgICAgIHZlcnRpY2VzLnJldmVyc2UoKTsgLy8gRW5zdXJlIGNsb2Nrd2lzZSB3aW5kaW5nXG4gICAgfVxuICAgIC8vIERlY29tcG9zZSB0aGUgcG9seWdvblxuICAgIGxldCBjb252ZXhQb2x5Z29ucyA9IFtdO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlICdmYXN0JzpcbiAgICAgICAgICAgIGNvbnZleFBvbHlnb25zID0gZGVjb21wLnF1aWNrRGVjb21wKHZlcnRpY2VzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvcHRpbWFsJzpcbiAgICAgICAgICAgIGNvbnZleFBvbHlnb25zID0gZGVjb21wLmRlY29tcCh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgcmVzdWx0IGludG8gYSBsaXN0IG9mIFBvbHlnb24gb2JqZWN0c1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgY29udmV4IG9mIGNvbnZleFBvbHlnb25zKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHZlcnRpY2VzOiBjb252ZXgubWFwKHYgPT4gKDAsIHZlY18xLnZlYzIpKHZbMF0sIHZbMV0pKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE9wdGlvbmFsbHkgZW5zdXJlIHRoZSB3aW5kaW5nIG9yZGVyIGlzIHByZXNlcnZlZFxuICAgIGlmIChrZWVwV2luZGluZ09yZGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgcG9seSBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uV2luZGluZ09yZGVyKHBvbHkpICE9PSBvcmlnaW5hbFdpbmRpbmdPcmRlcikge1xuICAgICAgICAgICAgICAgIHBvbHkudmVydGljZXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID4gMCA/IHJlc3VsdCA6IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSByYXlcbiAqL1xuZnVuY3Rpb24gcG9pbnRPblJheShwb2ludCwgcmF5KSB7XG4gICAgLy8gVmVjdG9yIGZyb20gcmF5IG9yaWdpbiB0byBwb2ludFxuICAgIGNvbnN0IHRvUG9pbnQgPSB2ZWNfMS52ZWMyLnN1Yihwb2ludCwgcmF5Lm9yaWdpbik7XG4gICAgLy8gR2V0IG5vcm1hbGl6ZWQgcmF5IGRpcmVjdGlvblxuICAgIGNvbnN0IHJheURpcmVjdGlvbiA9IHZlY18xLnZlYzIubm9yKHJheS5kaXJlY3Rpb24pO1xuICAgIC8vIFByb2plY3QgdG9Qb2ludCBvbnRvIHRoZSByYXkgZGlyZWN0aW9uXG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZlY18xLnZlYzIuZG90KHRvUG9pbnQsIHJheURpcmVjdGlvbik7XG4gICAgLy8gQ2FsY3VsYXRlIGNsb3Nlc3QgcG9pbnQgb24gcmF5XG4gICAgY29uc3QgY2xvc2VzdFBvaW50ID0gdmVjXzEudmVjMi5hZGQocmF5Lm9yaWdpbiwgdmVjXzEudmVjMi5tdWwocmF5RGlyZWN0aW9uLCBNYXRoLm1heCgwLCBwcm9qZWN0aW9uKSkpO1xuICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIGNsb3Nlc3QgcG9pbnRcbiAgICBjb25zdCBkaXN0YW5jZSA9IHZlY18xLnZlYzIubGVuKHZlY18xLnZlYzIuc3ViKHBvaW50LCBjbG9zZXN0UG9pbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBQb2ludCBpcyBvbiByYXkgaWYgZGlzdGFuY2UgaXMgemVybyBhbmQgcHJvamVjdGlvbiBpcyBub24tbmVnYXRpdmVcbiAgICAgICAgaW50ZXJzZWN0czogZGlzdGFuY2UgPCBjb25zdGFudHMuRVBTSUxPTiAmJiBwcm9qZWN0aW9uID49IDAsXG4gICAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbnRlcnNlY3RzIGEgbGluZSBzZWdtZW50XG4gKi9cbmZ1bmN0aW9uIHBvaW50T25MaW5lKHBvaW50LCBsaW5lKSB7XG4gICAgLy8gR2V0IHZlY3RvciBmcm9tIGxpbmUgc3RhcnQgdG8gZW5kXG4gICAgY29uc3QgbGluZVZlY3RvciA9IHZlY18xLnZlYzIuc3ViKGxpbmUuZW5kLCBsaW5lLnN0YXJ0KTtcbiAgICAvLyBHZXQgbm9ybWFsaXplZCBsaW5lIGRpcmVjdGlvblxuICAgIGNvbnN0IGxpbmVEaXJlY3Rpb24gPSB2ZWNfMS52ZWMyLm5vcihsaW5lVmVjdG9yKTtcbiAgICAvLyBHZXQgdmVjdG9yIGZyb20gbGluZSBzdGFydCB0byBwb2ludFxuICAgIGNvbnN0IHRvUG9pbnQgPSB2ZWNfMS52ZWMyLnN1Yihwb2ludCwgbGluZS5zdGFydCk7XG4gICAgLy8gUHJvamVjdCB0b1BvaW50IG9udG8gdGhlIGxpbmUgZGlyZWN0aW9uXG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZlY18xLnZlYzIuZG90KHRvUG9pbnQsIGxpbmVEaXJlY3Rpb24pO1xuICAgIC8vIEdldCBsaW5lIGxlbmd0aFxuICAgIGNvbnN0IGxpbmVMZW5ndGggPSB2ZWNfMS52ZWMyLmxlbihsaW5lVmVjdG9yKTtcbiAgICAvLyBDbGFtcCBwcm9qZWN0aW9uIHRvIGxpbmUgc2VnbWVudFxuICAgIGNvbnN0IGNsYW1wZWRQcm9qZWN0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGluZUxlbmd0aCwgcHJvamVjdGlvbikpO1xuICAgIC8vIENhbGN1bGF0ZSBjbG9zZXN0IHBvaW50IG9uIGxpbmUgc2VnbWVudFxuICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IHZlY18xLnZlYzIuYWRkKGxpbmUuc3RhcnQsIHZlY18xLnZlYzIubXVsKGxpbmVEaXJlY3Rpb24sIGNsYW1wZWRQcm9qZWN0aW9uKSk7XG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gY2xvc2VzdCBwb2ludFxuICAgIGNvbnN0IGRpc3RhbmNlID0gdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIocG9pbnQsIGNsb3Nlc3RQb2ludCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFBvaW50IGlzIG9uIGxpbmUgaWYgZGlzdGFuY2UgaXMgZWZmZWN0aXZlbHkgemVyb1xuICAgICAgICBpbnRlcnNlY3RzOiBkaXN0YW5jZSA8IGNvbnN0YW50cy5FUFNJTE9OLFxuICAgICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgY2lyY2xlXG4gKi9cbmZ1bmN0aW9uIHBvaW50SW5DaXJjbGUocG9pbnQsIGNpcmNsZSkge1xuICAgIC8vIENhbGN1bGF0ZSB2ZWN0b3IgZnJvbSBjaXJjbGUgY2VudGVyIHRvIHBvaW50XG4gICAgY29uc3QgdG9Qb2ludCA9IHZlY18xLnZlYzIuc3ViKHBvaW50LCBjaXJjbGUucG9zaXRpb24pO1xuICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIGNpcmNsZSBjZW50ZXJcbiAgICBjb25zdCBkaXN0YW5jZVRvQ2VudGVyID0gdmVjXzEudmVjMi5sZW4odG9Qb2ludCk7XG4gICAgLy8gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlIHRoZSBjaXJjbGVcbiAgICBjb25zdCBpbnRlcnNlY3RzID0gZGlzdGFuY2VUb0NlbnRlciA8PSBjaXJjbGUucmFkaXVzO1xuICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSB0byBjaXJjbGUgZWRnZVxuICAgIGNvbnN0IGRpc3RhbmNlID0gaW50ZXJzZWN0c1xuICAgICAgICA/IC0oY2lyY2xlLnJhZGl1cyAtIGRpc3RhbmNlVG9DZW50ZXIpIC8vIE5lZ2F0aXZlIGlmIGluc2lkZVxuICAgICAgICA6IGRpc3RhbmNlVG9DZW50ZXIgLSBjaXJjbGUucmFkaXVzOyAvLyBQb3NpdGl2ZSBpZiBvdXRzaWRlXG4gICAgLy8gQ2FsY3VsYXRlIGNsb3Nlc3QgcG9pbnQgb24gY2lyY2xlIGVkZ2VcbiAgICBjb25zdCBjbG9zZXN0UG9pbnQgPSB2ZWNfMS52ZWMyLmFkZChjaXJjbGUucG9zaXRpb24sIHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIubm9yKHRvUG9pbnQpLCBjaXJjbGUucmFkaXVzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0cyxcbiAgICAgICAgY2xvc2VzdFBvaW50LFxuICAgICAgICBkaXN0YW5jZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGlzIGluc2lkZSBhIHJlY3RhbmdsZVxuICpcbiAqIEluIGNhc2VzIHdoZXJlIHRoZSBjbG9zZXN0IHBvaW50IGlzIGFtYmlndW91cyAoZS5nLiBjb3JuZXJzKSwgdGhlIGZpcnN0IGVkZ2VcbiAqIGVuY291bnRlcmVkIHdpdGggYSBjbG9zZXN0IHBvaW50IHdpbGwgYmUgcmV0dXJuZWQgYWZ0ZXIgZXZhbHVhdGluZyBlZGdlcyBpblxuICogdGhpcyBvcmRlcjpcbiAqIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCAoYmVmb3JlIGFwcGx5aW5nIHRoZSByZWN0YW5nbGUncyByb3RhdGlvbilcbiAqL1xuZnVuY3Rpb24gcG9pbnRJblJlY3RhbmdsZShwb2ludCwgcmVjdGFuZ2xlKSB7XG4gICAgLy8gRWRnZSBjYXNlOiB6ZXJvLXNpemUgcmVjdGFuZ2xlXG4gICAgaWYgKCgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShyZWN0YW5nbGUuc2l6ZSkpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlY3RhbmdsZSBoYXMgbm8gc2l6ZSwgY2hlY2sgaWYgdGhlIHBvaW50IGlzIGF0IHRoZSByZWN0YW5nbGUnc1xuICAgICAgICAvLyBwb3NpdGlvblxuICAgICAgICBjb25zdCBpc0F0UG9zaXRpb24gPSAoMCwgdXRpbGl0aWVzXzEudmVjdG9yc0FsbW9zdEVxdWFsKShwb2ludCwgcmVjdGFuZ2xlLnBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IGlzQXRQb3NpdGlvbixcbiAgICAgICAgICAgIGNsb3Nlc3RQb2ludDogcmVjdGFuZ2xlLnBvc2l0aW9uLFxuICAgICAgICAgICAgZGlzdGFuY2U6IGlzQXRQb3NpdGlvblxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIocG9pbnQsIHJlY3RhbmdsZS5wb3NpdGlvbikpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHJlY3RhbmdsZSB0byBwb2x5Z29uXG4gICAgY29uc3QgdmVydGljZXMgPSByZWN0YW5nbGVWZXJ0aWNlcyhyZWN0YW5nbGUpO1xuICAgIGNvbnN0IHBvbHlnb25SZXN1bHQgPSBwb2ludEluUG9seWdvbihwb2ludCwgeyB2ZXJ0aWNlcyB9KTtcbiAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSB2YWxpZCBwb2x5Z29uLCBidXQganVzdCBpbiBjYXNlLi4uXG4gICAgaWYgKCFwb2x5Z29uUmVzdWx0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWN0YW5nbGUgdmVydGljZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlnb25SZXN1bHQ7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgcG9seWdvblxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgcG9seWdvbiBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIHBvaW50SW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHBvbHlnb24gaXMgdmFsaWRcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBGaW5kIGlmIHBvaW50IGlzIGluc2lkZSBwb2x5Z29uIHVzaW5nIHJheSBjYXN0aW5nIGFsZ29yaXRobVxuICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHBvbHlnb24udmVydGljZXM7XG4gICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBjbG9zZXN0IGVkZ2Ugd2hpbGUgd2UgaXRlcmF0ZVxuICAgIGxldCBtaW5EaXN0YW5jZVNxdWFyZWQgPSBJbmZpbml0eTtcbiAgICBsZXQgY2xvc2VzdFBvaW50ID0gcG9pbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdmkgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgY29uc3QgdmogPSB2ZXJ0aWNlc1tqXTtcbiAgICAgICAgLy8gUmF5IGNhc3RpbmcgYWxnb3JpdGhtXG4gICAgICAgIGlmICh2aS55ID4gcG9pbnQueSAhPT0gdmoueSA+IHBvaW50LnkgJiZcbiAgICAgICAgICAgIHBvaW50LnggPCAoKHZqLnggLSB2aS54KSAqIChwb2ludC55IC0gdmkueSkpIC8gKHZqLnkgLSB2aS55KSArIHZpLngpIHtcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCBjbG9zZXN0IHBvaW50IG9uIHRoaXMgZWRnZVxuICAgICAgICBjb25zdCBlZGdlID0geyBzdGFydDogdmksIGVuZDogdmogfTtcbiAgICAgICAgY29uc3QgeyBjbG9zZXN0UG9pbnQ6IGVkZ2VDbG9zZXN0LCBkaXN0YW5jZTogZWRnZURpc3RhbmNlIH0gPSBwb2ludE9uTGluZShwb2ludCwgZWRnZSk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlU3F1YXJlZCA9IGVkZ2VEaXN0YW5jZSAqIGVkZ2VEaXN0YW5jZTtcbiAgICAgICAgaWYgKGRpc3RhbmNlU3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdGFuY2VTcXVhcmVkO1xuICAgICAgICAgICAgY2xvc2VzdFBvaW50ID0gZWRnZUNsb3Nlc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2VTcXVhcmVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBpbnNpZGUsXG4gICAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgICAgZGlzdGFuY2U6IGluc2lkZSA/IC1kaXN0YW5jZSA6IGRpc3RhbmNlLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIHdoaWNoIGdyaWQgY2VsbHMgYSByYXkgdHJhdmVyc2VzXG4gKlxuICogQmFzZWQgb24gXCJBIEZhc3QgVm94ZWwgVHJhdmVyc2FsIEFsZ29yaXRobSBmb3IgUmF5IFRyYWNpbmdcIiBieSBBbWFuYXRpZGVzXG4gKiBhbmQgV29vXG4gKlxuICogV2UgY2FuIG9wdGlvbmFsbHkgbGltaXQgdGhlIG51bWJlciBvZiBjZWxscyB0cmF2ZXJzZWQgYnkgdGhlIHJheSwgb3Igc2V0XG4gKiBtYXhDZWxscyB0byAtMSB0byBjb250aW51ZSB0cmF2ZXJzaW5nIHVudGlsIHRoZSByYXkgZXhpdHMgdGhlIGdyaWQgKG9yIHVudGlsXG4gKiB3ZSBoaXQgdGhlIGhhcmQgbGltaXQgb2YgMTAwMDAgY2VsbHMpLlxuICovXG5mdW5jdGlvbiByYXlUcmF2ZXJzZUdyaWQocmF5LCBjZWxsU2l6ZSwgZ3JpZFRvcExlZnQsIGdyaWRCb3R0b21SaWdodCwgbWF4Q2VsbHMgPSAtMSkge1xuICAgIGlmIChjZWxsU2l6ZSA8PSAwKSB7XG4gICAgICAgIHJldHVybiB7IGNlbGxzOiBbXSB9OyAvLyBJbnZhbGlkIGNlbGwgc2l6ZSwgcmV0dXJuIGVtcHR5IGNlbGxzIGFycmF5XG4gICAgfVxuICAgIC8vIFNldCBhIGxpbWl0IG9uIHRoZSBudW1iZXIgb2YgY2VsbHMgdHJhdmVyc2VkXG4gICAgY29uc3QgSEFSRF9MSU1JVCA9IDEwMDAwO1xuICAgIG1heENlbGxzID0gKDAsIHV0aWxzXzEuY2xhbXApKG1heENlbGxzID09PSAtMSA/IEhBUkRfTElNSVQgOiBtYXhDZWxscywgMCwgSEFSRF9MSU1JVCk7XG4gICAgaWYgKG1heENlbGxzIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHsgY2VsbHM6IFtdIH07IC8vIE5vIGNlbGxzIHRvIHRyYXZlcnNlXG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgZ3JpZCB0b3AtbGVmdCBhbmQgYm90dG9tLXJpZ2h0IGJvdW5kYXJpZXMgYXJlIGludGVnZXJzXG4gICAgZ3JpZFRvcExlZnQgPSB2ZWNfMS52ZWMyLm1hcChncmlkVG9wTGVmdCwgTWF0aC5mbG9vcik7XG4gICAgZ3JpZEJvdHRvbVJpZ2h0ID0gdmVjXzEudmVjMi5tYXAoZ3JpZEJvdHRvbVJpZ2h0LCBNYXRoLmNlaWwpO1xuICAgIC8vIE5vcm1hbGl6ZSByYXkgZGlyZWN0aW9uIGFuZCBoYW5kbGUgemVybyBjb21wb25lbnRzXG4gICAgY29uc3QgcmF5RGlyID0gdmVjXzEudmVjMi5ub3IocmF5LmRpcmVjdGlvbik7XG4gICAgaWYgKCgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShyYXlEaXIpKSB7XG4gICAgICAgIHJldHVybiB7IGNlbGxzOiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCBjZWxscyA9IFtdO1xuICAgIC8vIENhbGN1bGF0ZSBpbml0aWFsIGNlbGwgY29vcmRpbmF0ZXNcbiAgICBsZXQgY3VycmVudENlbGwgPSB2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLmRpdih2ZWNfMS52ZWMyLnN1YihyYXkub3JpZ2luLCBncmlkVG9wTGVmdCksIGNlbGxTaXplKSwgTWF0aC5mbG9vcik7XG4gICAgLy8gQ2FsY3VsYXRlIGdyaWQgc2l6ZSBpbiBjZWxsc1xuICAgIGNvbnN0IGdyaWRTaXplID0gdmVjXzEudmVjMi5zdWIoZ3JpZEJvdHRvbVJpZ2h0LCBncmlkVG9wTGVmdCk7XG4gICAgLy8gSWYgc3RhcnRpbmcgcG9pbnQgaXMgb3V0c2lkZSBncmlkIGJvdW5kcywgZmluZCBlbnRyeSBwb2ludFxuICAgIGlmIChjdXJyZW50Q2VsbC54IDwgMCB8fFxuICAgICAgICBjdXJyZW50Q2VsbC54ID49IGdyaWRTaXplLnggfHxcbiAgICAgICAgY3VycmVudENlbGwueSA8IDAgfHxcbiAgICAgICAgY3VycmVudENlbGwueSA+PSBncmlkU2l6ZS55KSB7XG4gICAgICAgIC8vIFVzZSByYXlJbnRlcnNlY3RzUmVjdGFuZ2xlIHRvIGZpbmQgZ3JpZCBlbnRyeSBwb2ludFxuICAgICAgICBjb25zdCBncmlkUmVjdCA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWNfMS52ZWMyLmFkZChncmlkVG9wTGVmdCwgdmVjXzEudmVjMi5kaXYodmVjXzEudmVjMi5zdWIoZ3JpZEJvdHRvbVJpZ2h0LCBncmlkVG9wTGVmdCksIDIpKSxcbiAgICAgICAgICAgIHNpemU6IHZlY18xLnZlYzIuc3ViKGdyaWRCb3R0b21SaWdodCwgZ3JpZFRvcExlZnQpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSByYXlJbnRlcnNlY3RzUmVjdGFuZ2xlKHJheSwgZ3JpZFJlY3QpO1xuICAgICAgICBpZiAoIWludGVyc2VjdGlvbi5pbnRlcnNlY3RzIHx8ICFpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjZWxscyB9OyAvLyBSYXkgbWlzc2VzIGdyaWQgZW50aXJlbHlcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGZpcnN0IGludGVyc2VjdGlvbiBwb2ludCAoY2xvc2VzdCB0byByYXkgb3JpZ2luKVxuICAgICAgICBjb25zdCBlbnRyeVBvaW50ID0gaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50c1swXTtcbiAgICAgICAgY3VycmVudENlbGwgPSB2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLmRpdih2ZWNfMS52ZWMyLnN1YihlbnRyeVBvaW50LCBncmlkVG9wTGVmdCksIGNlbGxTaXplKSwgTWF0aC5mbG9vcik7XG4gICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IHBvaW50IGlzIHZhbGlkICh0aGlzIHNob3VsZCBuZXZlciBmYWlsIGJ1dCBjaGVjayBhbnl3YXkpXG4gICAgICAgIGlmIChjdXJyZW50Q2VsbC54IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueCA+PSBncmlkU2l6ZS54IHx8XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC55IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueSA+PSBncmlkU2l6ZS55KSB7XG4gICAgICAgICAgICByZXR1cm4geyBjZWxscyB9OyAvLyBObyB2YWxpZCBlbnRyeSBwb2ludCBmb3VuZFxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBzdGVwIGRpcmVjdGlvbiAoZWl0aGVyIDEgb3IgLTEpIGZvciBlYWNoIGF4aXNcbiAgICBjb25zdCBzdGVwID0ge1xuICAgICAgICB4OiBNYXRoLnNpZ24ocmF5RGlyLngpLFxuICAgICAgICB5OiBNYXRoLnNpZ24ocmF5RGlyLnkpLFxuICAgIH07XG4gICAgLy8gQ2FsY3VsYXRlIHREZWx0YSAtIGRpc3RhbmNlIGFsb25nIHJheSBmcm9tIG9uZSBncmlkIGxpbmUgdG8gbmV4dFxuICAgIGNvbnN0IHREZWx0YSA9IHtcbiAgICAgICAgeDogcmF5RGlyLnggIT09IDAgPyBNYXRoLmFicyhjZWxsU2l6ZSAvIHJheURpci54KSA6IEluZmluaXR5LFxuICAgICAgICB5OiByYXlEaXIueSAhPT0gMCA/IE1hdGguYWJzKGNlbGxTaXplIC8gcmF5RGlyLnkpIDogSW5maW5pdHksXG4gICAgfTtcbiAgICAvLyBDYWxjdWxhdGUgaW5pdGlhbCBjZWxsIGJvdW5kYXJ5IHBvc2l0aW9uc1xuICAgIGNvbnN0IGluaXRpYWxCb3VuZGFyeSA9ICgwLCB2ZWNfMS52ZWMyKShncmlkVG9wTGVmdC54ICsgKGN1cnJlbnRDZWxsLnggKyAoc3RlcC54ID4gMCA/IDEgOiAwKSkgKiBjZWxsU2l6ZSwgZ3JpZFRvcExlZnQueSArIChjdXJyZW50Q2VsbC55ICsgKHN0ZXAueSA+IDAgPyAxIDogMCkpICogY2VsbFNpemUpO1xuICAgIC8vIENhbGN1bGF0ZSBpbml0aWFsIHRNYXggdmFsdWVzLCBoYW5kbGluZyBib3VuZGFyeSBjYXNlc1xuICAgIGNvbnN0IHRNYXggPSB7XG4gICAgICAgIHg6IHJheURpci54ICE9PSAwXG4gICAgICAgICAgICA/IE1hdGguYWJzKChpbml0aWFsQm91bmRhcnkueCAtIHJheS5vcmlnaW4ueCkgLyByYXlEaXIueClcbiAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgICAgIHk6IHJheURpci55ICE9PSAwXG4gICAgICAgICAgICA/IE1hdGguYWJzKChpbml0aWFsQm91bmRhcnkueSAtIHJheS5vcmlnaW4ueSkgLyByYXlEaXIueSlcbiAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgfTtcbiAgICAvLyBJZiB3ZSdyZSBleGFjdGx5IG9uIGEgYm91bmRhcnksIHdlIG5lZWQgdG8gYWRqdXN0IHRNYXhcbiAgICBpZiAoTWF0aC5hYnMocmF5Lm9yaWdpbi54IC0gaW5pdGlhbEJvdW5kYXJ5LngpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgdE1heC54ID0gdERlbHRhLng7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhyYXkub3JpZ2luLnkgLSBpbml0aWFsQm91bmRhcnkueSkgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICB0TWF4LnkgPSB0RGVsdGEueTtcbiAgICB9XG4gICAgLy8gQWRkIHN0YXJ0aW5nIGNlbGxcbiAgICBjZWxscy5wdXNoKCgwLCB2ZWNfMS52ZWMyKShjdXJyZW50Q2VsbC54LCBjdXJyZW50Q2VsbC55KSk7XG4gICAgbGV0IGNlbGxDb3VudCA9IDE7XG4gICAgLy8gTWFpbiBsb29wXG4gICAgd2hpbGUgKGNlbGxDb3VudCA8IG1heENlbGxzICYmXG4gICAgICAgIGN1cnJlbnRDZWxsLnggPj0gMCAmJlxuICAgICAgICBjdXJyZW50Q2VsbC54IDwgZ3JpZFNpemUueCAmJlxuICAgICAgICBjdXJyZW50Q2VsbC55ID49IDAgJiZcbiAgICAgICAgY3VycmVudENlbGwueSA8IGdyaWRTaXplLnkpIHtcbiAgICAgICAgLy8gQWR2YW5jZSB0byBuZXh0IGNlbGwgYmFzZWQgb24gc2hvcnRlc3QgdE1heFxuICAgICAgICBpZiAodE1heC54IDwgdE1heC55KSB7XG4gICAgICAgICAgICB0TWF4LnggKz0gdERlbHRhLng7XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC54ICs9IHN0ZXAueDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRNYXgueSArPSB0RGVsdGEueTtcbiAgICAgICAgICAgIGN1cnJlbnRDZWxsLnkgKz0gc3RlcC55O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIHN0aWxsIGluIGJvdW5kc1xuICAgICAgICBpZiAoY3VycmVudENlbGwueCA8IDAgfHxcbiAgICAgICAgICAgIGN1cnJlbnRDZWxsLnggPj0gZ3JpZFNpemUueCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueSA8IDAgfHxcbiAgICAgICAgICAgIGN1cnJlbnRDZWxsLnkgPj0gZ3JpZFNpemUueSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGN1cnJlbnQgY2VsbFxuICAgICAgICBjZWxscy5wdXNoKCgwLCB2ZWNfMS52ZWMyKShjdXJyZW50Q2VsbC54LCBjdXJyZW50Q2VsbC55KSk7XG4gICAgICAgIGNlbGxDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4geyBjZWxscyB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiB0d28gcmF5cyBpbnRlcnNlY3RcbiAqL1xuZnVuY3Rpb24gcmF5SW50ZXJzZWN0c1JheShyYXlBLCByYXlCKSB7XG4gICAgLy8gTm9ybWFsaXplIHRoZSBkaXJlY3Rpb24gdmVjdG9yc1xuICAgIGNvbnN0IGRpckEgPSB2ZWNfMS52ZWMyLm5vcihyYXlBLmRpcmVjdGlvbik7XG4gICAgY29uc3QgZGlyQiA9IHZlY18xLnZlYzIubm9yKHJheUIuZGlyZWN0aW9uKTtcbiAgICAvLyBJZiBlaXRoZXIgcmF5IGhhcyB6ZXJvIGRpcmVjdGlvbiwgdGhleSBjYW5ub3QgaW50ZXJzZWN0XG4gICAgaWYgKCgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShkaXJBKSB8fCAoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykoZGlyQikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNyb3NzIHByb2R1Y3QgZGV0ZXJtaW5hbnRcbiAgICBjb25zdCBkZXQgPSB2ZWNfMS52ZWMyLmNyb3NzKGRpckEsIGRpckIpO1xuICAgIC8vIEdldCB0aGUgdmVjdG9yIGJldHdlZW4gc3RhcnRpbmcgcG9pbnRzXG4gICAgY29uc3Qgc3RhcnREaWZmID0gdmVjXzEudmVjMi5zdWIocmF5Qi5vcmlnaW4sIHJheUEub3JpZ2luKTtcbiAgICAvLyBJZiBkZXRlcm1pbmFudCBpcyBjbG9zZSB0byAwLCByYXlzIGFyZSBwYXJhbGxlbCBvciBjb2xsaW5lYXJcbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHJheXMgYXJlIGNvbGxpbmVhclxuICAgICAgICBpZiAoTWF0aC5hYnModmVjXzEudmVjMi5jcm9zcyhzdGFydERpZmYsIGRpckEpKSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgICAgICAvLyBSYXlzIGFyZSBjb2xsaW5lYXIgLSBjaGVjayBpZiB0aGV5IG92ZXJsYXBcbiAgICAgICAgICAgIGNvbnN0IHQgPSB2ZWNfMS52ZWMyLmRvdChzdGFydERpZmYsIGRpckEpO1xuICAgICAgICAgICAgLy8gRm9yIHJheXMgcG9pbnRpbmcgaW4gdGhlIHNhbWUgZGlyZWN0aW9uOlxuICAgICAgICAgICAgLy8gSWYgdCA8PSAwOiByYXlBJ3Mgb3JpZ2luIGlzIGJlaGluZCBvciBhdCByYXlCJ3Mgb3JpZ2luXG4gICAgICAgICAgICAvLyBJZiB0ID49IDA6IHJheUIncyBvcmlnaW4gaXMgYmVoaW5kIG9yIGF0IHJheUEncyBvcmlnaW5cbiAgICAgICAgICAgIC8vIGRvdChkaXJBLCBkaXJCKSBzaG91bGQgYmUgY2xvc2UgdG8gMSBmb3Igc2FtZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIGlmICgodCA8PSAwIHx8IHQgPj0gMCkgJiYgdmVjXzEudmVjMi5kb3QoZGlyQSwgZGlyQikgPiAxIC0gY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBObyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50IGZvciBvdmVybGFwcGluZyByYXlzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcGFyYW1ldGVyc1xuICAgIGNvbnN0IHQgPSB2ZWNfMS52ZWMyLmNyb3NzKHN0YXJ0RGlmZiwgZGlyQikgLyBkZXQ7XG4gICAgY29uc3QgcyA9IHZlY18xLnZlYzIuY3Jvc3Moc3RhcnREaWZmLCBkaXJBKSAvIGRldDtcbiAgICAvLyBDaGVjayBpZiBpbnRlcnNlY3Rpb24gb2NjdXJzIG9uIGJvdGggcmF5cyAodCA+PSAwIGFuZCBzID49IDApXG4gICAgaWYgKHQgPj0gMCAmJiBzID49IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludDogdmVjXzEudmVjMi5hZGQocmF5QS5vcmlnaW4sIHZlY18xLnZlYzIubXVsKGRpckEsIHQpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSByYXkgaW50ZXJzZWN0cyBhIGxpbmUgc2VnbWVudFxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzTGluZShyYXksIGxpbmUpIHtcbiAgICAvLyBDb252ZXJ0IGxpbmUgdG8gYSBkaXJlY3Rpb24gdmVjdG9yXG4gICAgY29uc3QgbGluZURpciA9IHZlY18xLnZlYzIuc3ViKGxpbmUuZW5kLCBsaW5lLnN0YXJ0KTtcbiAgICAvLyBOb3JtYWxpemUgdGhlIHJheSBkaXJlY3Rpb25cbiAgICBjb25zdCByYXlEaXIgPSB2ZWNfMS52ZWMyLm5vcihyYXkuZGlyZWN0aW9uKTtcbiAgICAvLyBJZiBlaXRoZXIgdGhlIHJheSBvciB0aGUgbGluZSBoYXMgemVybyBkaXJlY3Rpb24sIHRoZXkgY2Fubm90IGludGVyc2VjdFxuICAgIGlmICgoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykobGluZURpcikgfHwgKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKHJheURpcikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNyb3NzIHByb2R1Y3QgZGV0ZXJtaW5hbnRcbiAgICBjb25zdCBkZXQgPSB2ZWNfMS52ZWMyLmNyb3NzKHJheURpciwgbGluZURpcik7XG4gICAgLy8gR2V0IHRoZSB2ZWN0b3IgYmV0d2VlbiByYXkgb3JpZ2luIGFuZCBsaW5lIHN0YXJ0XG4gICAgY29uc3Qgc3RhcnREaWZmID0gdmVjXzEudmVjMi5zdWIobGluZS5zdGFydCwgcmF5Lm9yaWdpbik7XG4gICAgLy8gSWYgZGV0ZXJtaW5hbnQgaXMgY2xvc2UgdG8gMCwgcmF5IGFuZCBsaW5lIGFyZSBwYXJhbGxlbCBvciBjb2xsaW5lYXJcbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXkgYXJlIGNvbGxpbmVhclxuICAgICAgICBpZiAoTWF0aC5hYnModmVjXzEudmVjMi5jcm9zcyhzdGFydERpZmYsIHJheURpcikpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgIC8vIFRoZXkgYXJlIGNvbGxpbmVhciAtIHByb2plY3QgdGhlIGxpbmUgZW5kcG9pbnRzIG9udG8gdGhlIHJheVxuICAgICAgICAgICAgY29uc3QgdDEgPSB2ZWNfMS52ZWMyLmRvdCh2ZWNfMS52ZWMyLnN1YihsaW5lLnN0YXJ0LCByYXkub3JpZ2luKSwgcmF5RGlyKTtcbiAgICAgICAgICAgIGNvbnN0IHQyID0gdmVjXzEudmVjMi5kb3QodmVjXzEudmVjMi5zdWIobGluZS5lbmQsIHJheS5vcmlnaW4pLCByYXlEaXIpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IHBhcnQgb2YgdGhlIGxpbmUgc2VnbWVudCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5XG4gICAgICAgICAgICBpZiAoKHQxID49IDAgfHwgdDIgPj0gMCkgJiYgTWF0aC5taW4odDEsIHQyKSA8PSB2ZWNfMS52ZWMyLmxlbihsaW5lRGlyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHNpbmdsZSBpbnRlcnNlY3Rpb24gcG9pbnQgZm9yIG92ZXJsYXBwaW5nIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcGFyYW1ldGVyc1xuICAgIGNvbnN0IHQgPSB2ZWNfMS52ZWMyLmNyb3NzKHN0YXJ0RGlmZiwgbGluZURpcikgLyBkZXQ7IC8vIFJheSBwYXJhbWV0ZXJcbiAgICBjb25zdCBzID0gdmVjXzEudmVjMi5jcm9zcyhzdGFydERpZmYsIHJheURpcikgLyBkZXQ7IC8vIExpbmUgcGFyYW1ldGVyXG4gICAgLy8gQ2hlY2sgaWYgaW50ZXJzZWN0aW9uIG9jY3VycyBvbiB0aGUgcmF5ICh0ID49IDApIGFuZCB3aXRoaW4gdGhlIGxpbmVcbiAgICAvLyBzZWdtZW50ICgwIDw9IHMgPD0gMSlcbiAgICBpZiAodCA+PSAwICYmIHMgPj0gMCAmJiBzIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludDogdmVjXzEudmVjMi5hZGQocmF5Lm9yaWdpbiwgdmVjXzEudmVjMi5tdWwocmF5RGlyLCB0KSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGZhbHNlLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcmF5IGludGVyc2VjdHMgYSBjaXJjbGVcbiAqL1xuZnVuY3Rpb24gcmF5SW50ZXJzZWN0c0NpcmNsZShyYXksIGNpcmNsZSkge1xuICAgIC8vIDEuIFBhcmFtZXRlcml6ZWQgcmF5IGVxdWF0aW9uOiBQKHQpID0gb3JpZ2luICsgdCAqIGRpcmVjdGlvblxuICAgIGNvbnN0IHJheURpciA9IHZlY18xLnZlYzIubm9yKHJheS5kaXJlY3Rpb24pO1xuICAgIC8vIENhbGN1bGF0ZSB2ZWN0b3IgZnJvbSByYXkgb3JpZ2luIHRvIGNpcmNsZSBjZW50ZXJcbiAgICBjb25zdCB0b0NlbnRlciA9IHZlY18xLnZlYzIuc3ViKGNpcmNsZS5wb3NpdGlvbiwgcmF5Lm9yaWdpbik7XG4gICAgLy8gMi4gU3Vic3RpdHV0ZSByYXkgZXF1YXRpb24gaW50byBjaXJjbGUgZXF1YXRpb246XG4gICAgLy8gKG9yaWdpbi54ICsgdCpkaXIueCAtIGNpcmNsZS54KcKyICsgKG9yaWdpbi55ICsgdCpkaXIueSAtIGNpcmNsZS55KcKyID0gcsKyXG4gICAgLy8gRXhwYW5kIGFuZCBjb2xsZWN0IHRlcm1zIHRvIGdldCBxdWFkcmF0aWMgZXF1YXRpb246IGF0wrIgKyBidCArIGMgPSAwXG4gICAgLy8gYSA9IGRvdChkaXIsIGRpcikgKHNob3VsZCBiZSAxIHNpbmNlIGRpciBpcyBub3JtYWxpemVkKVxuICAgIGNvbnN0IGEgPSB2ZWNfMS52ZWMyLmRvdChyYXlEaXIsIHJheURpcik7XG4gICAgLy8gYiA9IDIgKiBkb3QoZGlyLCAob3JpZ2luIC0gY2VudGVyKSlcbiAgICBjb25zdCBiID0gMiAqIHZlY18xLnZlYzIuZG90KHJheURpciwgdmVjXzEudmVjMi5tdWwodG9DZW50ZXIsIC0xKSk7XG4gICAgLy8gYyA9IGRvdCgob3JpZ2luIC0gY2VudGVyKSwgKG9yaWdpbiAtIGNlbnRlcikpIC0gcmFkaXVzwrJcbiAgICBjb25zdCBjID0gdmVjXzEudmVjMi5kb3QodG9DZW50ZXIsIHRvQ2VudGVyKSAtIGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzO1xuICAgIC8vIDMuIFNvbHZlIHF1YWRyYXRpYyBlcXVhdGlvbiB1c2luZyBkaXNjcmltaW5hbnRcbiAgICBjb25zdCBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcbiAgICAvLyA0LiBDaGVjayBpZiBzb2x1dGlvbnMgZXhpc3QgKGRpc2NyaW1pbmFudCA+PSAwKVxuICAgIGlmIChkaXNjcmltaW5hbnQgPCAtY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcmF5IGp1c3QgdG91Y2hlcyBjaXJjbGUgKGRpc2NyaW1pbmFudCDiiYggMClcbiAgICBpZiAoTWF0aC5hYnMoZGlzY3JpbWluYW50KSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIGNvbnN0IHQgPSAtYiAvICgyICogYSk7XG4gICAgICAgIGlmICh0ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdmVjXzEudmVjMi5hZGQocmF5Lm9yaWdpbiwgdmVjXzEudmVjMi5tdWwocmF5RGlyLCB0KSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBbcG9pbnRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyA1LiBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50cyBmb3IgZGlzY3JpbWluYW50ID4gMFxuICAgIGNvbnN0IHNxcnREaXNjcmltaW5hbnQgPSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICBjb25zdCB0MSA9ICgtYiAtIHNxcnREaXNjcmltaW5hbnQpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB0MiA9ICgtYiArIHNxcnREaXNjcmltaW5hbnQpIC8gKDIgKiBhKTtcbiAgICAvLyBJZiBib3RoIHQgdmFsdWVzIGFyZSBuZWdhdGl2ZSwgcmF5IHBvaW50cyBhd2F5IGZyb20gY2lyY2xlXG4gICAgaWYgKHQyIDwgMCkge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50cyBmb3IgcG9zaXRpdmUgdCB2YWx1ZXNcbiAgICBsZXQgaW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgaWYgKHQxID49IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2godmVjXzEudmVjMi5hZGQocmF5Lm9yaWdpbiwgdmVjXzEudmVjMi5tdWwocmF5RGlyLCB0MSkpKTtcbiAgICB9XG4gICAgaWYgKHQyID49IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2godmVjXzEudmVjMi5hZGQocmF5Lm9yaWdpbiwgdmVjXzEudmVjMi5tdWwocmF5RGlyLCB0MikpKTtcbiAgICB9XG4gICAgaW50ZXJzZWN0aW9uUG9pbnRzID0gcmVtb3ZlRHVwbGljYXRlVmVydGljZXMoaW50ZXJzZWN0aW9uUG9pbnRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCA/IGludGVyc2VjdGlvblBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHJheSBpbnRlcnNlY3RzIGEgcmVjdGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIHJheUludGVyc2VjdHNSZWN0YW5nbGUocmF5LCByZWN0YW5nbGUpIHtcbiAgICAvLyBHZXQgdmVydGljZXMgb2YgdGhlIHJlY3RhbmdsZSBpbiBjbG9ja3dpc2Ugb3JkZXJcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHJlY3RhbmdsZVZlcnRpY2VzKHJlY3RhbmdsZSk7XG4gICAgbGV0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIENoZWNrIGVhY2ggZWRnZSBvZiB0aGUgcmVjdGFuZ2xlIGZvciBpbnRlcnNlY3Rpb25cbiAgICBjb25zdCBlZGdlcyA9IHZlcnRpY2VzVG9FZGdlcyh2ZXJ0aWNlcyk7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHJheUludGVyc2VjdHNMaW5lKHJheSwgZWRnZSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24uaW50ZXJzZWN0cyAmJiBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGFuZCBzb3J0IGJ5IGRpc3RhbmNlIHRvIHJheSBvcmlnaW5cbiAgICBpbnRlcnNlY3Rpb25Qb2ludHMgPSByZW1vdmVEdXBsaWNhdGVWZXJ0aWNlcyhpbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgIGlmIChpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCByYXlEaXIgPSB2ZWNfMS52ZWMyLm5vcihyYXkuZGlyZWN0aW9uKTtcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RBID0gdmVjXzEudmVjMi5kb3QodmVjXzEudmVjMi5zdWIoYSwgcmF5Lm9yaWdpbiksIHJheURpcik7XG4gICAgICAgICAgICBjb25zdCBkaXN0QiA9IHZlY18xLnZlYzIuZG90KHZlY18xLnZlYzIuc3ViKGIsIHJheS5vcmlnaW4pLCByYXlEaXIpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3RBIC0gZGlzdEI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCA/IGludGVyc2VjdGlvblBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHJheSBpbnRlcnNlY3RzIHRoZSBlZGdlcyBvZiBhIGNvbnZleCBwb2x5Z29uXG4gKlxuICogV2UgYXNzdW1lIHRoZSBwb2x5Z29uIGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZCBmb3IgdmFsaWRpdHkgYW5kIGNvbnZleGl0eVxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzVmFsaWRDb252ZXhQb2x5Z29uRWRnZXMocmF5LCBlZGdlcykge1xuICAgIGxldCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICAvLyBDaGVjayBlYWNoIG91dGVyIGVkZ2UgZm9yIGludGVyc2VjdGlvbnNcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gcmF5SW50ZXJzZWN0c0xpbmUocmF5LCBlZGdlKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3RzICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGludGVyc2VjdGlvbiBwb2ludHMgYW5kIHNvcnQgYnkgZGlzdGFuY2UgdG8gcmF5IG9yaWdpblxuICAgIGludGVyc2VjdGlvblBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGludGVyc2VjdGlvblBvaW50cyk7XG4gICAgaWYgKGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IHJheURpciA9IHZlY18xLnZlYzIubm9yKHJheS5kaXJlY3Rpb24pO1xuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlzdEEgPSB2ZWNfMS52ZWMyLmRvdCh2ZWNfMS52ZWMyLnN1YihhLCByYXkub3JpZ2luKSwgcmF5RGlyKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RCID0gdmVjXzEudmVjMi5kb3QodmVjXzEudmVjMi5zdWIoYiwgcmF5Lm9yaWdpbiksIHJheURpcik7XG4gICAgICAgICAgICByZXR1cm4gZGlzdEEgLSBkaXN0QjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcmF5IGludGVyc2VjdHMgYSBwb2x5Z29uXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBwb2x5Z29uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcmF5SW50ZXJzZWN0c1BvbHlnb24ocmF5LCBwb2x5Z29uKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHBvbHlnb24gaXMgdmFsaWRcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBJZiBwb2x5Z29uIGlzIG5vdCBjb252ZXgsIGRlY29tcG9zZSBpdCBpbnRvIGNvbnZleCBwb2x5Z29uc1xuICAgIGlmICghcG9seWdvbklzQ29udmV4KHBvbHlnb24pKSB7XG4gICAgICAgIGNvbnN0IGNvbnZleFBvbHlnb25zID0gZGVjb21wb3NlUG9seWdvbihwb2x5Z29uKTtcbiAgICAgICAgaWYgKCFjb252ZXhQb2x5Z29ucykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHJheSBhZ2FpbnN0IHRoZSBvdXRlciBlZGdlcyBvZiBlYWNoIGNvbnZleCBwb2x5Z29uc1xuICAgICAgICByZXR1cm4gcmF5SW50ZXJzZWN0c1ZhbGlkQ29udmV4UG9seWdvbkVkZ2VzKHJheSwgZmluZE91dGVyRWRnZXMoY29udmV4UG9seWdvbnMpKTtcbiAgICB9XG4gICAgLy8gRm9yIGNvbnZleCBwb2x5Z29ucywgY2hlY2sgZWFjaCBlZGdlXG4gICAgcmV0dXJuIHJheUludGVyc2VjdHNWYWxpZENvbnZleFBvbHlnb25FZGdlcyhyYXksIHZlcnRpY2VzVG9FZGdlcyhwb2x5Z29uLnZlcnRpY2VzKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgbGluZSBzZWdtZW50IGludGVyc2VjdHMgYSByYXlcbiAqL1xuZnVuY3Rpb24gbGluZUludGVyc2VjdHNSYXkobGluZSwgcmF5KSB7XG4gICAgcmV0dXJuIHJheUludGVyc2VjdHNMaW5lKHJheSwgbGluZSk7XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdFxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0xpbmUobGluZUEsIGxpbmVCKSB7XG4gICAgLy8gR2V0IHRoZSB2ZWN0b3JzIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9ucyBvZiBlYWNoIGxpbmVcbiAgICBjb25zdCBkaXJBID0gdmVjXzEudmVjMi5zdWIobGluZUEuZW5kLCBsaW5lQS5zdGFydCk7XG4gICAgY29uc3QgZGlyQiA9IHZlY18xLnZlYzIuc3ViKGxpbmVCLmVuZCwgbGluZUIuc3RhcnQpO1xuICAgIC8vIElmIGVpdGhlciBsaW5lIGhhcyB6ZXJvIGRpcmVjdGlvbiwgdGhleSBjYW5ub3QgaW50ZXJzZWN0XG4gICAgaWYgKCgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShkaXJBKSB8fCAoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykoZGlyQikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNyb3NzIHByb2R1Y3QgZGV0ZXJtaW5hbnRcbiAgICBjb25zdCBkZXQgPSB2ZWNfMS52ZWMyLmNyb3NzKGRpckEsIGRpckIpO1xuICAgIC8vIEdldCB0aGUgdmVjdG9yIGJldHdlZW4gc3RhcnRpbmcgcG9pbnRzXG4gICAgY29uc3Qgc3RhcnREaWZmID0gdmVjXzEudmVjMi5zdWIobGluZUIuc3RhcnQsIGxpbmVBLnN0YXJ0KTtcbiAgICAvLyBJZiBkZXRlcm1pbmFudCBpcyBjbG9zZSB0byAwLCBsaW5lcyBhcmUgcGFyYWxsZWwgb3IgY29sbGluZWFyXG4gICAgaWYgKE1hdGguYWJzKGRldCkgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICAvLyBDaGVjayBpZiBsaW5lcyBhcmUgY29sbGluZWFyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZWNfMS52ZWMyLmNyb3NzKHN0YXJ0RGlmZiwgZGlyQSkpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBjb2xsaW5lYXIgLSBjaGVjayBpZiB0aGV5IG92ZXJsYXBcbiAgICAgICAgICAgIGNvbnN0IHQwID0gdmVjXzEudmVjMi5kb3Qoc3RhcnREaWZmLCBkaXJBKSAvIHZlY18xLnZlYzIuZG90KGRpckEsIGRpckEpO1xuICAgICAgICAgICAgY29uc3QgdDEgPSB0MCArIHZlY18xLnZlYzIuZG90KGRpckIsIGRpckEpIC8gdmVjXzEudmVjMi5kb3QoZGlyQSwgZGlyQSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzZWdtZW50cyBvdmVybGFwXG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbDAgPSBNYXRoLm1pbih0MCwgdDEpO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwxID0gTWF0aC5tYXgodDAsIHQxKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbDAgPD0gMSAmJiBpbnRlcnZhbDEgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHNpbmdsZSBpbnRlcnNlY3Rpb24gcG9pbnQgZm9yIG92ZXJsYXBwaW5nIGxpbmVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcGFyYW1ldGVyc1xuICAgIGNvbnN0IHQgPSB2ZWNfMS52ZWMyLmNyb3NzKHN0YXJ0RGlmZiwgZGlyQikgLyBkZXQ7XG4gICAgY29uc3QgcyA9IHZlY18xLnZlYzIuY3Jvc3Moc3RhcnREaWZmLCBkaXJBKSAvIGRldDtcbiAgICAvLyBDaGVjayBpZiBpbnRlcnNlY3Rpb24gb2NjdXJzIHdpdGhpbiBib3RoIGxpbmUgc2VnbWVudHNcbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSAmJiBzID49IDAgJiYgcyA8PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQ6IHZlY18xLnZlYzIuYWRkKGxpbmVBLnN0YXJ0LCB2ZWNfMS52ZWMyLm11bChkaXJBLCB0KSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGZhbHNlLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgbGluZSBzZWdtZW50IGludGVyc2VjdHMgYSBjaXJjbGVcbiAqL1xuZnVuY3Rpb24gbGluZUludGVyc2VjdHNDaXJjbGUobGluZSwgY2lyY2xlKSB7XG4gICAgLy8gMS4gUGFyYW1ldGVyaXplZCBsaW5lIGVxdWF0aW9uOiBQKHQpID0gc3RhcnQgKyB0ICogKGVuZCAtIHN0YXJ0KVxuICAgIGNvbnN0IGxpbmVEaXIgPSB2ZWNfMS52ZWMyLnN1YihsaW5lLmVuZCwgbGluZS5zdGFydCk7XG4gICAgY29uc3QgbGluZUxlbmd0aFNxdWFyZWQgPSB2ZWNfMS52ZWMyLmRvdChsaW5lRGlyLCBsaW5lRGlyKTtcbiAgICAvLyBJZiB0aGUgbGluZSBzZWdtZW50IGhhcyB6ZXJvIGxlbmd0aCwgaXQgY2Fubm90IGludGVyc2VjdFxuICAgIGlmIChsaW5lTGVuZ3RoU3F1YXJlZCA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIElmIGJvdGggZW5kcG9pbnRzIG9mIHRoZSBsaW5lIGFyZSBpbnNpZGUgdGhlIGNpcmNsZSwgdGhlbiB3ZSBoYXZlIGFuXG4gICAgLy8gaW50ZXJzZWN0aW9uIChidXQgbm8gaW50ZXJzZWN0aW9uIHBvaW50cylcbiAgICBpZiAocG9pbnRJbkNpcmNsZShsaW5lLnN0YXJ0LCBjaXJjbGUpLmludGVyc2VjdHMgJiZcbiAgICAgICAgcG9pbnRJbkNpcmNsZShsaW5lLmVuZCwgY2lyY2xlKS5pbnRlcnNlY3RzKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IHRydWUgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHZlY3RvciBmcm9tIGNpcmNsZSBjZW50ZXIgdG8gbGluZSBzdGFydFxuICAgIGNvbnN0IHRvQ2VudGVyID0gdmVjXzEudmVjMi5zdWIoY2lyY2xlLnBvc2l0aW9uLCBsaW5lLnN0YXJ0KTtcbiAgICAvLyAyLiBTdWJzdGl0dXRlIGxpbmUgZXF1YXRpb24gaW50byBjaXJjbGUgZXF1YXRpb246XG4gICAgLy8gKHN0YXJ0LnggKyB0KmRpci54IC0gY2lyY2xlLngpwrIgKyAoc3RhcnQueSArIHQqZGlyLnkgLSBjaXJjbGUueSnCsiA9IHLCslxuICAgIC8vIEV4cGFuZCBhbmQgY29sbGVjdCB0ZXJtcyB0byBnZXQgcXVhZHJhdGljIGVxdWF0aW9uOiBhdMKyICsgYnQgKyBjID0gMFxuICAgIC8vIGEgPSBkb3QoZGlyLCBkaXIpXG4gICAgY29uc3QgYSA9IGxpbmVMZW5ndGhTcXVhcmVkO1xuICAgIC8vIGIgPSAyICogZG90KGRpciwgKHN0YXJ0IC0gY2VudGVyKSlcbiAgICBjb25zdCBiID0gMiAqIHZlY18xLnZlYzIuZG90KGxpbmVEaXIsIHZlY18xLnZlYzIubXVsKHRvQ2VudGVyLCAtMSkpO1xuICAgIC8vIGMgPSBkb3QoKHN0YXJ0IC0gY2VudGVyKSwgKHN0YXJ0IC0gY2VudGVyKSkgLSByYWRpdXPCslxuICAgIGNvbnN0IGMgPSB2ZWNfMS52ZWMyLmRvdCh0b0NlbnRlciwgdG9DZW50ZXIpIC0gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXM7XG4gICAgLy8gMy4gU29sdmUgcXVhZHJhdGljIGVxdWF0aW9uIHVzaW5nIGRpc2NyaW1pbmFudFxuICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgIC8vIElmIGRpc2NyaW1pbmFudCBpcyBuZWdhdGl2ZSwgbm8gaW50ZXJzZWN0aW9uXG4gICAgaWYgKGRpc2NyaW1pbmFudCA8IC1jb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBsaW5lIGp1c3QgdG91Y2hlcyBjaXJjbGUgKGRpc2NyaW1pbmFudCDiiYggMClcbiAgICBpZiAoTWF0aC5hYnMoZGlzY3JpbWluYW50KSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIGNvbnN0IHQgPSAtYiAvICgyICogYSk7XG4gICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHZlY18xLnZlYzIuYWRkKGxpbmUuc3RhcnQsIHZlY18xLnZlYzIubXVsKGxpbmVEaXIsIHQpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IFtwb2ludF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGZvciBkaXNjcmltaW5hbnQgPiAwXG4gICAgY29uc3Qgc3FydERpc2NyaW1pbmFudCA9IE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIGNvbnN0IHQxID0gKC1iIC0gc3FydERpc2NyaW1pbmFudCkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHQyID0gKC1iICsgc3FydERpc2NyaW1pbmFudCkgLyAoMiAqIGEpO1xuICAgIGxldCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICAvLyBJZiBib3RoIHQgdmFsdWVzIGFyZSBvdXRzaWRlIFswLCAxXSwgbm8gaW50ZXJzZWN0aW9uXG4gICAgaWYgKHQyIDwgMCB8fCB0MSA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBwb2ludHMgZm9yIHZhbGlkIHQgdmFsdWVzXG4gICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaCh2ZWNfMS52ZWMyLmFkZChsaW5lLnN0YXJ0LCB2ZWNfMS52ZWMyLm11bChsaW5lRGlyLCB0MSkpKTtcbiAgICB9XG4gICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaCh2ZWNfMS52ZWMyLmFkZChsaW5lLnN0YXJ0LCB2ZWNfMS52ZWMyLm11bChsaW5lRGlyLCB0MikpKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGFuZCBzb3J0IGJ5IGRpc3RhbmNlIHRvIGxpbmUgc3RhcnRcbiAgICBpbnRlcnNlY3Rpb25Qb2ludHMgPSByZW1vdmVEdXBsaWNhdGVWZXJ0aWNlcyhpbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgIGlmIChpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlzdEEgPSB2ZWNfMS52ZWMyLmxlbih2ZWNfMS52ZWMyLnN1YihhLCBsaW5lLnN0YXJ0KSk7XG4gICAgICAgICAgICBjb25zdCBkaXN0QiA9IHZlY18xLnZlYzIubGVuKHZlY18xLnZlYzIuc3ViKGIsIGxpbmUuc3RhcnQpKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0QSAtIGRpc3RCO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgPyBpbnRlcnNlY3Rpb25Qb2ludHMgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyBhIHJlY3RhbmdsZVxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShsaW5lLCByZWN0YW5nbGUpIHtcbiAgICAvLyBFZGdlIGNhc2U6IHplcm8tc2l6ZSByZWN0YW5nbGVcbiAgICBpZiAoKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKHJlY3RhbmdsZS5zaXplKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEdldCB2ZXJ0aWNlcyBvZiB0aGUgcmVjdGFuZ2xlIGluIGNsb2Nrd2lzZSBvcmRlclxuICAgIGNvbnN0IHZlcnRpY2VzID0gcmVjdGFuZ2xlVmVydGljZXMocmVjdGFuZ2xlKTtcbiAgICAvLyBJZiBib3RoIGVuZHBvaW50cyBhcmUgaW5zaWRlLCBsaW5lIGlzIGNvbXBsZXRlbHkgY29udGFpbmVkXG4gICAgaWYgKHBvaW50SW5SZWN0YW5nbGUobGluZS5zdGFydCwgcmVjdGFuZ2xlKS5pbnRlcnNlY3RzICYmXG4gICAgICAgIHBvaW50SW5SZWN0YW5nbGUobGluZS5lbmQsIHJlY3RhbmdsZSkuaW50ZXJzZWN0cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIENoZWNrIGVhY2ggZWRnZSBvZiB0aGUgcmVjdGFuZ2xlIGZvciBpbnRlcnNlY3Rpb25cbiAgICBjb25zdCBlZGdlcyA9IHZlcnRpY2VzVG9FZGdlcyh2ZXJ0aWNlcyk7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGxpbmVJbnRlcnNlY3RzTGluZShsaW5lLCBlZGdlKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3RzICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGludGVyc2VjdGlvbiBwb2ludHMgYW5kIHNvcnQgYnkgZGlzdGFuY2UgdG8gbGluZSBzdGFydFxuICAgIGludGVyc2VjdGlvblBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGludGVyc2VjdGlvblBvaW50cyk7XG4gICAgaWYgKGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXN0QSA9IHZlY18xLnZlYzIubGVuKHZlY18xLnZlYzIuc3ViKGEsIGxpbmUuc3RhcnQpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RCID0gdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIoYiwgbGluZS5zdGFydCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3RBIC0gZGlzdEI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCA/IGludGVyc2VjdGlvblBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIHRoZSBlZGdlcyBvZiBhIGNvbnZleCBwb2x5Z29uXG4gKlxuICogV2UgYXNzdW1lIHRoZSBwb2x5Z29uIGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZCBmb3IgdmFsaWRpdHkgYW5kIGNvbnZleGl0eVxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c1ZhbGlkQ29udmV4UG9seWdvbkVkZ2VzKGxpbmUsIHBvbHlnb24sIGVkZ2VzKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsaW5lIHNlZ21lbnQgaXMgZW50aXJlbHkgaW5zaWRlIHBvbHlnb25cbiAgICBjb25zdCBtaWRwb2ludCA9IHtcbiAgICAgICAgeDogKGxpbmUuc3RhcnQueCArIGxpbmUuZW5kLngpIC8gMixcbiAgICAgICAgeTogKGxpbmUuc3RhcnQueSArIGxpbmUuZW5kLnkpIC8gMixcbiAgICB9O1xuICAgIGNvbnN0IHBvaW50SW5zaWRlID0gcG9pbnRJblBvbHlnb24obWlkcG9pbnQsIHBvbHlnb24pO1xuICAgIGNvbnN0IHN0YXJ0SW5zaWRlID0gcG9pbnRJblBvbHlnb24obGluZS5zdGFydCwgcG9seWdvbik7XG4gICAgY29uc3QgZW5kSW5zaWRlID0gcG9pbnRJblBvbHlnb24obGluZS5lbmQsIHBvbHlnb24pO1xuICAgIGlmICgocG9pbnRJbnNpZGUgPT09IG51bGwgfHwgcG9pbnRJbnNpZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvaW50SW5zaWRlLmludGVyc2VjdHMpICYmXG4gICAgICAgIChzdGFydEluc2lkZSA9PT0gbnVsbCB8fCBzdGFydEluc2lkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhcnRJbnNpZGUuaW50ZXJzZWN0cykgJiZcbiAgICAgICAgKGVuZEluc2lkZSA9PT0gbnVsbCB8fCBlbmRJbnNpZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVuZEluc2lkZS5pbnRlcnNlY3RzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIENoZWNrIGVhY2ggb3V0ZXIgZWRnZSBmb3IgaW50ZXJzZWN0aW9uc1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBsaW5lSW50ZXJzZWN0c0xpbmUobGluZSwgZWRnZSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24uaW50ZXJzZWN0cyAmJiBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGFuZCBzb3J0IGJ5IGRpc3RhbmNlIHRvIGxpbmUgc3RhcnRcbiAgICBpbnRlcnNlY3Rpb25Qb2ludHMgPSByZW1vdmVEdXBsaWNhdGVWZXJ0aWNlcyhpbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgIGlmIChpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlzdEEgPSB2ZWNfMS52ZWMyLmxlbih2ZWNfMS52ZWMyLnN1YihhLCBsaW5lLnN0YXJ0KSk7XG4gICAgICAgICAgICBjb25zdCBkaXN0QiA9IHZlY18xLnZlYzIubGVuKHZlY18xLnZlYzIuc3ViKGIsIGxpbmUuc3RhcnQpKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0QSAtIGRpc3RCO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgPyBpbnRlcnNlY3Rpb25Qb2ludHMgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyBhIHBvbHlnb25cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlIHBvbHlnb24gaXMgaW52YWxpZFxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c1BvbHlnb24obGluZSwgcG9seWdvbikge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBwb2x5Z29uIGlzIHZhbGlkXG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gSWYgcG9seWdvbiBpcyBub3QgY29udmV4LCBkZWNvbXBvc2UgaXQgaW50byBjb252ZXggcG9seWdvbnNcbiAgICBpZiAoIXBvbHlnb25Jc0NvbnZleChwb2x5Z29uKSkge1xuICAgICAgICBjb25zdCBjb252ZXhQb2x5Z29ucyA9IGRlY29tcG9zZVBvbHlnb24ocG9seWdvbik7XG4gICAgICAgIGlmICghY29udmV4UG9seWdvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoZSBsaW5lIGFnYWluc3QgdGhlIG91dGVyIGVkZ2VzIG9mIGVhY2ggY29udmV4IHBvbHlnb25cbiAgICAgICAgcmV0dXJuIGxpbmVJbnRlcnNlY3RzVmFsaWRDb252ZXhQb2x5Z29uRWRnZXMobGluZSwgcG9seWdvbiwgZmluZE91dGVyRWRnZXMoY29udmV4UG9seWdvbnMpKTtcbiAgICB9XG4gICAgLy8gRm9yIGNvbnZleCBwb2x5Z29ucywgY2hlY2sgZWFjaCBlZGdlXG4gICAgcmV0dXJuIGxpbmVJbnRlcnNlY3RzVmFsaWRDb252ZXhQb2x5Z29uRWRnZXMobGluZSwgcG9seWdvbiwgdmVydGljZXNUb0VkZ2VzKHBvbHlnb24udmVydGljZXMpKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIGNpcmNsZXMgaW50ZXJzZWN0XG4gKi9cbmZ1bmN0aW9uIGNpcmNsZUludGVyc2VjdHNDaXJjbGUoY2lyY2xlQSwgY2lyY2xlQikge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgdmVjdG9yIGZyb20gY2VudGVyIEEgdG8gY2VudGVyIEJcbiAgICBjb25zdCBjZW50ZXJUb0NlbnRlclZlYyA9IHZlY18xLnZlYzIuc3ViKGNpcmNsZUIucG9zaXRpb24sIGNpcmNsZUEucG9zaXRpb24pO1xuICAgIGNvbnN0IGNlbnRlclRvQ2VudGVyID0gdmVjXzEudmVjMi5sZW4oY2VudGVyVG9DZW50ZXJWZWMpO1xuICAgIGNvbnN0IHN1bVJhZGlpID0gY2lyY2xlQS5yYWRpdXMgKyBjaXJjbGVCLnJhZGl1cztcbiAgICAvLyBJZiBkaXN0YW5jZSBiZXR3ZWVuIGNlbnRlcnMgaXMgZ3JlYXRlciB0aGFuIHN1bSBvZiByYWRpaSwgdGhlIGNpcmNsZXNcbiAgICAvLyBkb24ndCBpbnRlcnNlY3RcbiAgICBpZiAoY2VudGVyVG9DZW50ZXIgPiBzdW1SYWRpaSArIGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIElmIGNpcmNsZXMgYXJlIGlkZW50aWNhbCAoc2FtZSBwb3NpdGlvbiBhbmQgcmFkaXVzKSwgdGhleSBoYXZlIGluZmluaXRlbHlcbiAgICAvLyBtYW55IGludGVyc2VjdGlvbiBwb2ludHNcbiAgICBpZiAoY2VudGVyVG9DZW50ZXIgPCBjb25zdGFudHMuRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhjaXJjbGVBLnJhZGl1cyAtIGNpcmNsZUIucmFkaXVzKSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgbWluaW11bVNlcGFyYXRpb246IHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIudXgoKSwgMiAqIGNpcmNsZUEucmFkaXVzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgb25lIGNpcmNsZSBpcyBpbnNpZGUgdGhlIG90aGVyIChubyBpbnRlcnNlY3Rpb24gcG9pbnRzIGJ1dCBzdGlsbFxuICAgIC8vIGludGVyc2VjdGluZylcbiAgICBjb25zdCByYWRpdXNEaWZmID0gTWF0aC5hYnMoY2lyY2xlQS5yYWRpdXMgLSBjaXJjbGVCLnJhZGl1cyk7XG4gICAgaWYgKGNlbnRlclRvQ2VudGVyIDwgcmFkaXVzRGlmZiAtIGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgbWluaW11bVNlcGFyYXRpb246IHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIubm9yKGNlbnRlclRvQ2VudGVyVmVjKSwgY2lyY2xlQS5yYWRpdXMgLSBjZW50ZXJUb0NlbnRlciArIGNpcmNsZUIucmFkaXVzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBwb2ludHMgZm9yIHN0YW5kYXJkIGludGVyc2VjdGluZyBjYXNlXG4gICAgLy8gaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9DaXJjbGUtQ2lyY2xlSW50ZXJzZWN0aW9uLmh0bWxcbiAgICBjb25zdCBhID0gKGNpcmNsZUEucmFkaXVzICogY2lyY2xlQS5yYWRpdXMgLVxuICAgICAgICBjaXJjbGVCLnJhZGl1cyAqIGNpcmNsZUIucmFkaXVzICtcbiAgICAgICAgY2VudGVyVG9DZW50ZXIgKiBjZW50ZXJUb0NlbnRlcikgL1xuICAgICAgICAoMiAqIGNlbnRlclRvQ2VudGVyKTtcbiAgICBjb25zdCBoID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGNpcmNsZUEucmFkaXVzICogY2lyY2xlQS5yYWRpdXMgLSBhICogYSkpO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9pbnQgb24gdGhlIGxpbmUgYmV0d2VlbiBjZW50ZXJzIHRoYXQgaXMgZGlzdGFuY2UgJ2EnIGZyb21cbiAgICAvLyBjaXJjbGUgQSdzIGNlbnRlclxuICAgIGNvbnN0IHAgPSB2ZWNfMS52ZWMyLmFkZChjaXJjbGVBLnBvc2l0aW9uLCB2ZWNfMS52ZWMyLm11bCh2ZWNfMS52ZWMyLm5vcihjZW50ZXJUb0NlbnRlclZlYyksIGEpKTtcbiAgICAvLyBJZiBjaXJjbGVzIGFyZSB0YW5nZW50ICh0b3VjaGluZyBhdCBvbmUgcG9pbnQpXG4gICAgaWYgKE1hdGguYWJzKGNlbnRlclRvQ2VudGVyIC0gc3VtUmFkaWkpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IFtwXSxcbiAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9uOiAoMCwgdmVjXzEudmVjMikoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwZXJwZW5kaWN1bGFyIHZlY3RvciB0byBnZXQgYm90aCBpbnRlcnNlY3Rpb24gcG9pbnRzXG4gICAgY29uc3QgcGVycFZlYyA9IHZlY18xLnZlYzIubXVsKCgwLCB2ZWNfMS52ZWMyKSh7IHg6IC1jZW50ZXJUb0NlbnRlclZlYy55LCB5OiBjZW50ZXJUb0NlbnRlclZlYy54IH0pLCBoIC8gY2VudGVyVG9DZW50ZXIpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFt2ZWNfMS52ZWMyLmFkZChwLCBwZXJwVmVjKSwgdmVjXzEudmVjMi5zdWIocCwgcGVycFZlYyldO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBzZXBhcmF0aW9uIHZlY3RvclxuICAgIGNvbnN0IG1pbmltdW1TZXBhcmF0aW9uID0gdmVjXzEudmVjMi5tdWwodmVjXzEudmVjMi5ub3IoY2VudGVyVG9DZW50ZXJWZWMpLCBzdW1SYWRpaSAtIGNlbnRlclRvQ2VudGVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMsXG4gICAgICAgIG1pbmltdW1TZXBhcmF0aW9uLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY2lyY2xlIGludGVyc2VjdHMgYSByZWN0YW5nbGVcbiAqL1xuZnVuY3Rpb24gY2lyY2xlSW50ZXJzZWN0c1JlY3RhbmdsZShjaXJjbGUsIHJlY3RhbmdsZSkge1xuICAgIC8vIEdldCByZWN0YW5nbGUgdmVydGljZXMgc28gd2UgY2FuIHRlc3QgYWdhaW5zdCByb3RhdGVkIHJlY3RhbmdsZXNcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHJlY3RhbmdsZVZlcnRpY2VzKHJlY3RhbmdsZSk7XG4gICAgY29uc3QgZWRnZXMgPSB2ZXJ0aWNlc1RvRWRnZXModmVydGljZXMpO1xuICAgIC8vIENoZWNrIGlmIGNpcmNsZSdzIGNlbnRlciBpcyBpbnNpZGUgcmVjdGFuZ2xlXG4gICAgY29uc3QgcG9pbnRJblJlY3RSZXN1bHQgPSBwb2ludEluUmVjdGFuZ2xlKGNpcmNsZS5wb3NpdGlvbiwgcmVjdGFuZ2xlKTtcbiAgICBjb25zdCBjaXJjbGVDZW50ZXJJbnNpZGVSZWN0YW5nbGUgPSBwb2ludEluUmVjdFJlc3VsdC5pbnRlcnNlY3RzO1xuICAgIC8vIENoZWNrIGlmIHJlY3RhbmdsZSdzIGNlbnRlciBpcyBpbnNpZGUgY2lyY2xlXG4gICAgY29uc3QgcG9pbnRJbkNpcmNsZVJlc3VsdCA9IHBvaW50SW5DaXJjbGUocmVjdGFuZ2xlLnBvc2l0aW9uLCBjaXJjbGUpO1xuICAgIGNvbnN0IHJlY3RhbmdsZUNlbnRlckluc2lkZUNpcmNsZSA9IHBvaW50SW5DaXJjbGVSZXN1bHQuaW50ZXJzZWN0cztcbiAgICAvLyBDaGVjayBjaXJjbGUgaW50ZXJzZWN0aW9uIHdpdGggcmVjdGFuZ2xlIGVkZ2VzXG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGxpbmVJbnRlcnNlY3RzQ2lyY2xlKGVkZ2UsIGNpcmNsZSk7XG4gICAgICAgIGlmIChyZXN1bHQuaW50ZXJzZWN0cyAmJiByZXN1bHQuaW50ZXJzZWN0aW9uUG9pbnRzKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaCguLi5yZXN1bHQuaW50ZXJzZWN0aW9uUG9pbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gc2VwYXJhdGlvbiB2ZWN0b3JcbiAgICBsZXQgbWluaW11bVNlcGFyYXRpb247XG4gICAgaWYgKE1hdGguYWJzKHBvaW50SW5SZWN0UmVzdWx0LmRpc3RhbmNlKSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIG1pbmltdW1TZXBhcmF0aW9uID0gKDAsIHZlY18xLnZlYzIpKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBvaW50SW5SZWN0UmVzdWx0LmRpc3RhbmNlIDwgMCkge1xuICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbiA9IHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIubm9yKHZlY18xLnZlYzIuc3ViKHBvaW50SW5SZWN0UmVzdWx0LmNsb3Nlc3RQb2ludCwgY2lyY2xlLnBvc2l0aW9uKSksIGNpcmNsZS5yYWRpdXMgKyBNYXRoLmFicyhwb2ludEluUmVjdFJlc3VsdC5kaXN0YW5jZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWluaW11bVNlcGFyYXRpb24gPSB2ZWNfMS52ZWMyLm11bCh2ZWNfMS52ZWMyLm5vcih2ZWNfMS52ZWMyLnN1YihjaXJjbGUucG9zaXRpb24sIHBvaW50SW5SZWN0UmVzdWx0LmNsb3Nlc3RQb2ludCkpLCBjaXJjbGUucmFkaXVzIC0gcG9pbnRJblJlY3RSZXN1bHQuZGlzdGFuY2UpO1xuICAgIH1cbiAgICAvLyBJZiBlaXRoZXIgc2hhcGUncyBjZW50ZXIgaXMgaW5zaWRlIHRoZSBvdGhlciBhbmQgdGhlcmUgYXJlIG5vIGludGVyc2VjdGlvblxuICAgIC8vIHBvaW50cywgaXQgbWVhbnMgb25lIG9mIHRoZSBzaGFwZXMgY29tcGxldGVseSBlbmNsb3NlcyB0aGUgb3RoZXJcbiAgICBpZiAoKGNpcmNsZUNlbnRlckluc2lkZVJlY3RhbmdsZSB8fCByZWN0YW5nbGVDZW50ZXJJbnNpZGVDaXJjbGUpICYmXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzXG4gICAgY29uc3QgdW5pcXVlUG9pbnRzID0gcmVtb3ZlRHVwbGljYXRlVmVydGljZXMoaW50ZXJzZWN0aW9uUG9pbnRzKTtcbiAgICBpZiAodW5pcXVlUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IHVuaXF1ZVBvaW50cyxcbiAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGNpcmNsZSBpbnRlcnNlY3RzIHRoZSBlZGdlcyBvZiBhIGNvbnZleCBwb2x5Z29uXG4gKlxuICogV2UgYXNzdW1lIHRoZSBwb2x5Z29uIGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZCBmb3IgdmFsaWRpdHkgYW5kIGNvbnZleGl0eVxuICovXG5mdW5jdGlvbiBjaXJjbGVJbnRlcnNlY3RzVmFsaWRDb252ZXhQb2x5Z29uRWRnZXMoY2lyY2xlLCBlZGdlcywgY2lyY2xlQ2VudGVySW5zaWRlUG9seWdvbiwgcG9seWdvbkNlbnRlckluc2lkZUNpcmNsZSkge1xuICAgIGxldCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICAvLyBDaGVjayBlYWNoIG91dGVyIGVkZ2UgZm9yIGludGVyc2VjdGlvbnMgd2l0aCB0aGUgY2lyY2xlXG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGxpbmVJbnRlcnNlY3RzQ2lyY2xlKGVkZ2UsIGNpcmNsZSk7XG4gICAgICAgIGlmIChyZXN1bHQuaW50ZXJzZWN0cyAmJiByZXN1bHQuaW50ZXJzZWN0aW9uUG9pbnRzKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaCguLi5yZXN1bHQuaW50ZXJzZWN0aW9uUG9pbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBlaXRoZXIgc2hhcGUncyBjZW50ZXIgaXMgaW5zaWRlIHRoZSBvdGhlciBhbmQgdGhlcmUgYXJlIG5vXG4gICAgLy8gaW50ZXJzZWN0aW9uIHBvaW50cywgb25lIHNoYXBlIGNvbXBsZXRlbHkgZW5jbG9zZXMgdGhlIG90aGVyXG4gICAgaWYgKChjaXJjbGVDZW50ZXJJbnNpZGVQb2x5Z29uIHx8IHBvbHlnb25DZW50ZXJJbnNpZGVDaXJjbGUpICYmXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogdHJ1ZSB9O1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGludGVyc2VjdGlvbiBwb2ludHNcbiAgICBpbnRlcnNlY3Rpb25Qb2ludHMgPSByZW1vdmVEdXBsaWNhdGVWZXJ0aWNlcyhpbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY2lyY2xlIGludGVyc2VjdHMgYSBwb2x5Z29uXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBwb2x5Z29uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gY2lyY2xlSW50ZXJzZWN0c1BvbHlnb24oY2lyY2xlLCBwb2x5Z29uLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHBvbHlnb24gaXMgdmFsaWRcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBNQVhfSVRFUkFUSU9OUyA9IDEwO1xuICAgIGNvbnN0IGZpbmRNaW5pbXVtU2VwYXJhdGlvbiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5maW5kTWluaW11bVNlcGFyYXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIC8vIENoZWNrIGlmIGNpcmNsZSdzIGNlbnRlciBpcyBpbnNpZGUgcG9seWdvblxuICAgIGNvbnN0IHBvaW50SW5Qb2x5Z29uUmVzdWx0ID0gcG9pbnRJblBvbHlnb24oY2lyY2xlLnBvc2l0aW9uLCBwb2x5Z29uKTtcbiAgICBjb25zdCBjaXJjbGVDZW50ZXJJbnNpZGVQb2x5Z29uID0gKF9iID0gcG9pbnRJblBvbHlnb25SZXN1bHQgPT09IG51bGwgfHwgcG9pbnRJblBvbHlnb25SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvaW50SW5Qb2x5Z29uUmVzdWx0LmludGVyc2VjdHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgIC8vIElmIHBvbHlnb24gaXMgbm90IGNvbnZleCwgZGVjb21wb3NlIGl0IGludG8gY29udmV4IHBvbHlnb25zXG4gICAgaWYgKCFwb2x5Z29uSXNDb252ZXgocG9seWdvbikpIHtcbiAgICAgICAgY29uc3QgY29udmV4UG9seWdvbnMgPSBkZWNvbXBvc2VQb2x5Z29uKHBvbHlnb24pO1xuICAgICAgICBpZiAoIWNvbnZleFBvbHlnb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgYSBjb25jYXZlIHBvbHlnb24sIHRoZSBjZW50cm9pZCBtaWdodCBiZSBvdXRzaWRlIG9mIHRoZSBwb2x5Z29uLCBzb1xuICAgICAgICAvLyBpbiBvcmRlciB0byBjaGVjayBpZiB0aGUgcG9seWdvbiBpcyBlbnRpcmVseSBpbnNpZGUgdGhlIGNpcmNsZSwgd2UgbmVlZFxuICAgICAgICAvLyB0byBjaGVjayBpZiBhbGwgc3ViLXBvbHlnb24gY2VudHJvaWRzIGFyZSBpbnNpZGUgdGhlIGNpcmNsZVxuICAgICAgICBjb25zdCBwb2x5Z29uQ2VudGVySW5zaWRlQ2lyY2xlID0gY29udmV4UG9seWdvbnMuZXZlcnkoY29udmV4UG9seWdvbiA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBjZW50cm9pZCA9IHBvbHlnb25DZW50cm9pZChjb252ZXhQb2x5Z29uKTtcbiAgICAgICAgICAgIGlmICghY2VudHJvaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEludmFsaWQgY2VudHJvaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBwb2ludEluQ2lyY2xlKGNlbnRyb2lkLCBjaXJjbGUpLmludGVyc2VjdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmluZCBvdXRlciBlZGdlcyBmcm9tIHRoZSBkZWNvbXBvc2VkIHBvbHlnb25zXG4gICAgICAgIGNvbnN0IG91dGVyRWRnZXMgPSBmaW5kT3V0ZXJFZGdlcyhjb252ZXhQb2x5Z29ucyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNpcmNsZUludGVyc2VjdHNWYWxpZENvbnZleFBvbHlnb25FZGdlcyhjaXJjbGUsIG91dGVyRWRnZXMsIGNpcmNsZUNlbnRlckluc2lkZVBvbHlnb24sIHBvbHlnb25DZW50ZXJJbnNpZGVDaXJjbGUpO1xuICAgICAgICBpZiAocmVzdWx0LmludGVyc2VjdHMgJiYgZmluZE1pbmltdW1TZXBhcmF0aW9uKSB7XG4gICAgICAgICAgICBsZXQgaXRlcmF0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1NlcGFyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTZXBhcmF0aW9uID0gKDAsIHZlY18xLnZlYzIpKCk7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNlcGFyYXRpb25JbnRlcnNlY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIGlmIHdlIHN0aWxsIGhhdmVuJ3QgZm91bmQgYSBzZXBhcmF0aW9uIHRoYXQgZG9lc24ndFxuICAgICAgICAgICAgLy8gaW50ZXJzZWN0XG4gICAgICAgICAgICBjdXJyZW50U2VwYXJhdGlvbkludGVyc2VjdHMgJiZcbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpZiB3ZSdyZSBzdGlsbCBjb252ZXJnaW5nIChpLmUuIGlmIHdlIGRpZG4ndCBtYWtlIGFueVxuICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzIGluIHRoZSBsYXN0IGl0ZXJhdGlvbiB0aGVuIHdlIGNhbiBzdG9wKVxuICAgICAgICAgICAgICAgIChwcmV2aW91c1NlcGFyYXRpb24gPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgISgwLCB1dGlsaXRpZXNfMS52ZWN0b3JzQWxtb3N0RXF1YWwpKHByZXZpb3VzU2VwYXJhdGlvbiwgY3VycmVudFNlcGFyYXRpb24pKSAmJlxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHVudGlsIHdlIHJlYWNoIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zXG4gICAgICAgICAgICAgICAgKytpdGVyYXRpb24gPCBNQVhfSVRFUkFUSU9OUykge1xuICAgICAgICAgICAgICAgIGxldCBtaW5pbXVtU2VwYXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgY2lyY2xlUG9zaXRpb24gPSB2ZWNfMS52ZWMyLmFkZChjaXJjbGUucG9zaXRpb24sIGN1cnJlbnRTZXBhcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIG1pbmltdW0gc2VwYXJhdGlvbiB2ZWN0b3JzIGZvciBlYWNoIGNvbnZleCBzdWItcG9seWdvblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udmV4UG9seWdvbiBvZiBjb252ZXhQb2x5Z29ucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludEluQ29udmV4UG9seWdvblJlc3VsdCA9IHBvaW50SW5Qb2x5Z29uKGNpcmNsZVBvc2l0aW9uLCBjb252ZXhQb2x5Z29uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2ludEluQ29udmV4UG9seWdvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbmltdW1TZXBhcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocG9pbnRJbkNvbnZleFBvbHlnb25SZXN1bHQuZGlzdGFuY2UpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9uID0gKDAsIHZlY18xLnZlYzIpKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9pbnRJbkNvbnZleFBvbHlnb25SZXN1bHQuZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbiA9IHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIubm9yKHZlY18xLnZlYzIuc3ViKHBvaW50SW5Db252ZXhQb2x5Z29uUmVzdWx0LmNsb3Nlc3RQb2ludCwgY2lyY2xlUG9zaXRpb24pKSwgY2lyY2xlLnJhZGl1cyArIE1hdGguYWJzKHBvaW50SW5Db252ZXhQb2x5Z29uUmVzdWx0LmRpc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbiA9IHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIubm9yKHZlY18xLnZlYzIuc3ViKGNpcmNsZVBvc2l0aW9uLCBwb2ludEluQ29udmV4UG9seWdvblJlc3VsdC5jbG9zZXN0UG9pbnQpKSwgY2lyY2xlLnJhZGl1cyAtIHBvaW50SW5Db252ZXhQb2x5Z29uUmVzdWx0LmRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uOiBtaW5pbXVtU2VwYXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBNYXRoLmFicyhwb2ludEluQ29udmV4UG9seWdvblJlc3VsdC5kaXN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTb3J0IG1pbmltdW0gc2VwYXJhdGlvbnMgYnkgcGVuZXRyYXRpb24gZGlzdGFuY2VcbiAgICAgICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbnMgPSBtaW5pbXVtU2VwYXJhdGlvbnMuc29ydCgoYSwgYikgPT4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2VwYXJhdGlvbiA9IHZlY18xLnZlYzIuY3B5KGN1cnJlbnRTZXBhcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VwYXJhdGlvbiA9IHZlY18xLnZlYzIuYWRkKGN1cnJlbnRTZXBhcmF0aW9uLCAoKF9jID0gbWluaW11bVNlcGFyYXRpb25zWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2VwYXJhdGlvbikgfHwgKDAsIHZlY18xLnZlYzIpKCkpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHNlcGFyYXRpb24gc3RpbGwgaW50ZXJzZWN0c1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXBhcmF0aW9uSW50ZXJzZWN0cyA9XG4gICAgICAgICAgICAgICAgICAgIChfZSA9IChfZCA9IGNpcmNsZUludGVyc2VjdHNQb2x5Z29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNpcmNsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWNfMS52ZWMyLmFkZChjaXJjbGUucG9zaXRpb24sIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgc21hbGwgYnVmZmVyIHRvIGF2b2lkIG51bWVyaWNhbC9wcmVjaXNpb24gaXNzdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWNfMS52ZWMyLm11bChjdXJyZW50U2VwYXJhdGlvbiwgMS4wMSkpLFxuICAgICAgICAgICAgICAgICAgICB9LCBwb2x5Z29uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmVjdXJzZSB0byBhdm9pZCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluZE1pbmltdW1TZXBhcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pbnRlcnNlY3RzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9uOiBjdXJyZW50U2VwYXJhdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgcG9seWdvbidzIGNlbnRyb2lkIGlzIGluc2lkZSBjaXJjbGVcbiAgICAvLyBGb3IgYSBjb252ZXggcG9seWdvbiwgdGhlIGNlbnRyb2lkIGlzIGFsd2F5cyBpbnNpZGUgdGhlIHBvbHlnb25cbiAgICBjb25zdCBwb2x5Z29uQ2VudGVyID0gcG9seWdvbkNlbnRyb2lkKHBvbHlnb24pO1xuICAgIGNvbnN0IHBvaW50SW5DaXJjbGVSZXN1bHQgPSBwb2ludEluQ2lyY2xlKHBvbHlnb25DZW50ZXIsIGNpcmNsZSk7XG4gICAgY29uc3QgcG9seWdvbkNlbnRlckluc2lkZUNpcmNsZSA9IChfZiA9IHBvaW50SW5DaXJjbGVSZXN1bHQuaW50ZXJzZWN0cykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2U7XG4gICAgLy8gRm9yIGNvbnZleCBwb2x5Z29ucywgY2hlY2sgZWFjaCBlZGdlIGRpcmVjdGx5XG4gICAgY29uc3QgZWRnZXMgPSB2ZXJ0aWNlc1RvRWRnZXMocG9seWdvbi52ZXJ0aWNlcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gY2lyY2xlSW50ZXJzZWN0c1ZhbGlkQ29udmV4UG9seWdvbkVkZ2VzKGNpcmNsZSwgZWRnZXMsIGNpcmNsZUNlbnRlckluc2lkZVBvbHlnb24sIHBvbHlnb25DZW50ZXJJbnNpZGVDaXJjbGUpO1xuICAgIGlmIChyZXN1bHQuaW50ZXJzZWN0cyAmJiBmaW5kTWluaW11bVNlcGFyYXRpb24pIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIHNlcGFyYXRpb24gdmVjdG9yXG4gICAgICAgIGxldCBtaW5pbXVtU2VwYXJhdGlvbjtcbiAgICAgICAgaWYgKE1hdGguYWJzKHBvaW50SW5Qb2x5Z29uUmVzdWx0LmRpc3RhbmNlKSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvaW50SW5Qb2x5Z29uUmVzdWx0LmRpc3RhbmNlIDwgMCkge1xuICAgICAgICAgICAgbWluaW11bVNlcGFyYXRpb24gPSB2ZWNfMS52ZWMyLm11bCh2ZWNfMS52ZWMyLm5vcih2ZWNfMS52ZWMyLnN1Yihwb2ludEluUG9seWdvblJlc3VsdC5jbG9zZXN0UG9pbnQsIGNpcmNsZS5wb3NpdGlvbikpLCBjaXJjbGUucmFkaXVzICsgTWF0aC5hYnMocG9pbnRJblBvbHlnb25SZXN1bHQuZGlzdGFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9uID0gdmVjXzEudmVjMi5tdWwodmVjXzEudmVjMi5ub3IodmVjXzEudmVjMi5zdWIoY2lyY2xlLnBvc2l0aW9uLCBwb2ludEluUG9seWdvblJlc3VsdC5jbG9zZXN0UG9pbnQpKSwgY2lyY2xlLnJhZGl1cyAtIHBvaW50SW5Qb2x5Z29uUmVzdWx0LmRpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgbWluaW11bVNlcGFyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFByb2plY3QgdmVydGljZXMgb250byBhbiBheGlzIGFuZCByZXR1cm4gdGhlIG1pbi9tYXggdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHByb2plY3RWZXJ0aWNlc1RvQXhpcyh2ZXJ0aWNlcywgYXhpcykge1xuICAgIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAoY29uc3QgdmVydGV4IG9mIHZlcnRpY2VzKSB7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB2ZWNfMS52ZWMyLmRvdCh2ZXJ0ZXgsIGF4aXMpO1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHByb2plY3Rpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4geyBtaW4sIG1heCB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiB0d28gcmVjdGFuZ2xlcyBpbnRlcnNlY3RcbiAqL1xuZnVuY3Rpb24gcmVjdGFuZ2xlSW50ZXJzZWN0c1JlY3RhbmdsZShyZWN0YW5nbGVBLCByZWN0YW5nbGVCKSB7XG4gICAgLy8gRWRnZSBjYXNlOiBpZiBlaXRoZXIgcmVjdGFuZ2xlIGhhcyB6ZXJvIHNpemUsIHRoZXkgY2Fubm90IGludGVyc2VjdFxuICAgIGlmICgoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykocmVjdGFuZ2xlQS5zaXplKSB8fCAoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykocmVjdGFuZ2xlQi5zaXplKSkge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBHZXQgdmVydGljZXMgb2YgYm90aCByZWN0YW5nbGVzXG4gICAgY29uc3QgdmVydGljZXNBID0gcmVjdGFuZ2xlVmVydGljZXMocmVjdGFuZ2xlQSk7XG4gICAgY29uc3QgdmVydGljZXNCID0gcmVjdGFuZ2xlVmVydGljZXMocmVjdGFuZ2xlQik7XG4gICAgLy8gR2V0IGVkZ2VzIG9mIGJvdGggcmVjdGFuZ2xlc1xuICAgIGNvbnN0IGVkZ2VzQSA9IHZlcnRpY2VzVG9FZGdlcyh2ZXJ0aWNlc0EpO1xuICAgIGNvbnN0IGVkZ2VzQiA9IHZlcnRpY2VzVG9FZGdlcyh2ZXJ0aWNlc0IpO1xuICAgIC8vIEdldCBzZXBhcmF0aW5nIGF4ZXMgYnkgY2FsY3VsYXRpbmcgdGhlIG5vcm1hbHMgb2YgZWFjaCBlZGdlXG4gICAgY29uc3QgYXhlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBbLi4uZWRnZXNBLCAuLi5lZGdlc0JdKSB7XG4gICAgICAgIGNvbnN0IGVkZ2VWZWMgPSB2ZWNfMS52ZWMyLnN1YihlZGdlLmVuZCwgZWRnZS5zdGFydCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IHZlY18xLnZlYzIubm9yKHZlY18xLnZlYzIucm90ZihlZGdlVmVjLCAtMSkpO1xuICAgICAgICAvLyBPbmx5IGFkZCB1bmlxdWUgYXhlc1xuICAgICAgICBpZiAoIWF4ZXMuc29tZShheGlzID0+IE1hdGguYWJzKHZlY18xLnZlYzIuZG90KGF4aXMsIG5vcm1hbCkpID4gMSAtIGNvbnN0YW50cy5FUFNJTE9OKSkge1xuICAgICAgICAgICAgYXhlcy5wdXNoKG5vcm1hbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJhY2sgbWluaW11bSBwZW5ldHJhdGlvbiBmb3Igc2VwYXJhdGlvbiB2ZWN0b3JcbiAgICBsZXQgbWluUGVuZXRyYXRpb24gPSBJbmZpbml0eTtcbiAgICBsZXQgbWluQXhpcyA9ICgwLCB2ZWNfMS52ZWMyKSgpO1xuICAgIC8vIFRlc3QgZWFjaCBheGlzXG4gICAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICAgICAgLy8gUHJvamVjdCBib3RoIHJlY3RhbmdsZXMgb250byB0aGUgYXhpc1xuICAgICAgICBjb25zdCBwcm9qZWN0aW9uQSA9IHByb2plY3RWZXJ0aWNlc1RvQXhpcyh2ZXJ0aWNlc0EsIGF4aXMpO1xuICAgICAgICBjb25zdCBwcm9qZWN0aW9uQiA9IHByb2plY3RWZXJ0aWNlc1RvQXhpcyh2ZXJ0aWNlc0IsIGF4aXMpO1xuICAgICAgICAvLyBJZiB3ZSBmaW5kIGEgc2VwYXJhdGluZyBheGlzLCB0aGUgcmVjdGFuZ2xlcyBkb24ndCBpbnRlcnNlY3RcbiAgICAgICAgaWYgKHByb2plY3Rpb25BLm1heCA8IHByb2plY3Rpb25CLm1pbiB8fFxuICAgICAgICAgICAgcHJvamVjdGlvbkIubWF4IDwgcHJvamVjdGlvbkEubWluKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBwZW5ldHJhdGlvbiBkZXB0aFxuICAgICAgICBjb25zdCBvdmVybGFwID0gTWF0aC5taW4ocHJvamVjdGlvbkEubWF4IC0gcHJvamVjdGlvbkIubWluLCBwcm9qZWN0aW9uQi5tYXggLSBwcm9qZWN0aW9uQS5taW4pO1xuICAgICAgICAvLyBUcmFjayBtaW5pbXVtIHBlbmV0cmF0aW9uIGFuZCBpdHMgYXhpc1xuICAgICAgICBpZiAob3ZlcmxhcCA8IG1pblBlbmV0cmF0aW9uKSB7XG4gICAgICAgICAgICBtaW5QZW5ldHJhdGlvbiA9IG92ZXJsYXA7XG4gICAgICAgICAgICBtaW5BeGlzID0gYXhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIGludGVyc2VjdGlvbiBwb2ludHMgYnkgY2hlY2tpbmcgZWFjaCBlZGdlIG9mIHJlY3RhbmdsZSBBIGFnYWluc3QgZWFjaFxuICAgIC8vIGVkZ2Ugb2YgcmVjdGFuZ2xlIEJcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2VBIG9mIGVkZ2VzQSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVkZ2VCIG9mIGVkZ2VzQikge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdHNMaW5lKGVkZ2VBLCBlZGdlQik7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLmludGVyc2VjdHMgJiYgaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGludGVyc2VjdGlvbiBwb2ludHNcbiAgICBjb25zdCB1bmlxdWVQb2ludHMgPSByZW1vdmVEdXBsaWNhdGVWZXJ0aWNlcyhpbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBzZXBhcmF0aW9uIHZlY3RvclxuICAgIGNvbnN0IGNlbnRlckEgPSByZWN0YW5nbGVBLnBvc2l0aW9uO1xuICAgIGNvbnN0IGNlbnRlckIgPSByZWN0YW5nbGVCLnBvc2l0aW9uO1xuICAgIGNvbnN0IGNlbnRlclRvQ2VudGVyID0gdmVjXzEudmVjMi5zdWIoY2VudGVyQiwgY2VudGVyQSk7XG4gICAgLy8gSWYgdGhlIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGZsaXAgdGhlIGF4aXNcbiAgICBpZiAodmVjXzEudmVjMi5kb3QobWluQXhpcywgY2VudGVyVG9DZW50ZXIpIDwgMCkge1xuICAgICAgICBtaW5BeGlzID0gdmVjXzEudmVjMi5tdWwobWluQXhpcywgLTEpO1xuICAgIH1cbiAgICAvLyBUaGUgbWluaW11bSBzZXBhcmF0aW9uIHZlY3RvciBpcyB0aGUgYXhpcyBzY2FsZWQgYnkgdGhlIHBlbmV0cmF0aW9uIGRlcHRoXG4gICAgY29uc3QgbWluaW11bVNlcGFyYXRpb24gPSB2ZWNfMS52ZWMyLm11bChtaW5BeGlzLCBtaW5QZW5ldHJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiB1bmlxdWVQb2ludHMubGVuZ3RoID4gMCA/IHVuaXF1ZVBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWluaW11bVNlcGFyYXRpb24sXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSByZWN0YW5nbGUgaW50ZXJzZWN0cyBhIHBvbHlnb25cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlIHBvbHlnb24gaXMgaW52YWxpZFxuICovXG5mdW5jdGlvbiByZWN0YW5nbGVJbnRlcnNlY3RzUG9seWdvbihyZWN0YW5nbGUsIHBvbHlnb24pIHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgcG9seWdvbiBpcyB2YWxpZFxuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEVkZ2UgY2FzZTogaWYgdGhlIHJlY3RhbmdsZSBoYXMgemVybyBzaXplLCB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb25cbiAgICBpZiAoKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKHJlY3RhbmdsZS5zaXplKSkge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHJlY3RhbmdsZSB0byBwb2x5Z29uXG4gICAgY29uc3QgcmVjdFZlcnRpY2VzID0gcmVjdGFuZ2xlVmVydGljZXMocmVjdGFuZ2xlKTtcbiAgICBjb25zdCByZWN0UG9seWdvbiA9IHtcbiAgICAgICAgdmVydGljZXM6IHJlY3RWZXJ0aWNlcyxcbiAgICB9O1xuICAgIC8vIFVzZSBwb2x5Z29uIGludGVyc2VjdGlvbiBhbGdvcml0aG1cbiAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdHNQb2x5Z29uKHJlY3RQb2x5Z29uLCBwb2x5Z29uKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHBvbHlnb25zIGludGVyc2VjdFxuICpcbiAqIFJldHVybnMgbnVsbCBpZiBlaXRoZXIgcG9seWdvbiBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25JbnRlcnNlY3RzUG9seWdvbihwb2x5Z29uQSwgcG9seWdvbkIpIHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiBib3RoIHBvbHlnb25zIGFyZSB2YWxpZFxuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbkEpIHx8ICFwb2x5Z29uSXNWYWxpZChwb2x5Z29uQikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIERlY29tcG9zZSBwb2x5Z29uIEEgaWYgaXQncyBjb25jYXZlXG4gICAgbGV0IGNvbnZleFBvbHlnb25zQSA9IFtdO1xuICAgIGlmICghcG9seWdvbklzQ29udmV4KHBvbHlnb25BKSkge1xuICAgICAgICBjb25zdCBkZWNvbXBvc2VkQSA9IGRlY29tcG9zZVBvbHlnb24ocG9seWdvbkEpO1xuICAgICAgICBpZiAoIWRlY29tcG9zZWRBKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb252ZXhQb2x5Z29uc0EgPSBkZWNvbXBvc2VkQTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnZleFBvbHlnb25zQSA9IFtwb2x5Z29uQV07XG4gICAgfVxuICAgIC8vIERlY29tcG9zZSBwb2x5Z29uIEIgaWYgaXQncyBjb25jYXZlXG4gICAgbGV0IGNvbnZleFBvbHlnb25zQiA9IFtdO1xuICAgIGlmICghcG9seWdvbklzQ29udmV4KHBvbHlnb25CKSkge1xuICAgICAgICBjb25zdCBkZWNvbXBvc2VkQiA9IGRlY29tcG9zZVBvbHlnb24ocG9seWdvbkIpO1xuICAgICAgICBpZiAoIWRlY29tcG9zZWRCKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb252ZXhQb2x5Z29uc0IgPSBkZWNvbXBvc2VkQjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnZleFBvbHlnb25zQiA9IFtwb2x5Z29uQl07XG4gICAgfVxuICAgIC8vIEdldCB0aGUgb3V0ZXIgZWRnZXMgb2YgdGhlIGRlY29tcG9zZWQgcG9seWdvbnNcbiAgICBjb25zdCBvdXRlckVkZ2VzQSA9IGZpbmRPdXRlckVkZ2VzKGNvbnZleFBvbHlnb25zQSk7XG4gICAgY29uc3Qgb3V0ZXJFZGdlc0IgPSBmaW5kT3V0ZXJFZGdlcyhjb252ZXhQb2x5Z29uc0IpO1xuICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIHBvaW50cyBiZXR3ZWVuIG91dGVyIGVkZ2VzIG9ubHlcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2VBIG9mIG91dGVyRWRnZXNBKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWRnZUIgb2Ygb3V0ZXJFZGdlc0IpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGxpbmVJbnRlcnNlY3RzTGluZShlZGdlQSwgZWRnZUIpO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3RzICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgb25lIHBvbHlnb24gaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgb3RoZXJcbiAgICAvLyBBIHBvbHlnb24gaXMgY29udGFpbmVkIHdpdGhpbiBhbm90aGVyIGlmIHRoZSBjZW50cm9pZHMgb2YgYWxsIGl0c1xuICAgIC8vIGNvbnZleCBzdWItcG9seWdvbnMgYXJlIGluc2lkZSB0aGUgb3RoZXIgcG9seWdvblxuICAgIGlmIChpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHBvbHlnb25BQ2VudHJvaWRzID0gY29udmV4UG9seWdvbnNBXG4gICAgICAgICAgICAubWFwKHBvbHlnb25DZW50cm9pZClcbiAgICAgICAgICAgIC5maWx0ZXIoY2VudHJvaWQgPT4gISFjZW50cm9pZCk7XG4gICAgICAgIGlmIChwb2x5Z29uQUNlbnRyb2lkcy5ldmVyeShjZW50cm9pZCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHBvaW50SW5Qb2x5Z29uKGNlbnRyb2lkLCBwb2x5Z29uQikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnRlcnNlY3RzOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvbHlnb25CQ2VudHJvaWRzID0gY29udmV4UG9seWdvbnNCXG4gICAgICAgICAgICAubWFwKHBvbHlnb25DZW50cm9pZClcbiAgICAgICAgICAgIC5maWx0ZXIoY2VudHJvaWQgPT4gISFjZW50cm9pZCk7XG4gICAgICAgIGlmIChwb2x5Z29uQkNlbnRyb2lkcy5ldmVyeShjZW50cm9pZCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHBvaW50SW5Qb2x5Z29uKGNlbnRyb2lkLCBwb2x5Z29uQSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnRlcnNlY3RzOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGUgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgIGNvbnN0IHVuaXF1ZVBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGludGVyc2VjdGlvblBvaW50cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogdW5pcXVlUG9pbnRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogdW5pcXVlUG9pbnRzLmxlbmd0aCA+IDAgPyB1bmlxdWVQb2ludHMgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy8yZC90eXBlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy8yZC90eXBlcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5pc1BvaW50ID0gaXNQb2ludDtcbmV4cG9ydHMuaXNSYXkgPSBpc1JheTtcbmV4cG9ydHMuaXNMaW5lID0gaXNMaW5lO1xuZXhwb3J0cy5pc0NpcmNsZSA9IGlzQ2lyY2xlO1xuZXhwb3J0cy5pc0FBQkIgPSBpc0FBQkI7XG5leHBvcnRzLmlzUmVjdGFuZ2xlID0gaXNSZWN0YW5nbGU7XG5leHBvcnRzLmlzUG9seWdvbiA9IGlzUG9seWdvbjtcbmNvbnN0IHR5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsaXRpZXMvdHlwZXMgKi8gXCIuL3NyYy91dGlsaXRpZXMvdHlwZXMudHNcIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIFBvaW50XG4gKi9cbmZ1bmN0aW9uIGlzUG9pbnQodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHR5cGVzXzEuaXNWZWMyKSh2YWx1ZSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBSYXlcbiAqL1xuZnVuY3Rpb24gaXNSYXkodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ29yaWdpbicgaW4gdmFsdWUgJiZcbiAgICAgICAgaXNQb2ludCh2YWx1ZS5vcmlnaW4pICYmXG4gICAgICAgICdkaXJlY3Rpb24nIGluIHZhbHVlICYmXG4gICAgICAgICgwLCB0eXBlc18xLmlzVmVjMikodmFsdWUuZGlyZWN0aW9uKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBMaW5lXG4gKi9cbmZ1bmN0aW9uIGlzTGluZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnc3RhcnQnIGluIHZhbHVlICYmXG4gICAgICAgIGlzUG9pbnQodmFsdWUuc3RhcnQpICYmXG4gICAgICAgICdlbmQnIGluIHZhbHVlICYmXG4gICAgICAgIGlzUG9pbnQodmFsdWUuZW5kKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBDaXJjbGVcbiAqL1xuZnVuY3Rpb24gaXNDaXJjbGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3Bvc2l0aW9uJyBpbiB2YWx1ZSAmJlxuICAgICAgICBpc1BvaW50KHZhbHVlLnBvc2l0aW9uKSAmJlxuICAgICAgICAncmFkaXVzJyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUucmFkaXVzID09PSAnbnVtYmVyJyk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gQUFCQlxuICovXG5mdW5jdGlvbiBpc0FBQkIodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3Bvc2l0aW9uJyBpbiB2YWx1ZSAmJlxuICAgICAgICBpc1BvaW50KHZhbHVlLnBvc2l0aW9uKSAmJlxuICAgICAgICAnc2l6ZScgaW4gdmFsdWUgJiZcbiAgICAgICAgKDAsIHR5cGVzXzEuaXNWZWMyKSh2YWx1ZS5zaXplKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBSZWN0YW5nbGVcbiAqL1xuZnVuY3Rpb24gaXNSZWN0YW5nbGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3Bvc2l0aW9uJyBpbiB2YWx1ZSAmJlxuICAgICAgICBpc1BvaW50KHZhbHVlLnBvc2l0aW9uKSAmJlxuICAgICAgICAnc2l6ZScgaW4gdmFsdWUgJiZcbiAgICAgICAgKDAsIHR5cGVzXzEuaXNWZWMyKSh2YWx1ZS5zaXplKSAmJlxuICAgICAgICAoJ3JvdGF0aW9uJyBpbiB2YWx1ZSA/IHR5cGVvZiB2YWx1ZS5yb3RhdGlvbiA9PT0gJ251bWJlcicgOiB0cnVlKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBQb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIGlzUG9seWdvbih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndmVydGljZXMnIGluIHZhbHVlICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUudmVydGljZXMpICYmXG4gICAgICAgIHZhbHVlLnZlcnRpY2VzLmV2ZXJ5KGlzUG9pbnQpKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy8zZC9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy8zZC9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmFuZ2xlID0gYW5nbGU7XG5leHBvcnRzLmFuZ2xlQmV0d2VlbiA9IGFuZ2xlQmV0d2VlbjtcbmV4cG9ydHMucG9pbnRzQXJlQ29sbGluZWFyID0gcG9pbnRzQXJlQ29sbGluZWFyO1xuZXhwb3J0cy5saW5lVG9SYXkgPSBsaW5lVG9SYXk7XG5leHBvcnRzLnJheVRvTGluZSA9IHJheVRvTGluZTtcbmV4cG9ydHMuYWFiYiA9IGFhYmI7XG5leHBvcnRzLmFhYmJUb0N1Ym9pZCA9IGFhYmJUb0N1Ym9pZDtcbmV4cG9ydHMuYWFiYnNPdmVybGFwID0gYWFiYnNPdmVybGFwO1xuZXhwb3J0cy5wb2ludEluQUFCQiA9IHBvaW50SW5BQUJCO1xuZXhwb3J0cy5jdWJvaWRJc1JvdGF0ZWQgPSBjdWJvaWRJc1JvdGF0ZWQ7XG5leHBvcnRzLmN1Ym9pZFZlcnRpY2VzID0gY3Vib2lkVmVydGljZXM7XG5leHBvcnRzLmN1Ym9pZFRvUG9seWdvbnMgPSBjdWJvaWRUb1BvbHlnb25zO1xuZXhwb3J0cy52ZXJ0aWNlc1RvRWRnZXMgPSB2ZXJ0aWNlc1RvRWRnZXM7XG5leHBvcnRzLnBvbHlnb25Jc1ZhbGlkID0gcG9seWdvbklzVmFsaWQ7XG5leHBvcnRzLnBvbHlnb25XaW5kaW5nT3JkZXIgPSBwb2x5Z29uV2luZGluZ09yZGVyO1xuZXhwb3J0cy5wb2x5Z29uQXJlYSA9IHBvbHlnb25BcmVhO1xuZXhwb3J0cy5wb2x5Z29uQ2VudHJvaWQgPSBwb2x5Z29uQ2VudHJvaWQ7XG5leHBvcnRzLnBvbHlnb25Ub1BsYW5lID0gcG9seWdvblRvUGxhbmU7XG5leHBvcnRzLnBvbHlnb25zVG9NZXNoID0gcG9seWdvbnNUb01lc2g7XG5leHBvcnRzLm1lc2hUb1BvbHlnb25zID0gbWVzaFRvUG9seWdvbnM7XG5leHBvcnRzLm1lc2hUb0VkZ2VzID0gbWVzaFRvRWRnZXM7XG5leHBvcnRzLm1lc2hDZW50cm9pZCA9IG1lc2hDZW50cm9pZDtcbmV4cG9ydHMubWVzaElzV2F0ZXJ0aWdodCA9IG1lc2hJc1dhdGVydGlnaHQ7XG5leHBvcnRzLnBvaW50T25SYXkgPSBwb2ludE9uUmF5O1xuZXhwb3J0cy5wb2ludE9uTGluZSA9IHBvaW50T25MaW5lO1xuZXhwb3J0cy5wb2ludEluU3BoZXJlID0gcG9pbnRJblNwaGVyZTtcbmV4cG9ydHMucG9pbnRJbkN1Ym9pZCA9IHBvaW50SW5DdWJvaWQ7XG5leHBvcnRzLnBvaW50T25Qb2x5Z29uID0gcG9pbnRPblBvbHlnb247XG5leHBvcnRzLnJheVRyYXZlcnNlR3JpZCA9IHJheVRyYXZlcnNlR3JpZDtcbmV4cG9ydHMucmF5SW50ZXJzZWN0c1JheSA9IHJheUludGVyc2VjdHNSYXk7XG5leHBvcnRzLnJheUludGVyc2VjdHNMaW5lID0gcmF5SW50ZXJzZWN0c0xpbmU7XG5leHBvcnRzLnJheUludGVyc2VjdHNTcGhlcmUgPSByYXlJbnRlcnNlY3RzU3BoZXJlO1xuZXhwb3J0cy5yYXlJbnRlcnNlY3RzUGxhbmUgPSByYXlJbnRlcnNlY3RzUGxhbmU7XG5leHBvcnRzLnJheUludGVyc2VjdHNDdWJvaWQgPSByYXlJbnRlcnNlY3RzQ3Vib2lkO1xuZXhwb3J0cy5yYXlJbnRlcnNlY3RzUG9seWdvbiA9IHJheUludGVyc2VjdHNQb2x5Z29uO1xuZXhwb3J0cy5yYXlJbnRlcnNlY3RzTWVzaCA9IHJheUludGVyc2VjdHNNZXNoO1xuZXhwb3J0cy5saW5lSW50ZXJzZWN0c1JheSA9IGxpbmVJbnRlcnNlY3RzUmF5O1xuZXhwb3J0cy5saW5lSW50ZXJzZWN0c0xpbmUgPSBsaW5lSW50ZXJzZWN0c0xpbmU7XG5leHBvcnRzLmxpbmVJbnRlcnNlY3RzU3BoZXJlID0gbGluZUludGVyc2VjdHNTcGhlcmU7XG5leHBvcnRzLmxpbmVJbnRlcnNlY3RzUGxhbmUgPSBsaW5lSW50ZXJzZWN0c1BsYW5lO1xuZXhwb3J0cy5saW5lSW50ZXJzZWN0c0N1Ym9pZCA9IGxpbmVJbnRlcnNlY3RzQ3Vib2lkO1xuZXhwb3J0cy5saW5lSW50ZXJzZWN0c1BvbHlnb24gPSBsaW5lSW50ZXJzZWN0c1BvbHlnb247XG5leHBvcnRzLmxpbmVJbnRlcnNlY3RzTWVzaCA9IGxpbmVJbnRlcnNlY3RzTWVzaDtcbmV4cG9ydHMuc3BoZXJlSW50ZXJzZWN0c1NwaGVyZSA9IHNwaGVyZUludGVyc2VjdHNTcGhlcmU7XG5leHBvcnRzLnNwaGVyZUludGVyc2VjdHNQbGFuZSA9IHNwaGVyZUludGVyc2VjdHNQbGFuZTtcbmV4cG9ydHMuc3BoZXJlSW50ZXJzZWN0c0N1Ym9pZCA9IHNwaGVyZUludGVyc2VjdHNDdWJvaWQ7XG5leHBvcnRzLnNwaGVyZUludGVyc2VjdHNQb2x5Z29uID0gc3BoZXJlSW50ZXJzZWN0c1BvbHlnb247XG5leHBvcnRzLnNwaGVyZUludGVyc2VjdHNNZXNoID0gc3BoZXJlSW50ZXJzZWN0c01lc2g7XG5leHBvcnRzLnBsYW5lSW50ZXJzZWN0c1BsYW5lID0gcGxhbmVJbnRlcnNlY3RzUGxhbmU7XG5leHBvcnRzLnBsYW5lSW50ZXJzZWN0c01lc2ggPSBwbGFuZUludGVyc2VjdHNNZXNoO1xuZXhwb3J0cy5jdWJvaWRJbnRlcnNlY3RzQ3Vib2lkID0gY3Vib2lkSW50ZXJzZWN0c0N1Ym9pZDtcbmV4cG9ydHMuY3Vib2lkSW50ZXJzZWN0c1BsYW5lID0gY3Vib2lkSW50ZXJzZWN0c1BsYW5lO1xuZXhwb3J0cy5jdWJvaWRJbnRlcnNlY3RzUG9seWdvbiA9IGN1Ym9pZEludGVyc2VjdHNQb2x5Z29uO1xuZXhwb3J0cy5jdWJvaWRJbnRlcnNlY3RzTWVzaCA9IGN1Ym9pZEludGVyc2VjdHNNZXNoO1xuZXhwb3J0cy5wb2x5Z29uSW50ZXJzZWN0c1BvbHlnb24gPSBwb2x5Z29uSW50ZXJzZWN0c1BvbHlnb247XG5leHBvcnRzLnBvbHlnb25JbnRlcnNlY3RzUGxhbmUgPSBwb2x5Z29uSW50ZXJzZWN0c1BsYW5lO1xuZXhwb3J0cy5wb2x5Z29uSW50ZXJzZWN0c01lc2ggPSBwb2x5Z29uSW50ZXJzZWN0c01lc2g7XG5leHBvcnRzLm1lc2hJbnRlcnNlY3RzTWVzaCA9IG1lc2hJbnRlcnNlY3RzTWVzaDtcbmV4cG9ydHMubWVzaEludGVyc2VjdHNQbGFuZSA9IG1lc2hJbnRlcnNlY3RzUGxhbmU7XG5jb25zdCB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1wiKTtcbmNvbnN0IHZlY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdmVjICovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiKTtcbmNvbnN0IHV0aWxpdGllc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbGl0aWVzICovIFwiLi9zcmMvdXRpbGl0aWVzL2luZGV4LnRzXCIpO1xuY29uc3QgY29uc3RhbnRzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxpdGllcy9jb25zdGFudHMgKi8gXCIuL3NyYy91dGlsaXRpZXMvY29uc3RhbnRzLnRzXCIpKTtcbmNvbnN0IHR5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVzICovIFwiLi9zcmMvM2QvdHlwZXMudHNcIik7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlcyAqLyBcIi4vc3JjLzNkL3R5cGVzLnRzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogQ29udGVudHNcbiAqXG4gKiBVdGlsaXRpZXNcbiAqIEBzZWUgZGlzdGFuY2VcbiAqIEBzZWUgYW5nbGVcbiAqIEBzZWUgYW5nbGVCZXR3ZWVuXG4gKiBAc2VlIHBvaW50c0FyZUNvbGxpbmVhclxuICpcbiAqIExpbmUgYW5kIHJheSB1dGlsaXRpZXNcbiAqIEBzZWUgbGluZVRvUmF5XG4gKiBAc2VlIHJheVRvTGluZVxuICpcbiAqIEFBQkJzXG4gKiBAc2VlIGFhYmJcbiAqIEBzZWUgYWFiYlRvQ3Vib2lkXG4gKiBAc2VlIGFhYmJzT3ZlcmxhcFxuICogQHNlZSBwb2ludEluQUFCQlxuICpcbiAqIEN1Ym9pZCB1dGlsaXRpZXNcbiAqIEBzZWUgY3Vib2lkSXNSb3RhdGVkXG4gKiBAc2VlIGN1Ym9pZFZlcnRpY2VzXG4gKiBAc2VlIGN1Ym9pZFRvUG9seWdvbnNcbiAqXG4gKiBQb2x5Z29uIHV0aWxpdGllc1xuICogQHNlZSB2ZXJ0aWNlc1RvRWRnZXNcbiAqIEBzZWUgcG9seWdvbklzVmFsaWRcbiAqIEBzZWUgcG9seWdvbldpbmRpbmdPcmRlclxuICogQHNlZSBwb2x5Z29uQXJlYVxuICogQHNlZSBwb2x5Z29uQ2VudHJvaWRcbiAqIEBzZWUgcG9seWdvblRvUGxhbmVcbiAqXG4gKiBNZXNoIHV0aWxpdGllc1xuICogQHNlZSBwb2x5Z29uc1RvTWVzaFxuICogQHNlZSBtZXNoVG9Qb2x5Z29uc1xuICogQHNlZSBtZXNoVG9FZGdlc1xuICogQHNlZSBtZXNoQ2VudHJvaWRcbiAqIEBzZWUgbWVzaElzV2F0ZXJ0aWdodFxuICpcbiAqIFBvaW50c1xuICogQHNlZSBwb2ludE9uUmF5XG4gKiBAc2VlIHBvaW50T25MaW5lXG4gKiBAc2VlIHBvaW50SW5TcGhlcmVcbiAqIEBzZWUgcG9pbnRJbkN1Ym9pZFxuICogQHNlZSBwb2ludE9uUG9seWdvblxuICpcbiAqIFJheXNcbiAqIEBzZWUgcmF5VHJhdmVyc2VHcmlkXG4gKiBAc2VlIHJheUludGVyc2VjdHNSYXlcbiAqIEBzZWUgcmF5SW50ZXJzZWN0c0xpbmVcbiAqIEBzZWUgcmF5SW50ZXJzZWN0c1NwaGVyZVxuICogQHNlZSByYXlJbnRlcnNlY3RzUGxhbmVcbiAqIEBzZWUgcmF5SW50ZXJzZWN0c0N1Ym9pZFxuICogQHNlZSByYXlJbnRlcnNlY3RzUG9seWdvblxuICogQHNlZSByYXlJbnRlcnNlY3RzTWVzaFxuICpcbiAqIExpbmVzXG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzUmF5XG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzTGluZVxuICogQHNlZSBsaW5lSW50ZXJzZWN0c1NwaGVyZVxuICogQHNlZSBsaW5lSW50ZXJzZWN0c1BsYW5lXG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzQ3Vib2lkXG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzUG9seWdvblxuICogQHNlZSBsaW5lSW50ZXJzZWN0c01lc2hcbiAqXG4gKiBTcGhlcmVzXG4gKiBAc2VlIHNwaGVyZUludGVyc2VjdHNTcGhlcmVcbiAqIEBzZWUgc3BoZXJlSW50ZXJzZWN0c1BsYW5lXG4gKiBAc2VlIHNwaGVyZUludGVyc2VjdHNDdWJvaWRcbiAqIEBzZWUgc3BoZXJlSW50ZXJzZWN0c1BvbHlnb25cbiAqIEBzZWUgc3BoZXJlSW50ZXJzZWN0c01lc2hcbiAqXG4gKiBQbGFuZXNcbiAqIEBzZWUgcGxhbmVJbnRlcnNlY3RzUGxhbmVcbiAqIEBzZWUgcGxhbmVJbnRlcnNlY3RzTWVzaFxuICpcbiAqIEN1Ym9pZHNcbiAqIEBzZWUgY3Vib2lkSW50ZXJzZWN0c0N1Ym9pZFxuICogQHNlZSBjdWJvaWRJbnRlcnNlY3RzUGxhbmVcbiAqIEBzZWUgY3Vib2lkSW50ZXJzZWN0c1BvbHlnb25cbiAqIEBzZWUgY3Vib2lkSW50ZXJzZWN0c01lc2hcbiAqXG4gKiBQb2x5Z29uc1xuICogQHNlZSBwb2x5Z29uSW50ZXJzZWN0c1BvbHlnb25cbiAqIEBzZWUgcG9seWdvbkludGVyc2VjdHNQbGFuZVxuICogQHNlZSBwb2x5Z29uSW50ZXJzZWN0c01lc2hcbiAqXG4gKiBNZXNoZXNcbiAqIEBzZWUgbWVzaEludGVyc2VjdHNNZXNoXG4gKiBAc2VlIG1lc2hJbnRlcnNlY3RzUGxhbmVcbiAqL1xuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBpbiAzRCBzcGFjZVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIHZlY18xLnZlYzMubGVuKHZlY18xLnZlYzMuc3ViKGEsIGIpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBFdWxlciBhbmdsZSBmcm9tIHBvaW50IGEgdG8gcG9pbnQgYlxuICovXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgaWYgKCgwLCB1dGlsaXRpZXNfMS52ZWN0b3JzQWxtb3N0RXF1YWwpKGEsIGIpKSB7XG4gICAgICAgIHJldHVybiAoMCwgdmVjXzEudmVjMykoKTtcbiAgICB9XG4gICAgbGV0IHRoZXRhWCA9IHZlY18xLnZlYzMucmFkeCh2ZWNfMS52ZWMzLnN1YihiLCBhKSkgJSAoMiAqIE1hdGguUEkpO1xuICAgIGlmICh0aGV0YVggPCAwKSB7XG4gICAgICAgIHRoZXRhWCArPSAyICogTWF0aC5QSTsgLy8gRW5zdXJlIGFuZ2xlIGlzIHBvc2l0aXZlXG4gICAgfVxuICAgIGxldCB0aGV0YVkgPSB2ZWNfMS52ZWMzLnJhZHkodmVjXzEudmVjMy5zdWIoYiwgYSkpICUgKDIgKiBNYXRoLlBJKTtcbiAgICBpZiAodGhldGFZIDwgMCkge1xuICAgICAgICB0aGV0YVkgKz0gMiAqIE1hdGguUEk7IC8vIEVuc3VyZSBhbmdsZSBpcyBwb3NpdGl2ZVxuICAgIH1cbiAgICBsZXQgdGhldGFaID0gdmVjXzEudmVjMy5yYWR6KHZlY18xLnZlYzMuc3ViKGIsIGEpKSAlICgyICogTWF0aC5QSSk7XG4gICAgaWYgKHRoZXRhWiA8IDApIHtcbiAgICAgICAgdGhldGFaICs9IDIgKiBNYXRoLlBJOyAvLyBFbnN1cmUgYW5nbGUgaXMgcG9zaXRpdmVcbiAgICB9XG4gICAgcmV0dXJuICgwLCB2ZWNfMS52ZWMzKSh0aGV0YVgsIHRoZXRhWSwgdGhldGFaKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBsaW5lcyBvciByYXlzXG4gKlxuICogUmV0dXJucyAwIGlmIGVpdGhlciBsaW5lIGlzIHplcm8tbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGFuZ2xlQmV0d2VlbihhLCBiKSB7XG4gICAgbGV0IGFMaW5lID0gKDAsIHR5cGVzXzEuaXNSYXkpKGEpID8gcmF5VG9MaW5lKGEsIDEpIDogYTtcbiAgICBsZXQgYkxpbmUgPSAoMCwgdHlwZXNfMS5pc1JheSkoYikgPyByYXlUb0xpbmUoYiwgMSkgOiBiO1xuICAgIGlmICgoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykodmVjXzEudmVjMy5zdWIoYUxpbmUuc3RhcnQsIGFMaW5lLmVuZCkpIHx8XG4gICAgICAgICgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKSh2ZWNfMS52ZWMzLnN1YihiTGluZS5zdGFydCwgYkxpbmUuZW5kKSkpIHtcbiAgICAgICAgcmV0dXJuIDA7IC8vIFplcm8tbGVuZ3RoIGxpbmVcbiAgICB9XG4gICAgY29uc3QgZGlyQSA9IHZlY18xLnZlYzMubm9yKHZlY18xLnZlYzMuc3ViKGFMaW5lLmVuZCwgYUxpbmUuc3RhcnQpKTtcbiAgICBjb25zdCBkaXJCID0gdmVjXzEudmVjMy5ub3IodmVjXzEudmVjMy5zdWIoYkxpbmUuZW5kLCBiTGluZS5zdGFydCkpO1xuICAgIC8vIENsYW1wIGRvdCBwcm9kdWN0IHRvIFstMSwgMV0gdG8gYXZvaWQgTmFOIGR1ZSB0byBmbG9hdGluZy1wb2ludCBlcnJvcnNcbiAgICBjb25zdCBkb3QgPSAoMCwgdXRpbHNfMS5jbGFtcCkodmVjXzEudmVjMy5kb3QoZGlyQSwgZGlyQiksIC0xLCAxKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYWNvcyhkb3QpO1xuICAgIHJldHVybiBhbmdsZSA8IDAgPyBhbmdsZSArIDIgKiBNYXRoLlBJIDogYW5nbGU7IC8vIEVuc3VyZSBhbmdsZSBpcyBwb3NpdGl2ZVxufVxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgaW4gM0Qgc3BhY2UgYXJlIGNvbGxpbmVhclxuICovXG5mdW5jdGlvbiBwb2ludHNBcmVDb2xsaW5lYXIoYSwgYiwgYykge1xuICAgIC8vIENyZWF0ZSB0d28gdmVjdG9ycyBmcm9tIHRoZSBwb2ludHM6XG4gICAgLy8gdjEgPSBiIC0gYVxuICAgIC8vIHYyID0gYyAtIGFcbiAgICBjb25zdCB2MSA9IHZlY18xLnZlYzMuc3ViKGIsIGEpO1xuICAgIGNvbnN0IHYyID0gdmVjXzEudmVjMy5zdWIoYywgYSk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSB0d28gdmVjdG9yc1xuICAgIGNvbnN0IGNyb3NzID0gdmVjXzEudmVjMy5jcm9zcyh2MSwgdjIpO1xuICAgIC8vIElmIHRoZSBjcm9zcyBwcm9kdWN0IGlzIHplcm8gKG9yIHZlcnkgY2xvc2UgdG8gemVybyksXG4gICAgLy8gdGhlIHBvaW50cyBhcmUgY29sbGluZWFyXG4gICAgcmV0dXJuIHZlY18xLnZlYzMubGVuKGNyb3NzKSA8IGNvbnN0YW50cy5FUFNJTE9OO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgbGluZSBzZWdtZW50IHRvIGEgcmF5XG4gKi9cbmZ1bmN0aW9uIGxpbmVUb1JheShsaW5lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luOiBsaW5lLnN0YXJ0LFxuICAgICAgICBkaXJlY3Rpb246IHZlY18xLnZlYzMubm9yKHZlY18xLnZlYzMuc3ViKGxpbmUuZW5kLCBsaW5lLnN0YXJ0KSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIHJheSB0byBhIGxpbmUgc2VnbWVudFxuICovXG5mdW5jdGlvbiByYXlUb0xpbmUocmF5LCBsZW5ndGggPSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHJheS5vcmlnaW4sXG4gICAgICAgIGVuZDogdmVjXzEudmVjMy5hZGQocmF5Lm9yaWdpbiwgdmVjXzEudmVjMy5tdWwocmF5LmRpcmVjdGlvbiwgbGVuZ3RoKSksXG4gICAgfTtcbn1cbi8qKlxuICogR2V0IHRoZSBib3VuZGluZyBib3ggKEFBQkIpIG9mIGEgZ2VvbWV0cmljIG9iamVjdFxuICovXG5mdW5jdGlvbiBhYWJiKG8pIHtcbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNMaW5lKShvKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb246ICgwLCB2ZWNfMS52ZWMzKShNYXRoLm1pbihvLnN0YXJ0LngsIG8uZW5kLnkpLCBNYXRoLm1pbihvLnN0YXJ0LnksIG8uZW5kLnkpLCBNYXRoLm1pbihvLnN0YXJ0LnosIG8uZW5kLnopKSxcbiAgICAgICAgICAgIHNpemU6ICgwLCB2ZWNfMS52ZWMzKShNYXRoLmFicyhvLnN0YXJ0LnggLSBvLmVuZC54KSwgTWF0aC5hYnMoby5zdGFydC55IC0gby5lbmQueSksIE1hdGguYWJzKG8uc3RhcnQueiAtIG8uZW5kLnopKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzU3BoZXJlKShvKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb246IG8ucG9zaXRpb24sXG4gICAgICAgICAgICBzaXplOiAoMCwgdmVjXzEudmVjMykoby5yYWRpdXMgKiAyKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzQ3Vib2lkKShvKSkge1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGN1Ym9pZFZlcnRpY2VzKG8pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMzKShNYXRoLm1pbiguLi52ZXJ0aWNlcy5tYXAodiA9PiB2LngpKSwgTWF0aC5taW4oLi4udmVydGljZXMubWFwKHYgPT4gdi55KSksIE1hdGgubWluKC4uLnZlcnRpY2VzLm1hcCh2ID0+IHYueikpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgc2l6ZTogKDAsIHZlY18xLnZlYzMpKE1hdGgubWF4KC4uLnZlcnRpY2VzLm1hcCh2ID0+IHYueCkpIC0gcG9zaXRpb24ueCwgTWF0aC5tYXgoLi4udmVydGljZXMubWFwKHYgPT4gdi55KSkgLSBwb3NpdGlvbi55LCBNYXRoLm1heCguLi52ZXJ0aWNlcy5tYXAodiA9PiB2LnopKSAtIHBvc2l0aW9uLnopLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNNZXNoKShvKSB8fCAoMCwgdHlwZXNfMS5pc1BvbHlnb24pKG8pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIHZlY18xLnZlYzMpKE1hdGgubWluKC4uLm8udmVydGljZXMubWFwKHYgPT4gdi54KSksIE1hdGgubWluKC4uLm8udmVydGljZXMubWFwKHYgPT4gdi55KSksIE1hdGgubWluKC4uLm8udmVydGljZXMubWFwKHYgPT4gdi56KSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBzaXplOiAoMCwgdmVjXzEudmVjMykoTWF0aC5tYXgoLi4uby52ZXJ0aWNlcy5tYXAodiA9PiB2LngpKSAtIHBvc2l0aW9uLngsIE1hdGgubWF4KC4uLm8udmVydGljZXMubWFwKHYgPT4gdi55KSkgLSBwb3NpdGlvbi55LCBNYXRoLm1heCguLi5vLnZlcnRpY2VzLm1hcCh2ID0+IHYueikpIC0gcG9zaXRpb24ueiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIEFBQkIgdG8gYSBjdWJvaWRcbiAqL1xuZnVuY3Rpb24gYWFiYlRvQ3Vib2lkKGFhYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogdmVjXzEudmVjMy5hZGQoYWFiYi5wb3NpdGlvbiwgdmVjXzEudmVjMy5kaXYoYWFiYi5zaXplLCAyKSksXG4gICAgICAgIHNpemU6IGFhYmIuc2l6ZSxcbiAgICAgICAgcm90YXRpb246ICgwLCB2ZWNfMS52ZWMzKSgwLCAwLCAwKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiB0d28gQUFCQnMgb3ZlcmxhcCBhbmQgcmV0dXJuIHRoZSBvdmVybGFwcGluZyB2b2x1bWUgaWYgdGhleSBkb1xuICovXG5mdW5jdGlvbiBhYWJic092ZXJsYXAoYSwgYikge1xuICAgIGNvbnN0IG92ZXJsYXBYID0gKDAsIHV0aWxpdGllc18xLm92ZXJsYXBJbnRlcnZhbCkoeyBtaW46IGEucG9zaXRpb24ueCwgbWF4OiBhLnBvc2l0aW9uLnggKyBhLnNpemUueCB9LCB7IG1pbjogYi5wb3NpdGlvbi54LCBtYXg6IGIucG9zaXRpb24ueCArIGIuc2l6ZS54IH0pO1xuICAgIGNvbnN0IG92ZXJsYXBZID0gKDAsIHV0aWxpdGllc18xLm92ZXJsYXBJbnRlcnZhbCkoeyBtaW46IGEucG9zaXRpb24ueSwgbWF4OiBhLnBvc2l0aW9uLnkgKyBhLnNpemUueSB9LCB7IG1pbjogYi5wb3NpdGlvbi55LCBtYXg6IGIucG9zaXRpb24ueSArIGIuc2l6ZS55IH0pO1xuICAgIGNvbnN0IG92ZXJsYXBaID0gKDAsIHV0aWxpdGllc18xLm92ZXJsYXBJbnRlcnZhbCkoeyBtaW46IGEucG9zaXRpb24ueiwgbWF4OiBhLnBvc2l0aW9uLnogKyBhLnNpemUueiB9LCB7IG1pbjogYi5wb3NpdGlvbi56LCBtYXg6IGIucG9zaXRpb24ueiArIGIuc2l6ZS56IH0pO1xuICAgIC8vIElmIHRoZSBBQUJCcyBkb24ndCBvdmVybGFwIG9uIG9uZSBvciBtb3JlIGF4ZXMsIHRoZXkgZG9uJ3Qgb3ZlcmxhcCBhdCBhbGxcbiAgICBpZiAoIW92ZXJsYXBYIHx8ICFvdmVybGFwWSB8fCAhb3ZlcmxhcFopIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgb3ZlcmxhcDoge1xuICAgICAgICAgICAgcG9zaXRpb246ICgwLCB2ZWNfMS52ZWMzKShvdmVybGFwWC5taW4sIG92ZXJsYXBZLm1pbiwgb3ZlcmxhcFoubWluKSxcbiAgICAgICAgICAgIHNpemU6ICgwLCB2ZWNfMS52ZWMzKShvdmVybGFwWC5tYXggLSBvdmVybGFwWC5taW4sIG92ZXJsYXBZLm1heCAtIG92ZXJsYXBZLm1pbiwgb3ZlcmxhcFoubWF4IC0gb3ZlcmxhcFoubWluKSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGlzIGluc2lkZSBhbiBBQUJCXG4gKlxuICogVGhpcyBzaG91bGQgYmUgYSBiaXQgZmFzdGVyIHRoYW4gcG9pbnRJblJlY3RhbmdsZSBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvXG4gKiB3b3JyeSBhYm91dCByb3RhdGlvblxuICovXG5mdW5jdGlvbiBwb2ludEluQUFCQihwb2ludCwgYWFiYikge1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIHNpemUgfSA9IGFhYmI7XG4gICAgY29uc3QgbWluID0gcG9zaXRpb247XG4gICAgY29uc3QgbWF4ID0gdmVjXzEudmVjMy5hZGQocG9zaXRpb24sIHNpemUpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIEFBQkJcbiAgICBjb25zdCBpbnRlcnNlY3RzID0gKDAsIHV0aWxpdGllc18xLnZhbHVlSW5JbnRlcnZhbCkocG9pbnQueCwgeyBtaW46IG1pbi54LCBtYXg6IG1heC54IH0pICYmXG4gICAgICAgICgwLCB1dGlsaXRpZXNfMS52YWx1ZUluSW50ZXJ2YWwpKHBvaW50LnksIHsgbWluOiBtaW4ueSwgbWF4OiBtYXgueSB9KSAmJlxuICAgICAgICAoMCwgdXRpbGl0aWVzXzEudmFsdWVJbkludGVydmFsKShwb2ludC56LCB7IG1pbjogbWluLnosIG1heDogbWF4LnogfSk7XG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgQUFCQiBzdXJmYWNlIHRvIHRoZSBnaXZlbiBwb2ludFxuICAgIGxldCBjbG9zZXN0UG9pbnQ7XG4gICAgaWYgKCFpbnRlcnNlY3RzKSB7XG4gICAgICAgIC8vIElmIHRoZSBwb2ludCBpcyBvdXRzaWRlLCBjbGFtcCB0byB0aGUgYm94XG4gICAgICAgIGNsb3Nlc3RQb2ludCA9ICgwLCB2ZWNfMS52ZWMzKSgoMCwgdXRpbHNfMS5jbGFtcCkocG9pbnQueCwgbWluLngsIG1heC54KSwgKDAsIHV0aWxzXzEuY2xhbXApKHBvaW50LnksIG1pbi55LCBtYXgueSksICgwLCB1dGlsc18xLmNsYW1wKShwb2ludC56LCBtaW4ueiwgbWF4LnopKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBwb2ludCBpcyBpbnNpZGUsIHByb2plY3QgdG8gdGhlIG5lYXJlc3QgZWRnZVxuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBbXG4gICAgICAgICAgICB7IHg6IG1pbi54LCB5OiBwb2ludC55LCB6OiBwb2ludC56LCBkOiBNYXRoLmFicyhwb2ludC54IC0gbWluLngpIH0sIC8vIGxlZnRcbiAgICAgICAgICAgIHsgeDogbWF4LngsIHk6IHBvaW50LnksIHo6IHBvaW50LnosIGQ6IE1hdGguYWJzKHBvaW50LnggLSBtYXgueCkgfSwgLy8gcmlnaHRcbiAgICAgICAgICAgIHsgeDogcG9pbnQueCwgeTogbWluLnksIHo6IHBvaW50LnosIGQ6IE1hdGguYWJzKHBvaW50LnkgLSBtaW4ueSkgfSwgLy8gYm90dG9tXG4gICAgICAgICAgICB7IHg6IHBvaW50LngsIHk6IG1heC55LCB6OiBwb2ludC56LCBkOiBNYXRoLmFicyhwb2ludC55IC0gbWF4LnkpIH0sIC8vIHRvcFxuICAgICAgICAgICAgeyB4OiBwb2ludC54LCB5OiBwb2ludC55LCB6OiBtaW4ueiwgZDogTWF0aC5hYnMocG9pbnQueiAtIG1pbi56KSB9LCAvLyBmcm9udFxuICAgICAgICAgICAgeyB4OiBwb2ludC54LCB5OiBwb2ludC55LCB6OiBtYXgueiwgZDogTWF0aC5hYnMocG9pbnQueiAtIG1heC56KSB9LCAvLyBiYWNrXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IG5lYXJlc3QgPSBkaXN0YW5jZXMucmVkdWNlKChhLCBiKSA9PiAoYS5kIDwgYi5kID8gYSA6IGIpKTtcbiAgICAgICAgY2xvc2VzdFBvaW50ID0gKDAsIHZlY18xLnZlYzMpKG5lYXJlc3QueCwgbmVhcmVzdC55LCBuZWFyZXN0LnopO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHBvaW50IHRvIHRoZSBjbG9zZXN0IHBvaW50XG4gICAgY29uc3QgZGlzdGFuY2UgPSB2ZWNfMS52ZWMzLmxlbih2ZWNfMS52ZWMzLnN1Yihwb2ludCwgY2xvc2VzdFBvaW50KSk7XG4gICAgLy8gSWYgdGhlIHBvaW50IGlzIGluc2lkZSwgZGlzdGFuY2Ugc2hvdWxkIGJlIG5lZ2F0aXZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0cyxcbiAgICAgICAgY2xvc2VzdFBvaW50LFxuICAgICAgICBkaXN0YW5jZTogaW50ZXJzZWN0cyA/IC1kaXN0YW5jZSA6IGRpc3RhbmNlLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY3Vib2lkIGlzIHJvdGF0ZWRcbiAqL1xuZnVuY3Rpb24gY3Vib2lkSXNSb3RhdGVkKGN1Ym9pZCkge1xuICAgIHJldHVybiBjdWJvaWQucm90YXRpb24gIT09IHVuZGVmaW5lZCAmJiAhKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKGN1Ym9pZC5yb3RhdGlvbik7XG59XG4vKipcbiAqIEdldCB0aGUgdmVydGljZXMgb2YgYSBjdWJvaWRcbiAqXG4gKiBWZXJ0aWNlcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XG4gKiAtIFVwcGVyIGZhY2UgKG1heCB6LCBjbG9ja3dpc2Ugc3RhcnRpbmcgYXQgdGhlIHRvcC1sZWZ0KVxuICogICAtIFRvcC1sZWZ0XG4gKiAgIC0gVG9wLXJpZ2h0XG4gKiAgIC0gQm90dG9tLXJpZ2h0XG4gKiAgIC0gQm90dG9tLWxlZnRcbiAqIC0gTG93ZXIgZmFjZSAobWluIHosIGNsb2Nrd2lzZSBzdGFydGluZyBhdCB0aGUgdG9wLWxlZnQpXG4gKiAgIC0gVG9wLWxlZnRcbiAqICAgLSBUb3AtcmlnaHRcbiAqICAgLSBCb3R0b20tcmlnaHRcbiAqICAgLSBCb3R0b20tbGVmdFxuICovXG5mdW5jdGlvbiBjdWJvaWRWZXJ0aWNlcyhjdWJvaWQpIHtcbiAgICBjb25zdCB7IHBvc2l0aW9uLCBzaXplLCByb3RhdGlvbiA9ICgwLCB2ZWNfMS52ZWMzKSgpIH0gPSBjdWJvaWQ7XG4gICAgY29uc3QgaGFsZlNpemUgPSB2ZWNfMS52ZWMzLmRpdihzaXplLCAyKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIDggY29ybmVycyBvZiB0aGUgY3Vib2lkXG4gICAgbGV0IHVwcGVyVG9wTGVmdE9mZnNldCA9IHZlY18xLnZlYzMuZnJvbUNvbXBvbmVudHModmVjXzEudmVjMy5zd2l6KGhhbGZTaXplLCAnWFl6JykpO1xuICAgIGxldCB1cHBlclRvcFJpZ2h0T2Zmc2V0ID0gdmVjXzEudmVjMy5mcm9tQ29tcG9uZW50cyh2ZWNfMS52ZWMzLnN3aXooaGFsZlNpemUsICd4WXonKSk7XG4gICAgbGV0IHVwcGVyQm90dG9tUmlnaHRPZmZzZXQgPSB2ZWNfMS52ZWMzLmZyb21Db21wb25lbnRzKHZlY18xLnZlYzMuc3dpeihoYWxmU2l6ZSwgJ3h5eicpKTtcbiAgICBsZXQgdXBwZXJCb3R0b21MZWZ0T2Zmc2V0ID0gdmVjXzEudmVjMy5mcm9tQ29tcG9uZW50cyh2ZWNfMS52ZWMzLnN3aXooaGFsZlNpemUsICdYeXonKSk7XG4gICAgbGV0IGxvd2VyVG9wTGVmdE9mZnNldCA9IHZlY18xLnZlYzMuZnJvbUNvbXBvbmVudHModmVjXzEudmVjMy5zd2l6KGhhbGZTaXplLCAnWFlaJykpO1xuICAgIGxldCBsb3dlclRvcFJpZ2h0T2Zmc2V0ID0gdmVjXzEudmVjMy5mcm9tQ29tcG9uZW50cyh2ZWNfMS52ZWMzLnN3aXooaGFsZlNpemUsICd4WVonKSk7XG4gICAgbGV0IGxvd2VyQm90dG9tUmlnaHRPZmZzZXQgPSB2ZWNfMS52ZWMzLmZyb21Db21wb25lbnRzKHZlY18xLnZlYzMuc3dpeihoYWxmU2l6ZSwgJ3h5WicpKTtcbiAgICBsZXQgbG93ZXJCb3R0b21MZWZ0T2Zmc2V0ID0gdmVjXzEudmVjMy5mcm9tQ29tcG9uZW50cyh2ZWNfMS52ZWMzLnN3aXooaGFsZlNpemUsICdYeVonKSk7XG4gICAgLy8gUm90YXRlIHRoZSBvZmZzZXRzIGlmIHRoZSBjdWJvaWQgaXMgcm90YXRlZFxuICAgIGlmIChjdWJvaWRJc1JvdGF0ZWQoY3Vib2lkKSkge1xuICAgICAgICB1cHBlclRvcExlZnRPZmZzZXQgPSB2ZWNfMS52ZWMzLnJvdGEodXBwZXJUb3BMZWZ0T2Zmc2V0LCByb3RhdGlvbik7XG4gICAgICAgIHVwcGVyVG9wUmlnaHRPZmZzZXQgPSB2ZWNfMS52ZWMzLnJvdGEodXBwZXJUb3BSaWdodE9mZnNldCwgcm90YXRpb24pO1xuICAgICAgICB1cHBlckJvdHRvbVJpZ2h0T2Zmc2V0ID0gdmVjXzEudmVjMy5yb3RhKHVwcGVyQm90dG9tUmlnaHRPZmZzZXQsIHJvdGF0aW9uKTtcbiAgICAgICAgdXBwZXJCb3R0b21MZWZ0T2Zmc2V0ID0gdmVjXzEudmVjMy5yb3RhKHVwcGVyQm90dG9tTGVmdE9mZnNldCwgcm90YXRpb24pO1xuICAgICAgICBsb3dlclRvcExlZnRPZmZzZXQgPSB2ZWNfMS52ZWMzLnJvdGEobG93ZXJUb3BMZWZ0T2Zmc2V0LCByb3RhdGlvbik7XG4gICAgICAgIGxvd2VyVG9wUmlnaHRPZmZzZXQgPSB2ZWNfMS52ZWMzLnJvdGEobG93ZXJUb3BSaWdodE9mZnNldCwgcm90YXRpb24pO1xuICAgICAgICBsb3dlckJvdHRvbVJpZ2h0T2Zmc2V0ID0gdmVjXzEudmVjMy5yb3RhKGxvd2VyQm90dG9tUmlnaHRPZmZzZXQsIHJvdGF0aW9uKTtcbiAgICAgICAgbG93ZXJCb3R0b21MZWZ0T2Zmc2V0ID0gdmVjXzEudmVjMy5yb3RhKGxvd2VyQm90dG9tTGVmdE9mZnNldCwgcm90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBVcHBlciBmYWNlIHZlcnRpY2VzXG4gICAgICAgIHZlY18xLnZlYzMuYWRkKHBvc2l0aW9uLCB1cHBlclRvcExlZnRPZmZzZXQpLFxuICAgICAgICB2ZWNfMS52ZWMzLmFkZChwb3NpdGlvbiwgdXBwZXJUb3BSaWdodE9mZnNldCksXG4gICAgICAgIHZlY18xLnZlYzMuYWRkKHBvc2l0aW9uLCB1cHBlckJvdHRvbVJpZ2h0T2Zmc2V0KSxcbiAgICAgICAgdmVjXzEudmVjMy5hZGQocG9zaXRpb24sIHVwcGVyQm90dG9tTGVmdE9mZnNldCksXG4gICAgICAgIC8vIExvd2VyIGZhY2UgdmVydGljZXNcbiAgICAgICAgdmVjXzEudmVjMy5hZGQocG9zaXRpb24sIGxvd2VyVG9wTGVmdE9mZnNldCksXG4gICAgICAgIHZlY18xLnZlYzMuYWRkKHBvc2l0aW9uLCBsb3dlclRvcFJpZ2h0T2Zmc2V0KSxcbiAgICAgICAgdmVjXzEudmVjMy5hZGQocG9zaXRpb24sIGxvd2VyQm90dG9tUmlnaHRPZmZzZXQpLFxuICAgICAgICB2ZWNfMS52ZWMzLmFkZChwb3NpdGlvbiwgbG93ZXJCb3R0b21MZWZ0T2Zmc2V0KSxcbiAgICBdO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgY3Vib2lkIHRvIGEgbGlzdCBvZiBwb2x5Z29ucyByZXByZXNlbnRpbmcgaXRzIGZhY2VzXG4gKlxuICogUG9seWdvbnMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICogLSBVcHBlciBmYWNlICh0b3ApXG4gKiAtIExvd2VyIGZhY2UgKGJvdHRvbSlcbiAqIC0gRnJvbnQgZmFjZVxuICogLSBCYWNrIGZhY2VcbiAqIC0gTGVmdCBmYWNlXG4gKiAtIFJpZ2h0IGZhY2VcbiAqL1xuZnVuY3Rpb24gY3Vib2lkVG9Qb2x5Z29ucyhjdWJvaWQpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IGN1Ym9pZFZlcnRpY2VzKGN1Ym9pZCk7XG4gICAgaWYgKHZlcnRpY2VzLmxlbmd0aCAhPT0gOCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1Ym9pZCBtdXN0IGhhdmUgZXhhY3RseSA4IHZlcnRpY2VzJyk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBwb2x5Z29ucyBmb3IgZWFjaCBmYWNlIG9mIHRoZSBjdWJvaWRcbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBVcHBlciBmYWNlXG4gICAgICAgIHsgdmVydGljZXM6IFt2ZXJ0aWNlc1swXSwgdmVydGljZXNbMV0sIHZlcnRpY2VzWzJdXSB9LFxuICAgICAgICB7IHZlcnRpY2VzOiBbdmVydGljZXNbMF0sIHZlcnRpY2VzWzJdLCB2ZXJ0aWNlc1szXV0gfSxcbiAgICAgICAgLy8gTG93ZXIgZmFjZVxuICAgICAgICB7IHZlcnRpY2VzOiBbdmVydGljZXNbNF0sIHZlcnRpY2VzWzVdLCB2ZXJ0aWNlc1s2XV0gfSxcbiAgICAgICAgeyB2ZXJ0aWNlczogW3ZlcnRpY2VzWzRdLCB2ZXJ0aWNlc1s2XSwgdmVydGljZXNbN11dIH0sXG4gICAgICAgIC8vIEZyb250IGZhY2VcbiAgICAgICAgeyB2ZXJ0aWNlczogW3ZlcnRpY2VzWzBdLCB2ZXJ0aWNlc1sxXSwgdmVydGljZXNbNV1dIH0sXG4gICAgICAgIHsgdmVydGljZXM6IFt2ZXJ0aWNlc1swXSwgdmVydGljZXNbNV0sIHZlcnRpY2VzWzRdXSB9LFxuICAgICAgICAvLyBCYWNrIGZhY2VcbiAgICAgICAgeyB2ZXJ0aWNlczogW3ZlcnRpY2VzWzJdLCB2ZXJ0aWNlc1szXSwgdmVydGljZXNbN11dIH0sXG4gICAgICAgIHsgdmVydGljZXM6IFt2ZXJ0aWNlc1syXSwgdmVydGljZXNbN10sIHZlcnRpY2VzWzZdXSB9LFxuICAgICAgICAvLyBMZWZ0IGZhY2VcbiAgICAgICAgeyB2ZXJ0aWNlczogW3ZlcnRpY2VzWzBdLCB2ZXJ0aWNlc1szXSwgdmVydGljZXNbN11dIH0sXG4gICAgICAgIHsgdmVydGljZXM6IFt2ZXJ0aWNlc1swXSwgdmVydGljZXNbN10sIHZlcnRpY2VzWzRdXSB9LFxuICAgICAgICAvLyBSaWdodCBmYWNlXG4gICAgICAgIHsgdmVydGljZXM6IFt2ZXJ0aWNlc1sxXSwgdmVydGljZXNbMl0sIHZlcnRpY2VzWzZdXSB9LFxuICAgICAgICB7IHZlcnRpY2VzOiBbdmVydGljZXNbMV0sIHZlcnRpY2VzWzZdLCB2ZXJ0aWNlc1s1XV0gfSxcbiAgICBdO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgbGlzdCBvZiB2ZXJ0aWNlcyB0byBhIGxpc3Qgb2YgZWRnZXNcbiAqL1xuZnVuY3Rpb24gdmVydGljZXNUb0VkZ2VzKHZlcnRpY2VzKSB7XG4gICAgY29uc3QgZWRnZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdmVydGljZXNbaV07XG4gICAgICAgIGNvbnN0IGVuZCA9ICgwLCB1dGlsc18xLmF0KSh2ZXJ0aWNlcywgaSArIDEpO1xuICAgICAgICBlZGdlcy5wdXNoKHsgc3RhcnQsIGVuZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvbHlnb24gaXMgdmFsaWRcbiAqXG4gKiBBIHBvbHlnb24gaXMgdmFsaWQgaWYgaXQgaGFzIGV4YWN0bHkgMyB2ZXJ0aWNlc1xuICovXG5mdW5jdGlvbiBwb2x5Z29uSXNWYWxpZChwb2x5Z29uKSB7XG4gICAgcmV0dXJuIHBvbHlnb24udmVydGljZXMubGVuZ3RoID09PSAzO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHdpbmRpbmcgb3JkZXIgb2YgYSBwb2x5Z29uJ3MgdmVydGljZXNcbiAqXG4gKiBSZXR1cm5zICdjbG9ja3dpc2UnIG9yICdjb3VudGVyLWNsb2Nrd2lzZSdcbiAqXG4gKiBCeSBkZWZhdWx0IHVzZXMgdGhlIHJpZ2h0LWhhbmQgcnVsZTogaWYgdGhlIHZlcnRpY2VzIGFyZSBvcmRlcmVkXG4gKiBjb3VudGVyLWNsb2Nrd2lzZSwgdGhlIG5vcm1hbCBwb2ludHMgdG93YXJkcyB0aGUgdmlld2VyXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBwb2x5Z29uIGlzIGludmFsaWQgb3IgZGVnZW5lcmF0ZVxuICovXG5mdW5jdGlvbiBwb2x5Z29uV2luZGluZ09yZGVyKHBvbHlnb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbYSwgYiwgY10gPSBwb2x5Z29uLnZlcnRpY2VzO1xuICAgIGNvbnN0IGhhbmRlZG5lc3MgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhhbmRlZG5lc3MpIHx8ICdyaWdodCc7XG4gICAgLy8gQ2FsY3VsYXRlIHZlY3RvcnMgZnJvbSB2ZXJ0ZXggYSB0byBiIGFuZCBhIHRvIGNcbiAgICBjb25zdCBhYiA9IHZlY18xLnZlYzMuc3ViKGIsIGEpO1xuICAgIGNvbnN0IGFjID0gdmVjXzEudmVjMy5zdWIoYywgYSk7XG4gICAgLy8gQ2FsY3VsYXRlIG5vcm1hbCB2ZWN0b3IgdXNpbmcgY3Jvc3MgcHJvZHVjdFxuICAgIGNvbnN0IG5vcm1hbCA9IHZlY18xLnZlYzMuY3Jvc3MoYWIsIGFjKTtcbiAgICAvLyBJZiBub3JtYWwgaXMgemVybyB2ZWN0b3IgKG9yIHZlcnkgY2xvc2UgdG8gemVybyksIHZlcnRpY2VzIGFyZSBjb2xsaW5lYXJcbiAgICBpZiAoKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKG5vcm1hbCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIElmIGEgcmVmZXJlbmNlIG5vcm1hbCB3YXMgcHJvdmlkZWQsIHVzZSBpdFxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9ybWFsKSB7XG4gICAgICAgIGNvbnN0IGRvdCA9IHZlY18xLnZlYzMuZG90KHZlY18xLnZlYzMubm9yKG5vcm1hbCksIHZlY18xLnZlYzMubm9yKG9wdGlvbnMubm9ybWFsKSk7XG4gICAgICAgIC8vIERvdCBwcm9kdWN0ID4gMCBtZWFucyBub3JtYWxzIHBvaW50IGluIHNpbWlsYXIgZGlyZWN0aW9uXG4gICAgICAgIGlmIChNYXRoLmFicyhkb3QpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBOb3JtYWxzIGFyZSBwZXJwZW5kaWN1bGFyLCBjYW4ndCBkZXRlcm1pbmUgb3JkZXJcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGVkbmVzcyA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGRvdCA+IDAgPyAnY291bnRlci1jbG9ja3dpc2UnIDogJ2Nsb2Nrd2lzZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZG90ID4gMCA/ICdjbG9ja3dpc2UnIDogJ2NvdW50ZXItY2xvY2t3aXNlJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXaXRob3V0IGEgcmVmZXJlbmNlIG5vcm1hbCwgd2UnbGwgdXNlIHRoZSB6LWNvbXBvbmVudCBvZiB0aGUgbm9ybWFsXG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdpbmRpbmcgb3JkZXIgKHBvc2l0aXZlIHogcG9pbnRzIHRvd2FyZHMgdmlld2VyKVxuICAgIGlmIChNYXRoLmFicyhub3JtYWwueikgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gTm9ybWFsIGlzIHBlcnBlbmRpY3VsYXIgdG8gdmlldyBkaXJlY3Rpb25cbiAgICB9XG4gICAgaWYgKGhhbmRlZG5lc3MgPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbC56ID4gMCA/ICdjb3VudGVyLWNsb2Nrd2lzZScgOiAnY2xvY2t3aXNlJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBub3JtYWwueiA+IDAgPyAnY2xvY2t3aXNlJyA6ICdjb3VudGVyLWNsb2Nrd2lzZSc7XG4gICAgfVxufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIDJEIGFyZWEgb2YgYSBwb2x5Z29uIGluIDNEIHNwYWNlXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBwb2x5Z29uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvbkFyZWEocG9seWdvbikge1xuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFthLCBiLCBjXSA9IHBvbHlnb24udmVydGljZXM7XG4gICAgLy8gVXNlIHRoZSBzaG9lbGFjZSBmb3JtdWxhIHRvIGNhbGN1bGF0ZSB0aGUgYXJlYSBvZiB0aGUgdHJpYW5nbGVcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaG9lbGFjZV9mb3JtdWxhXG4gICAgcmV0dXJuIChNYXRoLmFicyhhLnggKiAoYi55IC0gYi54KSAqIGEueSArXG4gICAgICAgIGIueCAqIChjLnkgLSBjLngpICogYi55ICtcbiAgICAgICAgYy54ICogKGEueSAtIGEueCkgKiBjLnkpIC8gMik7XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgY2VudHJvaWQgb2YgYSBwb2x5Z29uXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBwb2x5Z29uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNlbnRyb2lkKHBvbHlnb24pIHtcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmVjXzEudmVjMy5kaXYodmVjXzEudmVjMy5hZGQocG9seWdvbi52ZXJ0aWNlc1swXSwgdmVjXzEudmVjMy5hZGQocG9seWdvbi52ZXJ0aWNlc1sxXSwgcG9seWdvbi52ZXJ0aWNlc1syXSkpLCAzKTtcbn1cbi8qKlxuICogQ29udmVydCBhIHBvbHlnb24gdG8gYSBwbGFuZVxuICovXG5mdW5jdGlvbiBwb2x5Z29uVG9QbGFuZShwb2x5Z29uKSB7XG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBub3JtYWwgdmVjdG9yXG4gICAgY29uc3QgW2EsIGIsIGNdID0gcG9seWdvbi52ZXJ0aWNlcztcbiAgICBjb25zdCBhYiA9IHZlY18xLnZlYzMuc3ViKGIsIGEpO1xuICAgIGNvbnN0IGFjID0gdmVjXzEudmVjMy5zdWIoYywgYSk7XG4gICAgY29uc3Qgbm9ybWFsID0gdmVjXzEudmVjMy5ub3IodmVjXzEudmVjMy5jcm9zcyhhYiwgYWMpKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBsYW5lJ3MgcG9zaXRpb24gYXMgdGhlIGNlbnRyb2lkIG9mIHRoZSBwb2x5Z29uXG4gICAgY29uc3QgcG9pbnQgPSBwb2x5Z29uQ2VudHJvaWQocG9seWdvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIG5vcm1hbCxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgbGlzdCBvZiBwb2x5Z29ucyB0byBhIG1lc2hcbiAqXG4gKiBUaGlzIG9wdGltaXNlcyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGFuZCBlZGdlcyBieSBtZXJnaW5nIGNvbW1vbiB2ZXJ0aWNlc1xuICovXG5mdW5jdGlvbiBwb2x5Z29uc1RvTWVzaChwb2x5Z29ucykge1xuICAgIGlmIChwb2x5Z29ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgdmVydGljZXM6IFtdLCBpbmRpY2VzOiBbXSB9O1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBtYXAgdG8gc3RvcmUgdW5pcXVlIHZlcnRpY2VzXG4gICAgY29uc3QgdmVydGV4TWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBwb2x5Z29uXG4gICAgcG9seWdvbnMuZm9yRWFjaCgocG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb2x5Z29uIGF0IGluZGV4ICR7cG9seWdvbkluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIHZlcnRleCBpbiB0aGUgcG9seWdvblxuICAgICAgICBwb2x5Z29uLnZlcnRpY2VzLmZvckVhY2godmVydGV4ID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBrZXkgZm9yIHRoZSB2ZXJ0ZXhcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke3ZlcnRleC54fSwke3ZlcnRleC55fSwke3ZlcnRleC56fWA7XG4gICAgICAgICAgICBpZiAoIXZlcnRleE1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2ZXJ0ZXggaXMgbm90IGluIHRoZSBtYXAsIGFkZCBpdFxuICAgICAgICAgICAgICAgIHZlcnRleE1hcC5zZXQoa2V5LCB2ZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgdmVydGV4IGluIHRoZSBtYXBcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gQXJyYXkuZnJvbSh2ZXJ0ZXhNYXAua2V5cygpKS5pbmRleE9mKGtleSk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBDb252ZXJ0IHRoZSB2ZXJ0ZXggbWFwIHRvIGFuIGFycmF5XG4gICAgY29uc3QgdmVydGljZXMgPSBBcnJheS5mcm9tKHZlcnRleE1hcC52YWx1ZXMoKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGljZXMsXG4gICAgICAgIGluZGljZXMsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIG1lc2ggdG8gYSBsaXN0IG9mIHBvbHlnb25zXG4gKi9cbmZ1bmN0aW9uIG1lc2hUb1BvbHlnb25zKG1lc2gpIHtcbiAgICBpZiAobWVzaC5pbmRpY2VzLmxlbmd0aCAlIDMgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNoIGluZGljZXMgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMgdG8gZm9ybSB0cmlhbmdsZXMnKTtcbiAgICB9XG4gICAgY29uc3QgcG9seWdvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc2guaW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gbWVzaC5pbmRpY2VzLnNsaWNlKGksIGkgKyAzKTtcbiAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc2ggaW5kaWNlcyBtdXN0IGZvcm0gdHJpYW5nbGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBpbmRpY2VzLm1hcChpbmRleCA9PiBtZXNoLnZlcnRpY2VzW2luZGV4XSk7XG4gICAgICAgIHBvbHlnb25zLnB1c2goeyB2ZXJ0aWNlcyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlnb25zO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgbWVzaCB0byBhIGxpc3Qgb2YgZWRnZXNcbiAqL1xuZnVuY3Rpb24gbWVzaFRvRWRnZXMobWVzaCkge1xuICAgIGlmIChtZXNoLmluZGljZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc2ggaW5kaWNlcyBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMiB0byBmb3JtIGVkZ2VzJyk7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNoLmluZGljZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IG1lc2guaW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBtZXNoLmluZGljZXNbaSArIDFdO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA+PSBtZXNoLnZlcnRpY2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgZW5kSW5kZXggPj0gbWVzaC52ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzaCBpbmRpY2VzIG91dCBvZiBib3VuZHMnKTtcbiAgICAgICAgfVxuICAgICAgICBlZGdlcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBtZXNoLnZlcnRpY2VzW3N0YXJ0SW5kZXhdLFxuICAgICAgICAgICAgZW5kOiBtZXNoLnZlcnRpY2VzW2VuZEluZGV4XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlZGdlcztcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBjZW50cm9pZCBvZiBhIG1lc2hcbiAqL1xuZnVuY3Rpb24gbWVzaENlbnRyb2lkKG1lc2gpIHtcbiAgICByZXR1cm4gdmVjXzEudmVjMy5kaXYobWVzaC52ZXJ0aWNlcy5yZWR1Y2UoKGFjYywgdikgPT4gdmVjXzEudmVjMy5hZGQoYWNjLCB2KSwgKDAsIHZlY18xLnZlYzMpKCkpLCBtZXNoLnZlcnRpY2VzLmxlbmd0aCk7XG59XG4vKipcbiAqIFBlcmZvcm0gYW4gZWRnZSBtYW5pZm9sZCBjaGVjayB0byB0ZWxsIGlmIGEgbWVzaCBpcyB3YXRlcnRpZ2h0XG4gKlxuICogRXZlcnkgZWRnZSBpbiBhIHdhdGVydGlnaHQgbWVzaCBzaG91bGQgYmUgc2hhcmVkIGJ5IGV4YWN0bHkgdHdvIHRyaWFuZ2xlc1xuICpcbiAqIFRoaXMgaXNuJ3QgcGVyZmVjdCwgYnV0IGl0IHNob3VsZCBiZSBzdWZmaWNpZW50IGZvciBtb3N0IHNpbXBsZSBjYXNlc1xuICovXG5mdW5jdGlvbiBtZXNoSXNXYXRlcnRpZ2h0KG1lc2gpIHtcbiAgICAvLyBDcmVhdGUgYSBtYXAgdG8gc3RvcmUgZWRnZSBjb3VudHNcbiAgICAvLyBLZXkgZm9ybWF0OiBcInNtYWxsZXJWZXJ0ZXhJbmRleCxsYXJnZXJWZXJ0ZXhJbmRleFwiXG4gICAgY29uc3QgZWRnZUNvdW50cyA9IG5ldyBNYXAoKTtcbiAgICAvLyBQcm9jZXNzIGVhY2ggdHJpYW5nbGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc2guaW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCB2MSA9IG1lc2guaW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgdjIgPSBtZXNoLmluZGljZXNbaSArIDFdO1xuICAgICAgICBjb25zdCB2MyA9IG1lc2guaW5kaWNlc1tpICsgMl07XG4gICAgICAgIC8vIEZvciBlYWNoIGVkZ2UgaW4gdGhlIHRyaWFuZ2xlLCBjcmVhdGUgYSBjYW5vbmljYWwga2V5XG4gICAgICAgIGNvbnN0IGVkZ2VzID0gW1xuICAgICAgICAgICAgW01hdGgubWluKHYxLCB2MiksIE1hdGgubWF4KHYxLCB2MildLFxuICAgICAgICAgICAgW01hdGgubWluKHYyLCB2MyksIE1hdGgubWF4KHYyLCB2MyldLFxuICAgICAgICAgICAgW01hdGgubWluKHYzLCB2MSksIE1hdGgubWF4KHYzLCB2MSldLFxuICAgICAgICBdO1xuICAgICAgICAvLyBDb3VudCBlYWNoIGVkZ2VcbiAgICAgICAgZWRnZXMuZm9yRWFjaCgoW2EsIGJdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHthfSwke2J9YDtcbiAgICAgICAgICAgIGVkZ2VDb3VudHMuc2V0KGtleSwgKGVkZ2VDb3VudHMuZ2V0KGtleSkgfHwgMCkgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGFsbCBlZGdlcyBhcHBlYXIgZXhhY3RseSB0d2ljZVxuICAgIHJldHVybiBBcnJheS5mcm9tKGVkZ2VDb3VudHMudmFsdWVzKCkpLmV2ZXJ5KGNvdW50ID0+IGNvdW50ID09PSAyKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpcyBvbiBhIHJheVxuICpcbiAqIEFsc28gcmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgcmF5IGFuZCB0aGUgZGlzdGFuY2UgdG8gaXRcbiAqL1xuZnVuY3Rpb24gcG9pbnRPblJheShwb2ludCwgcmF5KSB7XG4gICAgLy8gVmVjdG9yIGZyb20gcmF5IG9yaWdpbiB0byBwb2ludFxuICAgIGNvbnN0IHRvUG9pbnQgPSB2ZWNfMS52ZWMzLnN1Yihwb2ludCwgcmF5Lm9yaWdpbik7XG4gICAgLy8gR2V0IG5vcm1hbGl6ZWQgcmF5IGRpcmVjdGlvblxuICAgIGNvbnN0IHJheURpcmVjdGlvbiA9IHZlY18xLnZlYzMubm9yKHJheS5kaXJlY3Rpb24pO1xuICAgIC8vIFByb2plY3QgdG9Qb2ludCBvbnRvIHRoZSByYXkgZGlyZWN0aW9uXG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZlY18xLnZlYzMuZG90KHRvUG9pbnQsIHJheURpcmVjdGlvbik7XG4gICAgLy8gQ2FsY3VsYXRlIGNsb3Nlc3QgcG9pbnQgb24gcmF5XG4gICAgY29uc3QgY2xvc2VzdFBvaW50ID0gdmVjXzEudmVjMy5hZGQocmF5Lm9yaWdpbiwgdmVjXzEudmVjMy5tdWwocmF5RGlyZWN0aW9uLCBNYXRoLm1heCgwLCBwcm9qZWN0aW9uKSkpO1xuICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIGNsb3Nlc3QgcG9pbnRcbiAgICBjb25zdCBkaXN0YW5jZSA9IHZlY18xLnZlYzMubGVuKHZlY18xLnZlYzMuc3ViKHBvaW50LCBjbG9zZXN0UG9pbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBQb2ludCBpcyBvbiByYXkgaWYgZGlzdGFuY2UgaXMgemVybyBhbmQgcHJvamVjdGlvbiBpcyBub24tbmVnYXRpdmVcbiAgICAgICAgaW50ZXJzZWN0czogZGlzdGFuY2UgPCBjb25zdGFudHMuRVBTSUxPTiAmJiBwcm9qZWN0aW9uID49IDAsXG4gICAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbnRlcnNlY3RzIGEgbGluZSBzZWdtZW50XG4gKlxuICogQWxzbyByZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lIHNlZ21lbnQgYW5kIHRoZSBkaXN0YW5jZSB0byBpdFxuICovXG5mdW5jdGlvbiBwb2ludE9uTGluZShwb2ludCwgbGluZSkge1xuICAgIC8vIEdldCB2ZWN0b3IgZnJvbSBsaW5lIHN0YXJ0IHRvIGVuZFxuICAgIGNvbnN0IGxpbmVWZWN0b3IgPSB2ZWNfMS52ZWMzLnN1YihsaW5lLmVuZCwgbGluZS5zdGFydCk7XG4gICAgLy8gR2V0IG5vcm1hbGl6ZWQgbGluZSBkaXJlY3Rpb25cbiAgICBjb25zdCBsaW5lRGlyZWN0aW9uID0gdmVjXzEudmVjMy5ub3IobGluZVZlY3Rvcik7XG4gICAgLy8gR2V0IHZlY3RvciBmcm9tIGxpbmUgc3RhcnQgdG8gcG9pbnRcbiAgICBjb25zdCB0b1BvaW50ID0gdmVjXzEudmVjMy5zdWIocG9pbnQsIGxpbmUuc3RhcnQpO1xuICAgIC8vIFByb2plY3QgdG9Qb2ludCBvbnRvIHRoZSBsaW5lIGRpcmVjdGlvblxuICAgIGNvbnN0IHByb2plY3Rpb24gPSB2ZWNfMS52ZWMzLmRvdCh0b1BvaW50LCBsaW5lRGlyZWN0aW9uKTtcbiAgICAvLyBHZXQgbGluZSBsZW5ndGhcbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gdmVjXzEudmVjMy5sZW4obGluZVZlY3Rvcik7XG4gICAgLy8gQ2xhbXAgcHJvamVjdGlvbiB0byBsaW5lIHNlZ21lbnRcbiAgICBjb25zdCBjbGFtcGVkUHJvamVjdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxpbmVMZW5ndGgsIHByb2plY3Rpb24pKTtcbiAgICAvLyBDYWxjdWxhdGUgY2xvc2VzdCBwb2ludCBvbiBsaW5lIHNlZ21lbnRcbiAgICBjb25zdCBjbG9zZXN0UG9pbnQgPSB2ZWNfMS52ZWMzLmFkZChsaW5lLnN0YXJ0LCB2ZWNfMS52ZWMzLm11bChsaW5lRGlyZWN0aW9uLCBjbGFtcGVkUHJvamVjdGlvbikpO1xuICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIGNsb3Nlc3QgcG9pbnRcbiAgICBjb25zdCBkaXN0YW5jZSA9IHZlY18xLnZlYzMubGVuKHZlY18xLnZlYzMuc3ViKHBvaW50LCBjbG9zZXN0UG9pbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBQb2ludCBpcyBvbiBsaW5lIGlmIGRpc3RhbmNlIGlzIGVmZmVjdGl2ZWx5IHplcm9cbiAgICAgICAgaW50ZXJzZWN0czogZGlzdGFuY2UgPCBjb25zdGFudHMuRVBTSUxPTixcbiAgICAgICAgY2xvc2VzdFBvaW50LFxuICAgICAgICBkaXN0YW5jZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGlzIGluc2lkZSBhIHNwaGVyZVxuICpcbiAqIEFsc28gcmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc3BoZXJlIGVkZ2UgYW5kIHRoZSBkaXN0YW5jZSB0byBpdFxuICpcbiAqIElmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIGRpc3RhbmNlIHdpbGwgYmUgbmVnYXRpdmVcbiAqL1xuZnVuY3Rpb24gcG9pbnRJblNwaGVyZShwb2ludCwgc3BoZXJlKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gcG9pbnRcbiAgICBjb25zdCB0b1BvaW50ID0gdmVjXzEudmVjMy5zdWIocG9pbnQsIHNwaGVyZS5wb3NpdGlvbik7XG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gc3BoZXJlIGNlbnRlclxuICAgIGNvbnN0IGRpc3RhbmNlVG9DZW50ZXIgPSB2ZWNfMS52ZWMzLmxlbih0b1BvaW50KTtcbiAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZVxuICAgIGNvbnN0IGludGVyc2VjdHMgPSBkaXN0YW5jZVRvQ2VudGVyIDw9IHNwaGVyZS5yYWRpdXM7XG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIHRvIGNpcmNsZSBlZGdlXG4gICAgY29uc3QgZGlzdGFuY2UgPSBpbnRlcnNlY3RzXG4gICAgICAgID8gLShzcGhlcmUucmFkaXVzIC0gZGlzdGFuY2VUb0NlbnRlcikgLy8gTmVnYXRpdmUgaWYgaW5zaWRlXG4gICAgICAgIDogZGlzdGFuY2VUb0NlbnRlciAtIHNwaGVyZS5yYWRpdXM7IC8vIFBvc2l0aXZlIGlmIG91dHNpZGVcbiAgICAvLyBDYWxjdWxhdGUgY2xvc2VzdCBwb2ludCBvbiBzcGhlcmUgZWRnZVxuICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IHZlY18xLnZlYzMuYWRkKHNwaGVyZS5wb3NpdGlvbiwgdmVjXzEudmVjMy5tdWwodmVjXzEudmVjMy5ub3IodG9Qb2ludCksIHNwaGVyZS5yYWRpdXMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzLFxuICAgICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgY3Vib2lkXG4gKi9cbmZ1bmN0aW9uIHBvaW50SW5DdWJvaWQocG9pbnQsIGN1Ym9pZCkge1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIHNpemUsIHJvdGF0aW9uID0gKDAsIHZlY18xLnZlYzMpKCkgfSA9IGN1Ym9pZDtcbiAgICBjb25zdCBoYWxmU2l6ZSA9IHZlY18xLnZlYzMuZGl2KHNpemUsIDIpO1xuICAgIC8vIFRyYW5zZm9ybSBwb2ludCB0byBsb2NhbCBzcGFjZSBieSB1bmRvaW5nIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGlvblxuICAgIGxldCBsb2NhbFBvaW50ID0gdmVjXzEudmVjMy5zdWIocG9pbnQsIHBvc2l0aW9uKTtcbiAgICBpZiAoY3Vib2lkSXNSb3RhdGVkKGN1Ym9pZCkpIHtcbiAgICAgICAgbG9jYWxQb2ludCA9IHZlY18xLnZlYzMucm90YShsb2NhbFBvaW50LCB2ZWNfMS52ZWMzLm11bChyb3RhdGlvbiwgLTEpKTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlcyB0byBlYWNoIGZhY2UgaW4gbG9jYWwgc3BhY2VcbiAgICBjb25zdCBkeCA9IE1hdGgubWF4KE1hdGguYWJzKGxvY2FsUG9pbnQueCkgLSBoYWxmU2l6ZS54LCAwKTtcbiAgICBjb25zdCBkeSA9IE1hdGgubWF4KE1hdGguYWJzKGxvY2FsUG9pbnQueSkgLSBoYWxmU2l6ZS55LCAwKTtcbiAgICBjb25zdCBkeiA9IE1hdGgubWF4KE1hdGguYWJzKGxvY2FsUG9pbnQueikgLSBoYWxmU2l6ZS56LCAwKTtcbiAgICAvLyBDYWxjdWxhdGUgY2xvc2VzdCBwb2ludCBpbiBsb2NhbCBzcGFjZVxuICAgIGNvbnN0IGNsb3Nlc3RMb2NhbFBvaW50ID0gKDAsIHZlY18xLnZlYzMpKCgwLCB1dGlsc18xLmNsYW1wKShsb2NhbFBvaW50LngsIC1oYWxmU2l6ZS54LCBoYWxmU2l6ZS54KSwgKDAsIHV0aWxzXzEuY2xhbXApKGxvY2FsUG9pbnQueSwgLWhhbGZTaXplLnksIGhhbGZTaXplLnkpLCAoMCwgdXRpbHNfMS5jbGFtcCkobG9jYWxQb2ludC56LCAtaGFsZlNpemUueiwgaGFsZlNpemUueikpO1xuICAgIC8vIFRyYW5zZm9ybSBjbG9zZXN0IHBvaW50IGJhY2sgdG8gd29ybGQgc3BhY2VcbiAgICBsZXQgY2xvc2VzdFBvaW50ID0gY2xvc2VzdExvY2FsUG9pbnQ7XG4gICAgaWYgKGN1Ym9pZElzUm90YXRlZChjdWJvaWQpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludCA9IHZlY18xLnZlYzMucm90YShjbG9zZXN0UG9pbnQsIHJvdGF0aW9uKTtcbiAgICB9XG4gICAgY2xvc2VzdFBvaW50ID0gdmVjXzEudmVjMy5hZGQoY2xvc2VzdFBvaW50LCBwb3NpdGlvbik7XG4gICAgLy8gQ2FsY3VsYXRlIGlmIHBvaW50IGlzIGluc2lkZSBhbmQgdGhlIGRpc3RhbmNlXG4gICAgY29uc3QgaW50ZXJzZWN0cyA9IGR4ID09PSAwICYmIGR5ID09PSAwICYmIGR6ID09PSAwO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gaW50ZXJzZWN0c1xuICAgICAgICA/IC1NYXRoLm1pbihoYWxmU2l6ZS54IC0gTWF0aC5hYnMobG9jYWxQb2ludC54KSwgaGFsZlNpemUueSAtIE1hdGguYWJzKGxvY2FsUG9pbnQueSksIGhhbGZTaXplLnogLSBNYXRoLmFicyhsb2NhbFBvaW50LnopKVxuICAgICAgICA6IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHMsXG4gICAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBvaW50T25Qb2x5Z29uKHBvaW50LCBwb2x5Z29uKSB7XG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgdGhlIHBvbHlnb25cbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbdjEsIHYyLCB2M10gPSBwb2x5Z29uLnZlcnRpY2VzO1xuICAgIC8vIENhbGN1bGF0ZSB0d28gZWRnZXMgb2YgdGhlIHRyaWFuZ2xlXG4gICAgY29uc3QgZWRnZTEgPSB2ZWNfMS52ZWMzLnN1Yih2MiwgdjEpO1xuICAgIGNvbnN0IGVkZ2UyID0gdmVjXzEudmVjMy5zdWIodjMsIHYxKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG5vcm1hbCB2ZWN0b3Igb2YgdGhlIHBsYW5lIGNvbnRhaW5pbmcgdGhlIHRyaWFuZ2xlXG4gICAgY29uc3Qgbm9ybWFsID0gdmVjXzEudmVjMy5ub3IodmVjXzEudmVjMy5jcm9zcyhlZGdlMSwgZWRnZTIpKTtcbiAgICAvLyBDYWxjdWxhdGUgcGxhbmUgY29uc3RhbnQgZFxuICAgIGNvbnN0IGQgPSAtdmVjXzEudmVjMy5kb3Qobm9ybWFsLCB2MSk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzaWduZWQgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIHBsYW5lXG4gICAgY29uc3Qgc2lnbmVkRGlzdGFuY2UgPSB2ZWNfMS52ZWMzLmRvdChub3JtYWwsIHBvaW50KSArIGQ7XG4gICAgLy8gUHJvamVjdCB0aGUgcG9pbnQgb250byB0aGUgcGxhbmVcbiAgICBjb25zdCBwcm9qZWN0ZWRQb2ludCA9IHZlY18xLnZlYzMuc3ViKHBvaW50LCB2ZWNfMS52ZWMzLm11bChub3JtYWwsIHNpZ25lZERpc3RhbmNlKSk7XG4gICAgLy8gTm93IHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHByb2plY3RlZCBwb2ludCBpcyBpbnNpZGUgdGhlIHRyaWFuZ2xlXG4gICAgLy8gV2UnbGwgdXNlIHRoZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlIG1ldGhvZFxuICAgIGNvbnN0IGFyZWEgPSB2ZWNfMS52ZWMzLmxlbih2ZWNfMS52ZWMzLmNyb3NzKGVkZ2UxLCBlZGdlMikpIC8gMjsgLy8gVHJpYW5nbGUgYXJlYVxuICAgIC8vIENhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyB1c2luZyBzdWItdHJpYW5nbGUgYXJlYXNcbiAgICBjb25zdCBlZGdlMyA9IHZlY18xLnZlYzMuc3ViKHYzLCB2Mik7XG4gICAgY29uc3QgdnAxID0gdmVjXzEudmVjMy5zdWIocHJvamVjdGVkUG9pbnQsIHYxKTtcbiAgICBjb25zdCB2cDIgPSB2ZWNfMS52ZWMzLnN1Yihwcm9qZWN0ZWRQb2ludCwgdjIpO1xuICAgIGNvbnN0IHZwMyA9IHZlY18xLnZlYzMuc3ViKHByb2plY3RlZFBvaW50LCB2Myk7XG4gICAgY29uc3QgYWxwaGEgPSB2ZWNfMS52ZWMzLmxlbih2ZWNfMS52ZWMzLmNyb3NzKGVkZ2UzLCB2cDIpKSAvICgyICogYXJlYSk7XG4gICAgY29uc3QgYmV0YSA9IHZlY18xLnZlYzMubGVuKHZlY18xLnZlYzMuY3Jvc3MoZWRnZTIsIHZwMykpIC8gKDIgKiBhcmVhKTtcbiAgICBjb25zdCBnYW1tYSA9IHZlY18xLnZlYzMubGVuKHZlY18xLnZlYzMuY3Jvc3MoZWRnZTEsIHZwMSkpIC8gKDIgKiBhcmVhKTtcbiAgICAvLyBQb2ludCBpcyBpbnNpZGUgdHJpYW5nbGUgaWYgYWxsIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIGFyZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICAvLyBhbmQgdGhlaXIgc3VtIGlzIGFwcHJveGltYXRlbHkgMVxuICAgIGNvbnN0IHN1bSA9IGFscGhhICsgYmV0YSArIGdhbW1hO1xuICAgIGNvbnN0IGlzSW5zaWRlID0gYWxwaGEgPj0gLWNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgIGJldGEgPj0gLWNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgIGdhbW1hID49IC1jb25zdGFudHMuRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhzdW0gLSAxKSA8IGNvbnN0YW50cy5FUFNJTE9OO1xuICAgIC8vIElmIHBvaW50IGlzIGluc2lkZSwgdGhlIGNsb3Nlc3QgcG9pbnQgaXMgdGhlIHByb2plY3RlZCBwb2ludFxuICAgIC8vIElmIHBvaW50IGlzIG91dHNpZGUsIGZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHRyaWFuZ2xlJ3MgZWRnZXNcbiAgICBsZXQgY2xvc2VzdFBvaW50O1xuICAgIGxldCBkaXN0YW5jZTtcbiAgICBpZiAoaXNJbnNpZGUpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50ID0gcHJvamVjdGVkUG9pbnQ7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoc2lnbmVkRGlzdGFuY2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgZGlzdGFuY2VzIHRvIGVhY2ggZWRnZVxuICAgICAgICBjb25zdCBwMSA9IHBvaW50T25MaW5lKHBvaW50LCB7IHN0YXJ0OiB2MSwgZW5kOiB2MiB9KTtcbiAgICAgICAgY29uc3QgcDIgPSBwb2ludE9uTGluZShwb2ludCwgeyBzdGFydDogdjIsIGVuZDogdjMgfSk7XG4gICAgICAgIGNvbnN0IHAzID0gcG9pbnRPbkxpbmUocG9pbnQsIHsgc3RhcnQ6IHYzLCBlbmQ6IHYxIH0pO1xuICAgICAgICAvLyBGaW5kIHRoZSBtaW5pbXVtIGRpc3RhbmNlXG4gICAgICAgIGNvbnN0IG1pbkRpc3QgPSBNYXRoLm1pbihwMS5kaXN0YW5jZSwgcDIuZGlzdGFuY2UsIHAzLmRpc3RhbmNlKTtcbiAgICAgICAgLy8gVXNlIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gdGhlIGVkZ2Ugd2l0aCBtaW5pbXVtIGRpc3RhbmNlXG4gICAgICAgIGlmIChtaW5EaXN0ID09PSBwMS5kaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdFBvaW50ID0gcDEuY2xvc2VzdFBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1pbkRpc3QgPT09IHAyLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBjbG9zZXN0UG9pbnQgPSBwMi5jbG9zZXN0UG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbG9zZXN0UG9pbnQgPSBwMy5jbG9zZXN0UG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlzdGFuY2UgPSBtaW5EaXN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBkaXN0YW5jZSA8IGNvbnN0YW50cy5FUFNJTE9OLFxuICAgICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIHdoaWNoIGdyaWQgY2VsbHMgYSByYXkgdHJhdmVyc2VzXG4gKlxuICogQmFzZWQgb24gXCJBIEZhc3QgVm94ZWwgVHJhdmVyc2FsIEFsZ29yaXRobSBmb3IgUmF5IFRyYWNpbmdcIiBieSBBbWFuYXRpZGVzXG4gKiBhbmQgV29vXG4gKlxuICogV2UgY2FuIG9wdGlvbmFsbHkgbGltaXQgdGhlIG51bWJlciBvZiBjZWxscyB0cmF2ZXJzZWQgYnkgdGhlIHJheSwgb3Igc2V0XG4gKiBtYXhDZWxscyB0byAtMSB0byBjb250aW51ZSB0cmF2ZXJzaW5nIHVudGlsIHRoZSByYXkgZXhpdHMgdGhlIGdyaWQgKG9yIHVudGlsXG4gKiB3ZSBoaXQgdGhlIGhhcmQgbGltaXQgb2YgMTAwMDAgY2VsbHMpLlxuICovXG5mdW5jdGlvbiByYXlUcmF2ZXJzZUdyaWQocmF5LCBjZWxsU2l6ZSwgZ3JpZFRvcExlZnRGcm9udCwgZ3JpZEJvdHRvbVJpZ2h0QmFjaywgbWF4Q2VsbHMgPSAtMSkge1xuICAgIGlmIChjZWxsU2l6ZSA8PSAwKSB7XG4gICAgICAgIHJldHVybiB7IGNlbGxzOiBbXSB9OyAvLyBJbnZhbGlkIGNlbGwgc2l6ZSwgcmV0dXJuIGVtcHR5IGNlbGxzIGFycmF5XG4gICAgfVxuICAgIC8vIFNldCBhIGxpbWl0IG9uIHRoZSBudW1iZXIgb2YgY2VsbHMgdHJhdmVyc2VkXG4gICAgY29uc3QgSEFSRF9MSU1JVCA9IDEwMDAwO1xuICAgIG1heENlbGxzID0gKDAsIHV0aWxzXzEuY2xhbXApKG1heENlbGxzID09PSAtMSA/IEhBUkRfTElNSVQgOiBtYXhDZWxscywgMCwgSEFSRF9MSU1JVCk7XG4gICAgaWYgKG1heENlbGxzIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHsgY2VsbHM6IFtdIH07IC8vIE5vIGNlbGxzIHRvIHRyYXZlcnNlXG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgZ3JpZCBib3VuZGFyaWVzIGFyZSBpbnRlZ2Vyc1xuICAgIGdyaWRUb3BMZWZ0RnJvbnQgPSB2ZWNfMS52ZWMzLm1hcChncmlkVG9wTGVmdEZyb250LCBNYXRoLmZsb29yKTtcbiAgICBncmlkQm90dG9tUmlnaHRCYWNrID0gdmVjXzEudmVjMy5tYXAoZ3JpZEJvdHRvbVJpZ2h0QmFjaywgTWF0aC5jZWlsKTtcbiAgICAvLyBOb3JtYWxpemUgcmF5IGRpcmVjdGlvbiBhbmQgaGFuZGxlIHplcm8gY29tcG9uZW50c1xuICAgIGNvbnN0IHJheURpciA9IHZlY18xLnZlYzMubm9yKHJheS5kaXJlY3Rpb24pO1xuICAgIGlmICgoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykocmF5RGlyKSkge1xuICAgICAgICByZXR1cm4geyBjZWxsczogW10gfTtcbiAgICB9XG4gICAgY29uc3QgY2VsbHMgPSBbXTtcbiAgICAvLyBDYWxjdWxhdGUgaW5pdGlhbCBjZWxsIGNvb3JkaW5hdGVzXG4gICAgbGV0IGN1cnJlbnRDZWxsID0gdmVjXzEudmVjMy5tYXAodmVjXzEudmVjMy5kaXYodmVjXzEudmVjMy5zdWIocmF5Lm9yaWdpbiwgZ3JpZFRvcExlZnRGcm9udCksIGNlbGxTaXplKSwgTWF0aC5mbG9vcik7XG4gICAgLy8gQ2FsY3VsYXRlIGdyaWQgc2l6ZSBpbiBjZWxsc1xuICAgIGNvbnN0IGdyaWRTaXplID0gdmVjXzEudmVjMy5zdWIoZ3JpZEJvdHRvbVJpZ2h0QmFjaywgZ3JpZFRvcExlZnRGcm9udCk7XG4gICAgLy8gSWYgc3RhcnRpbmcgcG9pbnQgaXMgb3V0c2lkZSBncmlkIGJvdW5kcywgZmluZCBlbnRyeSBwb2ludFxuICAgIGlmIChjdXJyZW50Q2VsbC54IDwgMCB8fFxuICAgICAgICBjdXJyZW50Q2VsbC54ID49IGdyaWRTaXplLnggfHxcbiAgICAgICAgY3VycmVudENlbGwueSA8IDAgfHxcbiAgICAgICAgY3VycmVudENlbGwueSA+PSBncmlkU2l6ZS55IHx8XG4gICAgICAgIGN1cnJlbnRDZWxsLnogPCAwIHx8XG4gICAgICAgIGN1cnJlbnRDZWxsLnogPj0gZ3JpZFNpemUueikge1xuICAgICAgICAvLyBVc2UgY3Vib2lkIGludGVyc2VjdGlvbiB0byBmaW5kIGdyaWQgZW50cnkgcG9pbnRcbiAgICAgICAgY29uc3QgZ3JpZEN1Ym9pZCA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWNfMS52ZWMzLmFkZChncmlkVG9wTGVmdEZyb250LCB2ZWNfMS52ZWMzLmRpdih2ZWNfMS52ZWMzLnN1YihncmlkQm90dG9tUmlnaHRCYWNrLCBncmlkVG9wTGVmdEZyb250KSwgMikpLFxuICAgICAgICAgICAgc2l6ZTogdmVjXzEudmVjMy5zdWIoZ3JpZEJvdHRvbVJpZ2h0QmFjaywgZ3JpZFRvcExlZnRGcm9udCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHJheUludGVyc2VjdHNDdWJvaWQocmF5LCBncmlkQ3Vib2lkKTtcbiAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb24uaW50ZXJzZWN0cyB8fCAhaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2VsbHMgfTsgLy8gUmF5IG1pc3NlcyBncmlkIGVudGlyZWx5XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBmaXJzdCBpbnRlcnNlY3Rpb24gcG9pbnQgKGNsb3Nlc3QgdG8gcmF5IG9yaWdpbilcbiAgICAgICAgY29uc3QgZW50cnlQb2ludCA9IGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludHNbMF07XG4gICAgICAgIGN1cnJlbnRDZWxsID0gdmVjXzEudmVjMy5tYXAodmVjXzEudmVjMy5kaXYodmVjXzEudmVjMy5zdWIoZW50cnlQb2ludCwgZ3JpZFRvcExlZnRGcm9udCksIGNlbGxTaXplKSwgTWF0aC5mbG9vcik7XG4gICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IHBvaW50IGlzIHZhbGlkXG4gICAgICAgIGlmIChjdXJyZW50Q2VsbC54IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueCA+PSBncmlkU2l6ZS54IHx8XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC55IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueSA+PSBncmlkU2l6ZS55IHx8XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC56IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueiA+PSBncmlkU2l6ZS56KSB7XG4gICAgICAgICAgICByZXR1cm4geyBjZWxscyB9OyAvLyBObyB2YWxpZCBlbnRyeSBwb2ludCBmb3VuZFxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBzdGVwIGRpcmVjdGlvbiAoZWl0aGVyIDEgb3IgLTEpIGZvciBlYWNoIGF4aXNcbiAgICBjb25zdCBzdGVwID0ge1xuICAgICAgICB4OiBNYXRoLnNpZ24ocmF5RGlyLngpLFxuICAgICAgICB5OiBNYXRoLnNpZ24ocmF5RGlyLnkpLFxuICAgICAgICB6OiBNYXRoLnNpZ24ocmF5RGlyLnopLFxuICAgIH07XG4gICAgLy8gQ2FsY3VsYXRlIHREZWx0YSAtIGRpc3RhbmNlIGFsb25nIHJheSBmcm9tIG9uZSBncmlkIGxpbmUgdG8gbmV4dFxuICAgIGNvbnN0IHREZWx0YSA9IHtcbiAgICAgICAgeDogcmF5RGlyLnggIT09IDAgPyBNYXRoLmFicyhjZWxsU2l6ZSAvIHJheURpci54KSA6IEluZmluaXR5LFxuICAgICAgICB5OiByYXlEaXIueSAhPT0gMCA/IE1hdGguYWJzKGNlbGxTaXplIC8gcmF5RGlyLnkpIDogSW5maW5pdHksXG4gICAgICAgIHo6IHJheURpci56ICE9PSAwID8gTWF0aC5hYnMoY2VsbFNpemUgLyByYXlEaXIueikgOiBJbmZpbml0eSxcbiAgICB9O1xuICAgIC8vIENhbGN1bGF0ZSBpbml0aWFsIGNlbGwgYm91bmRhcnkgcG9zaXRpb25zXG4gICAgY29uc3QgaW5pdGlhbEJvdW5kYXJ5ID0gKDAsIHZlY18xLnZlYzMpKGdyaWRUb3BMZWZ0RnJvbnQueCArIChjdXJyZW50Q2VsbC54ICsgKHN0ZXAueCA+IDAgPyAxIDogMCkpICogY2VsbFNpemUsIGdyaWRUb3BMZWZ0RnJvbnQueSArIChjdXJyZW50Q2VsbC55ICsgKHN0ZXAueSA+IDAgPyAxIDogMCkpICogY2VsbFNpemUsIGdyaWRUb3BMZWZ0RnJvbnQueiArIChjdXJyZW50Q2VsbC56ICsgKHN0ZXAueiA+IDAgPyAxIDogMCkpICogY2VsbFNpemUpO1xuICAgIC8vIENhbGN1bGF0ZSBpbml0aWFsIHRNYXggdmFsdWVzXG4gICAgY29uc3QgdE1heCA9IHtcbiAgICAgICAgeDogcmF5RGlyLnggIT09IDBcbiAgICAgICAgICAgID8gTWF0aC5hYnMoKGluaXRpYWxCb3VuZGFyeS54IC0gcmF5Lm9yaWdpbi54KSAvIHJheURpci54KVxuICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgeTogcmF5RGlyLnkgIT09IDBcbiAgICAgICAgICAgID8gTWF0aC5hYnMoKGluaXRpYWxCb3VuZGFyeS55IC0gcmF5Lm9yaWdpbi55KSAvIHJheURpci55KVxuICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgejogcmF5RGlyLnogIT09IDBcbiAgICAgICAgICAgID8gTWF0aC5hYnMoKGluaXRpYWxCb3VuZGFyeS56IC0gcmF5Lm9yaWdpbi56KSAvIHJheURpci56KVxuICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICB9O1xuICAgIC8vIElmIHdlJ3JlIGV4YWN0bHkgb24gYSBib3VuZGFyeSwgd2UgbmVlZCB0byBhZGp1c3QgdE1heFxuICAgIGlmIChNYXRoLmFicyhyYXkub3JpZ2luLnggLSBpbml0aWFsQm91bmRhcnkueCkgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICB0TWF4LnggPSB0RGVsdGEueDtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHJheS5vcmlnaW4ueSAtIGluaXRpYWxCb3VuZGFyeS55KSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIHRNYXgueSA9IHREZWx0YS55O1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMocmF5Lm9yaWdpbi56IC0gaW5pdGlhbEJvdW5kYXJ5LnopIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgdE1heC56ID0gdERlbHRhLno7XG4gICAgfVxuICAgIC8vIEFkZCBzdGFydGluZyBjZWxsXG4gICAgY2VsbHMucHVzaCgoMCwgdmVjXzEudmVjMykoY3VycmVudENlbGwueCwgY3VycmVudENlbGwueSwgY3VycmVudENlbGwueikpO1xuICAgIGxldCBjZWxsQ291bnQgPSAxO1xuICAgIC8vIE1haW4gbG9vcFxuICAgIHdoaWxlIChjZWxsQ291bnQgPCBtYXhDZWxscyAmJlxuICAgICAgICBjdXJyZW50Q2VsbC54ID49IDAgJiZcbiAgICAgICAgY3VycmVudENlbGwueCA8IGdyaWRTaXplLnggJiZcbiAgICAgICAgY3VycmVudENlbGwueSA+PSAwICYmXG4gICAgICAgIGN1cnJlbnRDZWxsLnkgPCBncmlkU2l6ZS55ICYmXG4gICAgICAgIGN1cnJlbnRDZWxsLnogPj0gMCAmJlxuICAgICAgICBjdXJyZW50Q2VsbC56IDwgZ3JpZFNpemUueikge1xuICAgICAgICAvLyBBZHZhbmNlIHRvIG5leHQgY2VsbCBiYXNlZCBvbiBzaG9ydGVzdCB0TWF4XG4gICAgICAgIGlmICh0TWF4LnggPCB0TWF4LnkgJiYgdE1heC54IDwgdE1heC56KSB7XG4gICAgICAgICAgICB0TWF4LnggKz0gdERlbHRhLng7XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC54ICs9IHN0ZXAueDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0TWF4LnkgPCB0TWF4LnopIHtcbiAgICAgICAgICAgIHRNYXgueSArPSB0RGVsdGEueTtcbiAgICAgICAgICAgIGN1cnJlbnRDZWxsLnkgKz0gc3RlcC55O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdE1heC56ICs9IHREZWx0YS56O1xuICAgICAgICAgICAgY3VycmVudENlbGwueiArPSBzdGVwLno7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgc3RpbGwgaW4gYm91bmRzXG4gICAgICAgIGlmIChjdXJyZW50Q2VsbC54IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueCA+PSBncmlkU2l6ZS54IHx8XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC55IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueSA+PSBncmlkU2l6ZS55IHx8XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC56IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueiA+PSBncmlkU2l6ZS56KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgY3VycmVudCBjZWxsXG4gICAgICAgIGNlbGxzLnB1c2goKDAsIHZlY18xLnZlYzMpKGN1cnJlbnRDZWxsLngsIGN1cnJlbnRDZWxsLnksIGN1cnJlbnRDZWxsLnopKTtcbiAgICAgICAgY2VsbENvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiB7IGNlbGxzIH07XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byByYXlzIGludGVyc2VjdFxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzUmF5KHJheUEsIHJheUIpIHtcbiAgICAvLyBOb3JtYWxpemUgcmF5IGRpcmVjdGlvbnNcbiAgICBjb25zdCBkaXJBID0gdmVjXzEudmVjMy5ub3IocmF5QS5kaXJlY3Rpb24pO1xuICAgIGNvbnN0IGRpckIgPSB2ZWNfMS52ZWMzLm5vcihyYXlCLmRpcmVjdGlvbik7XG4gICAgLy8gSWYgZWl0aGVyIHJheSBoYXMgemVybyBkaXJlY3Rpb24sIHRoZXkgY2Fubm90IGludGVyc2VjdFxuICAgIGlmICgoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykoZGlyQSkgfHwgKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKGRpckIpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHZlY3RvciBiZXR3ZWVuIHJheSBvcmlnaW5zXG4gICAgY29uc3Qgb3JpZ2luRGlmZiA9IHZlY18xLnZlYzMuc3ViKHJheUIub3JpZ2luLCByYXlBLm9yaWdpbik7XG4gICAgLy8gQ2FsY3VsYXRlIHRyaXBsZSBwcm9kdWN0c1xuICAgIGNvbnN0IG5vcm1hbCA9IHZlY18xLnZlYzMuY3Jvc3MoZGlyQSwgZGlyQik7XG4gICAgY29uc3Qgbm9ybWFsTGVuZ3RoU3EgPSB2ZWNfMS52ZWMzLmRvdChub3JtYWwsIG5vcm1hbCk7XG4gICAgLy8gSWYgbm9ybWFsIGlzIHplcm8sIHJheXMgYXJlIHBhcmFsbGVsXG4gICAgaWYgKG5vcm1hbExlbmd0aFNxIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcmF5cyBhcmUgY29pbmNpZGVudFxuICAgICAgICBjb25zdCBjcm9zc09yaWdpbnMgPSB2ZWNfMS52ZWMzLmNyb3NzKG9yaWdpbkRpZmYsIGRpckEpO1xuICAgICAgICBpZiAodmVjXzEudmVjMy5sZW4oY3Jvc3NPcmlnaW5zKSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgICAgICAvLyBSYXlzIGFyZSBjb2luY2lkZW50IC0gcmV0dXJuIHBvaW50IG9uIHJheUEgY2xvc2VzdCB0byByYXlCLm9yaWdpblxuICAgICAgICAgICAgY29uc3QgdCA9IHZlY18xLnZlYzMuZG90KG9yaWdpbkRpZmYsIGRpckEpO1xuICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50OiB2ZWNfMS52ZWMzLmFkZChyYXlBLm9yaWdpbiwgdmVjXzEudmVjMy5tdWwoZGlyQSwgdCkpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHBhcmFtZXRlcnMgZm9yIGNsb3Nlc3QgcG9pbnRzXG4gICAgY29uc3QgYzEgPSB2ZWNfMS52ZWMzLmRvdChvcmlnaW5EaWZmLCB2ZWNfMS52ZWMzLmNyb3NzKGRpckIsIG5vcm1hbCkpIC8gbm9ybWFsTGVuZ3RoU3E7XG4gICAgY29uc3QgYzIgPSB2ZWNfMS52ZWMzLmRvdChvcmlnaW5EaWZmLCB2ZWNfMS52ZWMzLmNyb3NzKGRpckEsIG5vcm1hbCkpIC8gbm9ybWFsTGVuZ3RoU3E7XG4gICAgLy8gSWYgZWl0aGVyIHBhcmFtZXRlciBpcyBuZWdhdGl2ZSwgY2xvc2VzdCBwb2ludHMgYXJlIGJlaGluZCByYXkgb3JpZ2luc1xuICAgIGlmIChjMSA8IDAgfHwgYzIgPCAwKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBjbG9zZXN0IHBvaW50cyBvbiBlYWNoIHJheVxuICAgIGNvbnN0IHBvaW50QSA9IHZlY18xLnZlYzMuYWRkKHJheUEub3JpZ2luLCB2ZWNfMS52ZWMzLm11bChkaXJBLCBjMSkpO1xuICAgIGNvbnN0IHBvaW50QiA9IHZlY18xLnZlYzMuYWRkKHJheUIub3JpZ2luLCB2ZWNfMS52ZWMzLm11bChkaXJCLCBjMikpO1xuICAgIC8vIENoZWNrIGlmIHBvaW50cyBhcmUgY2xvc2UgZW5vdWdoIHRvIGNvbnNpZGVyIGludGVyc2VjdGlvblxuICAgIGNvbnN0IGRpc3RhbmNlID0gdmVjXzEudmVjMy5sZW4odmVjXzEudmVjMy5zdWIocG9pbnRBLCBwb2ludEIpKTtcbiAgICBpZiAoZGlzdGFuY2UgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICAvLyBVc2UgbWlkcG9pbnQgYXMgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQ6IHZlY18xLnZlYzMuYWRkKHBvaW50QSwgdmVjXzEudmVjMy5tdWwodmVjXzEudmVjMy5zdWIocG9pbnRCLCBwb2ludEEpLCAwLjUpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSByYXkgaW50ZXJzZWN0cyBhIGxpbmUgc2VnbWVudFxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzTGluZShyYXksIGxpbmUpIHtcbiAgICAvLyBDb252ZXJ0IGxpbmUgdG8gYSBkaXJlY3Rpb24gdmVjdG9yXG4gICAgbGV0IGxpbmVEaXIgPSB2ZWNfMS52ZWMzLnN1YihsaW5lLmVuZCwgbGluZS5zdGFydCk7XG4gICAgY29uc3QgbGluZUxlbmd0aCA9IHZlY18xLnZlYzMubGVuKGxpbmVEaXIpO1xuICAgIC8vIElmIHRoZSBsaW5lIGhhcyB6ZXJvIGxlbmd0aCwgaXQgY2Fubm90IGludGVyc2VjdFxuICAgIGlmIChsaW5lTGVuZ3RoIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgcmF5IGFuZCBsaW5lIGRpcmVjdGlvbnNcbiAgICBjb25zdCByYXlEaXIgPSB2ZWNfMS52ZWMzLm5vcihyYXkuZGlyZWN0aW9uKTtcbiAgICBsaW5lRGlyID0gdmVjXzEudmVjMy5kaXYobGluZURpciwgbGluZUxlbmd0aCk7IC8vIE5vcm1hbGl6ZSBsaW5lIGRpcmVjdGlvblxuICAgIC8vIENhbGN1bGF0ZSB2ZWN0b3IgYmV0d2VlbiByYXkgb3JpZ2luIGFuZCBsaW5lIHN0YXJ0XG4gICAgY29uc3Qgc3RhcnREaWZmID0gdmVjXzEudmVjMy5zdWIobGluZS5zdGFydCwgcmF5Lm9yaWdpbik7XG4gICAgLy8gQ2FsY3VsYXRlIHRyaXBsZSBwcm9kdWN0c1xuICAgIGNvbnN0IG5vcm1hbCA9IHZlY18xLnZlYzMuY3Jvc3MocmF5RGlyLCBsaW5lRGlyKTtcbiAgICBjb25zdCBub3JtYWxMZW5ndGhTcSA9IHZlY18xLnZlYzMuZG90KG5vcm1hbCwgbm9ybWFsKTtcbiAgICAvLyBJZiBub3JtYWwgaXMgemVybywgcmF5IGFuZCBsaW5lIGFyZSBwYXJhbGxlbFxuICAgIGlmIChub3JtYWxMZW5ndGhTcSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXkgYXJlIGNvbGxpbmVhclxuICAgICAgICBjb25zdCBjcm9zc09yaWdpbnMgPSB2ZWNfMS52ZWMzLmNyb3NzKHN0YXJ0RGlmZiwgcmF5RGlyKTtcbiAgICAgICAgaWYgKHZlY18xLnZlYzMubGVuKGNyb3NzT3JpZ2lucykgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICAgICAgLy8gVGhleSBhcmUgY29sbGluZWFyIC0gZmluZCBjbG9zZXN0IHBvaW50IG9uIGxpbmUgdG8gcmF5IG9yaWdpblxuICAgICAgICAgICAgY29uc3QgdCA9IHZlY18xLnZlYzMuZG90KHN0YXJ0RGlmZiwgbGluZURpcik7XG4gICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50OiB2ZWNfMS52ZWMzLmFkZChsaW5lLnN0YXJ0LCB2ZWNfMS52ZWMzLm11bChsaW5lRGlyLCB0KSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgcGFyYW1ldGVycyBmb3IgY2xvc2VzdCBwb2ludHNcbiAgICBjb25zdCBjMSA9IHZlY18xLnZlYzMuZG90KHN0YXJ0RGlmZiwgdmVjXzEudmVjMy5jcm9zcyhsaW5lRGlyLCBub3JtYWwpKSAvIG5vcm1hbExlbmd0aFNxO1xuICAgIGNvbnN0IGMyID0gdmVjXzEudmVjMy5kb3Qoc3RhcnREaWZmLCB2ZWNfMS52ZWMzLmNyb3NzKHJheURpciwgbm9ybWFsKSkgLyBub3JtYWxMZW5ndGhTcTtcbiAgICAvLyBDaGVjayBpZiBpbnRlcnNlY3Rpb24gb2NjdXJzIG9uIHJheSBhbmQgd2l0aGluIGxpbmUgc2VnbWVudCBib3VuZHNcbiAgICBpZiAoYzEgPj0gMCAmJiBjMiA+PSAwICYmIGMyIDw9IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNsb3Nlc3QgcG9pbnRzXG4gICAgICAgIGNvbnN0IHBvaW50T25SYXkgPSB2ZWNfMS52ZWMzLmFkZChyYXkub3JpZ2luLCB2ZWNfMS52ZWMzLm11bChyYXlEaXIsIGMxKSk7XG4gICAgICAgIGNvbnN0IHBvaW50T25MaW5lID0gdmVjXzEudmVjMy5hZGQobGluZS5zdGFydCwgdmVjXzEudmVjMy5tdWwobGluZURpciwgYzIpKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcG9pbnRzIGFyZSBjbG9zZSBlbm91Z2ggdG8gY29uc2lkZXIgaW50ZXJzZWN0aW9uXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdmVjXzEudmVjMy5sZW4odmVjXzEudmVjMy5zdWIocG9pbnRPblJheSwgcG9pbnRPbkxpbmUpKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgIC8vIFVzZSBtaWRwb2ludCBhcyBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludDogdmVjXzEudmVjMy5hZGQocG9pbnRPblJheSwgdmVjXzEudmVjMy5tdWwodmVjXzEudmVjMy5zdWIocG9pbnRPbkxpbmUsIHBvaW50T25SYXkpLCAwLjUpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSByYXkgaW50ZXJzZWN0cyBhIHNwaGVyZVxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzU3BoZXJlKHJheSwgc3BoZXJlKSB7XG4gICAgLy8gTm9ybWFsaXplIHJheSBkaXJlY3Rpb25cbiAgICBjb25zdCByYXlEaXIgPSB2ZWNfMS52ZWMzLm5vcihyYXkuZGlyZWN0aW9uKTtcbiAgICAvLyBDYWxjdWxhdGUgdmVjdG9yIGZyb20gcmF5IG9yaWdpbiB0byBzcGhlcmUgY2VudGVyXG4gICAgY29uc3QgdG9DZW50ZXIgPSB2ZWNfMS52ZWMzLnN1YihzcGhlcmUucG9zaXRpb24sIHJheS5vcmlnaW4pO1xuICAgIC8vIENhbGN1bGF0ZSBxdWFkcmF0aWMgZXF1YXRpb24gY29lZmZpY2llbnRzXG4gICAgLy8gYSA9IGRvdChkaXIsIGRpcikgKHNob3VsZCBiZSAxIHNpbmNlIGRpciBpcyBub3JtYWxpemVkKVxuICAgIGNvbnN0IGEgPSB2ZWNfMS52ZWMzLmRvdChyYXlEaXIsIHJheURpcik7XG4gICAgLy8gYiA9IDIgKiBkb3QoZGlyLCAob3JpZ2luIC0gY2VudGVyKSlcbiAgICBjb25zdCBiID0gMiAqIHZlY18xLnZlYzMuZG90KHJheURpciwgdmVjXzEudmVjMy5tdWwodG9DZW50ZXIsIC0xKSk7XG4gICAgLy8gYyA9IGRvdCgob3JpZ2luIC0gY2VudGVyKSwgKG9yaWdpbiAtIGNlbnRlcikpIC0gcmFkaXVzwrJcbiAgICBjb25zdCBjID0gdmVjXzEudmVjMy5kb3QodG9DZW50ZXIsIHRvQ2VudGVyKSAtIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuICAgIC8vIFNvbHZlIHF1YWRyYXRpYyBlcXVhdGlvbiB1c2luZyBkaXNjcmltaW5hbnRcbiAgICBjb25zdCBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcbiAgICAvLyBObyBpbnRlcnNlY3Rpb24gaWYgZGlzY3JpbWluYW50IGlzIG5lZ2F0aXZlXG4gICAgaWYgKGRpc2NyaW1pbmFudCA8IC1jb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSByYXkganVzdCB0b3VjaGVzIHNwaGVyZSAoZGlzY3JpbWluYW50IOKJiCAwKVxuICAgIGlmIChNYXRoLmFicyhkaXNjcmltaW5hbnQpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgY29uc3QgdCA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB2ZWNfMS52ZWMzLmFkZChyYXkub3JpZ2luLCB2ZWNfMS52ZWMzLm11bChyYXlEaXIsIHQpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IFtwb2ludF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGZvciBkaXNjcmltaW5hbnQgPiAwXG4gICAgY29uc3Qgc3FydERpc2NyaW1pbmFudCA9IE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIGNvbnN0IHQxID0gKC1iIC0gc3FydERpc2NyaW1pbmFudCkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHQyID0gKC1iICsgc3FydERpc2NyaW1pbmFudCkgLyAoMiAqIGEpO1xuICAgIC8vIElmIGJvdGggdCB2YWx1ZXMgYXJlIG5lZ2F0aXZlLCByYXkgcG9pbnRzIGF3YXkgZnJvbSBzcGhlcmVcbiAgICBpZiAodDIgPCAwKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGZvciBwb3NpdGl2ZSB0IHZhbHVlc1xuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIGlmICh0MSA+PSAwKSB7XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHZlY18xLnZlYzMuYWRkKHJheS5vcmlnaW4sIHZlY18xLnZlYzMubXVsKHJheURpciwgdDEpKSk7XG4gICAgfVxuICAgIGlmICh0MiA+PSAwKSB7XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHZlY18xLnZlYzMuYWRkKHJheS5vcmlnaW4sIHZlY18xLnZlYzMubXVsKHJheURpciwgdDIpKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcmF5IGludGVyc2VjdHMgYSBwbGFuZVxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzUGxhbmUocmF5LCBwbGFuZSkge1xuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcmF5IGRpcmVjdGlvbiBhbmQgcGxhbmUgbm9ybWFsXG4gICAgY29uc3QgcmF5RGlyID0gdmVjXzEudmVjMy5ub3IocmF5LmRpcmVjdGlvbik7XG4gICAgY29uc3QgcGxhbmVOb3JtYWwgPSB2ZWNfMS52ZWMzLm5vcihwbGFuZS5ub3JtYWwpO1xuICAgIC8vIENhbGN1bGF0ZSBkZW5vbWluYXRvciAoZG90IHByb2R1Y3Qgb2YgcmF5IGRpcmVjdGlvbiBhbmQgcGxhbmUgbm9ybWFsKVxuICAgIGNvbnN0IGRlbm9taW5hdG9yID0gdmVjXzEudmVjMy5kb3QocmF5RGlyLCBwbGFuZU5vcm1hbCk7XG4gICAgLy8gSWYgZGVub21pbmF0b3IgaXMgY2xvc2UgdG8gMCwgcmF5IGlzIHBhcmFsbGVsIHRvIHBsYW5lXG4gICAgaWYgKE1hdGguYWJzKGRlbm9taW5hdG9yKSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSByYXkgbGllcyBpbiB0aGUgcGxhbmUgKG9yaWdpbiBpcyBvbiB0aGUgcGxhbmUpXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9QbGFuZSA9IHZlY18xLnZlYzMuZG90KHZlY18xLnZlYzMuc3ViKHJheS5vcmlnaW4sIHBsYW5lLnBvaW50KSwgcGxhbmVOb3JtYWwpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2VUb1BsYW5lKSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgICAgICAvLyBSYXkgbGllcyBpbiB0aGUgcGxhbmU6IGluZmluaXRlIGludGVyc2VjdGlvbiBwb2ludHNcbiAgICAgICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSYXkgaXMgcGFyYWxsZWwgYW5kIG5vdCBvbiB0aGUgcGxhbmVcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gcmF5IG9yaWdpbiB0byBwbGFuZVxuICAgIGNvbnN0IHQgPSB2ZWNfMS52ZWMzLmRvdCh2ZWNfMS52ZWMzLnN1YihwbGFuZS5wb2ludCwgcmF5Lm9yaWdpbiksIHBsYW5lTm9ybWFsKSAvIGRlbm9taW5hdG9yO1xuICAgIC8vIElmIHQgaXMgbmVnYXRpdmUsIGludGVyc2VjdGlvbiBpcyBiZWhpbmQgcmF5IG9yaWdpblxuICAgIGlmICh0IDwgMCkge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnQgPSB2ZWNfMS52ZWMzLmFkZChyYXkub3JpZ2luLCB2ZWNfMS52ZWMzLm11bChyYXlEaXIsIHQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHJheSBpbnRlcnNlY3RzIGEgY3Vib2lkXG4gKi9cbmZ1bmN0aW9uIHJheUludGVyc2VjdHNDdWJvaWQocmF5LCBjdWJvaWQpIHtcbiAgICAvLyBOb3JtYWxpemUgcmF5IGRpcmVjdGlvblxuICAgIGNvbnN0IHJheURpciA9IHZlY18xLnZlYzMubm9yKHJheS5kaXJlY3Rpb24pO1xuICAgIC8vIEV4dHJhY3QgY3Vib2lkIHByb3BlcnRpZXMgd2l0aCBkZWZhdWx0IHJvdGF0aW9uXG4gICAgY29uc3QgeyBwb3NpdGlvbiwgc2l6ZSwgcm90YXRpb24gPSAoMCwgdmVjXzEudmVjMykoKSB9ID0gY3Vib2lkO1xuICAgIC8vIFRyYW5zZm9ybSByYXkgdG8gbG9jYWwgc3BhY2UgaWYgY3Vib2lkIGlzIHJvdGF0ZWRcbiAgICBsZXQgbG9jYWxSYXlPcmlnaW4gPSB2ZWNfMS52ZWMzLnN1YihyYXkub3JpZ2luLCBwb3NpdGlvbik7XG4gICAgbGV0IGxvY2FsUmF5RGlyID0gcmF5RGlyO1xuICAgIGlmIChjdWJvaWRJc1JvdGF0ZWQoY3Vib2lkKSkge1xuICAgICAgICAvLyBVbmRvIHJvdGF0aW9uIGJ5IGFwcGx5aW5nIGludmVyc2Ugcm90YXRpb24gdG8gcmF5XG4gICAgICAgIGNvbnN0IGludmVyc2VSb3RhdGlvbiA9IHZlY18xLnZlYzMubXVsKHJvdGF0aW9uLCAtMSk7XG4gICAgICAgIGxvY2FsUmF5T3JpZ2luID0gdmVjXzEudmVjMy5yb3RhKGxvY2FsUmF5T3JpZ2luLCBpbnZlcnNlUm90YXRpb24pO1xuICAgICAgICBsb2NhbFJheURpciA9IHZlY18xLnZlYzMucm90YShsb2NhbFJheURpciwgaW52ZXJzZVJvdGF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgaGFsZlNpemUgPSB2ZWNfMS52ZWMzLmRpdihzaXplLCAyKTtcbiAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHdpdGggZWFjaCBwYWlyIG9mIHBhcmFsbGVsIHBsYW5lc1xuICAgIGNvbnN0IHR4TWluID0gdmVjXzEudmVjMy5kaXYodmVjXzEudmVjMy5zdWIodmVjXzEudmVjMy5tdWwoaGFsZlNpemUsIC0xKSwgbG9jYWxSYXlPcmlnaW4pLCBsb2NhbFJheURpcik7XG4gICAgY29uc3QgdHhNYXggPSB2ZWNfMS52ZWMzLmRpdih2ZWNfMS52ZWMzLnN1YihoYWxmU2l6ZSwgbG9jYWxSYXlPcmlnaW4pLCBsb2NhbFJheURpcik7XG4gICAgLy8gRmluZCB0aGUgZmFydGhlc3QgbmVhciBpbnRlcnNlY3Rpb24gYW5kIHRoZSBjbG9zZXN0IGZhciBpbnRlcnNlY3Rpb25cbiAgICBjb25zdCB0TmVhciA9ICgwLCB2ZWNfMS52ZWMzKShNYXRoLm1pbih0eE1pbi54LCB0eE1heC54KSwgTWF0aC5taW4odHhNaW4ueSwgdHhNYXgueSksIE1hdGgubWluKHR4TWluLnosIHR4TWF4LnopKTtcbiAgICBjb25zdCB0RmFyID0gKDAsIHZlY18xLnZlYzMpKE1hdGgubWF4KHR4TWluLngsIHR4TWF4LngpLCBNYXRoLm1heCh0eE1pbi55LCB0eE1heC55KSwgTWF0aC5tYXgodHhNaW4ueiwgdHhNYXgueikpO1xuICAgIC8vIElmIHRoZSBsYXJnZXN0IHROZWFyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc21hbGxlc3QgdEZhciwgdGhlcmUgaXMgbm9cbiAgICAvLyBpbnRlcnNlY3Rpb25cbiAgICBjb25zdCB0TWluID0gTWF0aC5tYXgodE5lYXIueCwgdE5lYXIueSwgdE5lYXIueik7XG4gICAgY29uc3QgdE1heCA9IE1hdGgubWluKHRGYXIueCwgdEZhci55LCB0RmFyLnopO1xuICAgIGlmICh0TWluID4gdE1heCB8fCB0TWF4IDwgMCkge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIEFkZCBlbnRyeSBwb2ludCBpZiBpdCdzIGluIGZyb250IG9mIHJheSBvcmlnaW5cbiAgICBpZiAodE1pbiA+PSAwKSB7XG4gICAgICAgIGxldCBwb2ludCA9IHZlY18xLnZlYzMuYWRkKGxvY2FsUmF5T3JpZ2luLCB2ZWNfMS52ZWMzLm11bChsb2NhbFJheURpciwgdE1pbikpO1xuICAgICAgICBpZiAoY3Vib2lkSXNSb3RhdGVkKGN1Ym9pZCkpIHtcbiAgICAgICAgICAgIHBvaW50ID0gdmVjXzEudmVjMy5yb3RhKHBvaW50LCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2godmVjXzEudmVjMy5hZGQocG9zaXRpb24sIHBvaW50KSk7XG4gICAgfVxuICAgIC8vIEFkZCBleGl0IHBvaW50IGlmIGRpZmZlcmVudCBmcm9tIGVudHJ5IHBvaW50XG4gICAgaWYgKHRNYXggPiB0TWluICYmIHRNYXggPj0gMCkge1xuICAgICAgICBsZXQgcG9pbnQgPSB2ZWNfMS52ZWMzLmFkZChsb2NhbFJheU9yaWdpbiwgdmVjXzEudmVjMy5tdWwobG9jYWxSYXlEaXIsIHRNYXgpKTtcbiAgICAgICAgaWYgKGN1Ym9pZElzUm90YXRlZChjdWJvaWQpKSB7XG4gICAgICAgICAgICBwb2ludCA9IHZlY18xLnZlYzMucm90YShwb2ludCwgcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHZlY18xLnZlYzMuYWRkKHBvc2l0aW9uLCBwb2ludCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCA/IGludGVyc2VjdGlvblBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHJheSBpbnRlcnNlY3RzIGEgcG9seWdvblxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzUG9seWdvbihyYXksIHBvbHlnb24pIHtcbiAgICAvLyBGaXJzdCB2YWxpZGF0ZSB0aGUgcG9seWdvblxuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcGxhbmUgb2YgdGhlIHBvbHlnb25cbiAgICBjb25zdCBbdjEsIHYyLCB2M10gPSBwb2x5Z29uLnZlcnRpY2VzO1xuICAgIGNvbnN0IGVkZ2UxID0gdmVjXzEudmVjMy5zdWIodjIsIHYxKTtcbiAgICBjb25zdCBlZGdlMiA9IHZlY18xLnZlYzMuc3ViKHYzLCB2MSk7XG4gICAgY29uc3Qgbm9ybWFsID0gdmVjXzEudmVjMy5ub3IodmVjXzEudmVjMy5jcm9zcyhlZGdlMSwgZWRnZTIpKTtcbiAgICAvLyBDcmVhdGUgYSBwbGFuZSBmcm9tIHRoZSBwb2x5Z29uXG4gICAgY29uc3QgcGxhbmUgPSB7XG4gICAgICAgIHBvaW50OiB2MSxcbiAgICAgICAgbm9ybWFsLFxuICAgIH07XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJheSBpbnRlcnNlY3RzIHRoZSBwbGFuZVxuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHJheUludGVyc2VjdHNQbGFuZShyYXksIHBsYW5lKTtcbiAgICBpZiAoIWludGVyc2VjdGlvbi5pbnRlcnNlY3RzIHx8ICFpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGludGVyc2VjdGlvbiBwb2ludCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbiAgICBjb25zdCBwb2ludENoZWNrID0gcG9pbnRPblBvbHlnb24oaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50LCBwb2x5Z29uKTtcbiAgICBpZiAoIXBvaW50Q2hlY2sgfHwgIXBvaW50Q2hlY2suaW50ZXJzZWN0cykge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludDogaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50LFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcmF5IGludGVyc2VjdHMgYW55IG9mIHRoZSBwb2x5Z29ucyBpbiBhIG1lc2hcbiAqL1xuZnVuY3Rpb24gcmF5SW50ZXJzZWN0c01lc2gocmF5LCBtZXNoKSB7XG4gICAgY29uc3QgcG9seWdvbnMgPSBtZXNoVG9Qb2x5Z29ucyhtZXNoKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICBwb2x5Z29ucy5mb3JFYWNoKHBvbHlnb24gPT4ge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSByYXlJbnRlcnNlY3RzUG9seWdvbihyYXksIHBvbHlnb24pO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgPyBpbnRlcnNlY3Rpb25Qb2ludHMgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyBhIHJheVxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c1JheShsaW5lLCByYXkpIHtcbiAgICByZXR1cm4gcmF5SW50ZXJzZWN0c0xpbmUocmF5LCBsaW5lKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0XG4gKi9cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzTGluZShsaW5lQSwgbGluZUIpIHtcbiAgICAvLyBDb252ZXJ0IGxpbmVzIHRvIGRpcmVjdGlvbiB2ZWN0b3JzXG4gICAgY29uc3QgZGlyQSA9IHZlY18xLnZlYzMuc3ViKGxpbmVBLmVuZCwgbGluZUEuc3RhcnQpO1xuICAgIGNvbnN0IGRpckIgPSB2ZWNfMS52ZWMzLnN1YihsaW5lQi5lbmQsIGxpbmVCLnN0YXJ0KTtcbiAgICAvLyBHZXQgbGluZSBsZW5ndGhzXG4gICAgY29uc3QgbGVuZ3RoQSA9IHZlY18xLnZlYzMubGVuKGRpckEpO1xuICAgIGNvbnN0IGxlbmd0aEIgPSB2ZWNfMS52ZWMzLmxlbihkaXJCKTtcbiAgICAvLyBJZiBlaXRoZXIgbGluZSBoYXMgemVybyBsZW5ndGgsIHRoZXkgY2Fubm90IGludGVyc2VjdFxuICAgIGlmIChsZW5ndGhBIDwgY29uc3RhbnRzLkVQU0lMT04gfHwgbGVuZ3RoQiA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBkaXJlY3Rpb25zXG4gICAgY29uc3Qgbm9ybUEgPSB2ZWNfMS52ZWMzLmRpdihkaXJBLCBsZW5ndGhBKTtcbiAgICBjb25zdCBub3JtQiA9IHZlY18xLnZlYzMuZGl2KGRpckIsIGxlbmd0aEIpO1xuICAgIC8vIENhbGN1bGF0ZSB2ZWN0b3IgYmV0d2VlbiBsaW5lIHN0YXJ0c1xuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IHZlY18xLnZlYzMuc3ViKGxpbmVCLnN0YXJ0LCBsaW5lQS5zdGFydCk7XG4gICAgLy8gQ2FsY3VsYXRlIGNyb3NzIHByb2R1Y3Qgb2YgZGlyZWN0aW9uc1xuICAgIGNvbnN0IG5vcm1hbCA9IHZlY18xLnZlYzMuY3Jvc3Mobm9ybUEsIG5vcm1CKTtcbiAgICBjb25zdCBub3JtYWxMZW5ndGhTcSA9IHZlY18xLnZlYzMuZG90KG5vcm1hbCwgbm9ybWFsKTtcbiAgICAvLyBJZiBub3JtYWwgaXMgemVybywgbGluZXMgYXJlIHBhcmFsbGVsXG4gICAgaWYgKG5vcm1hbExlbmd0aFNxIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgY29sbGluZWFyXG4gICAgICAgIGNvbnN0IGNyb3NzU3RhcnRzID0gdmVjXzEudmVjMy5jcm9zcyhzdGFydERpZmYsIG5vcm1BKTtcbiAgICAgICAgaWYgKHZlY18xLnZlYzMubGVuKGNyb3NzU3RhcnRzKSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgICAgICAvLyBUaGV5IGFyZSBjb2xsaW5lYXIgLSBjaGVjayBmb3Igb3ZlcmxhcFxuICAgICAgICAgICAgY29uc3QgdDAgPSB2ZWNfMS52ZWMzLmRvdChzdGFydERpZmYsIG5vcm1BKTtcbiAgICAgICAgICAgIGNvbnN0IHQxID0gdDAgKyB2ZWNfMS52ZWMzLmRvdChkaXJCLCBub3JtQSk7XG4gICAgICAgICAgICAvLyBGaW5kIG92ZXJsYXAgaW50ZXJ2YWxcbiAgICAgICAgICAgIGNvbnN0IHRNaW4gPSBNYXRoLm1pbih0MCwgdDEpO1xuICAgICAgICAgICAgY29uc3QgdE1heCA9IE1hdGgubWF4KHQwLCB0MSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBsaW5lcyBvdmVybGFwXG4gICAgICAgICAgICBpZiAodE1pbiA8PSBsZW5ndGhBICYmIHRNYXggPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcG9pbnQgYXQgbWlkZGxlIG9mIG92ZXJsYXBcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gKDAsIHV0aWxzXzEuY2xhbXApKDAsIE1hdGgubWF4KDAsIHRNaW4pLCBsZW5ndGhBKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludDogdmVjXzEudmVjMy5hZGQobGluZUEuc3RhcnQsIHZlY18xLnZlYzMubXVsKG5vcm1BLCB0KSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgcGFyYW1ldGVycyBmb3IgY2xvc2VzdCBwb2ludHNcbiAgICBjb25zdCBjMSA9IHZlY18xLnZlYzMuZG90KHN0YXJ0RGlmZiwgdmVjXzEudmVjMy5jcm9zcyhkaXJCLCBub3JtYWwpKSAvIG5vcm1hbExlbmd0aFNxO1xuICAgIGNvbnN0IGMyID0gdmVjXzEudmVjMy5kb3Qoc3RhcnREaWZmLCB2ZWNfMS52ZWMzLmNyb3NzKGRpckEsIG5vcm1hbCkpIC8gbm9ybWFsTGVuZ3RoU3E7XG4gICAgLy8gQ2hlY2sgaWYgY2xvc2VzdCBwb2ludHMgbGllIHdpdGhpbiBsaW5lIHNlZ21lbnRzXG4gICAgaWYgKGMxID49IDAgJiYgYzEgPD0gbGVuZ3RoQSAmJiBjMiA+PSAwICYmIGMyIDw9IGxlbmd0aEIpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNsb3Nlc3QgcG9pbnRzXG4gICAgICAgIGNvbnN0IHBvaW50T25BID0gdmVjXzEudmVjMy5hZGQobGluZUEuc3RhcnQsIHZlY18xLnZlYzMubXVsKG5vcm1BLCBjMSkpO1xuICAgICAgICBjb25zdCBwb2ludE9uQiA9IHZlY18xLnZlYzMuYWRkKGxpbmVCLnN0YXJ0LCB2ZWNfMS52ZWMzLm11bChub3JtQiwgYzIpKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcG9pbnRzIGFyZSBjbG9zZSBlbm91Z2ggdG8gY29uc2lkZXIgaW50ZXJzZWN0aW9uXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdmVjXzEudmVjMy5sZW4odmVjXzEudmVjMy5zdWIocG9pbnRPbkEsIHBvaW50T25CKSk7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgICAgICAvLyBVc2UgbWlkcG9pbnQgYXMgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQ6IHZlY18xLnZlYzMuYWRkKHBvaW50T25BLCB2ZWNfMS52ZWMzLm11bCh2ZWNfMS52ZWMzLnN1Yihwb2ludE9uQiwgcG9pbnRPbkEpLCAwLjUpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBsaW5lIHNlZ21lbnRzIGludGVyc2VjdHMgYSBzcGhlcmVcbiAqL1xuZnVuY3Rpb24gbGluZUludGVyc2VjdHNTcGhlcmUobGluZSwgc3BoZXJlKSB7XG4gICAgLy8gQ2FsY3VsYXRlIGxpbmUgZGlyZWN0aW9uIGFuZCBsZW5ndGhcbiAgICBjb25zdCBsaW5lRGlyID0gdmVjXzEudmVjMy5zdWIobGluZS5lbmQsIGxpbmUuc3RhcnQpO1xuICAgIGNvbnN0IGxpbmVMZW5ndGggPSB2ZWNfMS52ZWMzLmxlbihsaW5lRGlyKTtcbiAgICAvLyBJZiBsaW5lIGhhcyB6ZXJvIGxlbmd0aCwgdHJlYXQgYXMgcG9pbnQtc3BoZXJlIGludGVyc2VjdGlvblxuICAgIGlmIChsaW5lTGVuZ3RoIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB2ZWNfMS52ZWMzLmxlbih2ZWNfMS52ZWMzLnN1YihsaW5lLnN0YXJ0LCBzcGhlcmUucG9zaXRpb24pKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDw9IHNwaGVyZS5yYWRpdXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IFtsaW5lLnN0YXJ0XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIGxpbmUgZGlyZWN0aW9uXG4gICAgY29uc3Qgbm9ybURpciA9IHZlY18xLnZlYzMuZGl2KGxpbmVEaXIsIGxpbmVMZW5ndGgpO1xuICAgIC8vIENhbGN1bGF0ZSB2ZWN0b3IgZnJvbSBsaW5lIHN0YXJ0IHRvIHNwaGVyZSBjZW50ZXJcbiAgICBjb25zdCB0b0NlbnRlciA9IHZlY18xLnZlYzMuc3ViKHNwaGVyZS5wb3NpdGlvbiwgbGluZS5zdGFydCk7XG4gICAgLy8gQ2FsY3VsYXRlIHF1YWRyYXRpYyBlcXVhdGlvbiBjb2VmZmljaWVudHNcbiAgICAvLyBhID0gZG90KGRpciwgZGlyKSA9IDEgc2luY2UgZGlyIGlzIG5vcm1hbGl6ZWRcbiAgICBjb25zdCBhID0gdmVjXzEudmVjMy5kb3Qobm9ybURpciwgbm9ybURpcik7XG4gICAgLy8gYiA9IDIgKiBkb3QoZGlyLCAoc3RhcnQgLSBjZW50ZXIpKVxuICAgIGNvbnN0IGIgPSAyICogdmVjXzEudmVjMy5kb3Qobm9ybURpciwgdmVjXzEudmVjMy5tdWwodG9DZW50ZXIsIC0xKSk7XG4gICAgLy8gYyA9IGRvdCgoc3RhcnQgLSBjZW50ZXIpLCAoc3RhcnQgLSBjZW50ZXIpKSAtIHJhZGl1c8KyXG4gICAgY29uc3QgYyA9IHZlY18xLnZlYzMuZG90KHRvQ2VudGVyLCB0b0NlbnRlcikgLSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcbiAgICAvLyBTb2x2ZSBxdWFkcmF0aWMgZXF1YXRpb24gdXNpbmcgZGlzY3JpbWluYW50XG4gICAgY29uc3QgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gICAgLy8gTm8gaW50ZXJzZWN0aW9uIGlmIGRpc2NyaW1pbmFudCBpcyBuZWdhdGl2ZVxuICAgIGlmIChkaXNjcmltaW5hbnQgPCAtY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgbGluZSBqdXN0IHRvdWNoZXMgc3BoZXJlIChkaXNjcmltaW5hbnQg4omIIDApXG4gICAgaWYgKE1hdGguYWJzKGRpc2NyaW1pbmFudCkgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICBjb25zdCB0ID0gLWIgLyAoMiAqIGEpO1xuICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB2ZWNfMS52ZWMzLmFkZChsaW5lLnN0YXJ0LCB2ZWNfMS52ZWMzLm11bChub3JtRGlyLCB0KSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBbcG9pbnRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50cyBmb3IgZGlzY3JpbWluYW50ID4gMFxuICAgIGNvbnN0IHNxcnREaXNjcmltaW5hbnQgPSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICBjb25zdCB0MSA9ICgtYiAtIHNxcnREaXNjcmltaW5hbnQpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB0MiA9ICgtYiArIHNxcnREaXNjcmltaW5hbnQpIC8gKDIgKiBhKTtcbiAgICAvLyBDb2xsZWN0IGludGVyc2VjdGlvbiBwb2ludHMgdGhhdCBsaWUgd2l0aGluIGxpbmUgc2VnbWVudFxuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2godmVjXzEudmVjMy5hZGQobGluZS5zdGFydCwgdmVjXzEudmVjMy5tdWwobm9ybURpciwgdDEpKSk7XG4gICAgfVxuICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2godmVjXzEudmVjMy5hZGQobGluZS5zdGFydCwgdmVjXzEudmVjMy5tdWwobm9ybURpciwgdDIpKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgbGluZSBzZWdtZW50cyBpbnRlcnNlY3RzIGEgcGxhbmVcbiAqL1xuZnVuY3Rpb24gbGluZUludGVyc2VjdHNQbGFuZShsaW5lLCBwbGFuZSkge1xuICAgIC8vIENvbnZlcnQgbGluZSB0byBkaXJlY3Rpb24gdmVjdG9yXG4gICAgY29uc3QgbGluZURpciA9IHZlY18xLnZlYzMuc3ViKGxpbmUuZW5kLCBsaW5lLnN0YXJ0KTtcbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gdmVjXzEudmVjMy5sZW4obGluZURpcik7XG4gICAgLy8gSWYgdGhlIGxpbmUgaGFzIHplcm8gbGVuZ3RoLCBpdCBjYW5ub3QgaW50ZXJzZWN0XG4gICAgaWYgKGxpbmVMZW5ndGggPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgbGluZSBkaXJlY3Rpb25cbiAgICBjb25zdCBub3JtRGlyID0gdmVjXzEudmVjMy5kaXYobGluZURpciwgbGluZUxlbmd0aCk7XG4gICAgLy8gQ2FsY3VsYXRlIGRlbm9taW5hdG9yIChkb3QgcHJvZHVjdCBvZiBsaW5lIGRpcmVjdGlvbiBhbmQgcGxhbmUgbm9ybWFsKVxuICAgIGNvbnN0IGRlbm9taW5hdG9yID0gdmVjXzEudmVjMy5kb3Qobm9ybURpciwgcGxhbmUubm9ybWFsKTtcbiAgICAvLyBJZiBkZW5vbWluYXRvciBpcyBjbG9zZSB0byAwLCBsaW5lIGlzIHBhcmFsbGVsIHRvIHBsYW5lXG4gICAgaWYgKE1hdGguYWJzKGRlbm9taW5hdG9yKSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBsaW5lIHN0YXJ0IGlzIG9uIHRoZSBwbGFuZVxuICAgICAgICBjb25zdCBkaXN0YW5jZVRvUGxhbmUgPSB2ZWNfMS52ZWMzLmRvdCh2ZWNfMS52ZWMzLnN1YihsaW5lLnN0YXJ0LCBwbGFuZS5wb2ludCksIHBsYW5lLm5vcm1hbCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVRvUGxhbmUpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgIC8vIExpbmUgbGllcyBpbiB0aGUgcGxhbmU6IGluZmluaXRlIGludGVyc2VjdGlvbiBwb2ludHNcbiAgICAgICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaW5lIGlzIHBhcmFsbGVsIGFuZCBub3Qgb24gdGhlIHBsYW5lXG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIGxpbmUgc3RhcnQgdG8gcGxhbmVcbiAgICBjb25zdCB0ID0gdmVjXzEudmVjMy5kb3QodmVjXzEudmVjMy5zdWIocGxhbmUucG9pbnQsIGxpbmUuc3RhcnQpLCBwbGFuZS5ub3JtYWwpIC8gZGVub21pbmF0b3I7XG4gICAgLy8gSWYgdCBpcyBuZWdhdGl2ZSBvciBncmVhdGVyIHRoYW4gbGluZSBsZW5ndGgsIGludGVyc2VjdGlvbiBpcyBvdXRzaWRlIG9mXG4gICAgLy8gdGhlIGxpbmUgc2VnbWVudFxuICAgIGlmICh0IDwgMCB8fCB0ID4gbGluZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnQgPSB2ZWNfMS52ZWMzLmFkZChsaW5lLnN0YXJ0LCB2ZWNfMS52ZWMzLm11bChub3JtRGlyLCB0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyBhIGN1Ym9pZFxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0N1Ym9pZChsaW5lLCBjdWJvaWQpIHtcbiAgICAvLyBHZXQgbGluZSBkaXJlY3Rpb24gYW5kIGxlbmd0aFxuICAgIGNvbnN0IGxpbmVEaXIgPSB2ZWNfMS52ZWMzLnN1YihsaW5lLmVuZCwgbGluZS5zdGFydCk7XG4gICAgY29uc3QgbGluZUxlbmd0aCA9IHZlY18xLnZlYzMubGVuKGxpbmVEaXIpO1xuICAgIC8vIElmIGxpbmUgaGFzIHplcm8gbGVuZ3RoLCB0cmVhdCBhcyBwb2ludC1jdWJvaWQgaW50ZXJzZWN0aW9uXG4gICAgaWYgKGxpbmVMZW5ndGggPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwb2ludEluQ3Vib2lkKGxpbmUuc3RhcnQsIGN1Ym9pZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiByZXN1bHQuaW50ZXJzZWN0cyxcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50czogcmVzdWx0LmludGVyc2VjdHMgPyBbbGluZS5zdGFydF0gOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBsaW5lIGRpcmVjdGlvblxuICAgIGNvbnN0IG5vcm1EaXIgPSB2ZWNfMS52ZWMzLmRpdihsaW5lRGlyLCBsaW5lTGVuZ3RoKTtcbiAgICAvLyBFeHRyYWN0IGN1Ym9pZCBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCByb3RhdGlvblxuICAgIGNvbnN0IHsgcG9zaXRpb24sIHNpemUsIHJvdGF0aW9uID0gKDAsIHZlY18xLnZlYzMpKCkgfSA9IGN1Ym9pZDtcbiAgICAvLyBUcmFuc2Zvcm0gbGluZSB0byBsb2NhbCBzcGFjZSBpZiBjdWJvaWQgaXMgcm90YXRlZFxuICAgIGxldCBsb2NhbExpbmVTdGFydCA9IHZlY18xLnZlYzMuc3ViKGxpbmUuc3RhcnQsIHBvc2l0aW9uKTtcbiAgICBsZXQgbG9jYWxMaW5lRGlyID0gbm9ybURpcjtcbiAgICBpZiAoY3Vib2lkSXNSb3RhdGVkKGN1Ym9pZCkpIHtcbiAgICAgICAgLy8gVW5kbyByb3RhdGlvbiBieSBhcHBseWluZyBpbnZlcnNlIHJvdGF0aW9uXG4gICAgICAgIGNvbnN0IGludmVyc2VSb3RhdGlvbiA9IHZlY18xLnZlYzMubXVsKHJvdGF0aW9uLCAtMSk7XG4gICAgICAgIGxvY2FsTGluZVN0YXJ0ID0gdmVjXzEudmVjMy5yb3RhKGxvY2FsTGluZVN0YXJ0LCBpbnZlcnNlUm90YXRpb24pO1xuICAgICAgICBsb2NhbExpbmVEaXIgPSB2ZWNfMS52ZWMzLnJvdGEobG9jYWxMaW5lRGlyLCBpbnZlcnNlUm90YXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBoYWxmU2l6ZSA9IHZlY18xLnZlYzMuZGl2KHNpemUsIDIpO1xuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gd2l0aCBlYWNoIHBhaXIgb2YgcGFyYWxsZWwgcGxhbmVzXG4gICAgY29uc3QgdHhNaW4gPSB2ZWNfMS52ZWMzLmRpdih2ZWNfMS52ZWMzLnN1Yih2ZWNfMS52ZWMzLm11bChoYWxmU2l6ZSwgLTEpLCBsb2NhbExpbmVTdGFydCksIGxvY2FsTGluZURpcik7XG4gICAgY29uc3QgdHhNYXggPSB2ZWNfMS52ZWMzLmRpdih2ZWNfMS52ZWMzLnN1YihoYWxmU2l6ZSwgbG9jYWxMaW5lU3RhcnQpLCBsb2NhbExpbmVEaXIpO1xuICAgIC8vIEZpbmQgdGhlIGZhcnRoZXN0IG5lYXIgaW50ZXJzZWN0aW9uIGFuZCB0aGUgY2xvc2VzdCBmYXIgaW50ZXJzZWN0aW9uXG4gICAgY29uc3QgdE5lYXIgPSAoMCwgdmVjXzEudmVjMykoTWF0aC5taW4odHhNaW4ueCwgdHhNYXgueCksIE1hdGgubWluKHR4TWluLnksIHR4TWF4LnkpLCBNYXRoLm1pbih0eE1pbi56LCB0eE1heC56KSk7XG4gICAgY29uc3QgdEZhciA9ICgwLCB2ZWNfMS52ZWMzKShNYXRoLm1heCh0eE1pbi54LCB0eE1heC54KSwgTWF0aC5tYXgodHhNaW4ueSwgdHhNYXgueSksIE1hdGgubWF4KHR4TWluLnosIHR4TWF4LnopKTtcbiAgICAvLyBGaW5kIHRoZSBsYXRlc3QgZW50cnkgYW5kIGVhcmxpZXN0IGV4aXRcbiAgICBjb25zdCB0TWluID0gTWF0aC5tYXgodE5lYXIueCwgdE5lYXIueSwgdE5lYXIueik7XG4gICAgY29uc3QgdE1heCA9IE1hdGgubWluKHRGYXIueCwgdEZhci55LCB0RmFyLnopO1xuICAgIC8vIElmIHRoZSBlbnRyeSBpcyBhZnRlciB0aGUgZXhpdCwgb3IgdGhlIGV4aXQgaXMgYmVmb3JlIHRoZSBzdGFydCBvZiB0aGVcbiAgICAvLyBsaW5lLCBvciB0aGUgZW50cnkgaXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgbGluZSwgdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uXG4gICAgaWYgKHRNaW4gPiB0TWF4IHx8IHRNYXggPCAwIHx8IHRNaW4gPiBsaW5lTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzXG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgLy8gQWRkIGVudHJ5IHBvaW50IGlmIGl0J3Mgd2l0aGluIGxpbmUgc2VnbWVudFxuICAgIGlmICh0TWluID49IDAgJiYgdE1pbiA8PSBsaW5lTGVuZ3RoKSB7XG4gICAgICAgIGxldCBwb2ludCA9IHZlY18xLnZlYzMuYWRkKGxvY2FsTGluZVN0YXJ0LCB2ZWNfMS52ZWMzLm11bChsb2NhbExpbmVEaXIsIHRNaW4pKTtcbiAgICAgICAgaWYgKGN1Ym9pZElzUm90YXRlZChjdWJvaWQpKSB7XG4gICAgICAgICAgICBwb2ludCA9IHZlY18xLnZlYzMucm90YShwb2ludCwgcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHZlY18xLnZlYzMuYWRkKHBvc2l0aW9uLCBwb2ludCkpO1xuICAgIH1cbiAgICAvLyBBZGQgZXhpdCBwb2ludCBpZiBpdCdzIGRpZmZlcmVudCBmcm9tIGVudHJ5IHBvaW50IGFuZCB3aXRoaW4gbGluZSBzZWdtZW50XG4gICAgaWYgKHRNYXggPiB0TWluICYmIHRNYXggPj0gMCAmJiB0TWF4IDw9IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gdmVjXzEudmVjMy5hZGQobG9jYWxMaW5lU3RhcnQsIHZlY18xLnZlYzMubXVsKGxvY2FsTGluZURpciwgdE1heCkpO1xuICAgICAgICBpZiAoY3Vib2lkSXNSb3RhdGVkKGN1Ym9pZCkpIHtcbiAgICAgICAgICAgIHBvaW50ID0gdmVjXzEudmVjMy5yb3RhKHBvaW50LCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2godmVjXzEudmVjMy5hZGQocG9zaXRpb24sIHBvaW50KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgbGluZSBzZWdtZW50IGludGVyc2VjdHMgYSBwb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzUG9seWdvbihsaW5lLCBwb2x5Z29uKSB7XG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgdGhlIHBvbHlnb25cbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcGxhbmUgb2YgdGhlIHBvbHlnb25cbiAgICBjb25zdCBbdjEsIHYyLCB2M10gPSBwb2x5Z29uLnZlcnRpY2VzO1xuICAgIGNvbnN0IGVkZ2UxID0gdmVjXzEudmVjMy5zdWIodjIsIHYxKTtcbiAgICBjb25zdCBlZGdlMiA9IHZlY18xLnZlYzMuc3ViKHYzLCB2MSk7XG4gICAgY29uc3Qgbm9ybWFsID0gdmVjXzEudmVjMy5ub3IodmVjXzEudmVjMy5jcm9zcyhlZGdlMSwgZWRnZTIpKTtcbiAgICAvLyBDcmVhdGUgYSBwbGFuZSBmcm9tIHRoZSBwb2x5Z29uXG4gICAgY29uc3QgcGxhbmUgPSB7XG4gICAgICAgIHBvaW50OiB2MSxcbiAgICAgICAgbm9ybWFsLFxuICAgIH07XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmVcbiAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBsaW5lSW50ZXJzZWN0c1BsYW5lKGxpbmUsIHBsYW5lKTtcbiAgICBpZiAoIWludGVyc2VjdGlvbi5pbnRlcnNlY3RzIHx8ICFpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGludGVyc2VjdGlvbiBwb2ludCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbiAgICBjb25zdCBwb2ludENoZWNrID0gcG9pbnRPblBvbHlnb24oaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50LCBwb2x5Z29uKTtcbiAgICBpZiAoIXBvaW50Q2hlY2sgfHwgIXBvaW50Q2hlY2suaW50ZXJzZWN0cykge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludDogaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50LFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgbGluZSBzZWdtZW50IGludGVyc2VjdHMgYSBjdWJvaWRcbiAqL1xuZnVuY3Rpb24gbGluZUludGVyc2VjdHNNZXNoKGxpbmUsIG1lc2gpIHtcbiAgICBjb25zdCBwb2x5Z29ucyA9IG1lc2hUb1BvbHlnb25zKG1lc2gpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIHBvbHlnb25zLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGxpbmVJbnRlcnNlY3RzUG9seWdvbihsaW5lLCBwb2x5Z29uKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbiAmJiBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0cykge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byBzcGhlcmVzIGludGVyc2VjdFxuICovXG5mdW5jdGlvbiBzcGhlcmVJbnRlcnNlY3RzU3BoZXJlKHNwaGVyZUEsIHNwaGVyZUIpIHtcbiAgICAvLyBDYWxjdWxhdGUgdmVjdG9yIGZyb20gY2VudGVyIG9mIHNwaGVyZSBBIHRvIGNlbnRlciBvZiBzcGhlcmUgQlxuICAgIGNvbnN0IGNlbnRlclRvQ2VudGVyID0gdmVjXzEudmVjMy5zdWIoc3BoZXJlQi5wb3NpdGlvbiwgc3BoZXJlQS5wb3NpdGlvbik7XG4gICAgLy8gQ2FsY3VsYXRlIGFjdHVhbCBkaXN0YW5jZSBiZXR3ZWVuIGNlbnRlcnNcbiAgICBjb25zdCBkaXN0YW5jZSA9IHZlY18xLnZlYzMubGVuKGNlbnRlclRvQ2VudGVyKTtcbiAgICAvLyBDYWxjdWxhdGUgc3VtIG9mIHJhZGlpXG4gICAgY29uc3QgcmFkaWlTdW0gPSBzcGhlcmVBLnJhZGl1cyArIHNwaGVyZUIucmFkaXVzO1xuICAgIC8vIElmIGRpc3RhbmNlIGlzIGdyZWF0ZXIgdGhhbiBzdW0gb2YgcmFkaWksIHNwaGVyZXMgZG9uJ3QgaW50ZXJzZWN0XG4gICAgaWYgKGRpc3RhbmNlID4gcmFkaWlTdW0pIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gSWYgZGlzdGFuY2UgaXMgemVybywgc3BoZXJlcyBhcmUgY29uY2VudHJpY1xuICAgIGlmIChkaXN0YW5jZSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQ6IHNwaGVyZUEucG9zaXRpb24sXG4gICAgICAgICAgICBwZW5ldHJhdGlvbkRlcHRoOiByYWRpaVN1bSxcbiAgICAgICAgICAgIG5vcm1hbDogKDAsIHZlY18xLnZlYzMpKDEsIDAsIDApLCAvLyBBcmJpdHJhcnkgbm9ybWFsIGZvciBjb25jZW50cmljIHNwaGVyZXNcbiAgICAgICAgICAgIGNvbnRhY3RQb2ludHM6IHtcbiAgICAgICAgICAgICAgICBzcGhlcmVBOiB2ZWNfMS52ZWMzLmFkZChzcGhlcmVBLnBvc2l0aW9uLCAoMCwgdmVjXzEudmVjMykoc3BoZXJlQS5yYWRpdXMsIDAsIDApKSxcbiAgICAgICAgICAgICAgICBzcGhlcmVCOiB2ZWNfMS52ZWMzLmFkZChzcGhlcmVCLnBvc2l0aW9uLCAoMCwgdmVjXzEudmVjMykoc3BoZXJlQi5yYWRpdXMsIDAsIDApKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBub3JtYWxpemVkIGRpcmVjdGlvbiBmcm9tIHNwaGVyZSBBIHRvIHNwaGVyZSBCXG4gICAgY29uc3Qgbm9ybWFsID0gdmVjXzEudmVjMy5ub3IoY2VudGVyVG9DZW50ZXIpO1xuICAgIC8vIENhbGN1bGF0ZSBwZW5ldHJhdGlvbiBkZXB0aFxuICAgIGNvbnN0IHBlbmV0cmF0aW9uRGVwdGggPSByYWRpaVN1bSAtIGRpc3RhbmNlO1xuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gY2VudGVyIHBvaW50IChoYWxmd2F5IGJldHdlZW4gc3VyZmFjZSBpbnRlcnNlY3Rpb25cbiAgICAvLyBwb2ludHMpXG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnQgPSB2ZWNfMS52ZWMzLmFkZChzcGhlcmVBLnBvc2l0aW9uLCB2ZWNfMS52ZWMzLm11bChub3JtYWwsIHNwaGVyZUEucmFkaXVzICsgcGVuZXRyYXRpb25EZXB0aCAvIDIpKTtcbiAgICAvLyBDYWxjdWxhdGUgY29udGFjdCBwb2ludHMgb24gZWFjaCBzcGhlcmUncyBzdXJmYWNlXG4gICAgY29uc3QgY29udGFjdFBvaW50cyA9IHtcbiAgICAgICAgc3BoZXJlQTogdmVjXzEudmVjMy5hZGQoc3BoZXJlQS5wb3NpdGlvbiwgdmVjXzEudmVjMy5tdWwobm9ybWFsLCBzcGhlcmVBLnJhZGl1cykpLFxuICAgICAgICBzcGhlcmVCOiB2ZWNfMS52ZWMzLmFkZChzcGhlcmVCLnBvc2l0aW9uLCB2ZWNfMS52ZWMzLm11bChub3JtYWwsIC1zcGhlcmVCLnJhZGl1cykpLFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQsXG4gICAgICAgIHBlbmV0cmF0aW9uRGVwdGgsXG4gICAgICAgIG5vcm1hbCxcbiAgICAgICAgY29udGFjdFBvaW50cyxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHNwaGVyZSBpbnRlcnNlY3RzIGEgcGxhbmVcbiAqL1xuZnVuY3Rpb24gc3BoZXJlSW50ZXJzZWN0c1BsYW5lKHNwaGVyZSwgcGxhbmUpIHtcbiAgICAvLyBOb3JtYWxpemUgdGhlIHBsYW5lIG5vcm1hbFxuICAgIGNvbnN0IG5vcm1hbCA9IHZlY18xLnZlYzMubm9yKHBsYW5lLm5vcm1hbCk7XG4gICAgLy8gQ2FsY3VsYXRlIHNpZ25lZCBkaXN0YW5jZSBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gcGxhbmVcbiAgICBjb25zdCBzaWduZWREaXN0YW5jZSA9IHZlY18xLnZlYzMuZG90KHZlY18xLnZlYzMuc3ViKHNwaGVyZS5wb3NpdGlvbiwgcGxhbmUucG9pbnQpLCBub3JtYWwpO1xuICAgIC8vIElmIHRoZSBkaXN0YW5jZSBpcyBncmVhdGVyIHRoYW4gc3BoZXJlIHJhZGl1cywgbm8gaW50ZXJzZWN0aW9uXG4gICAgaWYgKE1hdGguYWJzKHNpZ25lZERpc3RhbmNlKSA+IHNwaGVyZS5yYWRpdXMpIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHBlbmV0cmF0aW9uIGRlcHRoXG4gICAgY29uc3QgcGVuZXRyYXRpb25EZXB0aCA9IHNwaGVyZS5yYWRpdXMgLSBNYXRoLmFicyhzaWduZWREaXN0YW5jZSk7XG4gICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBwb2ludCAoY2VudGVyIG9mIGludGVyc2VjdGlvbiBjaXJjbGUpXG4gICAgLy8gVGhpcyBpcyB0aGUgcHJvamVjdGlvbiBvZiB0aGUgc3BoZXJlJ3MgY2VudGVyIG9udG8gdGhlIHBsYW5lXG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnQgPSB2ZWNfMS52ZWMzLnN1YihzcGhlcmUucG9zaXRpb24sIHZlY18xLnZlYzMubXVsKG5vcm1hbCwgc2lnbmVkRGlzdGFuY2UpKTtcbiAgICAvLyBDYWxjdWxhdGUgcmFkaXVzIG9mIGludGVyc2VjdGlvbiBjaXJjbGUgdXNpbmcgUHl0aGFnb3JlYW4gdGhlb3JlbVxuICAgIGNvbnN0IGludGVyc2VjdGlvblJhZGl1cyA9IE1hdGguc3FydChzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyAtIHNpZ25lZERpc3RhbmNlICogc2lnbmVkRGlzdGFuY2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50LFxuICAgICAgICBwZW5ldHJhdGlvbkRlcHRoLFxuICAgICAgICBpbnRlcnNlY3Rpb25SYWRpdXMsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBzcGhlcmUgaW50ZXJzZWN0cyBhIGN1Ym9pZFxuICovXG5mdW5jdGlvbiBzcGhlcmVJbnRlcnNlY3RzQ3Vib2lkKHNwaGVyZSwgY3Vib2lkKSB7XG4gICAgY29uc3QgeyBwb3NpdGlvbiwgc2l6ZSwgcm90YXRpb24gPSAoMCwgdmVjXzEudmVjMykoKSB9ID0gY3Vib2lkO1xuICAgIGNvbnN0IGhhbGZTaXplID0gdmVjXzEudmVjMy5kaXYoc2l6ZSwgMik7XG4gICAgLy8gVHJhbnNmb3JtIHNwaGVyZSBjZW50ZXIgdG8gY3Vib2lkJ3MgbG9jYWwgc3BhY2VcbiAgICBsZXQgbG9jYWxTcGhlcmVDZW50ZXIgPSB2ZWNfMS52ZWMzLnN1YihzcGhlcmUucG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAoY3Vib2lkSXNSb3RhdGVkKGN1Ym9pZCkpIHtcbiAgICAgICAgbG9jYWxTcGhlcmVDZW50ZXIgPSB2ZWNfMS52ZWMzLnJvdGEobG9jYWxTcGhlcmVDZW50ZXIsIHZlY18xLnZlYzMubXVsKHJvdGF0aW9uLCAtMSkpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBjdWJvaWQgdG8gdGhlIHNwaGVyZSBjZW50ZXJcbiAgICBjb25zdCBjbG9zZXN0TG9jYWxQb2ludCA9ICgwLCB2ZWNfMS52ZWMzKSgoMCwgdXRpbHNfMS5jbGFtcCkobG9jYWxTcGhlcmVDZW50ZXIueCwgLWhhbGZTaXplLngsIGhhbGZTaXplLngpLCAoMCwgdXRpbHNfMS5jbGFtcCkobG9jYWxTcGhlcmVDZW50ZXIueSwgLWhhbGZTaXplLnksIGhhbGZTaXplLnkpLCAoMCwgdXRpbHNfMS5jbGFtcCkobG9jYWxTcGhlcmVDZW50ZXIueiwgLWhhbGZTaXplLnosIGhhbGZTaXplLnopKTtcbiAgICAvLyBUcmFuc2Zvcm0gY2xvc2VzdCBwb2ludCBiYWNrIHRvIHdvcmxkIHNwYWNlXG4gICAgbGV0IGNsb3Nlc3RQb2ludCA9IGNsb3Nlc3RMb2NhbFBvaW50O1xuICAgIGlmIChjdWJvaWRJc1JvdGF0ZWQoY3Vib2lkKSkge1xuICAgICAgICBjbG9zZXN0UG9pbnQgPSB2ZWNfMS52ZWMzLnJvdGEoY2xvc2VzdFBvaW50LCByb3RhdGlvbik7XG4gICAgfVxuICAgIGNsb3Nlc3RQb2ludCA9IHZlY18xLnZlYzMuYWRkKGNsb3Nlc3RQb2ludCwgcG9zaXRpb24pO1xuICAgIC8vIENhbGN1bGF0ZSB2ZWN0b3IgZnJvbSBjbG9zZXN0IHBvaW50IHRvIHNwaGVyZSBjZW50ZXJcbiAgICBjb25zdCBzZXBhcmF0aW9uVmVjdG9yID0gdmVjXzEudmVjMy5zdWIoc3BoZXJlLnBvc2l0aW9uLCBjbG9zZXN0UG9pbnQpO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gdmVjXzEudmVjMy5sZW4oc2VwYXJhdGlvblZlY3Rvcik7XG4gICAgLy8gSWYgZGlzdGFuY2UgaXMgZ3JlYXRlciB0aGFuIHNwaGVyZSByYWRpdXMsIG5vIGludGVyc2VjdGlvblxuICAgIGlmIChkaXN0YW5jZSA+IHNwaGVyZS5yYWRpdXMpIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgc3BoZXJlIGNlbnRlciBpcyBleGFjdGx5IG9uIGN1Ym9pZCBzdXJmYWNlXG4gICAgaWYgKGRpc3RhbmNlIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgLy8gVXNlIHZlY3RvciBmcm9tIGN1Ym9pZCBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBhcyBub3JtYWxcbiAgICAgICAgbGV0IG5vcm1hbCA9IHZlY18xLnZlYzMubm9yKHZlY18xLnZlYzMuc3ViKHNwaGVyZS5wb3NpdGlvbiwgcG9zaXRpb24pKTtcbiAgICAgICAgY29uc3QgcGVuZXRyYXRpb25EZXB0aCA9IHNwaGVyZS5yYWRpdXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQ6IHNwaGVyZS5wb3NpdGlvbixcbiAgICAgICAgICAgIHBlbmV0cmF0aW9uRGVwdGgsXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBjb250YWN0UG9pbnQ6IGNsb3Nlc3RQb2ludCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIG5vcm1hbCBhbmQgcGVuZXRyYXRpb24gZGVwdGhcbiAgICBjb25zdCBub3JtYWwgPSB2ZWNfMS52ZWMzLm5vcihzZXBhcmF0aW9uVmVjdG9yKTtcbiAgICBjb25zdCBwZW5ldHJhdGlvbkRlcHRoID0gc3BoZXJlLnJhZGl1cyAtIGRpc3RhbmNlO1xuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcG9pbnQgYXQgY2VudGVyIG9mIGludGVyc2VjdGlvbiB2b2x1bWVcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25Qb2ludCA9IHZlY18xLnZlYzMuYWRkKGNsb3Nlc3RQb2ludCwgdmVjXzEudmVjMy5tdWwobm9ybWFsLCBwZW5ldHJhdGlvbkRlcHRoIC8gMikpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50LFxuICAgICAgICBwZW5ldHJhdGlvbkRlcHRoLFxuICAgICAgICBub3JtYWwsXG4gICAgICAgIGNvbnRhY3RQb2ludDogY2xvc2VzdFBvaW50LFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgc3BoZXJlIGludGVyc2VjdHMgYSBwb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIHNwaGVyZUludGVyc2VjdHNQb2x5Z29uKHNwaGVyZSwgcG9seWdvbikge1xuICAgIC8vIEZpcnN0IHZhbGlkYXRlIHRoZSBwb2x5Z29uXG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgW3YxLCB2MiwgdjNdID0gcG9seWdvbi52ZXJ0aWNlcztcbiAgICAvLyBDYWxjdWxhdGUgcG9seWdvbiBwbGFuZVxuICAgIGNvbnN0IGVkZ2UxID0gdmVjXzEudmVjMy5zdWIodjIsIHYxKTtcbiAgICBjb25zdCBlZGdlMiA9IHZlY18xLnZlYzMuc3ViKHYzLCB2MSk7XG4gICAgY29uc3Qgbm9ybWFsID0gdmVjXzEudmVjMy5ub3IodmVjXzEudmVjMy5jcm9zcyhlZGdlMSwgZWRnZTIpKTtcbiAgICAvLyBDcmVhdGUgcGxhbmUgZnJvbSBwb2x5Z29uXG4gICAgY29uc3QgcGxhbmUgPSB7XG4gICAgICAgIHBvaW50OiB2MSxcbiAgICAgICAgbm9ybWFsLFxuICAgIH07XG4gICAgLy8gQ2hlY2sgc3BoZXJlLXBsYW5lIGludGVyc2VjdGlvbiBmaXJzdFxuICAgIGNvbnN0IHBsYW5lSW50ZXJzZWN0aW9uID0gc3BoZXJlSW50ZXJzZWN0c1BsYW5lKHNwaGVyZSwgcGxhbmUpO1xuICAgIGlmICghcGxhbmVJbnRlcnNlY3Rpb24uaW50ZXJzZWN0cykge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDaGVjayBlYWNoIHZlcnRleCBkaXN0YW5jZSBmcm9tIHNwaGVyZSBjZW50ZXJcbiAgICBjb25zdCB2ZXJ0ZXhEaXN0YW5jZXMgPSBwb2x5Z29uLnZlcnRpY2VzLm1hcCh2ZXJ0ZXggPT4gdmVjXzEudmVjMy5sZW4odmVjXzEudmVjMy5zdWIodmVydGV4LCBzcGhlcmUucG9zaXRpb24pKSk7XG4gICAgLy8gSWYgYWxsIHZlcnRpY2VzIGFyZSBpbnNpZGUgc3BoZXJlLCBwb2x5Z29uIGlzIGNvbnRhaW5lZFxuICAgIGlmICh2ZXJ0ZXhEaXN0YW5jZXMuZXZlcnkoZGlzdCA9PiBkaXN0IDw9IHNwaGVyZS5yYWRpdXMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQ6IHBsYW5lSW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50LFxuICAgICAgICAgICAgcGVuZXRyYXRpb25EZXB0aDogc3BoZXJlLnJhZGl1cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIHBvbHlnb24gZWRnZXNcbiAgICBjb25zdCBlZGdlcyA9IFtcbiAgICAgICAgeyBzdGFydDogdjEsIGVuZDogdjIgfSxcbiAgICAgICAgeyBzdGFydDogdjIsIGVuZDogdjMgfSxcbiAgICAgICAgeyBzdGFydDogdjMsIGVuZDogdjEgfSxcbiAgICBdO1xuICAgIC8vIENoZWNrIGVhY2ggZWRnZSBmb3IgaW50ZXJzZWN0aW9uIHdpdGggc3BoZXJlXG4gICAgY29uc3QgcG9seWdvbkludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIGVkZ2VzLmZvckVhY2goZWRnZSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVJbnRlcnNlY3Rpb24gPSBsaW5lSW50ZXJzZWN0c1NwaGVyZShlZGdlLCBzcGhlcmUpO1xuICAgICAgICBpZiAobGluZUludGVyc2VjdGlvbi5pbnRlcnNlY3RzICYmIGxpbmVJbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnRzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGFkZCBwb2ludHMgdGhhdCBsaWUgb24gdGhlIHBvbHlnb24gZWRnZXNcbiAgICAgICAgICAgIGxpbmVJbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnRzLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uTGluZSA9IHBvaW50T25MaW5lKHBvaW50LCBlZGdlKTtcbiAgICAgICAgICAgICAgICBpZiAob25MaW5lLmludGVyc2VjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkludGVyc2VjdGlvblBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIENoZWNrIGlmIHNwaGVyZSBjZW50ZXIgcHJvamVjdHMgb250byBwb2x5Z29uXG4gICAgY29uc3QgcHJvamVjdGVkQ2VudGVyID0gcG9pbnRPblBvbHlnb24oc3BoZXJlLnBvc2l0aW9uLCBwb2x5Z29uKTtcbiAgICBpZiAocHJvamVjdGVkQ2VudGVyICYmIHByb2plY3RlZENlbnRlci5pbnRlcnNlY3RzKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdmVjXzEudmVjMy5sZW4odmVjXzEudmVjMy5zdWIoc3BoZXJlLnBvc2l0aW9uLCBwcm9qZWN0ZWRDZW50ZXIuY2xvc2VzdFBvaW50KSk7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8PSBzcGhlcmUucmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQ6IHByb2plY3RlZENlbnRlci5jbG9zZXN0UG9pbnQsXG4gICAgICAgICAgICAgICAgcGVuZXRyYXRpb25EZXB0aDogc3BoZXJlLnJhZGl1cyAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgIHBvbHlnb25JbnRlcnNlY3Rpb25Qb2ludHM6IHBvbHlnb25JbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IHBvbHlnb25JbnRlcnNlY3Rpb25Qb2ludHNcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGhhdmUgaW50ZXJzZWN0aW9uIHBvaW50cyBidXQgbm8gY2VudGVyIHByb2plY3Rpb24sXG4gICAgLy8gdXNlIHRoZSBtaWRwb2ludCBvZiBpbnRlcnNlY3Rpb24gcG9pbnRzIGFzIGludGVyc2VjdGlvbiBwb2ludFxuICAgIGlmIChwb2x5Z29uSW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbWlkUG9pbnQgPSB2ZWNfMS52ZWMzLmRpdihwb2x5Z29uSW50ZXJzZWN0aW9uUG9pbnRzLnJlZHVjZSgoc3VtLCBwKSA9PiB2ZWNfMS52ZWMzLmFkZChzdW0sIHApLCAoMCwgdmVjXzEudmVjMykoKSksIHBvbHlnb25JbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludDogbWlkUG9pbnQsXG4gICAgICAgICAgICBwZW5ldHJhdGlvbkRlcHRoOiBzcGhlcmUucmFkaXVzIC0gdmVjXzEudmVjMy5sZW4odmVjXzEudmVjMy5zdWIobWlkUG9pbnQsIHNwaGVyZS5wb3NpdGlvbikpLFxuICAgICAgICAgICAgcG9seWdvbkludGVyc2VjdGlvblBvaW50czogcG9seWdvbkludGVyc2VjdGlvblBvaW50cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gaW50ZXJzZWN0aW9uIGZvdW5kXG4gICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBzcGhlcmUgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBpbiBhIG1lc2hcbiAqL1xuZnVuY3Rpb24gc3BoZXJlSW50ZXJzZWN0c01lc2goc3BoZXJlLCBtZXNoKSB7XG4gICAgY29uc3QgcG9seWdvbnMgPSBtZXNoVG9Qb2x5Z29ucyhtZXNoKTtcbiAgICBsZXQgaW50ZXJzZWN0cyA9IGZhbHNlO1xuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIGNvbnN0IHBvbHlnb25JbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICBwb2x5Z29ucy5mb3JFYWNoKHBvbHlnb24gPT4ge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBzcGhlcmVJbnRlcnNlY3RzUG9seWdvbihzcGhlcmUsIHBvbHlnb24pO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnBvbHlnb25JbnRlcnNlY3Rpb25Qb2ludHMpIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uSW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goLi4uaW50ZXJzZWN0aW9uLnBvbHlnb25JbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0cyxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCA/IGludGVyc2VjdGlvblBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9seWdvbkludGVyc2VjdGlvblBvaW50czogcG9seWdvbkludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHBvbHlnb25JbnRlcnNlY3Rpb25Qb2ludHNcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byBwbGFuZXMgaW50ZXJzZWN0XG4gKlxuICogQmFzZWQgb24gdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgaW4gXCJSZWFsLVRpbWUgQ29sbGlzaW9uIERldGVjdGlvblwiIGJ5XG4gKiBDaHJpc3RlciBFcmljc29uXG4gKi9cbmZ1bmN0aW9uIHBsYW5lSW50ZXJzZWN0c1BsYW5lKHBsYW5lQSwgcGxhbmVCKSB7XG4gICAgLy8gTm9ybWFsaXplIHBsYW5lIG5vcm1hbHNcbiAgICBjb25zdCBub3JtYWxBID0gdmVjXzEudmVjMy5ub3IocGxhbmVBLm5vcm1hbCk7XG4gICAgY29uc3Qgbm9ybWFsQiA9IHZlY18xLnZlYzMubm9yKHBsYW5lQi5ub3JtYWwpO1xuICAgIC8vIENhbGN1bGF0ZSBkaXJlY3Rpb24gb2YgaW50ZXJzZWN0aW9uIGxpbmUgdXNpbmcgY3Jvc3MgcHJvZHVjdFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHZlY18xLnZlYzMuY3Jvc3Mobm9ybWFsQSwgbm9ybWFsQik7XG4gICAgY29uc3QgZGlyZWN0aW9uTGVuZ3RoU3EgPSB2ZWNfMS52ZWMzLmRvdChkaXJlY3Rpb24sIGRpcmVjdGlvbik7XG4gICAgLy8gSWYgZGlyZWN0aW9uIGxlbmd0aCBpcyBhbG1vc3QgemVybywgcGxhbmVzIGFyZSBwYXJhbGxlbFxuICAgIGlmIChkaXJlY3Rpb25MZW5ndGhTcSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHBsYW5lcyBhcmUgY29pbmNpZGVudCBieSBjb21wYXJpbmcgZGlzdGFuY2UgZnJvbSBvbmUgcGxhbmUncyBwb2ludCB0byBvdGhlciBwbGFuZVxuICAgICAgICBjb25zdCBzaWduZWREaXN0YW5jZSA9IHZlY18xLnZlYzMuZG90KHZlY18xLnZlYzMuc3ViKHBsYW5lQi5wb2ludCwgcGxhbmVBLnBvaW50KSwgbm9ybWFsQSk7XG4gICAgICAgIC8vIElmIGRpc3RhbmNlIGlzIGVmZmVjdGl2ZWx5IHplcm8sIHBsYW5lcyBhcmUgY29pbmNpZGVudFxuICAgICAgICBpZiAoTWF0aC5hYnMoc2lnbmVkRGlzdGFuY2UpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSwgLy8gQ29pbmNpZGVudCBwbGFuZXMgaGF2ZSBpbmZpbml0ZSBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGxhbmVzIGFyZSBwYXJhbGxlbCB3aXRoIGdhcCBiZXR3ZWVuIHRoZW1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQbGFuZXMgaW50ZXJzZWN0IGFsb25nIGEgbGluZVxuICAgIC8vIENhbGN1bGF0ZSBhIHBvaW50IG9uIHRoZSBpbnRlcnNlY3Rpb24gbGluZSB1c2luZzpcbiAgICAvLyBwb2ludCA9IChi4oKCbuKCgSAtIGLigoFu4oKCKSDDlyAobuKCgSDDlyBu4oKCKSAvIHxu4oKBIMOXIG7igoJ8wrJcbiAgICAvLyB3aGVyZSBi4oKBLCBi4oKCIGFyZSB0aGUgcGxhbmUgY29uc3RhbnRzIChkIGluIGF4ICsgYnkgKyBjeiArIGQgPSAwIGZvcm0pXG4gICAgLy8gYW5kIG7igoEsIG7igoIgYXJlIHRoZSBwbGFuZSBub3JtYWxzXG4gICAgY29uc3QgYjEgPSAtdmVjXzEudmVjMy5kb3Qobm9ybWFsQSwgcGxhbmVBLnBvaW50KTtcbiAgICBjb25zdCBiMiA9IC12ZWNfMS52ZWMzLmRvdChub3JtYWxCLCBwbGFuZUIucG9pbnQpO1xuICAgIGNvbnN0IHBvaW50ID0gdmVjXzEudmVjMy5kaXYodmVjXzEudmVjMy5jcm9zcyh2ZWNfMS52ZWMzLnN1Yih2ZWNfMS52ZWMzLm11bChub3JtYWxBLCBiMiksIHZlY18xLnZlYzMubXVsKG5vcm1hbEIsIGIxKSksIGRpcmVjdGlvbiksIGRpcmVjdGlvbkxlbmd0aFNxKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICBpbnRlcnNlY3Rpb25MaW5lOiB7XG4gICAgICAgICAgICBzdGFydDogcG9pbnQsXG4gICAgICAgICAgICBlbmQ6IHZlY18xLnZlYzMuYWRkKHBvaW50LCBkaXJlY3Rpb24pLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcGxhbmUgaW50ZXJzZWN0cyBvbmUgb3IgbW9yZSBwb2x5Z29ucyBpbiBhIG1lc2hcbiAqL1xuZnVuY3Rpb24gcGxhbmVJbnRlcnNlY3RzTWVzaChwbGFuZSwgbWVzaCkge1xuICAgIHJldHVybiBtZXNoSW50ZXJzZWN0c1BsYW5lKG1lc2gsIHBsYW5lKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIGN1Ym9pZHMgaW50ZXJzZWN0IHVzaW5nIHRoZSBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbVxuICovXG5mdW5jdGlvbiBjdWJvaWRJbnRlcnNlY3RzQ3Vib2lkKGN1Ym9pZEEsIGN1Ym9pZEIpIHtcbiAgICAvLyBFeHRyYWN0IHByb3BlcnRpZXMgd2l0aCBkZWZhdWx0IHJvdGF0aW9uc1xuICAgIGNvbnN0IHsgcG9zaXRpb246IHBvc0EsIHNpemU6IHNpemVBLCByb3RhdGlvbjogcm90YXRpb25BID0gKDAsIHZlY18xLnZlYzMpKCkgfSA9IGN1Ym9pZEE7XG4gICAgY29uc3QgeyBwb3NpdGlvbjogcG9zQiwgc2l6ZTogc2l6ZUIsIHJvdGF0aW9uOiByb3RhdGlvbkIgPSAoMCwgdmVjXzEudmVjMykoKSB9ID0gY3Vib2lkQjtcbiAgICAvLyBDYWxjdWxhdGUgaGFsZi1zaXplc1xuICAgIGNvbnN0IGhhbGZTaXplQSA9IHZlY18xLnZlYzMuZGl2KHNpemVBLCAyKTtcbiAgICBjb25zdCBoYWxmU2l6ZUIgPSB2ZWNfMS52ZWMzLmRpdihzaXplQiwgMik7XG4gICAgLy8gR2V0IHJvdGF0aW9uIG1hdHJpY2VzIGZvciBib3RoIGN1Ym9pZHNcbiAgICBjb25zdCByb3RNYXRBID0gY3Vib2lkSXNSb3RhdGVkKGN1Ym9pZEEpXG4gICAgICAgID8gZ2V0Um90YXRpb25NYXRyaXgocm90YXRpb25BKVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3Qgcm90TWF0QiA9IGN1Ym9pZElzUm90YXRlZChjdWJvaWRCKVxuICAgICAgICA/IGdldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uQilcbiAgICAgICAgOiBudWxsO1xuICAgIC8vIEdldCBjdWJvaWQgYXhlcyAoZmFjZSBub3JtYWxzKVxuICAgIGNvbnN0IGF4ZXNBID0gZ2V0Um90YXRlZEF4ZXMocm90TWF0QSk7XG4gICAgY29uc3QgYXhlc0IgPSBnZXRSb3RhdGVkQXhlcyhyb3RNYXRCKTtcbiAgICAvLyBWZWN0b3IgYmV0d2VlbiBjdWJvaWQgY2VudGVyc1xuICAgIGNvbnN0IGNlbnRlckRpZmYgPSB2ZWNfMS52ZWMzLnN1Yihwb3NCLCBwb3NBKTtcbiAgICAvLyBUZXN0IGFsbCAxNSBwb3RlbnRpYWwgc2VwYXJhdGluZyBheGVzOlxuICAgIC8vIC0gMyBmcm9tIGN1Ym9pZCBBJ3MgZmFjZSBub3JtYWxzXG4gICAgLy8gLSAzIGZyb20gY3Vib2lkIEIncyBmYWNlIG5vcm1hbHNcbiAgICAvLyAtIDkgZnJvbSBjcm9zcyBwcm9kdWN0cyBvZiBlZGdlcyAoM3gzKVxuICAgIGNvbnN0IGF4ZXMgPSBbLi4uYXhlc0EsIC4uLmF4ZXNCLCAuLi5nZXRDcm9zc1Byb2R1Y3RBeGVzKGF4ZXNBLCBheGVzQildO1xuICAgIGxldCBtaW5QZW5ldHJhdGlvbiA9IEluZmluaXR5O1xuICAgIGxldCBzZXBhcmF0aW9uQXhpcyA9IG51bGw7XG4gICAgLy8gVGVzdCBlYWNoIGF4aXNcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgICBjb25zdCBheGlzTGVuZ3RoID0gdmVjXzEudmVjMy5sZW4oYXhpcyk7XG4gICAgICAgIGlmIChheGlzTGVuZ3RoIDwgY29uc3RhbnRzLkVQU0lMT04pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gTm9ybWFsaXplIGF4aXNcbiAgICAgICAgY29uc3Qgbm9ybUF4aXMgPSB2ZWNfMS52ZWMzLmRpdihheGlzLCBheGlzTGVuZ3RoKTtcbiAgICAgICAgLy8gUHJvamVjdCBjZW50ZXItdG8tY2VudGVyIHZlY3RvciBvbnRvIGF4aXNcbiAgICAgICAgY29uc3QgY2VudGVyUHJvaiA9IHZlY18xLnZlYzMuZG90KGNlbnRlckRpZmYsIG5vcm1BeGlzKTtcbiAgICAgICAgLy8gUHJvamVjdCBib3RoIGN1Ym9pZHMgb250byBheGlzXG4gICAgICAgIGNvbnN0IHByb2pBID0gcHJvamVjdEN1Ym9pZChoYWxmU2l6ZUEsIHJvdE1hdEEsIG5vcm1BeGlzKTtcbiAgICAgICAgY29uc3QgcHJvakIgPSBwcm9qZWN0Q3Vib2lkKGhhbGZTaXplQiwgcm90TWF0Qiwgbm9ybUF4aXMpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgcGVuZXRyYXRpb24gZGVwdGggYWxvbmcgdGhpcyBheGlzXG4gICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uID0gcHJvakEgKyBwcm9qQiAtIE1hdGguYWJzKGNlbnRlclByb2opO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgZ2FwLCBjdWJvaWRzIGFyZSBzZXBhcmF0ZWRcbiAgICAgICAgaWYgKHBlbmV0cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhY2sgbWluaW11bSBwZW5ldHJhdGlvbiBhbmQgaXRzIGF4aXNcbiAgICAgICAgaWYgKHBlbmV0cmF0aW9uIDwgbWluUGVuZXRyYXRpb24pIHtcbiAgICAgICAgICAgIG1pblBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247XG4gICAgICAgICAgICBzZXBhcmF0aW9uQXhpcyA9IG5vcm1BeGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGdldCBoZXJlLCBubyBzZXBhcmF0aW5nIGF4aXMgd2FzIGZvdW5kIC0gY3Vib2lkcyBpbnRlcnNlY3RcbiAgICBpZiAoIXNlcGFyYXRpb25BeGlzKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IHRydWUgfTtcbiAgICB9XG4gICAgLy8gRW5zdXJlIG5vcm1hbCBwb2ludHMgZnJvbSBBIHRvIEJcbiAgICBjb25zdCBub3JtYWwgPSB2ZWNfMS52ZWMzLmRvdChjZW50ZXJEaWZmLCBzZXBhcmF0aW9uQXhpcykgPCAwXG4gICAgICAgID8gdmVjXzEudmVjMy5tdWwoc2VwYXJhdGlvbkF4aXMsIC0xKVxuICAgICAgICA6IHNlcGFyYXRpb25BeGlzO1xuICAgIC8vIENhbGN1bGF0ZSBjb250YWN0IHBvaW50cyBvbiBlYWNoIGN1Ym9pZCdzIHN1cmZhY2VcbiAgICBjb25zdCBjb250YWN0QSA9IGdldENvbnRhY3RQb2ludChjdWJvaWRBLCBub3JtYWwpO1xuICAgIGNvbnN0IGNvbnRhY3RCID0gZ2V0Q29udGFjdFBvaW50KGN1Ym9pZEIsIHZlY18xLnZlYzMubXVsKG5vcm1hbCwgLTEpKTtcbiAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50IGhhbGZ3YXkgYmV0d2VlbiBjb250YWN0c1xuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50ID0gdmVjXzEudmVjMy5hZGQoY29udGFjdEEsIHZlY18xLnZlYzMubXVsKHZlY18xLnZlYzMuc3ViKGNvbnRhY3RCLCBjb250YWN0QSksIDAuNSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50LFxuICAgICAgICBwZW5ldHJhdGlvbkRlcHRoOiBtaW5QZW5ldHJhdGlvbixcbiAgICAgICAgbm9ybWFsLFxuICAgICAgICBjb250YWN0UG9pbnRzOiB7XG4gICAgICAgICAgICBjdWJvaWRBOiBjb250YWN0QSxcbiAgICAgICAgICAgIGN1Ym9pZEI6IGNvbnRhY3RCLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSByb3RhdGlvbiBtYXRyaXggZnJvbSBFdWxlciBhbmdsZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Um90YXRpb25NYXRyaXgocm90YXRpb24pIHtcbiAgICBjb25zdCBjeCA9IE1hdGguY29zKHJvdGF0aW9uLngpO1xuICAgIGNvbnN0IGN5ID0gTWF0aC5jb3Mocm90YXRpb24ueSk7XG4gICAgY29uc3QgY3ogPSBNYXRoLmNvcyhyb3RhdGlvbi56KTtcbiAgICBjb25zdCBzeCA9IE1hdGguc2luKHJvdGF0aW9uLngpO1xuICAgIGNvbnN0IHN5ID0gTWF0aC5zaW4ocm90YXRpb24ueSk7XG4gICAgY29uc3Qgc3ogPSBNYXRoLnNpbihyb3RhdGlvbi56KTtcbiAgICByZXR1cm4gW1xuICAgICAgICAoMCwgdmVjXzEudmVjMykoY3kgKiBjeiwgY3kgKiBzeiwgLXN5KSxcbiAgICAgICAgKDAsIHZlY18xLnZlYzMpKHN4ICogc3kgKiBjeiAtIGN4ICogc3osIHN4ICogc3kgKiBzeiArIGN4ICogY3osIHN4ICogY3kpLFxuICAgICAgICAoMCwgdmVjXzEudmVjMykoY3ggKiBzeSAqIGN6ICsgc3ggKiBzeiwgY3ggKiBzeSAqIHN6IC0gc3ggKiBjeiwgY3ggKiBjeSksXG4gICAgXTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCByb3RhdGVkIGF4ZXMgZm9yIGEgY3Vib2lkXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0ZWRBeGVzKHJvdGF0aW9uTWF0cml4KSB7XG4gICAgaWYgKCFyb3RhdGlvbk1hdHJpeCkge1xuICAgICAgICByZXR1cm4gWygwLCB2ZWNfMS52ZWMzKSgxLCAwLCAwKSwgKDAsIHZlY18xLnZlYzMpKDAsIDEsIDApLCAoMCwgdmVjXzEudmVjMykoMCwgMCwgMSldO1xuICAgIH1cbiAgICByZXR1cm4gcm90YXRpb25NYXRyaXg7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjcm9zcyBwcm9kdWN0IGF4ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q3Jvc3NQcm9kdWN0QXhlcyhheGVzQSwgYXhlc0IpIHtcbiAgICBjb25zdCBjcm9zc0F4ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF4aXNBIG9mIGF4ZXNBKSB7XG4gICAgICAgIGZvciAoY29uc3QgYXhpc0Igb2YgYXhlc0IpIHtcbiAgICAgICAgICAgIGNyb3NzQXhlcy5wdXNoKHZlY18xLnZlYzMuY3Jvc3MoYXhpc0EsIGF4aXNCKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyb3NzQXhlcztcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHByb2plY3QgY3Vib2lkIG9udG8gYXhpc1xuICovXG5mdW5jdGlvbiBwcm9qZWN0Q3Vib2lkKGhhbGZTaXplLCByb3RhdGlvbk1hdHJpeCwgYXhpcykge1xuICAgIGxldCBwcm9qZWN0aW9uID0gMDtcbiAgICBpZiAoIXJvdGF0aW9uTWF0cml4KSB7XG4gICAgICAgIC8vIFVucm90YXRlZCBjdWJvaWQgLSBqdXN0IHN1bSB1cCB0aGUgY29tcG9uZW50c1xuICAgICAgICBwcm9qZWN0aW9uID1cbiAgICAgICAgICAgIE1hdGguYWJzKGhhbGZTaXplLnggKiBheGlzLngpICtcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhoYWxmU2l6ZS55ICogYXhpcy55KSArXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoaGFsZlNpemUueiAqIGF4aXMueik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBSb3RhdGVkIGN1Ym9pZCAtIG5lZWQgdG8gYWNjb3VudCBmb3Igcm90YXRpb25cbiAgICAgICAgcHJvamVjdGlvbiA9XG4gICAgICAgICAgICBNYXRoLmFicyh2ZWNfMS52ZWMzLmRvdCh2ZWNfMS52ZWMzLm11bChyb3RhdGlvbk1hdHJpeFswXSwgaGFsZlNpemUueCksIGF4aXMpKSArXG4gICAgICAgICAgICAgICAgTWF0aC5hYnModmVjXzEudmVjMy5kb3QodmVjXzEudmVjMy5tdWwocm90YXRpb25NYXRyaXhbMV0sIGhhbGZTaXplLnkpLCBheGlzKSkgK1xuICAgICAgICAgICAgICAgIE1hdGguYWJzKHZlY18xLnZlYzMuZG90KHZlY18xLnZlYzMubXVsKHJvdGF0aW9uTWF0cml4WzJdLCBoYWxmU2l6ZS56KSwgYXhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBjb250YWN0IHBvaW50IG9uIGN1Ym9pZCBzdXJmYWNlXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRhY3RQb2ludChjdWJvaWQsIG5vcm1hbCkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gY3Vib2lkVmVydGljZXMoY3Vib2lkKTtcbiAgICBsZXQgbWF4UHJvaiA9IC1JbmZpbml0eTtcbiAgICBsZXQgY29udGFjdFBvaW50ID0gdmVydGljZXNbMF07XG4gICAgLy8gRmluZCB2ZXJ0ZXggd2l0aCBtYXhpbXVtIHByb2plY3Rpb24gYWxvbmcgbm9ybWFsXG4gICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgdmVydGljZXMpIHtcbiAgICAgICAgY29uc3QgcHJvaiA9IHZlY18xLnZlYzMuZG90KHZlcnRleCwgbm9ybWFsKTtcbiAgICAgICAgaWYgKHByb2ogPiBtYXhQcm9qKSB7XG4gICAgICAgICAgICBtYXhQcm9qID0gcHJvajtcbiAgICAgICAgICAgIGNvbnRhY3RQb2ludCA9IHZlcnRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFjdFBvaW50O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGN1Ym9pZCBpbnRlcnNlY3RzIGEgcGxhbmVcbiAqL1xuZnVuY3Rpb24gY3Vib2lkSW50ZXJzZWN0c1BsYW5lKGN1Ym9pZCwgcGxhbmUpIHtcbiAgICAvLyBHZXQgY3Vib2lkIGZhY2VzIGFzIHRyaWFuZ2xlc1xuICAgIGNvbnN0IHBvbHlnb25zID0gY3Vib2lkVG9Qb2x5Z29ucyhjdWJvaWQpO1xuICAgIGNvbnN0IGFsbEludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIFRyYWNrIHZlcnRpY2VzIG9uIGVhY2ggc2lkZSBvZiB0aGUgcGxhbmUgZm9yIHBlbmV0cmF0aW9uIGRlcHRoIGNhbGN1bGF0aW9uXG4gICAgY29uc3Qgbm9ybWFsaXplZFBsYW5lTm9ybWFsID0gdmVjXzEudmVjMy5ub3IocGxhbmUubm9ybWFsKTtcbiAgICBsZXQgbWF4UGVuZXRyYXRpb24gPSAtSW5maW5pdHk7XG4gICAgbGV0IG1pblBlbmV0cmF0aW9uID0gSW5maW5pdHk7XG4gICAgLy8gQ2hlY2sgZWFjaCB2ZXJ0ZXgncyBzaWduZWQgZGlzdGFuY2UgdG8gcGxhbmVcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IGN1Ym9pZFZlcnRpY2VzKGN1Ym9pZCk7XG4gICAgdmVydGljZXMuZm9yRWFjaCh2ZXJ0ZXggPT4ge1xuICAgICAgICBjb25zdCBzaWduZWREaXN0YW5jZSA9IHZlY18xLnZlYzMuZG90KHZlY18xLnZlYzMuc3ViKHZlcnRleCwgcGxhbmUucG9pbnQpLCBub3JtYWxpemVkUGxhbmVOb3JtYWwpO1xuICAgICAgICBtYXhQZW5ldHJhdGlvbiA9IE1hdGgubWF4KG1heFBlbmV0cmF0aW9uLCBzaWduZWREaXN0YW5jZSk7XG4gICAgICAgIG1pblBlbmV0cmF0aW9uID0gTWF0aC5taW4obWluUGVuZXRyYXRpb24sIHNpZ25lZERpc3RhbmNlKTtcbiAgICB9KTtcbiAgICAvLyBDaGVjayBlYWNoIHBvbHlnb24gZm9yIGludGVyc2VjdGlvblxuICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiBwb2x5Z29ucykge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBwb2x5Z29uSW50ZXJzZWN0c1BsYW5lKHBvbHlnb24sIHBsYW5lKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbiA9PT0gbnVsbCB8fCBpbnRlcnNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyc2VjdGlvbi5pbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICAvLyBJZiBwb2x5Z29uIGhhcyBzcGVjaWZpYyBpbnRlcnNlY3Rpb24gcG9pbnRzLCBhZGQgdGhlbVxuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnRzLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBhbHJlYWR5IGluIGxpc3QgKHdpdGhpbiBlcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0R1cGxpY2F0ZSA9IGFsbEludGVyc2VjdGlvblBvaW50cy5zb21lKGV4aXN0aW5nID0+IHZlY18xLnZlYzMubGVuKHZlY18xLnZlYzMuc3ViKGV4aXN0aW5nLCBwb2ludCkpIDwgY29uc3RhbnRzLkVQU0lMT04pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxJbnRlcnNlY3Rpb25Qb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgcGVuZXRyYXRpb24gZGVwdGhcbiAgICAvLyBJZiBtaW4gYW5kIG1heCBwZW5ldHJhdGlvbnMgaGF2ZSBkaWZmZXJlbnQgc2lnbnMsIGN1Ym9pZCBzdHJhZGRsZXMgdGhlXG4gICAgLy8gcGxhbmUuIE90aGVyd2lzZSwgcGVuZXRyYXRpb24gaXMgdGhlIG1pbmltdW0gYWJzb2x1dGUgZGlzdGFuY2UgdG8gcGxhbmVcbiAgICBsZXQgcGVuZXRyYXRpb25EZXB0aDtcbiAgICBpZiAobWluUGVuZXRyYXRpb24gKiBtYXhQZW5ldHJhdGlvbiA8PSAwKSB7XG4gICAgICAgIC8vIEN1Ym9pZCBzdHJhZGRsZXMgcGxhbmUgLSBwZW5ldHJhdGlvbiBpcyB0aGUgbGFyZ2VyIGFic29sdXRlIHZhbHVlXG4gICAgICAgIHBlbmV0cmF0aW9uRGVwdGggPSBNYXRoLm1heChNYXRoLmFicyhtaW5QZW5ldHJhdGlvbiksIE1hdGguYWJzKG1heFBlbmV0cmF0aW9uKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKG1heFBlbmV0cmF0aW9uKSA8IE1hdGguYWJzKG1pblBlbmV0cmF0aW9uKSkge1xuICAgICAgICAvLyBBbGwgdmVydGljZXMgb24gcG9zaXRpdmUgc2lkZSBvZiBwbGFuZVxuICAgICAgICBwZW5ldHJhdGlvbkRlcHRoID0gTWF0aC5hYnMobWF4UGVuZXRyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQWxsIHZlcnRpY2VzIG9uIG5lZ2F0aXZlIHNpZGUgb2YgcGxhbmVcbiAgICAgICAgcGVuZXRyYXRpb25EZXB0aCA9IE1hdGguYWJzKG1pblBlbmV0cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogYWxsSW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogYWxsSW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgPyBhbGxJbnRlcnNlY3Rpb25Qb2ludHMgOiB1bmRlZmluZWQsXG4gICAgICAgIHBlbmV0cmF0aW9uRGVwdGg6IHBlbmV0cmF0aW9uRGVwdGgsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjdWJvaWQgaW50ZXJzZWN0cyBhIHBvbHlnb25cbiAqL1xuZnVuY3Rpb24gY3Vib2lkSW50ZXJzZWN0c1BvbHlnb24oY3Vib2lkLCBwb2x5Z29uKSB7XG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgdGhlIHBvbHlnb25cbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbnkgcG9seWdvbiB2ZXJ0ZXggaXMgaW5zaWRlIHRoZSBjdWJvaWRcbiAgICBjb25zdCB2ZXJ0aWNlc0luc2lkZSA9IHBvbHlnb24udmVydGljZXMubWFwKHYgPT4gcG9pbnRJbkN1Ym9pZCh2LCBjdWJvaWQpKTtcbiAgICBpZiAodmVydGljZXNJbnNpZGUuZXZlcnkocmVzdWx0ID0+IHJlc3VsdC5pbnRlcnNlY3RzKSkge1xuICAgICAgICAvLyBQb2x5Z29uIGlzIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gY3Vib2lkXG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IHRydWUgfTtcbiAgICB9XG4gICAgLy8gR2V0IGN1Ym9pZCB2ZXJ0aWNlcyBhbmQgY2hlY2sgaWYgYW55IGFyZSBvbiB0aGUgcG9seWdvblxuICAgIGNvbnN0IGN1Ym9pZFZlcnRpY2VzQXJyYXkgPSBjdWJvaWRWZXJ0aWNlcyhjdWJvaWQpO1xuICAgIGNvbnN0IHZlcnRpY2VzT25Qb2x5Z29uID0gY3Vib2lkVmVydGljZXNBcnJheS5tYXAodiA9PiBwb2ludE9uUG9seWdvbih2LCBwb2x5Z29uKSk7XG4gICAgaWYgKHZlcnRpY2VzT25Qb2x5Z29uLnNvbWUocmVzdWx0ID0+IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5pbnRlcnNlY3RzKSkge1xuICAgICAgICAvLyBBdCBsZWFzdCBvbmUgY3Vib2lkIHZlcnRleCBsaWVzIG9uIHRoZSBwb2x5Z29uXG4gICAgICAgIC8vIFRoaXMgbGlrZWx5IG1lYW5zIHRoZSBwb2x5Z29uIGlzIGNvaW5jaWRlbnQgd2l0aCBhIGN1Ym9pZCBmYWNlXG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IHRydWUgfTtcbiAgICB9XG4gICAgLy8gR2V0IGN1Ym9pZCBlZGdlc1xuICAgIGNvbnN0IGN1Ym9pZEVkZ2VzID0gdmVydGljZXNUb0VkZ2VzKGN1Ym9pZFZlcnRpY2VzQXJyYXkpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIENoZWNrIGVhY2ggY3Vib2lkIGVkZ2UgZm9yIGludGVyc2VjdGlvbiB3aXRoIHRoZSBwb2x5Z29uXG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGN1Ym9pZEVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGxpbmVJbnRlcnNlY3RzUG9seWdvbihlZGdlLCBwb2x5Z29uKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbiAmJlxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmludGVyc2VjdHMgJiZcbiAgICAgICAgICAgIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBwb2ludCBpcyBhbHJlYWR5IGluIG91ciBsaXN0ICh3aXRoaW4gZXBzaWxvbilcbiAgICAgICAgICAgIGNvbnN0IGlzRHVwbGljYXRlID0gaW50ZXJzZWN0aW9uUG9pbnRzLnNvbWUoZXhpc3RpbmcgPT4gKDAsIHV0aWxpdGllc18xLnZlY3RvcnNBbG1vc3RFcXVhbCkoZXhpc3RpbmcsIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCkpO1xuICAgICAgICAgICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHBvbHlnb24gZWRnZXMgYW5kIGNoZWNrIGFnYWluc3QgY3Vib2lkIGZhY2VzXG4gICAgY29uc3QgcG9seWdvbkVkZ2VzID0gdmVydGljZXNUb0VkZ2VzKHBvbHlnb24udmVydGljZXMpO1xuICAgIGNvbnN0IGN1Ym9pZFBvbHlnb25zID0gY3Vib2lkVG9Qb2x5Z29ucyhjdWJvaWQpO1xuICAgIC8vIENoZWNrIGVhY2ggcG9seWdvbiBlZGdlIGFnYWluc3QgZWFjaCBjdWJvaWQgZmFjZVxuICAgIGZvciAoY29uc3QgZWRnZSBvZiBwb2x5Z29uRWRnZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmYWNlIG9mIGN1Ym9pZFBvbHlnb25zKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBsaW5lSW50ZXJzZWN0c1BvbHlnb24oZWRnZSwgZmFjZSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmludGVyc2VjdHMgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHBvaW50IGlzIGFscmVhZHkgaW4gb3VyIGxpc3QgKHdpdGhpbiBlcHNpbG9uKVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzRHVwbGljYXRlID0gaW50ZXJzZWN0aW9uUG9pbnRzLnNvbWUoZXhpc3RpbmcgPT4gKDAsIHV0aWxpdGllc18xLnZlY3RvcnNBbG1vc3RFcXVhbCkoZXhpc3RpbmcsIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCkpO1xuICAgICAgICAgICAgICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgICAgIHZlcnRpY2VzSW5zaWRlLnNvbWUocmVzdWx0ID0+IHJlc3VsdC5pbnRlcnNlY3RzKSB8fFxuICAgICAgICAgICAgdmVydGljZXNPblBvbHlnb24uc29tZShyZXN1bHQgPT4gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmludGVyc2VjdHMpLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY3Vib2lkIGludGVyc2VjdHMgYW55IHBvbHlnb24gaW4gYSBtZXNoXG4gKi9cbmZ1bmN0aW9uIGN1Ym9pZEludGVyc2VjdHNNZXNoKGN1Ym9pZCwgbWVzaCkge1xuICAgIGNvbnN0IHBvbHlnb25zID0gbWVzaFRvUG9seWdvbnMobWVzaCk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgLy8gQ2hlY2sgZWFjaCBwb2x5Z29uIGluIHRoZSBtZXNoIGFnYWluc3QgdGhlIGN1Ym9pZFxuICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiBwb2x5Z29ucykge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBjdWJvaWRJbnRlcnNlY3RzUG9seWdvbihjdWJvaWQsIHBvbHlnb24pO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNwZWNpZmljIGludGVyc2VjdGlvbiBwb2ludHMsIGFkZCB0aGVtXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50cykge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGFscmVhZHkgaW4gbGlzdCAod2l0aGluIGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRHVwbGljYXRlID0gaW50ZXJzZWN0aW9uUG9pbnRzLnNvbWUoZXhpc3RpbmcgPT4gKDAsIHV0aWxpdGllc18xLnZlY3RvcnNBbG1vc3RFcXVhbCkoZXhpc3RpbmcsIHBvaW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGJ1dCB3ZSBrbm93IHRoZXJlJ3MgYW5cbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3Rpb24sIHdlIGNhbiBlYXJseSByZXR1cm4gc2luY2Ugd2Uga25vdyB0aGV5IGludGVyc2VjdFxuICAgICAgICAgICAgICAgIC8vICh0aGlzIGhhcHBlbnMgd2hlbiBhIHBvbHlnb24gaXMgaW5zaWRlIHRoZSBjdWJvaWQgb3IgY29pbmNpZGVudFxuICAgICAgICAgICAgICAgIC8vIHdpdGggYSBmYWNlKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCA/IGludGVyc2VjdGlvblBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiB0d28gcG9seWdvbnMgaW50ZXJzZWN0XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25JbnRlcnNlY3RzUG9seWdvbihwb2x5Z29uQSwgcG9seWdvbkIpIHtcbiAgICAvLyBGaXJzdCB2YWxpZGF0ZSBib3RoIHBvbHlnb25zXG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uQSkgfHwgIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb25CKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIHBsYW5lcyBmcm9tIGJvdGggcG9seWdvbnNcbiAgICBjb25zdCBwbGFuZUEgPSB7XG4gICAgICAgIHBvaW50OiBwb2x5Z29uQS52ZXJ0aWNlc1swXSxcbiAgICAgICAgbm9ybWFsOiB2ZWNfMS52ZWMzLm5vcih2ZWNfMS52ZWMzLmNyb3NzKHZlY18xLnZlYzMuc3ViKHBvbHlnb25BLnZlcnRpY2VzWzFdLCBwb2x5Z29uQS52ZXJ0aWNlc1swXSksIHZlY18xLnZlYzMuc3ViKHBvbHlnb25BLnZlcnRpY2VzWzJdLCBwb2x5Z29uQS52ZXJ0aWNlc1swXSkpKSxcbiAgICB9O1xuICAgIGNvbnN0IHBsYW5lQiA9IHtcbiAgICAgICAgcG9pbnQ6IHBvbHlnb25CLnZlcnRpY2VzWzBdLFxuICAgICAgICBub3JtYWw6IHZlY18xLnZlYzMubm9yKHZlY18xLnZlYzMuY3Jvc3ModmVjXzEudmVjMy5zdWIocG9seWdvbkIudmVydGljZXNbMV0sIHBvbHlnb25CLnZlcnRpY2VzWzBdKSwgdmVjXzEudmVjMy5zdWIocG9seWdvbkIudmVydGljZXNbMl0sIHBvbHlnb25CLnZlcnRpY2VzWzBdKSkpLFxuICAgIH07XG4gICAgLy8gQ2hlY2sgaWYgcGxhbmVzIGludGVyc2VjdFxuICAgIGNvbnN0IHBsYW5lSW50ZXJzZWN0aW9uID0gcGxhbmVJbnRlcnNlY3RzUGxhbmUocGxhbmVBLCBwbGFuZUIpO1xuICAgIC8vIElmIHBsYW5lcyBkb24ndCBpbnRlcnNlY3QsIHBvbHlnb25zIGNhbid0IGludGVyc2VjdFxuICAgIGlmICghcGxhbmVJbnRlcnNlY3Rpb24uaW50ZXJzZWN0cykge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBJZiBwbGFuZXMgYXJlIGNvaW5jaWRlbnQsIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHBvbHlnb24gb3ZlcmxhcFxuICAgIGlmICghcGxhbmVJbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uTGluZSkge1xuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiBhbnkgdmVydGV4IG9mIHBvbHlnb24gQSBsaWVzIGluc2lkZSBwb2x5Z29uIEJcbiAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgcG9seWdvbkEudmVydGljZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50Q2hlY2sgPSBwb2ludE9uUG9seWdvbih2ZXJ0ZXgsIHBvbHlnb25CKTtcbiAgICAgICAgICAgIGlmIChwb2ludENoZWNrID09PSBudWxsIHx8IHBvaW50Q2hlY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvaW50Q2hlY2suaW50ZXJzZWN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IHRydWUgfTsgLy8gQ29wbGFuYXIgb3ZlcmxhcFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZW4gY2hlY2sgaWYgYW55IHZlcnRleCBvZiBwb2x5Z29uIEIgbGllcyBpbnNpZGUgcG9seWdvbiBBXG4gICAgICAgIGZvciAoY29uc3QgdmVydGV4IG9mIHBvbHlnb25CLnZlcnRpY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludENoZWNrID0gcG9pbnRPblBvbHlnb24odmVydGV4LCBwb2x5Z29uQSk7XG4gICAgICAgICAgICBpZiAocG9pbnRDaGVjayA9PT0gbnVsbCB8fCBwb2ludENoZWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2ludENoZWNrLmludGVyc2VjdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiB0cnVlIH07IC8vIENvcGxhbmFyIG92ZXJsYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBvdmVybGFwIGZvdW5kXG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIEdldCBlZGdlcyBmcm9tIGJvdGggcG9seWdvbnNcbiAgICBjb25zdCBlZGdlc0EgPSB2ZXJ0aWNlc1RvRWRnZXMocG9seWdvbkEudmVydGljZXMpO1xuICAgIGNvbnN0IGVkZ2VzQiA9IHZlcnRpY2VzVG9FZGdlcyhwb2x5Z29uQi52ZXJ0aWNlcyk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgLy8gQ2hlY2sgZWFjaCBlZGdlIG9mIHBvbHlnb24gQSBhZ2FpbnN0IGVhY2ggZWRnZSBvZiBwb2x5Z29uIEJcbiAgICBmb3IgKGNvbnN0IGVkZ2VBIG9mIGVkZ2VzQSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVkZ2VCIG9mIGVkZ2VzQikge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdHNMaW5lKGVkZ2VBLCBlZGdlQik7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLmludGVyc2VjdHMgJiYgaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgbGllcyBvbiBib3RoIGVkZ2VzXG4gICAgICAgICAgICAgICAgY29uc3Qgb25FZGdlQSA9IHBvaW50T25MaW5lKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCwgZWRnZUEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uRWRnZUIgPSBwb2ludE9uTGluZShpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQsIGVkZ2VCKTtcbiAgICAgICAgICAgICAgICBpZiAob25FZGdlQS5pbnRlcnNlY3RzICYmIG9uRWRnZUIuaW50ZXJzZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHBvaW50IGlzIGFscmVhZHkgaW4gb3VyIGxpc3QgKHdpdGhpbiBlcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0R1cGxpY2F0ZSA9IGludGVyc2VjdGlvblBvaW50cy5zb21lKGV4aXN0aW5nID0+IHZlY18xLnZlYzMubGVuKHZlY18xLnZlYzMuc3ViKGV4aXN0aW5nLCBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpKSA8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuRVBTSUxPTik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgPyBpbnRlcnNlY3Rpb25Qb2ludHMgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2x5Z29uIGludGVyc2VjdHMgYSBwbGFuZVxuICovXG5mdW5jdGlvbiBwb2x5Z29uSW50ZXJzZWN0c1BsYW5lKHBvbHlnb24sIHBsYW5lKSB7XG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgdGhlIHBvbHlnb25cbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHBvbHlnb24gdmVydGljZXMgdG8gZWRnZXNcbiAgICBjb25zdCBlZGdlcyA9IHZlcnRpY2VzVG9FZGdlcyhwb2x5Z29uLnZlcnRpY2VzKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICBsZXQgZWRnZUluUGxhbmUgPSBmYWxzZTtcbiAgICAvLyBDaGVjayBlYWNoIGVkZ2UgZm9yIGludGVyc2VjdGlvbiB3aXRoIHRoZSBwbGFuZVxuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBsaW5lSW50ZXJzZWN0c1BsYW5lKGVkZ2UsIHBsYW5lKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBpbnRlcnNlY3RzIHBsYW5lIGF0IGEgcG9pbnRcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBsaWVzIGluIHRoZSBwbGFuZVxuICAgICAgICAgICAgICAgIGVkZ2VJblBsYW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gRWFybHkgZXhpdCBhcyBwb2x5Z29uIG11c3QgbGllIGluIHBsYW5lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgYW55IGVkZ2UgbGllcyBpbiB0aGUgcGxhbmUsIHRoZSB3aG9sZSBwb2x5Z29uIG11c3QgbGllIGluIHRoZSBwbGFuZVxuICAgIC8vIChzaW5jZSB3ZSd2ZSB2ZXJpZmllZCBpdCdzIGEgdmFsaWQgdHJpYW5nbGUpXG4gICAgaWYgKGVkZ2VJblBsYW5lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGludGVyc2VjdGlvbiBwb2ludHMgKHdpdGhpbiBlcHNpbG9uKVxuICAgIGNvbnN0IHVuaXF1ZVBvaW50cyA9IGludGVyc2VjdGlvblBvaW50cy5maWx0ZXIoKHBvaW50LCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gIWludGVyc2VjdGlvblBvaW50cy5zb21lKChwLCBpKSA9PiBpIDwgaW5kZXggJiYgdmVjXzEudmVjMy5sZW4odmVjXzEudmVjMy5zdWIocCwgcG9pbnQpKSA8IGNvbnN0YW50cy5FUFNJTE9OKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiB1bmlxdWVQb2ludHMubGVuZ3RoID4gMCxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiB1bmlxdWVQb2ludHMubGVuZ3RoID4gMCA/IHVuaXF1ZVBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvbHlnb24gaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBpbiBhIG1lc2hcbiAqL1xuZnVuY3Rpb24gcG9seWdvbkludGVyc2VjdHNNZXNoKHBvbHlnb24sIG1lc2gpIHtcbiAgICAvLyBGaXJzdCB2YWxpZGF0ZSB0aGUgcG9seWdvblxuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1lc2hQb2x5Z29ucyA9IG1lc2hUb1BvbHlnb25zKG1lc2gpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIENoZWNrIHRoZSBwb2x5Z29uIGFnYWluc3QgZWFjaCBtZXNoIHBvbHlnb25cbiAgICBmb3IgKGNvbnN0IG1lc2hQb2x5Z29uIG9mIG1lc2hQb2x5Z29ucykge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBwb2x5Z29uSW50ZXJzZWN0c1BvbHlnb24ocG9seWdvbiwgbWVzaFBvbHlnb24pO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGludGVyc2VjdGlvbiBwb2ludHMsIGNvbGxlY3QgdGhlbVxuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnRzLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBhbHJlYWR5IGluIGxpc3QgKHdpdGhpbiBlcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0R1cGxpY2F0ZSA9IGludGVyc2VjdGlvblBvaW50cy5zb21lKGV4aXN0aW5nID0+ICgwLCB1dGlsaXRpZXNfMS52ZWN0b3JzQWxtb3N0RXF1YWwpKGV4aXN0aW5nLCBwb2ludCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW50ZXJzZWN0aW9uIGJ1dCBubyBwb2ludHMsIGl0IG1lYW5zIHdlIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBjb3BsYW5hciBvdmVybGFwcGluZyBwb2x5Z29ucyAtIHdlIGNhbiByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgPyBpbnRlcnNlY3Rpb25Qb2ludHMgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG1lc2hlcyBpbnRlcnNlY3QgdXNpbmcgdGhlaXIgcG9seWdvbnNcbiAqL1xuZnVuY3Rpb24gbWVzaEludGVyc2VjdHNNZXNoKG1lc2hBLCBtZXNoQikge1xuICAgIGNvbnN0IHBvbHlnb25zQSA9IG1lc2hUb1BvbHlnb25zKG1lc2hBKTtcbiAgICBjb25zdCBwb2x5Z29uc0IgPSBtZXNoVG9Qb2x5Z29ucyhtZXNoQik7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgLy8gQ2hlY2sgZWFjaCBwb2x5Z29uIGluIG1lc2ggQSBhZ2FpbnN0IGVhY2ggcG9seWdvbiBpbiBtZXNoIEJcbiAgICBmb3IgKGNvbnN0IHBvbHlnb25BIG9mIHBvbHlnb25zQSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBvbHlnb25CIG9mIHBvbHlnb25zQikge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gcG9seWdvbkludGVyc2VjdHNQb2x5Z29uKHBvbHlnb25BLCBwb2x5Z29uQik7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50cy5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGFscmVhZHkgaW4gbGlzdCAod2l0aGluIGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0R1cGxpY2F0ZSA9IGludGVyc2VjdGlvblBvaW50cy5zb21lKGV4aXN0aW5nID0+IHZlY18xLnZlYzMubGVuKHZlY18xLnZlYzMuc3ViKGV4aXN0aW5nLCBwb2ludCkpIDwgY29uc3RhbnRzLkVQU0lMT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGFueSBwb2x5Z29ucyBpbiBhIG1lc2ggaW50ZXJzZWN0IGEgcGxhbmVcbiAqL1xuZnVuY3Rpb24gbWVzaEludGVyc2VjdHNQbGFuZShtZXNoLCBwbGFuZSkge1xuICAgIC8vIENvbnZlcnQgbWVzaCB0byBwb2x5Z29uc1xuICAgIGNvbnN0IHBvbHlnb25zID0gbWVzaFRvUG9seWdvbnMobWVzaCk7XG4gICAgY29uc3QgYWxsSW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgLy8gVHJhY2sgbWF4aW11bSBwZW5ldHJhdGlvbiBkZXB0aFxuICAgIGxldCBtYXhQZW5ldHJhdGlvbiA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluUGVuZXRyYXRpb24gPSBJbmZpbml0eTtcbiAgICAvLyBOb3JtYWxpemUgcGxhbmUgbm9ybWFsIGZvciBjb25zaXN0ZW50IHNpZ25lZCBkaXN0YW5jZSBjYWxjdWxhdGlvbnNcbiAgICBjb25zdCBub3JtYWxpemVkUGxhbmVOb3JtYWwgPSB2ZWNfMS52ZWMzLm5vcihwbGFuZS5ub3JtYWwpO1xuICAgIC8vIENoZWNrIGVhY2ggdmVydGV4J3Mgc2lnbmVkIGRpc3RhbmNlIHRvIHBsYW5lXG4gICAgbWVzaC52ZXJ0aWNlcy5mb3JFYWNoKHZlcnRleCA9PiB7XG4gICAgICAgIGNvbnN0IHNpZ25lZERpc3RhbmNlID0gdmVjXzEudmVjMy5kb3QodmVjXzEudmVjMy5zdWIodmVydGV4LCBwbGFuZS5wb2ludCksIG5vcm1hbGl6ZWRQbGFuZU5vcm1hbCk7XG4gICAgICAgIG1heFBlbmV0cmF0aW9uID0gTWF0aC5tYXgobWF4UGVuZXRyYXRpb24sIHNpZ25lZERpc3RhbmNlKTtcbiAgICAgICAgbWluUGVuZXRyYXRpb24gPSBNYXRoLm1pbihtaW5QZW5ldHJhdGlvbiwgc2lnbmVkRGlzdGFuY2UpO1xuICAgIH0pO1xuICAgIC8vIENoZWNrIGVhY2ggcG9seWdvbiBmb3IgaW50ZXJzZWN0aW9uXG4gICAgbGV0IGhhc0ludGVyc2VjdGlvbiA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiBwb2x5Z29ucykge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBwb2x5Z29uSW50ZXJzZWN0c1BsYW5lKHBvbHlnb24sIHBsYW5lKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbiA9PT0gbnVsbCB8fCBpbnRlcnNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyc2VjdGlvbi5pbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICBoYXNJbnRlcnNlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgLy8gSWYgcG9seWdvbiBoYXMgc3BlY2lmaWMgaW50ZXJzZWN0aW9uIHBvaW50cywgYWRkIHRoZW1cbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50cy5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcG9pbnQgaXMgYWxyZWFkeSBpbiBsaXN0ICh3aXRoaW4gZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNEdXBsaWNhdGUgPSBhbGxJbnRlcnNlY3Rpb25Qb2ludHMuc29tZShleGlzdGluZyA9PiB2ZWNfMS52ZWMzLmxlbih2ZWNfMS52ZWMzLnN1YihleGlzdGluZywgcG9pbnQpKSA8IGNvbnN0YW50cy5FUFNJTE9OKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsSW50ZXJzZWN0aW9uUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHBlbmV0cmF0aW9uIGRlcHRoXG4gICAgLy8gSWYgbWluIGFuZCBtYXggcGVuZXRyYXRpb25zIGhhdmUgZGlmZmVyZW50IHNpZ25zLCBtZXNoIHN0cmFkZGxlcyB0aGUgcGxhbmVcbiAgICAvLyBPdGhlcndpc2UsIHBlbmV0cmF0aW9uIGlzIHRoZSBtaW5pbXVtIGFic29sdXRlIGRpc3RhbmNlIHRvIHBsYW5lXG4gICAgbGV0IHBlbmV0cmF0aW9uRGVwdGg7XG4gICAgaWYgKG1pblBlbmV0cmF0aW9uICogbWF4UGVuZXRyYXRpb24gPD0gMCkge1xuICAgICAgICAvLyBNZXNoIHN0cmFkZGxlcyBwbGFuZSAtIHBlbmV0cmF0aW9uIGlzIHRoZSBsYXJnZXIgYWJzb2x1dGUgdmFsdWVcbiAgICAgICAgcGVuZXRyYXRpb25EZXB0aCA9IE1hdGgubWF4KE1hdGguYWJzKG1pblBlbmV0cmF0aW9uKSwgTWF0aC5hYnMobWF4UGVuZXRyYXRpb24pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoTWF0aC5hYnMobWF4UGVuZXRyYXRpb24pIDwgTWF0aC5hYnMobWluUGVuZXRyYXRpb24pKSB7XG4gICAgICAgIC8vIEFsbCB2ZXJ0aWNlcyBvbiBwb3NpdGl2ZSBzaWRlIG9mIHBsYW5lXG4gICAgICAgIHBlbmV0cmF0aW9uRGVwdGggPSBNYXRoLmFicyhtYXhQZW5ldHJhdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBBbGwgdmVydGljZXMgb24gbmVnYXRpdmUgc2lkZSBvZiBwbGFuZVxuICAgICAgICBwZW5ldHJhdGlvbkRlcHRoID0gTWF0aC5hYnMobWluUGVuZXRyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBoYXNJbnRlcnNlY3Rpb24sXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogYWxsSW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgPyBhbGxJbnRlcnNlY3Rpb25Qb2ludHMgOiB1bmRlZmluZWQsXG4gICAgICAgIHBlbmV0cmF0aW9uRGVwdGg6IHBlbmV0cmF0aW9uRGVwdGgsXG4gICAgfTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy8zZC90eXBlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy8zZC90eXBlcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5pc1BvaW50ID0gaXNQb2ludDtcbmV4cG9ydHMuaXNSYXkgPSBpc1JheTtcbmV4cG9ydHMuaXNMaW5lID0gaXNMaW5lO1xuZXhwb3J0cy5pc1NwaGVyZSA9IGlzU3BoZXJlO1xuZXhwb3J0cy5pc0FBQkIgPSBpc0FBQkI7XG5leHBvcnRzLmlzQ3Vib2lkID0gaXNDdWJvaWQ7XG5leHBvcnRzLmlzUGxhbmUgPSBpc1BsYW5lO1xuZXhwb3J0cy5pc1BvbHlnb24gPSBpc1BvbHlnb247XG5leHBvcnRzLmlzTWVzaCA9IGlzTWVzaDtcbmNvbnN0IHR5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsaXRpZXMvdHlwZXMgKi8gXCIuL3NyYy91dGlsaXRpZXMvdHlwZXMudHNcIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIFBvaW50XG4gKi9cbmZ1bmN0aW9uIGlzUG9pbnQodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHR5cGVzXzEuaXNWZWMzKSh2YWx1ZSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBSYXlcbiAqL1xuZnVuY3Rpb24gaXNSYXkodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ29yaWdpbicgaW4gdmFsdWUgJiZcbiAgICAgICAgaXNQb2ludCh2YWx1ZS5vcmlnaW4pICYmXG4gICAgICAgICdkaXJlY3Rpb24nIGluIHZhbHVlICYmXG4gICAgICAgICgwLCB0eXBlc18xLmlzVmVjMykodmFsdWUuZGlyZWN0aW9uKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBMaW5lXG4gKi9cbmZ1bmN0aW9uIGlzTGluZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnc3RhcnQnIGluIHZhbHVlICYmXG4gICAgICAgIGlzUG9pbnQodmFsdWUuc3RhcnQpICYmXG4gICAgICAgICdlbmQnIGluIHZhbHVlICYmXG4gICAgICAgIGlzUG9pbnQodmFsdWUuZW5kKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBTcGhlcmVcbiAqL1xuZnVuY3Rpb24gaXNTcGhlcmUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3Bvc2l0aW9uJyBpbiB2YWx1ZSAmJlxuICAgICAgICBpc1BvaW50KHZhbHVlLnBvc2l0aW9uKSAmJlxuICAgICAgICAncmFkaXVzJyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUucmFkaXVzID09PSAnbnVtYmVyJyk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gQUFCQlxuICovXG5mdW5jdGlvbiBpc0FBQkIodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3Bvc2l0aW9uJyBpbiB2YWx1ZSAmJlxuICAgICAgICBpc1BvaW50KHZhbHVlLnBvc2l0aW9uKSAmJlxuICAgICAgICAnc2l6ZScgaW4gdmFsdWUgJiZcbiAgICAgICAgKDAsIHR5cGVzXzEuaXNWZWMzKSh2YWx1ZS5zaXplKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBDdWJvaWRcbiAqL1xuZnVuY3Rpb24gaXNDdWJvaWQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3Bvc2l0aW9uJyBpbiB2YWx1ZSAmJlxuICAgICAgICBpc1BvaW50KHZhbHVlLnBvc2l0aW9uKSAmJlxuICAgICAgICAnc2l6ZScgaW4gdmFsdWUgJiZcbiAgICAgICAgKDAsIHR5cGVzXzEuaXNWZWMzKSh2YWx1ZS5zaXplKSAmJlxuICAgICAgICAoJ3JvdGF0aW9uJyBpbiB2YWx1ZSA/ICgwLCB0eXBlc18xLmlzVmVjMykodmFsdWUucm90YXRpb24pIDogdHJ1ZSkpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgUGxhbmVcbiAqL1xuZnVuY3Rpb24gaXNQbGFuZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAncG9pbnQnIGluIHZhbHVlICYmXG4gICAgICAgIGlzUG9pbnQodmFsdWUucG9pbnQpICYmXG4gICAgICAgICdub3JtYWwnIGluIHZhbHVlICYmXG4gICAgICAgICgwLCB0eXBlc18xLmlzVmVjMykodmFsdWUubm9ybWFsKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBQb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIGlzUG9seWdvbih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndmVydGljZXMnIGluIHZhbHVlICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUudmVydGljZXMpICYmXG4gICAgICAgIHZhbHVlLnZlcnRpY2VzLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgICB2YWx1ZS52ZXJ0aWNlcy5ldmVyeShpc1BvaW50KSAmJlxuICAgICAgICAhKCdpbmRpY2VzJyBpbiB2YWx1ZSkpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgTWVzaFxuICovXG5mdW5jdGlvbiBpc01lc2godmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3ZlcnRpY2VzJyBpbiB2YWx1ZSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlLnZlcnRpY2VzKSAmJlxuICAgICAgICB2YWx1ZS52ZXJ0aWNlcy5ldmVyeShpc1BvaW50KSAmJlxuICAgICAgICAnaW5kaWNlcycgaW4gdmFsdWUgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZS5pbmRpY2VzKSAmJlxuICAgICAgICB2YWx1ZS5pbmRpY2VzLmV2ZXJ5KChpKSA9PiB0eXBlb2YgaSA9PT0gJ251bWJlcicpKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuaW50ZXJzZWN0aW9uVXRpbGl0aWVzID0gZXhwb3J0cy5pbnRlcnNlY3Rpb24zZCA9IGV4cG9ydHMuaW50ZXJzZWN0aW9uMmQgPSB2b2lkIDA7XG5leHBvcnRzLmludGVyc2VjdGlvbjJkID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vMmQgKi8gXCIuL3NyYy8yZC9pbmRleC50c1wiKSk7XG5leHBvcnRzLmludGVyc2VjdGlvbjNkID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vM2QgKi8gXCIuL3NyYy8zZC9pbmRleC50c1wiKSk7XG5leHBvcnRzLmludGVyc2VjdGlvblV0aWxpdGllcyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxpdGllcyAqLyBcIi4vc3JjL3V0aWxpdGllcy9pbmRleC50c1wiKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbGl0aWVzL2NvbnN0YW50cy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxpdGllcy9jb25zdGFudHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5FUFNJTE9OID0gdm9pZCAwO1xuZXhwb3J0cy5FUFNJTE9OID0gMWUtNjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsaXRpZXMvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxpdGllcy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy52ZWN0b3JBbG1vc3RaZXJvID0gdmVjdG9yQWxtb3N0WmVybztcbmV4cG9ydHMudmVjdG9yc0FsbW9zdEVxdWFsID0gdmVjdG9yc0FsbW9zdEVxdWFsO1xuZXhwb3J0cy52YWx1ZUluSW50ZXJ2YWwgPSB2YWx1ZUluSW50ZXJ2YWw7XG5leHBvcnRzLmludGVydmFsc092ZXJsYXAgPSBpbnRlcnZhbHNPdmVybGFwO1xuZXhwb3J0cy5vdmVybGFwSW50ZXJ2YWwgPSBvdmVybGFwSW50ZXJ2YWw7XG5jb25zdCBjb25zdGFudHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25zdGFudHMgKi8gXCIuL3NyYy91dGlsaXRpZXMvY29uc3RhbnRzLnRzXCIpKTtcbmNvbnN0IHR5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVzICovIFwiLi9zcmMvdXRpbGl0aWVzL3R5cGVzLnRzXCIpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHlwZXMgKi8gXCIuL3NyYy91dGlsaXRpZXMvdHlwZXMudHNcIiksIGV4cG9ydHMpO1xuZnVuY3Rpb24gdmVjdG9yQWxtb3N0WmVybyh2KSB7XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzVmVjMykodikpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyh2LngpIDwgY29uc3RhbnRzLkVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHYueSkgPCBjb25zdGFudHMuRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnModi56KSA8IGNvbnN0YW50cy5FUFNJTE9OKTtcbiAgICB9XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzVmVjMikodikpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyh2LngpIDwgY29uc3RhbnRzLkVQU0lMT04gJiYgTWF0aC5hYnModi55KSA8IGNvbnN0YW50cy5FUFNJTE9OKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdmVjdG9yc0FsbW9zdEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNWZWMzKShhKSAmJiAoMCwgdHlwZXNfMS5pc1ZlYzMpKGIpKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnMoYS54IC0gYi54KSA8IGNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhLnkgLSBiLnkpIDwgY29uc3RhbnRzLkVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEueiAtIGIueikgPCBjb25zdGFudHMuRVBTSUxPTik7XG4gICAgfVxuICAgIGlmICgoMCwgdHlwZXNfMS5pc1ZlYzIpKGEpICYmICgwLCB0eXBlc18xLmlzVmVjMikoYikpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyhhLnggLSBiLngpIDwgY29uc3RhbnRzLkVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEueSAtIGIueSkgPCBjb25zdGFudHMuRVBTSUxPTik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyB3aXRoaW4gYSBzcGVjaWZpZWQgaW50ZXJ2YWxcbiAqL1xuZnVuY3Rpb24gdmFsdWVJbkludGVydmFsKHZhbHVlLCBpbnRlcnZhbCkge1xuICAgIGNvbnN0IHsgbWluLCBtaW5JbmNsdXNpdmUgPSB0cnVlLCBtYXgsIG1heEluY2x1c2l2ZSA9IHRydWUgfSA9IGludGVydmFsO1xuICAgIHJldHVybiAoKG1pbkluY2x1c2l2ZSA/IHZhbHVlID49IG1pbiA6IHZhbHVlID4gbWluKSAmJlxuICAgICAgICAobWF4SW5jbHVzaXZlID8gdmFsdWUgPD0gbWF4IDogdmFsdWUgPCBtYXgpKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIGludGVydmFscyAoYTEsIGEyKSBhbmQgKGIxLCBiMikgb3ZlcmxhcFxuICovXG5mdW5jdGlvbiBpbnRlcnZhbHNPdmVybGFwKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoYS5taW4sIGIubWluKSA8PSBNYXRoLm1pbihhLm1heCwgYi5tYXgpO1xufVxuLyoqXG4gKiBHZXQgdGhlIG92ZXJsYXBwaW5nIHBhcnQgb2YgdHdvIGludGVydmFscyAoYTEsIGEyKSBhbmQgKGIxLCBiMilcbiAqXG4gKiBJZiB0aGUgaW50ZXJ2YWxzIGRvIG5vdCBvdmVybGFwLCByZXR1cm4gbnVsbFxuICovXG5mdW5jdGlvbiBvdmVybGFwSW50ZXJ2YWwoYSwgYikge1xuICAgIGlmICghaW50ZXJ2YWxzT3ZlcmxhcChhLCBiKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWluOiBNYXRoLm1heChhLm1pbiwgYi5taW4pLCBtYXg6IE1hdGgubWluKGEubWF4LCBiLm1heCkgfTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsaXRpZXMvdHlwZXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxpdGllcy90eXBlcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuaXNWZWMyID0gaXNWZWMyO1xuZXhwb3J0cy5pc1ZlYzMgPSBpc1ZlYzM7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSB2ZWMyXG4gKi9cbmZ1bmN0aW9uIGlzVmVjMih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAneCcgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnggPT09ICdudW1iZXInICYmXG4gICAgICAgICd5JyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUueSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgISgneicgaW4gdmFsdWUpKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHZlYzNcbiAqL1xuZnVuY3Rpb24gaXNWZWMzKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICd4JyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUueCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgJ3knIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS55ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAneicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnogPT09ICdudW1iZXInKTtcbn1cblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qKlxuICogQG92ZXJ2aWV3IEEgbGlicmFyeSBvZiB1c2VmdWwgZnVuY3Rpb25zXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxuICovXG5cbi8qKlxuICogTWVtb2l6ZSBhIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIFRoZSBmdW5jdGlvbiB0byBtZW1vaXplXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbWVtb2l6ZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb25cbiAqL1xuY29uc3QgbWVtb2l6ZSA9IGYgPT4ge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY2FjaGVbYXJnc10gPz8gKGNhY2hlW2FyZ3NdID0gZi5hcHBseSh0aGlzLCBhcmdzKSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXIgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgTnVtYmVyIGJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcD1OdW1iZXIuRVBTSUxPTl0gVGhlIHByZWNpc2lvbiB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBudW1iZXJzIGEgYW5kIGIgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAqL1xuY29uc3QgZmxvYXRFcXVhbHMgPSAoYSwgYiwgcCA9IE51bWJlci5FUFNJTE9OKSA9PiBNYXRoLmFicyhhIC0gYikgPCBwO1xuXG4vKipcbiAqIENsYW1wIGEgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gY2xhbXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfSBBIGNsYW1wZWQgbnVtYmVyXG4gKi9cbmNvbnN0IGNsYW1wID0gKGEsIG1pbiA9IDAsIG1heCA9IDEpID0+IGEgPCBtaW4gPyBtaW4gOiAoYSA+IG1heCA/IG1heCA6IGEpO1xuXG4vKipcbiAqIEdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIGEgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBmcmFjdGlvbmFsIHBhcnRcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZyYWN0aW9uYWwgcGFydCBvZiB0aGUgbnVtYmVyXG4gKi9cbmNvbnN0IGZyYWMgPSBhID0+IGEgPj0gMCA/IGEgLSBNYXRoLmZsb29yKGEpIDogYSAtIE1hdGguY2VpbChhKTtcblxuLyoqXG4gKiBSb3VuZCBuIHRvIGQgZGVjaW1hbCBwbGFjZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZD0wXSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kIHRvXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcm91bmRlZCBudW1iZXJcbiAqL1xuY29uc3Qgcm91bmQgPSAobiwgZCA9IDApID0+IHtcbiAgY29uc3QgcCA9IE1hdGgucG93KDEwLCBkKTtcbiAgcmV0dXJuIE1hdGgucm91bmQobiAqIHAgKyBOdW1iZXIuRVBTSUxPTikgLyBwO1xufVxuXG4vKipcbiAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWUsIHNob3VsZCBiZSBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXG4gKi9cbmNvbnN0IGxlcnAgPSAoYSwgYiwgaSkgPT4gYSArIChiIC0gYSkgKiBpO1xuXG4vKipcbiAqIEdldCB0aGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmNvbnN0IHVubGVycCA9IChhLCBiLCBpKSA9PiAoaSAtIGEpIC8gKGIgLSBhKTtcblxuLyoqXG4gKiBEbyBhIGJpbGluZWFyIGludGVycG9sYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDAgVG9wLWxlZnQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTAgVG9wLXJpZ2h0IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gYzAxIEJvdHRvbS1sZWZ0IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gYzExIEJvdHRvbS1yaWdodCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGl4IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeFxuICogQHBhcmFtIHtudW1iZXJ9IGl5IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeVxuICogQHJldHVybiB7bnVtYmVyfSBBIGJpbGluZWFyIGludGVycG9sYXRlZCB2YWx1ZVxuICovXG5jb25zdCBibGVycCA9IChjMDAsIGMxMCwgYzAxLCBjMTEsIGl4LCBpeSkgPT4gbGVycChsZXJwKGMwMCwgYzEwLCBpeCksIGxlcnAoYzAxLCBjMTEsIGl4KSwgaXkpO1xuXG4vKipcbiAqIFJlLW1hcCBhIG51bWJlciBpIGZyb20gcmFuZ2UgYTEuLi5hMiB0byBiMS4uLmIyXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgbnVtYmVyIHRvIHJlLW1hcFxuICogQHBhcmFtIHtudW1iZXJ9IGExXG4gKiBAcGFyYW0ge251bWJlcn0gYTJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMVxuICogQHBhcmFtIHtudW1iZXJ9IGIyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmNvbnN0IHJlbWFwID0gKGksIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArIChpIC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xuXG4vKipcbiAqIERvIGEgc21vb3RoIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cbiAqL1xuY29uc3Qgc21vb3Roc3RlcCA9IChhLCBiLCBpKSA9PiBsZXJwKGEsIGIsIDMgKiBNYXRoLnBvdyhpLCAyKSAtIDIgKiBNYXRoLnBvdyhpLCAzKSk7XG5cbi8qKlxuICogR2V0IGFuIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWVzIFRoZSBhbmdsZSBpbiBkZWdyZWVzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmNvbnN0IHJhZGlhbnMgPSBkZWdyZWVzID0+IChNYXRoLlBJIC8gMTgwKSAqIGRlZ3JlZXM7XG5cbi8qKlxuICogR2V0IGFuIGFuZ2xlIGluIGRlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiBkZWdyZWVzXG4gKi9cbmNvbnN0IGRlZ3JlZXMgPSByYWRpYW5zID0+ICgxODAgLyBNYXRoLlBJKSAqIHJhZGlhbnM7XG5cbi8qKlxuICogR2V0IGEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggRXhjbHVzaXZlIG1heFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxuICovXG5jb25zdCByYW5kb21CZXR3ZWVuID0gKG1pbiwgbWF4KSA9PiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG5cbi8qKlxuICogR2V0IGEgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cbiAqL1xuY29uc3QgcmFuZG9tSW50QmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcblxuLyoqXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gW211PTAuNV0gVGhlIG1lYW4gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2lnbWE9MC41XSBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9Ml0gVGhlIG51bWJlciBvZiBzYW1wbGVzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxuICovXG5jb25zdCBjbHRSYW5kb20gPSAobXUgPSAwLjUsIHNpZ21hID0gMC41LCBzYW1wbGVzID0gMikgPT4ge1xuICBsZXQgdG90YWwgPSAwO1xuICBmb3IgKGxldCBpID0gc2FtcGxlczsgaS0tOykge1xuICAgIHRvdGFsICs9IE1hdGgucmFuZG9tKCk7XG4gIH1cbiAgcmV0dXJuIG11ICsgKHRvdGFsIC0gc2FtcGxlcyAvIDIpIC8gKHNhbXBsZXMgLyAyKSAqIHNpZ21hO1xufTtcblxuLyoqXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlclxuICovXG5jb25zdCBjbHRSYW5kb21JbnQgPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IobWluICsgY2x0UmFuZG9tKDAuNSwgMC41LCAyKSAqIChtYXggKyAxIC0gbWluKSk7XG5cbi8qKlxuICogUmV0dXJuIGEgd2VpZ2h0ZWQgcmFuZG9tIGludGVnZXJcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdyBBbiBhcnJheSBvZiB3ZWlnaHRzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGluZGV4IGZyb20gd1xuICovXG5jb25zdCB3ZWlnaHRlZFJhbmRvbSA9IHcgPT4ge1xuICBsZXQgdG90YWwgPSB3LnJlZHVjZSgoYSwgaSkgPT4gYSArIGksIDApLCBuID0gMDtcbiAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiB0b3RhbDtcbiAgd2hpbGUgKHRvdGFsID4gcikge1xuICAgIHRvdGFsIC09IHdbbisrXTtcbiAgfVxuICByZXR1cm4gbiAtIDE7XG59O1xuXG4vKipcbiAqIEFuIGludGVycG9sYXRpb24gZnVuY3Rpb25cbiAqIEBjYWxsYmFjayBJbnRlcnBvbGF0aW9uRnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gYW4gaW50ZXJwb2xhdGVkIHZhbHVlIGZyb20gYW4gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBBbiBhcnJheSBvZiB2YWx1ZXMgaW50ZXJwb2xhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIEEgbnVtYmVyIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cbiAqIEBwYXJhbSB7SW50ZXJwb2xhdGlvbkZ1bmN0aW9ufSBbZj1NYXRoLmxlcnBdIFRoZSBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIHRvIHVzZVxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFttaW4oYSksIG1heChhKV1cbiAqL1xuY29uc3QgbGVycEFycmF5ID0gKGEsIGksIGYgPSBsZXJwKSA9PiB7XG4gIGNvbnN0IHMgPSBpICogKGEubGVuZ3RoIC0gMSk7XG4gIGNvbnN0IHAgPSBjbGFtcChNYXRoLnRydW5jKHMpLCAwLCBhLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gZihhW3BdIHx8IDAsIGFbcCArIDFdIHx8IDAsIGZyYWMocykpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYiBWZWN0b3IgYlxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXG4gKi9cbmNvbnN0IGRvdCA9IChhLCBiKSA9PiBhLnJlZHVjZSgobiwgdiwgaSkgPT4gbiArIHYgKiBiW2ldLCAwKTtcblxuLyoqXG4gKiBHZXQgdGhlIGZhY3RvcmlhbCBvZiBhIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEByZXR1cm4ge251bWJlcn0gYSFcbiAqL1xuY29uc3QgZmFjdG9yaWFsID0gYSA9PiB7XG4gIGxldCByZXN1bHQgPSAxO1xuICBmb3IgKGxldCBpID0gMjsgaSA8PSBhOyBpKyspIHtcbiAgICByZXN1bHQgKj0gaTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBwZXJtdXRhdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcGFyYW0ge251bWJlcn0gclxuICogQHJldHVybiB7bnVtYmVyfSBuUHJcbiAqL1xuY29uc3QgbnByID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIGZhY3RvcmlhbChuIC0gcik7XG5cbi8qKlxuICogR2V0IHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHBhcmFtIHtudW1iZXJ9IHJcbiAqIEByZXR1cm4ge251bWJlcn0gbkNyXG4gKi9cbmNvbnN0IG5jciA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyAoZmFjdG9yaWFsKHIpICogZmFjdG9yaWFsKG4gLSByKSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYWxsIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYW4gYXJyYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHBlcm11dGF0aW9ucyhbMSwgMiwgM10sIDIpO1xuICogYGBgXG4gKlxuICogT3V0cHV0OlxuICogYGBganNvblxuICogW1xuICogICBbMSwgMl0sXG4gKiAgIFsxLCAzXSxcbiAqICAgWzIsIDFdLFxuICogICBbMiwgM10sXG4gKiAgIFszLCAxXSxcbiAqICAgWzMsIDJdXG4gKiBdXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gY2hvb3NlIGluIGVhY2ggcGVybXV0YXRpb25cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgcGVybXV0YXRpb24gYXJyYXlzXG4gKi9cbmNvbnN0IHBlcm11dGF0aW9ucyA9IChhLCByKSA9PiB7XG4gIGlmIChyID09PSAxKSB7XG4gICAgcmV0dXJuIGEubWFwKGl0ZW0gPT4gW2l0ZW1dKTtcbiAgfVxuXG4gIHJldHVybiBhLnJlZHVjZShcbiAgICAoYWNjLCBpdGVtLCBpKSA9PiBbXG4gICAgICAuLi5hY2MsXG4gICAgICAuLi5wZXJtdXRhdGlvbnMoYS5zbGljZSgwLCBpKS5jb25jYXQoYS5zbGljZShpICsgMSkpLCByIC0gMSkubWFwKGMgPT4gW2l0ZW0sIC4uLmNdKSxcbiAgICBdLFxuICAgIFtdXG4gICk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYWxsIGNvbWJpbmF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYW4gYXJyYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbWJpbmF0aW9ucyhbMSwgMiwgM10sIDIpO1xuICogYGBgXG4gKlxuICogT3V0cHV0OlxuICogYGBganNvblxuICogW1xuICogICBbMSwgMl0sXG4gKiAgIFsxLCAzXSxcbiAqICAgWzIsIDNdXG4gKiBdXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gY2hvb3NlIGluIGVhY2ggY29tYmluYXRpb25cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgY29tYmluYXRpb24gYXJyYXlzXG4gKi9cbmNvbnN0IGNvbWJpbmF0aW9ucyA9IChhLCByKSA9PiB7XG4gIGlmIChyID09PSAxKSB7XG4gICAgcmV0dXJuIGEubWFwKGl0ZW0gPT4gW2l0ZW1dKTtcbiAgfVxuXG4gIHJldHVybiBhLnJlZHVjZShcbiAgICAoYWNjLCBpdGVtLCBpKSA9PiBbXG4gICAgICAuLi5hY2MsXG4gICAgICAuLi5jb21iaW5hdGlvbnMoYS5zbGljZShpICsgMSksIHIgLSAxKS5tYXAoYyA9PiBbaXRlbSwgLi4uY10pLFxuICAgIF0sXG4gICAgW11cbiAgKTtcbn07XG5cbi8qKlxuICogR2V0IGEgY2FydGVzaWFuIHByb2R1Y3Qgb2YgYXJyYXlzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjYXJ0ZXNpYW4oWzEsIDIsIDNdLCBbJ2EnLCAnYiddKTtcbiAqIGBgYFxuICpcbiAqIE91dHB1dDpcbiAqIGBgYGpzb25cbiAqIFtcbiAqICAgWzEsIFwiYVwiXSxcbiAqICAgWzEsIFwiYlwiXSxcbiAqICAgWzIsIFwiYVwiXSxcbiAqICAgWzIsIFwiYlwiXSxcbiAqICAgWzMsIFwiYVwiXSxcbiAqICAgWzMsIFwiYlwiXVxuICogXVxuICogYGBgXG4gKi9cbmNvbnN0IGNhcnRlc2lhbiA9ICguLi5hcnIpID0+XG4gIGFyci5yZWR1Y2UoXG4gICAgKGEsIGIpID0+IGEuZmxhdE1hcChjID0+IGIubWFwKGQgPT4gWy4uLmMsIGRdKSksXG4gICAgW1tdXVxuICApO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYXJyYXkgdmFsdWVzXG4gKiBAY2FsbGJhY2sgVGltZXNGdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGFycmF5IGluZGV4XG4gKiBAcmV0dXJuIHsqfSBUaGUgYXJyYXkgdmFsdWVcbiAqL1xuXG4vKipcbiAqIFJldHVybiBhIG5ldyBhcnJheSB3aXRoIGxlbmd0aCBuIGJ5IGNhbGxpbmcgZnVuY3Rpb24gZihpKSBvbiBlYWNoIGVsZW1lbnRcbiAqIEBwYXJhbSB7VGltZXNGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheTwqPn1cbiAqL1xuY29uc3QgdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIG51bWJlcnMgMC0+KG4gLSAxKVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBpbnRlZ2VycyAwLT4obiAtIDEpXG4gKi9cbmNvbnN0IHJhbmdlID0gbiA9PiB0aW1lcyhpID0+IGksIG4pO1xuXG4vKipcbiAqIFppcCBtdWx0aXBsZSBhcnJheXMgdG9nZXRoZXIsIGkuZS4gKFsxLCAyLCAzXSwgW2EsIGIsIGNdKSA9PiBbWzEsIGFdLCBbMiwgYl0sIFszLCBjXV1cbiAqIEBwYXJhbSB7Li4uQXJyYXk8Kj59IGEgVGhlIGFycmF5cyB0byB6aXBcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn1cbiAqL1xuY29uc3QgemlwID0gKC4uLmEpID0+IHRpbWVzKGkgPT4gYS5tYXAoYSA9PiBhW2ldKSwgTWF0aC5tYXgoLi4uYS5tYXAoYSA9PiBhLmxlbmd0aCkpKTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXlbaV0gd2l0aCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgd3JhcHBpbmdcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGEgVGhlIGFycmF5IHRvIGFjY2Vzc1xuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHBvc2l0aXZlbHkvbmVnYXRpdmVseSB3cmFwcGVkIGFycmF5IGluZGV4XG4gKiBAcmV0dXJuIHsqfSBBbiBlbGVtZW50IGZyb20gdGhlIGFycmF5XG4gKi9cbmNvbnN0IGF0ID0gKGEsIGkpID0+IGFbaSA8IDAgPyBhLmxlbmd0aCAtIChNYXRoLmFicyhpICsgMSkgJSBhLmxlbmd0aCkgLSAxIDogaSAlIGEubGVuZ3RoXTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheSB3aXRob3V0IHJlbW92aW5nIGl0XG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcmV0dXJuIHsqfSBUaGUgbGFzdCBlbGVtZW50IGZyb20gdGhlIGFycmF5XG4gKi9cbmNvbnN0IHBlZWsgPSAoYSkgPT4ge1xuICBpZiAoIWEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggZm9yIGEgZ2l2ZW4gcG9zaXRpb24gaW4gYW4gdW5yb2xsZWQgMmQgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeSBwb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSAyZCBhcnJheVxuICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IGluIHRoZSB1bnJvbGxlZCBhcnJheVxuICovXG5jb25zdCBpbmQgPSAoeCwgeSwgdykgPT4geCArIHkgKiB3O1xuXG4vKipcbiAqIFJldHVybiB0aGUgcG9zaXRpb24gZm9yIGEgZ2l2ZW4gaW5kZXggaW4gYW4gdW5yb2xsZWQgMmQgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSAyZCBhcnJheVxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSBwb3NpdGlvbiBhcyBhIDItdHVwbGVcbiAqL1xuY29uc3QgcG9zID0gKGksIHcpID0+IFtpICUgdywgTWF0aC5mbG9vcihpIC8gdyldO1xuXG4vKipcbiAqIENob3AgYW4gYXJyYXkgaW50byBjaHVua3Mgb2Ygc2l6ZSBuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY2h1bmsgc2l6ZVxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheSBjaHVua3NcbiAqL1xuY29uc3QgY2h1bmsgPSAoYSwgbikgPT4gdGltZXMoaSA9PiBhLnNsaWNlKGkgKiBuLCBpICogbiArIG4pLCBNYXRoLmNlaWwoYS5sZW5ndGggLyBuKSk7XG5cbi8qKlxuICogUmFuZG9tbHkgc2h1ZmZsZSBhIHNoYWxsb3cgY29weSBvZiBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSBzaHVmZmxlZCBhcnJheVxuICovXG5jb25zdCBzaHVmZmxlID0gYSA9PiBhLnNsaWNlKCkuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcblxuLyoqXG4gKiBGbGF0dGVuIGFuIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jYXRlbmF0b3IgVGhlIHN0cmluZyB0byB1c2UgZm9yIGNvbmNhdGVuYXRpbmcga2V5c1xuICogQHJldHVybiB7b2JqZWN0fSBBIGZsYXR0ZW5lZCBvYmplY3RcbiAqL1xuY29uc3QgZmxhdCA9IChvLCBjb25jYXRlbmF0b3IgPSAnLicpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBpZiAob1trZXldIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBba2V5XTogb1trZXldLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb1trZXldICE9PSAnb2JqZWN0JyB8fCAhb1trZXldKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFtrZXldOiBvW2tleV0sXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBmbGF0dGVuZWQgPSBmbGF0KG9ba2V5XSwgY29uY2F0ZW5hdG9yKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICAuLi5PYmplY3Qua2V5cyhmbGF0dGVuZWQpLnJlZHVjZShcbiAgICAgICAgKGNoaWxkQWNjLCBjaGlsZEtleSkgPT4gKHtcbiAgICAgICAgICAuLi5jaGlsZEFjYyxcbiAgICAgICAgICBbYCR7a2V5fSR7Y29uY2F0ZW5hdG9yfSR7Y2hpbGRLZXl9YF06IGZsYXR0ZW5lZFtjaGlsZEtleV0sXG4gICAgICAgIH0pLFxuICAgICAgICB7fVxuICAgICAgKSxcbiAgICB9O1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIFVuZmxhdHRlbiBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uY2F0ZW5hdG9yIFRoZSBzdHJpbmcgdG8gY2hlY2sgZm9yIGluIGNvbmNhdGVuYXRlZCBrZXlzXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIHVuLWZsYXR0ZW5lZCBvYmplY3RcbiAqL1xuY29uc3QgdW5mbGF0ID0gKG8sIGNvbmNhdGVuYXRvciA9ICcuJykgPT4ge1xuICBsZXQgcmVzdWx0ID0ge30sIHRlbXAsIHN1YnN0cmluZ3MsIHByb3BlcnR5LCBpO1xuXG4gIGZvciAocHJvcGVydHkgaW4gbykge1xuICAgIHN1YnN0cmluZ3MgPSBwcm9wZXJ0eS5zcGxpdChjb25jYXRlbmF0b3IpO1xuICAgIHRlbXAgPSByZXN1bHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHN1YnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBpZiAoIShzdWJzdHJpbmdzW2ldIGluIHRlbXApKSB7XG4gICAgICAgIGlmIChpc0Zpbml0ZShzdWJzdHJpbmdzW2kgKyAxXSkpIHtcbiAgICAgICAgICB0ZW1wW3N1YnN0cmluZ3NbaV1dID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcFtzdWJzdHJpbmdzW2ldXSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wID0gdGVtcFtzdWJzdHJpbmdzW2ldXTtcbiAgICB9XG4gICAgdGVtcFtzdWJzdHJpbmdzW3N1YnN0cmluZ3MubGVuZ3RoIC0gMV1dID0gb1twcm9wZXJ0eV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBIHNwbGl0IHByZWRpY2F0ZVxuICogQGNhbGxiYWNrIFNwbGl0UHJlZGljYXRlXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFycmF5IHNob3VsZCBzcGxpdCBhdCB0aGlzIGluZGV4XG4gKi9cblxuLyoqXG4gKiBTcGxpdCBhbiBhcnJheSBpbnRvIHN1Yi1hcnJheXMgYmFzZWQgb24gYSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5XG4gKiBAcGFyYW0ge1NwbGl0UHJlZGljYXRlfSBwcmVkaWNhdGVcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgYXJyYXlzXG4gKi9cbmNvbnN0IHNwbGl0ID0gKGFycmF5LCBwcmVkaWNhdGUpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBjdXJyZW50ID0gW107XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkpIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IFt2YWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBsdWNrIGtleXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBwbHVjayBmcm9tIHRoZSBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBsdWNrZWQga2V5c1xuICovXG5jb25zdCBwbHVjayA9IChvLCAuLi5rZXlzKSA9PiB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShcbiAgICAocmVzdWx0LCBrZXkpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvW2tleV0gfSksXG4gICAge31cbiAgKTtcbn07XG5cbi8qKlxuICogRXhjbHVkZSBrZXlzIGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gb1xuICogQHBhcmFtIHsuLi5zdHJpbmd9IGtleXMgVGhlIGtleXMgdG8gZXhjbHVkZSBmcm9tIHRoZSBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGtleXMgZXhjZXB0IGV4Y2x1ZGVkIGtleXNcbiAqL1xuY29uc3QgZXhjbHVkZSA9IChvLCAuLi5rZXlzKSA9PiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMobykuZmlsdGVyKChba2V5XSkgPT4gIWtleXMuaW5jbHVkZXMoa2V5KSlcbiAgKTtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtZW1vaXplLFxuICAgIGZsb2F0RXF1YWxzLFxuICAgIGNsYW1wLFxuICAgIGZyYWMsXG4gICAgcm91bmQsXG4gICAgbGVycCxcbiAgICB1bmxlcnAsXG4gICAgYmxlcnAsXG4gICAgcmVtYXAsXG4gICAgc21vb3Roc3RlcCxcbiAgICByYWRpYW5zLFxuICAgIGRlZ3JlZXMsXG4gICAgcmFuZG9tQmV0d2VlbixcbiAgICByYW5kb21JbnRCZXR3ZWVuLFxuICAgIGNsdFJhbmRvbSxcbiAgICBjbHRSYW5kb21JbnQsXG4gICAgd2VpZ2h0ZWRSYW5kb20sXG4gICAgbGVycEFycmF5LFxuICAgIGRvdCxcbiAgICBmYWN0b3JpYWwsXG4gICAgbnByLFxuICAgIG5jcixcbiAgICBwZXJtdXRhdGlvbnMsXG4gICAgY29tYmluYXRpb25zLFxuICAgIGNhcnRlc2lhbixcbiAgICB0aW1lcyxcbiAgICByYW5nZSxcbiAgICB6aXAsXG4gICAgYXQsXG4gICAgcGVlayxcbiAgICBpbmQsXG4gICAgcG9zLFxuICAgIGNodW5rLFxuICAgIHNodWZmbGUsXG4gICAgZmxhdCxcbiAgICB1bmZsYXQsXG4gICAgc3BsaXQsXG4gICAgcGx1Y2ssXG4gICAgZXhjbHVkZSxcbiAgfTtcbn1cbiIsIi8qKlxuICogQG92ZXJ2aWV3IEEgc21hbGwgdmVjdG9yIGFuZCBtYXRyaXggbGlicmFyeVxuICogQGF1dGhvciBHb3Jkb24gTGFycmlnYW5cbiAqL1xuXG5jb25zdCBfdmVjX3RpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcbmNvbnN0IF92ZWNfY2h1bmsgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcbmNvbnN0IF92ZWNfZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xuY29uc3QgX3ZlY19pc192ZWMyID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGE7XG5jb25zdCBfdmVjX2lzX3ZlYzMgPSBhID0+IHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAneCcgaW4gYSAmJiAneScgaW4gYSAmJiAneicgaW4gYTtcblxuLyoqXG4gKiBBIDJkIHZlY3RvclxuICogQHR5cGVkZWYge09iamVjdH0gdmVjMlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgMmQgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMyfSBbeF0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIGEgdmVjdG9yIHRvIGNvcHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IDJkIHZlY3RvclxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzIoMywgMik7IC8vICgzLCAyKVxuICogbGV0IGIgPSB2ZWMyKDQpOyAgICAvLyAoNCwgNClcbiAqIGxldCBjID0gdmVjMihhKTsgICAgLy8gKDMsIDIpXG4gKiBsZXQgZCA9IHZlYzIoKTsgICAgIC8vICgwLCAwKVxuICovXG5jb25zdCB2ZWMyID0gKHgsIHkpID0+IHtcbiAgaWYgKCF4ICYmICF5KSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICB9XG4gIGlmIChfdmVjX2lzX3ZlYzIoeCkpIHtcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAgfTtcbiAgfVxuICByZXR1cm4geyB4OiB4LCB5OiB5ID8/IHggfTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcbiAqL1xudmVjMi5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnldO1xuXG4vKipcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29tcG9uZW50cyBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIG5ldyB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgPT4gdmVjMiguLi5jb21wb25lbnRzLnNsaWNlKDAsIDIpKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMClcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdW5pdCB2ZWN0b3IgKDEsIDApXG4gKi9cbnZlYzIudXggPSAoKSA9PiB2ZWMyKDEsIDApO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxKVxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMCwgMSlcbiAqL1xudmVjMi51eSA9ICgpID0+IHZlYzIoMCwgMSk7XG5cbi8qKlxuICogQWRkIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKyBiXG4gKi9cbnZlYzIuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIChiLnggPz8gYiksIHk6IGEueSArIChiLnkgPz8gYikgfSk7XG5cbi8qKlxuICogU3VidHJhY3QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjMn0gYSAtIGJcbiAqL1xudmVjMi5zdWIgPSAoYSwgYikgPT4gKHsgeDogYS54IC0gKGIueCA/PyBiKSwgeTogYS55IC0gKGIueSA/PyBiKSB9KTtcblxuLyoqXG4gKiBTY2FsZSBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjMn0gYSAqIGJcbiAqL1xudmVjMi5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogKGIueCA/PyBiKSwgeTogYS55ICogKGIueSA/PyBiKSB9KTtcblxuLyoqXG4gKiBTY2FsZSBhIHZlY3RvciBieSBhIHNjYWxhciwgYWxpYXMgZm9yIHZlYzIubXVsXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxuICovXG52ZWMyLnNjYWxlID0gKGEsIGIpID0+IHZlYzIubXVsKGEsIGIpO1xuXG4vKipcbiAqIERpdmlkZSBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjMn0gYSAvIGJcbiAqL1xudmVjMi5kaXYgPSAoYSwgYikgPT4gKHsgeDogYS54IC8gKGIueCA/PyBiKSwgeTogYS55IC8gKGIueSA/PyBiKSB9KTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxuICovXG52ZWMyLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxuICovXG52ZWMyLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSk7XG5cbi8qKlxuICogTm9ybWFsaXNlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcbiAqIEByZXR1cm4ge3ZlYzJ9IF5hXG4gKi9cbnZlYzIubm9yID0gYSA9PiB7XG4gIGxldCBsZW4gPSB2ZWMyLmxlbihhKTtcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYzIoKTtcbn07XG5cbi8qKlxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxuICovXG52ZWMyLmRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFuc1xuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzIucm90ID0gKGEsIHIpID0+IHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyKSxcbiAgICBjID0gTWF0aC5jb3Mocik7XG4gIHJldHVybiB7IHg6IGMgKiBhLnggLSBzICogYS55LCB5OiBzICogYS54ICsgYyAqIGEueSB9O1xufTtcblxuLyoqXG4gKiBGYXN0IG1ldGhvZCB0byByb3RhdGUgYSB2ZWN0b3IgYnkgLTkwLCA5MCBvciAxODAgZGVncmVlc1xuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciAxIGZvciA5MCBkZWdyZWVzIChjdyksIC0xIGZvciAtOTAgZGVncmVlcyAoY2N3KSwgMiBvciAtMiBmb3IgMTgwIGRlZ3JlZXNcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcbiAqL1xudmVjMi5yb3RmID0gKGEsIHIpID0+IHtcbiAgc3dpdGNoIChyKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gdmVjMihhLnksIC1hLngpO1xuICAgIGNhc2UgLTE6IHJldHVybiB2ZWMyKC1hLnksIGEueCk7XG4gICAgY2FzZSAyOiBjYXNlIC0yOiByZXR1cm4gdmVjMigtYS54LCAtYS55KTtcbiAgICBkZWZhdWx0OiByZXR1cm4gYTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2FsYXIgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge251bWJlcn0gYSDDlyBiXG4gKi9cbnZlYzIuY3Jvc3MgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gYS54ICogYi55IC0gYS55ICogYi54O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG52ZWMyLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xuICovXG52ZWMyLnJhZCA9IGEgPT4gTWF0aC5hdGFuMihhLnksIGEueCk7XG5cbi8qKlxuICogQ29weSBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxuICogQHJldHVybiB7dmVjMn0gQSBjb3B5IG9mIHZlY3RvciBhXG4gKi9cbnZlYzIuY3B5ID0gYSA9PiB2ZWMyKGEpO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDJkIHZlY3RvclxuICogQGNhbGxiYWNrIHZlYzJNYXBDYWxsYmFja1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgY29tcG9uZW50XG4gKi9cblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMk1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcbiAqL1xudmVjMi5tYXAgPSAoYSwgZikgPT4gKHsgeDogZihhLngsICd4JyksIHk6IGYoYS55LCAneScpIH0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcblxuLyoqXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xuICpcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XG4gKiAtIGB4YCBvciBgeWBcbiAqIC0gYHVgIG9yIGB2YCAoYWxpYXNlcyBmb3IgYHhgIGFuZCBgeWAsIHJlc3BlY3RpdmVseSlcbiAqIC0gYFhgLCBgWWAsIGBVYCwgYFZgIChuZWdhdGVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSlcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXG4gKlxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zd2l6emxpbmcgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzIoMywgLTIpO1xuICogdmVjMi5zd2l6KGEsICd4Jyk7ICAgIC8vIFszXVxuICogdmVjMi5zd2l6KGEsICd5eCcpOyAgIC8vIFstMiwgM11cbiAqIHZlYzIuc3dpeihhLCAneFknKTsgICAvLyBbMywgMl1cbiAqIHZlYzIuc3dpeihhLCAnWXknKTsgICAvLyBbMiwgLTJdXG4gKiB2ZWMyLnN3aXooYSwgJ3gueCcpOyAgLy8gWzMsIC0yLCAzXVxuICogdmVjMi5zd2l6KGEsICd5MDF4Jyk7IC8vIFstMiwgMCwgMSwgM11cbiAqL1xudmVjMi5zd2l6ID0gKGEsIHMgPSAnLi4nKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlICd4JzogY2FzZSAndSc6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiByZXN1bHQucHVzaChhLnkpOyBicmVhaztcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogcmVzdWx0LnB1c2goLWEueCk7IGJyZWFrO1xuICAgICAgY2FzZSAnWSc6IGNhc2UgJ1YnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xuICAgICAgY2FzZSAnMSc6IHJlc3VsdC5wdXNoKDEpOyBicmVhaztcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnldW2ldID8/IDApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBvbGFyIGNvb3JkaW5hdGVzIGZvciBhIDJkIHZlY3RvclxuICogQHR5cGVkZWYge09iamVjdH0gcG9sYXJDb29yZGluYXRlczJkXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGV0YSBUaGUgYW5nbGUgb2YgdGhlIHZlY3RvclxuICovXG5cbi8qKlxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIHBvbGFyIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtwb2xhckNvb3JkaW5hdGVzMmR9IFRoZSBtYWduaXR1ZGUgYW5kIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5wb2xhciA9IGEgPT4gKHsgcjogdmVjMi5sZW4oYSksIHRoZXRhOiBNYXRoLmF0YW4yKGEueSwgYS54KSB9KTtcblxuLyoqXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBhbmdsZSBhbmQgbWFnbml0dWRlXG4gKi9cbnZlYzIuZnJvbVBvbGFyID0gKHIsIHRoZXRhKSA9PiB2ZWMyKHIgKiBNYXRoLmNvcyh0aGV0YSksIHIgKiBNYXRoLnNpbih0aGV0YSkpO1xuXG4vKipcbiAqIEEgM2QgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMzXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgM2QgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMzfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgdGhlIHogY29tcG9uZW50IGlmIHggaXMgYSB2ZWMyXG4gKiBAcGFyYW0ge251bWJlcn0gW3pdIFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyAzZCB2ZWN0b3JcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxuICogbGV0IGEgPSB2ZWMzKDMsIDIsIDEpOyAgICAgICAvLyAoMywgMiwgMSlcbiAqIGxldCBiID0gdmVjMyg0LCA1KTsgICAgICAgICAgLy8gKDQsIDUsIDApXG4gKiBsZXQgYyA9IHZlYzMoNik7ICAgICAgICAgICAgIC8vICg2LCA2LCA2KVxuICogbGV0IGQgPSB2ZWMzKGEpOyAgICAgICAgICAgICAvLyAoMywgMiwgMSlcbiAqIGxldCBlID0gdmVjMygpOyAgICAgICAgICAgICAgLy8gKDAsIDAsIDApXG4gKiBsZXQgZiA9IHZlYzModmVjMigxLCAyKSwgMyk7IC8vICgxLCAyLCAzKVxuICogbGV0IGcgPSB2ZWMzKHZlYzIoNCwgNSkpOyAgICAvLyAoNCwgNSwgMClcbiAqL1xuY29uc3QgdmVjMyA9ICh4LCB5LCB6KSA9PiB7XG4gIGlmICgheCAmJiAheSAmJiAheikge1xuICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcbiAgfVxuICBpZiAoX3ZlY19pc192ZWMzKHgpKSB7XG4gICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwLCB6OiB4LnogfHwgMCB9O1xuICB9XG4gIGlmIChfdmVjX2lzX3ZlYzIoeCkpIHtcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHkgfHwgMCB9O1xuICB9XG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCwgejogeiA/PyB4IH07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhcyBhbiBhcnJheVxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XG4gKi9cbnZlYzMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55LCBhLnpdO1xuXG4vKipcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29tcG9uZW50cyBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyB2ZWN0b3JcbiAqL1xudmVjMy5mcm9tQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgPT4gdmVjMyguLi5jb21wb25lbnRzLnNsaWNlKDAsIDMpKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMCwgMClcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDEsIDAsIDApXG4gKi9cbnZlYzMudXggPSAoKSA9PiB2ZWMzKDEsIDAsIDApO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMCwgMSwgMClcbiAqL1xudmVjMy51eSA9ICgpID0+IHZlYzMoMCwgMSwgMCk7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAwLCAxKVxuICovXG52ZWMzLnV6ID0gKCkgPT4gdmVjMygwLCAwLCAxKTtcblxuLyoqXG4gKiBBZGQgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjM30gYSArIGJcbiAqL1xudmVjMy5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSwgejogYS56ICsgKGIueiA/PyBiKSB9KTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC0gYlxuICovXG52ZWMzLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpLCB6OiBhLnogLSAoYi56ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICogYlxuICovXG52ZWMzLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpLCB6OiBhLnogKiAoYi56ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMy5tdWxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXG4gKi9cbnZlYzMuc2NhbGUgPSAoYSwgYikgPT4gdmVjMy5tdWwoYSwgYik7XG5cbi8qKlxuICogRGl2aWRlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC8gYlxuICovXG52ZWMzLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpLCB6OiBhLnogLyAoYi56ID8/IGIpIH0pO1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55ICsgYS56ICogYS56KTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzMubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KSArIE1hdGguYWJzKGEueik7XG5cbi8qKlxuICogTm9ybWFsaXNlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcbiAqIEByZXR1cm4ge3ZlYzN9IF5hXG4gKi9cbnZlYzMubm9yID0gYSA9PiB7XG4gIGxldCBsZW4gPSB2ZWMzLmxlbihhKTtcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4sIHo6IGEueiAvIGxlbiB9IDogdmVjMygpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXG4gKi9cbnZlYzMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueSArIGEueiAqIGIuejtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgYSByb3RhdGlvbiBtYXRyaXhcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHttYXR9IG0gVGhlIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdCA9IChhLCBtKSA9PiB2ZWMzKFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMSkpLCBhKSxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDIpKSwgYSksXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAzKSksIGEpXG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB4IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHggPSAoYSwgcikgPT4gdmVjMyhcbiAgYS54LFxuICBhLnkgKiBNYXRoLmNvcyhyKSAtIGEueiAqIE1hdGguc2luKHIpLFxuICBhLnkgKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB5IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHkgPSAoYSwgcikgPT4gdmVjMyhcbiAgYS54ICogTWF0aC5jb3MocikgKyBhLnogKiBNYXRoLnNpbihyKSxcbiAgYS55LFxuICAtYS54ICogTWF0aC5zaW4ocikgKyBhLnogKiBNYXRoLmNvcyhyKVxuKTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeiBheGlzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcbiAqL1xudmVjMy5yb3R6ID0gKGEsIHIpID0+IHZlYzMoXG4gIGEueCAqIE1hdGguY29zKHIpIC0gYS55ICogTWF0aC5zaW4ociksXG4gIGEueCAqIE1hdGguc2luKHIpICsgYS55ICogTWF0aC5jb3MociksXG4gIGEuelxuKTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgYSBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcSBUaGUgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcbiAqL1xudmVjMy5yb3RxID0gKHYsIHEpID0+IHtcbiAgaWYgKHEubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIHZlYzMoKTtcbiAgfVxuXG4gIGNvbnN0IGQgPSBNYXRoLnNxcnQocVswXSAqIHFbMF0gKyBxWzFdICogcVsxXSArIHFbMl0gKiBxWzJdICsgcVszXSAqIHFbM10pO1xuICBpZiAoZCA9PT0gMCkge1xuICAgIHJldHVybiB2ZWMzKCk7XG4gIH1cblxuICBjb25zdCB1cSA9IFtxWzBdIC8gZCwgcVsxXSAvIGQsIHFbMl0gLyBkLCBxWzNdIC8gZF07XG4gIGNvbnN0IHUgPSB2ZWMzKC4uLnVxLnNsaWNlKDAsIDMpKTtcbiAgY29uc3QgcyA9IHVxWzNdO1xuICByZXR1cm4gdmVjMy5hZGQoXG4gICAgdmVjMy5hZGQoXG4gICAgICB2ZWMzLm11bCh1LCAyICogdmVjMy5kb3QodSwgdikpLFxuICAgICAgdmVjMy5tdWwodiwgcyAqIHMgLSB2ZWMzLmRvdCh1LCB1KSlcbiAgICApLFxuICAgIHZlYzMubXVsKHZlYzMuY3Jvc3ModSwgdiksIDIgKiBzKVxuICApO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgRXVsZXIgYW5nbGVzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gZSBUaGUgRXVsZXIgYW5nbGVzIHRvIHJvdGF0ZSBieVxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdGEgPSAoYSwgZSkgPT4gdmVjMy5yb3R6KHZlYzMucm90eSh2ZWMzLnJvdHgoYSwgZS54KSwgZS55KSwgZS56KTtcblxuLyoqXG4gKiBHZXQgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgw5cgYlxuICovXG52ZWMzLmNyb3NzID0gKGEsIGIpID0+IHZlYzMoXG4gIGEueSAqIGIueiAtIGEueiAqIGIueSxcbiAgYS56ICogYi54IC0gYS54ICogYi56LFxuICBhLnggKiBiLnkgLSBhLnkgKiBiLnhcbik7XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZWN0b3JzIGEgYW5kIGIgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xudmVjMy5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLnogPT09IGIuejtcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHggYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXG4gKi9cbnZlYzMucmFkeCA9IGEgPT4gTWF0aC5hdGFuMihhLnosIGEueSk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB5IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xuICovXG52ZWMzLnJhZHkgPSBhID0+IE1hdGguYXRhbjIoYS54LCBhLnkpO1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeiBheGlzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcbiAqL1xudmVjMy5yYWR6ID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS56KTtcblxuLyoqXG4gKiBDb3B5IGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb3B5XG4gKiBAcmV0dXJuIHt2ZWMzfSBBIGNvcHkgb2YgdmVjdG9yIGFcbiAqL1xudmVjMy5jcHkgPSBhID0+IHZlYzMoYSk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgM2QgdmVjdG9yXG4gKiBAY2FsbGJhY2sgdmVjM01hcENhbGxiYWNrXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICogQHBhcmFtIHsneCcgfCAneScgfCAneid9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHgsIHkgb3IgeilcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcbiAqL1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjM30gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxuICovXG52ZWMzLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JyksIHo6IGYoYS56LCAneicpIH0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMy5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9JHtzfSR7YS56fWA7XG5cbi8qKlxuICogU3dpenpsZSBhIHZlY3RvciB3aXRoIGEgc3RyaW5nIG9mIGNvbXBvbmVudCBsYWJlbHNcbiAqXG4gKiBUaGUgc3RyaW5nIGNhbiBjb250YWluOlxuICogLSBgeGAsIGB5YCBvciBgemBcbiAqIC0gYHVgLCBgdmAgb3IgYHdgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXG4gKiAtIGByYCwgYGdgIG9yIGBiYCAoYWxpYXNlcyBmb3IgYHhgLCBgeWAgYW5kIGB6YCwgcmVzcGVjdGl2ZWx5KVxuICogLSBgWGAsIGBZYCwgYFpgLCBgVWAsIGBWYCwgYFdgLCBgUmAsIGBHYCwgYEJgIChuZWdhdGVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSlcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXG4gKlxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLi4uJ10gVGhlIHN3aXp6bGUgc3RyaW5nXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc3dpenpsZWQgY29tcG9uZW50c1xuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxuICogbGV0IGEgPSB2ZWMzKDMsIC0yLCAxKTtcbiAqIHZlYzMuc3dpeihhLCAneCcpOyAgICAgLy8gWzNdXG4gKiB2ZWMzLnN3aXooYSwgJ3p5eCcpOyAgIC8vIFsxLCAtMiwgM11cbiAqIHZlYzMuc3dpeihhLCAneFlaJyk7ICAgLy8gWzMsIDIsIC0xXVxuICogdmVjMy5zd2l6KGEsICdaengnKTsgICAvLyBbLTEsIDEsIDNdXG4gKiB2ZWMzLnN3aXooYSwgJ3gueCcpOyAgIC8vIFszLCAtMiwgM11cbiAqIHZlYzMuc3dpeihhLCAneTAxengnKTsgLy8gWy0yLCAwLCAxLCAxLCAzXVxuICovXG52ZWMzLnN3aXogPSAoYSwgcyA9ICcuLi4nKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlICd4JzogY2FzZSAndSc6IGNhc2UgJ3InOiByZXN1bHQucHVzaChhLngpOyBicmVhaztcbiAgICAgIGNhc2UgJ3knOiBjYXNlICd2JzogY2FzZSAnZyc6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xuICAgICAgY2FzZSAneic6IGNhc2UgJ3cnOiBjYXNlICdiJzogcmVzdWx0LnB1c2goYS56KTsgYnJlYWs7XG4gICAgICBjYXNlICdYJzogY2FzZSAnVSc6IGNhc2UgJ1InOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IGNhc2UgJ0cnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XG4gICAgICBjYXNlICdaJzogY2FzZSAnVyc6IGNhc2UgJ0InOiByZXN1bHQucHVzaCgtYS56KTsgYnJlYWs7XG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xuICAgICAgY2FzZSAnMSc6IHJlc3VsdC5wdXNoKDEpOyBicmVhaztcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnksIGEuel1baV0gPz8gMCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmVzdWx0LnB1c2goMCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgM2QgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzM2RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSB0aWx0IGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBhbmdsZSBvZiB0aGUgdmVjdG9yXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMzZH0gVGhlIG1hZ25pdHVkZSwgdGlsdCBhbmQgcGFuIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMy5wb2xhciA9IGEgPT4ge1xuICBsZXQgciA9IHZlYzMubGVuKGEpLFxuICAgIHRoZXRhID0gTWF0aC5hY29zKGEueSAvIHIpLFxuICAgIHBoaSA9IE1hdGguYXRhbjIoYS56LCBhLngpO1xuICByZXR1cm4geyByLCB0aGV0YSwgcGhpIH07XG59O1xuXG4vKipcbiAqIENvbnZlcnQgcG9sYXIgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIHRpbHQgb2YgdGhlIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHBoaSBUaGUgcGFuIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcbiAqL1xudmVjMy5mcm9tUG9sYXIgPSAociwgdGhldGEsIHBoaSkgPT4ge1xuICBjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcbiAgcmV0dXJuIHZlYzMoXG4gICAgciAqIHNpblRoZXRhICogTWF0aC5jb3MocGhpKSxcbiAgICByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguc2luKHBoaSlcbiAgKTtcbn07XG5cbi8qKlxuICogQSBtYXRyaXhcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1hdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG0gVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBtYXRyaXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIG1hdHJpeCB2YWx1ZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXRyaXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj00XSBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2VudHJpZXM9W11dIE1hdHJpeCB2YWx1ZXMgaW4gcmVhZGluZyBvcmRlclxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcbiAqL1xuY29uc3QgbWF0ID0gKG0gPSA0LCBuID0gNCwgZW50cmllcyA9IFtdKSA9PiAoe1xuICBtLCBuLFxuICBlbnRyaWVzOiBlbnRyaWVzLmNvbmNhdChBcnJheShtICogbikuZmlsbCgwKSkuc2xpY2UoMCwgbSAqIG4pXG59KTtcblxuLyoqXG4gKiBHZXQgYW4gaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgblxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxuICogQHJldHVybiB7bWF0fSBBbiBpZGVudGl0eSBtYXRyaXhcbiAqL1xubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcblxuLyoqXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgYXQgcG9zaXRpb24gKGksIGopIGluIG1hdHJpeCBhXG4gKi9cbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcblxuLyoqXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB2YWx1ZSB0byBzZXQgaW4gbWF0cml4IGFcbiAqL1xubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xuXG4vKipcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IG0gVGhlIHJvdyBvZmZzZXRcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcbiAqL1xubWF0LnJvdyA9IChhLCBtKSA9PiB7XG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xuICByZXR1cm4gYS5lbnRyaWVzLnNsaWNlKHMsIHMgKyBhLm4pO1xufTtcblxuLyoqXG4gKiBHZXQgYSBjb2x1bW4gZnJvbSBhIG1hdHJpeCBhcyBhbiBhcnJheVxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjb2x1bW4gb2Zmc2V0XG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBDb2x1bW4gbiBmcm9tIG1hdHJpeCBhXG4gKi9cbm1hdC5jb2wgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IG1hdC5nZXQoYSwgKGkgKyAxKSwgbiksIGEubSk7XG5cbi8qKlxuICogQWRkIG1hdHJpY2VzXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcbiAqIEByZXR1cm4ge21hdH0gYSArIGJcbiAqL1xubWF0LmFkZCA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2ICsgYi5lbnRyaWVzW2ldKTtcblxuLyoqXG4gKiBTdWJ0cmFjdCBtYXRyaWNlc1xuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXG4gKiBAcmV0dXJuIHttYXR9IGEgLSBiXG4gKi9cbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XG5cbi8qKlxuICogTXVsdGlwbHkgbWF0cmljZXNcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cmljZXMgY2Fubm90IGJlIG11bHRpcGxpZWRcbiAqL1xubWF0Lm11bCA9IChhLCBiKSA9PiB7XG4gIGlmIChhLm4gIT09IGIubSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBiLm47IGorKykge1xuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIF92ZWNfZG90KG1hdC5yb3coYSwgaSksIG1hdC5jb2woYiwgaikpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgYSBtYXRyaXggYnkgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge3ZlYzJ8dmVjM3xudW1iZXJbXX0gYiBWZWN0b3IgYlxuICogQHJldHVybiB7dmVjMnx2ZWMzfG51bWJlcltdfGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGFuZCB2ZWN0b3IgY2Fubm90IGJlIG11bHRpcGxpZWRcbiAqL1xubWF0Lm11bHYgPSAoYSwgYikgPT4ge1xuICBsZXQgbiwgYmIsIHJ0O1xuICBpZiAoX3ZlY19pc192ZWMzKGIpKSB7XG4gICAgYmIgPSB2ZWMzLmNvbXBvbmVudHMoYik7XG4gICAgbiA9IDM7XG4gICAgcnQgPSB2ZWMzLmZyb21Db21wb25lbnRzO1xuICB9IGVsc2UgaWYgKF92ZWNfaXNfdmVjMihiKSkge1xuICAgIGJiID0gdmVjMi5jb21wb25lbnRzKGIpO1xuICAgIG4gPSAyO1xuICAgIHJ0ID0gdmVjMi5mcm9tQ29tcG9uZW50cztcbiAgfSBlbHNlIHtcbiAgICBiYiA9IGI7XG4gICAgbiA9IGIubGVuZ3RoID8/IDA7XG4gICAgcnQgPSB2ID0+IHY7XG4gIH1cbiAgaWYgKGEubiAhPT0gbikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2goX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgYmIpKTtcbiAgfVxuICByZXR1cm4gcnQocmVzdWx0KTtcbn1cblxuLyoqXG4gKiBTY2FsZSBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXG4gKi9cbm1hdC5zY2FsZSA9IChhLCBiKSA9PiBtYXQubWFwKGEsIHYgPT4gdiAqIGIpO1xuXG4vKipcbiAqIFRyYW5zcG9zZSBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcbiAqIEByZXR1cm4ge21hdH0gQSB0cmFuc3Bvc2VkIG1hdHJpeFxuICovXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgX3ZlY190aW1lcyhpID0+IG1hdC5jb2woYSwgKGkgKyAxKSksIGEubikuZmxhdCgpKTtcblxuLyoqXG4gKiBHZXQgdGhlIG1pbm9yIG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IFRoZSAoaSwgaikgbWlub3Igb2YgbWF0cml4IGEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXG4gKi9cbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgZW50cmllcyA9IFtdO1xuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xuICAgIGlmIChpaSA9PT0gaSkgeyBjb250aW51ZTsgfVxuICAgIGZvciAobGV0IGpqID0gMTsgamogPD0gYS5uOyBqaisrKSB7XG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cbiAgICAgIGVudHJpZXMucHVzaChtYXQuZ2V0KGEsIGlpLCBqaikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0KGEubSAtIDEsIGEubiAtIDEsIGVudHJpZXMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHJldHVybiB7bnVtYmVyfGZhbHNlfSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXG4gKi9cbm1hdC5kZXQgPSBhID0+IHtcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYS5tID09PSAxKSB7XG4gICAgcmV0dXJuIGEuZW50cmllc1swXTtcbiAgfVxuICBpZiAoYS5tID09PSAyKSB7XG4gICAgcmV0dXJuIGEuZW50cmllc1swXSAqIGEuZW50cmllc1szXSAtIGEuZW50cmllc1sxXSAqIGEuZW50cmllc1syXTtcbiAgfVxuICBsZXQgdG90YWwgPSAwLCBzaWduID0gMTtcbiAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcbiAgICBzaWduICo9IC0xO1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXNlIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIG5vcm1hbGlzZVxuICogQHJldHVybiB7bWF0fGZhbHNlfSBeYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcbiAqL1xubWF0Lm5vciA9IGEgPT4ge1xuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xuICByZXR1cm4gbWF0Lm1hcChhLCBpID0+IGkgKiBkKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcbiAqIEByZXR1cm4ge21hdH0gVGhlIGFkanVnYXRlIG9mIGFcbiAqL1xubWF0LmFkaiA9IGEgPT4ge1xuICBjb25zdCBtaW5vcnMgPSBtYXQoYS5tLCBhLm4pO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XG4gICAgICBtYXQuc2V0KG1pbm9ycywgaSwgaiwgbWF0LmRldChtYXQubWlub3IoYSwgaSwgaikpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29mYWN0b3JzID0gbWF0Lm1hcChtaW5vcnMsICh2LCBpKSA9PiB2ICogKGkgJSAyID8gLTEgOiAxKSk7XG4gIHJldHVybiBtYXQudHJhbnMoY29mYWN0b3JzKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGludmVydFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhXi0xIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaGFzIG5vIGludmVyc2VcbiAqL1xubWF0LmludiA9IGEgPT4ge1xuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIG1hdC5zY2FsZShtYXQuYWRqKGEpLCAxIC8gZCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byBtYXRyaWNlcyBhcmUgZXF1YWxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtYXRyaWNlcyBhIGFuZCBiIGFyZSBpZGVudGljYWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG5tYXQuZXEgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0LnN0cihhKSA9PT0gbWF0LnN0cihiKTtcblxuLyoqXG4gKiBDb3B5IGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvcHlcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXG4gKi9cbm1hdC5jcHkgPSBhID0+IG1hdChhLm0sIGEubiwgWy4uLmEuZW50cmllc10pO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4XG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZW50cnkgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgZW50cnkgaW5kZXhcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBlbnRyeVxuICovXG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXggYW5kIGJ1aWxkIGEgbmV3IG1hdHJpeCBmcm9tIHRoZSByZXN1bHRzXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHttYXRyaXhNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXhcbiAqIEByZXR1cm4ge21hdH0gTWF0cml4IGEgbWFwcGVkIHRocm91Z2ggZlxuICovXG5tYXQubWFwID0gKGEsIGYpID0+IG1hdChhLm0sIGEubiwgYS5lbnRyaWVzLm1hcChmKSk7XG5cbi8qKlxuICogQ29udmVydCBhIG1hdHJpeCBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbnM9J1xcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcbicpID0+IF92ZWNfY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IHZlYzIsIHZlYzMsIG1hdCB9O1xufVxuIiwiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGF0YWFydHMvZGF0Lmd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZ1bmN0aW9uIF9fXyRpbnNlcnRTdHlsZShjc3MpIHtcbiAgaWYgKCFjc3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICByZXR1cm4gY3NzO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvU3RyaW5nIChjb2xvciwgZm9yY2VDU1NIZXgpIHtcbiAgdmFyIGNvbG9yRm9ybWF0ID0gY29sb3IuX19zdGF0ZS5jb252ZXJzaW9uTmFtZS50b1N0cmluZygpO1xuICB2YXIgciA9IE1hdGgucm91bmQoY29sb3Iucik7XG4gIHZhciBnID0gTWF0aC5yb3VuZChjb2xvci5nKTtcbiAgdmFyIGIgPSBNYXRoLnJvdW5kKGNvbG9yLmIpO1xuICB2YXIgYSA9IGNvbG9yLmE7XG4gIHZhciBoID0gTWF0aC5yb3VuZChjb2xvci5oKTtcbiAgdmFyIHMgPSBjb2xvci5zLnRvRml4ZWQoMSk7XG4gIHZhciB2ID0gY29sb3Iudi50b0ZpeGVkKDEpO1xuICBpZiAoZm9yY2VDU1NIZXggfHwgY29sb3JGb3JtYXQgPT09ICdUSFJFRV9DSEFSX0hFWCcgfHwgY29sb3JGb3JtYXQgPT09ICdTSVhfQ0hBUl9IRVgnKSB7XG4gICAgdmFyIHN0ciA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCA2KSB7XG4gICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiAnIycgKyBzdHI7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCJykge1xuICAgIHJldHVybiAncmdiKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCQScpIHtcbiAgICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIRVgnKSB7XG4gICAgcmV0dXJuICcweCcgKyBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnXSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdSR0JBX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJ10nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX09CSicpIHtcbiAgICByZXR1cm4gJ3tyOicgKyByICsgJyxnOicgKyBnICsgJyxiOicgKyBiICsgJ30nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCQV9PQkonKSB7XG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICcsYTonICsgYSArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVl9PQkonKSB7XG4gICAgcmV0dXJuICd7aDonICsgaCArICcsczonICsgcyArICcsdjonICsgdiArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVkFfT0JKJykge1xuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnLGE6JyArIGEgKyAnfSc7XG4gIH1cbiAgcmV0dXJuICd1bmtub3duIGZvcm1hdCc7XG59XG5cbnZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBDb21tb24gPSB7XG4gIEJSRUFLOiB7fSxcbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5pc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCkge1xuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgY29tcG9zZTogZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9LFxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRyLCBzY29wZSkge1xuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHtcbiAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAgIGZvciAoa2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtfa2V5XSwgX2tleSkgPT09IHRoaXMuQlJFQUspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlcihmbmMpIHtcbiAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gIH0sXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB0aHJlc2hvbGQsIGNhbGxJbW1lZGlhdGVseSkge1xuICAgIHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghY2FsbEltbWVkaWF0ZWx5KSBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgY2FsbE5vdyA9IGNhbGxJbW1lZGlhdGVseSB8fCAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHRocmVzaG9sZCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICB9LFxuICBpc1VuZGVmaW5lZDogZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9LFxuICBpc05hTjogZnVuY3Rpb24gKF9pc05hTikge1xuICAgIGZ1bmN0aW9uIGlzTmFOKF94KSB7XG4gICAgICByZXR1cm4gX2lzTmFOLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlzTmFOLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pc05hTi50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzTmFOO1xuICB9KGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gaXNOYU4ob2JqKTtcbiAgfSksXG4gIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gIH0sXG4gIGlzTnVtYmVyOiBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBvYmogKyAwO1xuICB9LFxuICBpc1N0cmluZzogZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgJyc7XG4gIH0sXG4gIGlzQm9vbGVhbjogZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgfSxcbiAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH1cbn07XG5cbnZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG57XG4gIGxpdG11czogQ29tbW9uLmlzU3RyaW5nLFxuICBjb252ZXJzaW9uczoge1xuICAgIFRIUkVFX0NIQVJfSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBTSVhfQ0hBUl9IRVg6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKlxcKS8pO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCQToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqXFwpLyk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNOdW1iZXIsXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc0FycmF5LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQl9BUlJBWToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICB9XG4gICAgfSxcbiAgICBSR0JBX0FSUkFZOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT09IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzT2JqZWN0LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQkFfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFJHQl9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZBX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufV07XG52YXIgcmVzdWx0ID0gdm9pZCAwO1xudmFyIHRvUmV0dXJuID0gdm9pZCAwO1xudmFyIGludGVycHJldCA9IGZ1bmN0aW9uIGludGVycHJldCgpIHtcbiAgdG9SZXR1cm4gPSBmYWxzZTtcbiAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBDb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuICBDb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcbiAgICAgIENvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24gKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG4gICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICByZXR1cm4gQ29tbW9uLkJSRUFLO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21tb24uQlJFQUs7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufTtcblxudmFyIHRtcENvbXBvbmVudCA9IHZvaWQgMDtcbnZhciBDb2xvck1hdGggPSB7XG4gIGhzdl90b19yZ2I6IGZ1bmN0aW9uIGhzdl90b19yZ2IoaCwgcywgdikge1xuICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG4gICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgIHZhciBxID0gdiAqICgxLjAgLSBmICogcyk7XG4gICAgdmFyIHQgPSB2ICogKDEuMCAtICgxLjAgLSBmKSAqIHMpO1xuICAgIHZhciBjID0gW1t2LCB0LCBwXSwgW3EsIHYsIHBdLCBbcCwgdiwgdF0sIFtwLCBxLCB2XSwgW3QsIHAsIHZdLCBbdiwgcCwgcV1dW2hpXTtcbiAgICByZXR1cm4ge1xuICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICBiOiBjWzJdICogMjU1XG4gICAgfTtcbiAgfSxcbiAgcmdiX3RvX2hzdjogZnVuY3Rpb24gcmdiX3RvX2hzdihyLCBnLCBiKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgdmFyIGggPSB2b2lkIDA7XG4gICAgdmFyIHMgPSB2b2lkIDA7XG4gICAgaWYgKG1heCAhPT0gMCkge1xuICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBOYU4sXG4gICAgICAgIHM6IDAsXG4gICAgICAgIHY6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChyID09PSBtYXgpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICB9XG4gICAgaCAvPSA2O1xuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaDogaCAqIDM2MCxcbiAgICAgIHM6IHMsXG4gICAgICB2OiBtYXggLyAyNTVcbiAgICB9O1xuICB9LFxuICByZ2JfdG9faGV4OiBmdW5jdGlvbiByZ2JfdG9faGV4KHIsIGcsIGIpIHtcbiAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgIHJldHVybiBoZXg7XG4gIH0sXG4gIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24gY29tcG9uZW50X2Zyb21faGV4KGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICByZXR1cm4gaGV4ID4+IGNvbXBvbmVudEluZGV4ICogOCAmIDB4RkY7XG4gIH0sXG4gIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24gaGV4X3dpdGhfY29tcG9uZW50KGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgaGV4ICYgfigweEZGIDw8IHRtcENvbXBvbmVudCk7XG4gIH1cbn07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbG9yKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yKTtcbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29sb3IsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBjb2xvclRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSGV4U3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXhTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gY29sb3JUb1N0cmluZyh0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b09yaWdpbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PcmlnaW5hbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbG9yO1xufSgpO1xuZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgIH1cbiAgICAgIENvbG9yLnJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICB9XG4gICAgICBDb2xvci5yZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgIENvbG9yLnJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcbiAgICB9XG4gIH0pO1xufVxuQ29sb3IucmVjYWxjdWxhdGVSR0IgPSBmdW5jdGlvbiAoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcbiAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG4gICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gQ29sb3JNYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG4gICAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBDb2xvck1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3JydXB0ZWQgY29sb3Igc3RhdGUnKTtcbiAgfVxufTtcbkNvbG9yLnJlY2FsY3VsYXRlSFNWID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHZhciByZXN1bHQgPSBDb2xvck1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCB7XG4gICAgczogcmVzdWx0LnMsXG4gICAgdjogcmVzdWx0LnZcbiAgfSk7XG4gIGlmICghQ29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICB9IGVsc2UgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgfVxufTtcbkNvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCAnZycsICdiJywgJ2gnLCAncycsICd2JywgJ2hleCcsICdhJ107XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gQ29sb3JNYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcbiAgfVxufSk7XG5cbnZhciBDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sbGVyKTtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIHRoaXMuX19vbkNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdvbkNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlKGZuYykge1xuICAgICAgdGhpcy5fX29uQ2hhbmdlID0gZm5jO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GaW5pc2hDaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZpbmlzaENoYW5nZShmbmMpIHtcbiAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IGZuYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzTW9kaWZpZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc01vZGlmaWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlICE9PSB0aGlzLmdldFZhbHVlKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb250cm9sbGVyO1xufSgpO1xuXG52YXIgRVZFTlRfTUFQID0ge1xuICBIVE1MRXZlbnRzOiBbJ2NoYW5nZSddLFxuICBNb3VzZUV2ZW50czogWydjbGljaycsICdtb3VzZW1vdmUnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2VvdmVyJ10sXG4gIEtleWJvYXJkRXZlbnRzOiBbJ2tleWRvd24nXVxufTtcbnZhciBFVkVOVF9NQVBfSU5WID0ge307XG5Db21tb24uZWFjaChFVkVOVF9NQVAsIGZ1bmN0aW9uICh2LCBrKSB7XG4gIENvbW1vbi5lYWNoKHYsIGZ1bmN0aW9uIChlKSB7XG4gICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XG4gIH0pO1xufSk7XG52YXIgQ1NTX1ZBTFVFX1BJWEVMUyA9IC8oXFxkKyhcXC5cXGQrKT8pcHgvO1xuZnVuY3Rpb24gY3NzVmFsdWVUb1BpeGVscyh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gJzAnIHx8IENvbW1vbi5pc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKENTU19WQUxVRV9QSVhFTFMpO1xuICBpZiAoIUNvbW1vbi5pc051bGwobWF0Y2gpKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIGRvbSA9IHtcbiAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uIG1ha2VTZWxlY3RhYmxlKGVsZW0sIHNlbGVjdGFibGUpIHtcbiAgICBpZiAoZWxlbSA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uc3R5bGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGVsZW0ub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIGVsZW0uc3R5bGUuTW96VXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgZWxlbS5zdHlsZS5LaHRtbFVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIGVsZW0udW5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZSA/ICdvbicgOiAnb2ZmJztcbiAgfSxcbiAgbWFrZUZ1bGxzY3JlZW46IGZ1bmN0aW9uIG1ha2VGdWxsc2NyZWVuKGVsZW0sIGhvciwgdmVydCkge1xuICAgIHZhciB2ZXJ0aWNhbCA9IHZlcnQ7XG4gICAgdmFyIGhvcml6b250YWwgPSBob3I7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChob3Jpem9udGFsKSkge1xuICAgICAgaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQodmVydGljYWwpKSB7XG4gICAgICB2ZXJ0aWNhbCA9IHRydWU7XG4gICAgfVxuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICBlbGVtLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IDA7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgZWxlbS5zdHlsZS50b3AgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSAwO1xuICAgIH1cbiAgfSxcbiAgZmFrZUV2ZW50OiBmdW5jdGlvbiBmYWtlRXZlbnQoZWxlbSwgZXZlbnRUeXBlLCBwYXJzLCBhdXgpIHtcbiAgICB2YXIgcGFyYW1zID0gcGFycyB8fCB7fTtcbiAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgJyArIGV2ZW50VHlwZSArICcgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGNsYXNzTmFtZSk7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjbGllbnRYID0gcGFyYW1zLnggfHwgcGFyYW1zLmNsaWVudFggfHwgMDtcbiAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XG4gICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUsIHdpbmRvdywgcGFyYW1zLmNsaWNrQ291bnQgfHwgMSwgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ0tleWJvYXJkRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbml0ID0gZXZ0LmluaXRLZXlib2FyZEV2ZW50IHx8IGV2dC5pbml0S2V5RXZlbnQ7XG4gICAgICAgICAgQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAga2V5Q29kZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUsIHdpbmRvdywgcGFyYW1zLmN0cmxLZXksIHBhcmFtcy5hbHRLZXksIHBhcmFtcy5zaGlmdEtleSwgcGFyYW1zLm1ldGFLZXksIHBhcmFtcy5rZXlDb2RlLCBwYXJhbXMuY2hhckNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb21tb24uZGVmYXVsdHMoZXZ0LCBhdXgpO1xuICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9LFxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09PSAtMSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gY2xhc3NOYW1lKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpLnRlc3QoZWxlbS5jbGFzc05hbWUpIHx8IGZhbHNlO1xuICB9LFxuICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoZWxlbSkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1sZWZ0J10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1yaWdodCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUud2lkdGgpO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uIGdldEhlaWdodChlbGVtKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXRvcCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZS5oZWlnaHQpO1xuICB9LFxuICBnZXRPZmZzZXQ6IGZ1bmN0aW9uIGdldE9mZnNldChlbCkge1xuICAgIHZhciBlbGVtID0gZWw7XG4gICAgdmFyIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgaWYgKGVsZW0ub2Zmc2V0UGFyZW50KSB7XG4gICAgICBkbyB7XG4gICAgICAgIG9mZnNldC5sZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgICAgb2Zmc2V0LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAoZWxlbSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH0sXG4gIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZShlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYpO1xuICB9XG59O1xuXG52YXIgQm9vbGVhbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoQm9vbGVhbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJvb2xlYW5Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQm9vbGVhbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19wcmV2ID0gX3RoaXMyLmdldFZhbHVlKCk7XG4gICAgX3RoaXMyLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoIV90aGlzLl9fcHJldik7XG4gICAgfVxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2NoZWNrYm94LCAnY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19jaGVja2JveCk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKEJvb2xlYW5Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIHRvUmV0dXJuID0gZ2V0KEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIGlmICh0aGlzLmdldFZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG52YXIgT3B0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhPcHRpb25Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgb3B0cykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPcHRpb25Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBvcHRpb25zID0gb3B0cztcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgaWYgKENvbW1vbi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBtYXBbZWxlbWVudF0gPSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgICBvcHRpb25zID0gbWFwO1xuICAgIH1cbiAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0LmlubmVySFRNTCA9IGtleTtcbiAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgX3RoaXMuX19zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgIF90aGlzLnNldFZhbHVlKGRlc2lyZWRWYWx1ZSk7XG4gICAgfSk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2VsZWN0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE9wdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgdG9SZXR1cm4gPSBnZXQoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoZG9tLmlzQWN0aXZlKHRoaXMuX19zZWxlY3QpKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX19zZWxlY3QudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gZ2V0KE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBPcHRpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIFN0cmluZ0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoU3RyaW5nQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpbmdDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyaW5nQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ0NvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKFN0cmluZ0NvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoIWRvbS5pc0FjdGl2ZSh0aGlzLl9faW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XG4gIHZhciBfeCA9IHgudG9TdHJpbmcoKTtcbiAgaWYgKF94LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIF94Lmxlbmd0aCAtIF94LmluZGV4T2YoJy4nKSAtIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3BhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBfdGhpcy5fX21pbiA9IF9wYXJhbXMubWluO1xuICAgIF90aGlzLl9fbWF4ID0gX3BhcmFtcy5tYXg7XG4gICAgX3RoaXMuX19zdGVwID0gX3BhcmFtcy5zdGVwO1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoX3RoaXMuX19zdGVwKSkge1xuICAgICAgaWYgKF90aGlzLmluaXRpYWxWYWx1ZSA9PT0gMCkge1xuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyhfdGhpcy5pbml0aWFsVmFsdWUpKSAvIE1hdGguTE4xMCkpIC8gMTA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBfdGhpcy5fX3N0ZXA7XG4gICAgfVxuICAgIF90aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHMoX3RoaXMuX19pbXBsaWVkU3RlcCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgX3YgPSB2O1xuICAgICAgaWYgKHRoaXMuX19taW4gIT09IHVuZGVmaW5lZCAmJiBfdiA8IHRoaXMuX19taW4pIHtcbiAgICAgICAgX3YgPSB0aGlzLl9fbWluO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbWF4ICE9PSB1bmRlZmluZWQgJiYgX3YgPiB0aGlzLl9fbWF4KSB7XG4gICAgICAgIF92ID0gdGhpcy5fX21heDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fc3RlcCAhPT0gdW5kZWZpbmVkICYmIF92ICUgdGhpcy5fX3N0ZXAgIT09IDApIHtcbiAgICAgICAgX3YgPSBNYXRoLnJvdW5kKF92IC8gdGhpcy5fX3N0ZXApICogdGhpcy5fX3N0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIF92KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4obWluVmFsdWUpIHtcbiAgICAgIHRoaXMuX19taW4gPSBtaW5WYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21heCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heChtYXhWYWx1ZSkge1xuICAgICAgdGhpcy5fX21heCA9IG1heFZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RlcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXAoc3RlcFZhbHVlKSB7XG4gICAgICB0aGlzLl9fc3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyhzdGVwVmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gcm91bmRUb0RlY2ltYWwodmFsdWUsIGRlY2ltYWxzKSB7XG4gIHZhciB0ZW5UbyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogdGVuVG8pIC8gdGVuVG87XG59XG52YXIgTnVtYmVyQ29udHJvbGxlckJveCA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyQm94LCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlckJveCk7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXJCb3guX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyQm94KSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpKTtcbiAgICBfdGhpczIuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIHZhciBwcmV2WSA9IHZvaWQgMDtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHZhciBhdHRlbXB0ZWQgPSBwYXJzZUZsb2F0KF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgICAgaWYgKCFDb21tb24uaXNOYU4oYXR0ZW1wdGVkKSkge1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShhdHRlbXB0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkZpbmlzaCgpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcbiAgICAgIHZhciBkaWZmID0gcHJldlkgLSBlLmNsaWVudFk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5nZXRWYWx1ZSgpICsgZGlmZiAqIF90aGlzLl9faW1wbGllZFN0ZXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgb25GaW5pc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXJCb3gsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA/IHRoaXMuZ2V0VmFsdWUoKSA6IHJvdW5kVG9EZWNpbWFsKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fX3ByZWNpc2lvbik7XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94O1xufShOdW1iZXJDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gbWFwKHYsIGkxLCBpMiwgbzEsIG8yKSB7XG4gIHJldHVybiBvMSArIChvMiAtIG8xKSAqICgodiAtIGkxKSAvIChpMiAtIGkxKSk7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgbWluLCBtYXgsIHN0ZXApIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyU2xpZGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlclNsaWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJTbGlkZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwIH0pKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2ZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19iYWNrZ3JvdW5kLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2JhY2tncm91bmQsICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ3NsaWRlcicpO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19mb3JlZ3JvdW5kLCAnc2xpZGVyLWZnJyk7XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uTW91c2VEcmFnKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGUuY2xpZW50WCwgYmdSZWN0LmxlZnQsIGJnUmVjdC5yaWdodCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgICAgb25Ub3VjaE1vdmUoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICAgIHZhciBjbGllbnRYID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGNsaWVudFgsIGJnUmVjdC5sZWZ0LCBiZ1JlY3QucmlnaHQsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fZm9yZWdyb3VuZCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fYmFja2dyb3VuZCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdmFyIHBjdCA9ICh0aGlzLmdldFZhbHVlKCkgLSB0aGlzLl9fbWluKSAvICh0aGlzLl9fbWF4IC0gdGhpcy5fX21pbik7XG4gICAgICB0aGlzLl9fZm9yZWdyb3VuZC5zdHlsZS53aWR0aCA9IHBjdCAqIDEwMCArICclJztcbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXI7XG59KE51bWJlckNvbnRyb2xsZXIpO1xuXG52YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKEZ1bmN0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgdGV4dCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZ1bmN0aW9uQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19idXR0b24uaW5uZXJIVE1MID0gdGV4dCA9PT0gdW5kZWZpbmVkID8gJ0ZpcmUnIDogdGV4dDtcbiAgICBkb20uYmluZChfdGhpczIuX19idXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5maXJlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2J1dHRvbiwgJ2J1dHRvbicpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2J1dHRvbik7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhGdW5jdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZmlyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRWYWx1ZSgpLmNhbGwodGhpcy5vYmplY3QpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRnVuY3Rpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIENvbG9yQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhDb2xvckNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvckNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xvckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICBfdGhpczIuX19jb2xvciA9IG5ldyBDb2xvcihfdGhpczIuZ2V0VmFsdWUoKSk7XG4gICAgX3RoaXMyLl9fdGVtcCA9IG5ldyBDb2xvcigwKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20ubWFrZVNlbGVjdGFibGUoX3RoaXMyLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBfdGhpczIuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmNsYXNzTmFtZSA9ICdzZWxlY3Rvcic7XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lID0gJ3NhdHVyYXRpb24tZmllbGQnO1xuICAgIF90aGlzMi5fX2ZpZWxkX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19maWVsZF9rbm9iLmNsYXNzTmFtZSA9ICdmaWVsZC1rbm9iJztcbiAgICBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciA9ICcycHggc29saWQgJztcbiAgICBfdGhpczIuX19odWVfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2h1ZV9rbm9iLmNsYXNzTmFtZSA9ICdodWUta25vYic7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkLmNsYXNzTmFtZSA9ICdodWUtZmllbGQnO1xuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIF90aGlzMi5fX2lucHV0X3RleHRTaGFkb3cgPSAnMCAxcHggMXB4ICc7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIG9uQmx1ci5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMsICdkcmFnJykuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgdmFsdWVGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2VsZWN0b3Iuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTIycHgnLFxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxuICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMnB4JyxcbiAgICAgIGhlaWdodDogJzEycHgnLFxuICAgICAgYm9yZGVyOiBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciArIChfdGhpczIuX19jb2xvci52IDwgMC41ID8gJyNmZmYnIDogJyMwMDAnKSxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBtYXJnaW5SaWdodDogJzNweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZCh2YWx1ZUZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICB9KTtcbiAgICBsaW5lYXJHcmFkaWVudCh2YWx1ZUZpZWxkLCAndG9wJywgJ3JnYmEoMCwwLDAsMCknLCAnIzAwMCcpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnM3B4JyxcbiAgICAgIHJpZ2h0OiAnM3B4J1xuICAgIH0pO1xuICAgIGh1ZUdyYWRpZW50KF90aGlzMi5fX2h1ZV9maWVsZCk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19pbnB1dC5zdHlsZSwge1xuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICB0ZXh0U2hhZG93OiBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bkgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd25IKTtcbiAgICBmdW5jdGlvbiBmaWVsZERvd24oZSkge1xuICAgICAgc2V0U1YoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGREb3duSChlKSB7XG4gICAgICBzZXRIKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBIKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGRVcFNWKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkVXBIKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcEgpO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy52YWx1ZSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5hcHBlbmRDaGlsZCh2YWx1ZUZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19maWVsZF9rbm9iKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfZmllbGQpO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfa25vYik7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdG9yKTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGZ1bmN0aW9uIHNldFNWKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBfcmVmID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgICAgIHZhciBzID0gKGNsaWVudFggLSBmaWVsZFJlY3QubGVmdCkgLyAoZmllbGRSZWN0LnJpZ2h0IC0gZmllbGRSZWN0LmxlZnQpO1xuICAgICAgdmFyIHYgPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAodiA+IDEpIHtcbiAgICAgICAgdiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHMgPiAxKSB7XG4gICAgICAgIHMgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzIDwgMCkge1xuICAgICAgICBzID0gMDtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XG4gICAgICBfdGhpcy5fX2NvbG9yLnMgPSBzO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRIKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9faHVlX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIF9yZWYyID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmMi5jbGllbnRZO1xuICAgICAgdmFyIGggPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgaCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGggPCAwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfVxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb2xvckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuICAgICAgICBDb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQoaVtjb21wb25lbnRdKSAmJiAhQ29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pICYmIGlbY29tcG9uZW50XSAhPT0gdGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX190ZW1wLl9fc3RhdGUsIHRoaXMuX19jb2xvci5fX3N0YXRlKTtcbiAgICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuICAgICAgdmFyIGZsaXAgPSB0aGlzLl9fY29sb3IudiA8IDAuNSB8fCB0aGlzLl9fY29sb3IucyA+IDAuNSA/IDI1NSA6IDA7XG4gICAgICB2YXIgX2ZsaXAgPSAyNTUgLSBmbGlwO1xuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuICAgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcCA9ICgxIC0gdGhpcy5fX2NvbG9yLmggLyAzNjApICogMTAwICsgJ3B4JztcbiAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xuICAgICAgdGhpcy5fX3RlbXAudiA9IDE7XG4gICAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCkpO1xuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19jb2xvci50b0hleFN0cmluZygpLFxuICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknLFxuICAgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLC43KSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3JDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcbnZhciB2ZW5kb3JzID0gWyctbW96LScsICctby0nLCAnLXdlYmtpdC0nLCAnLW1zLScsICcnXTtcbmZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KGVsZW0sIHgsIGEsIGIpIHtcbiAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gIENvbW1vbi5lYWNoKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3IpIHtcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcgKyB4ICsgJywgJyArIGEgKyAnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG4gIH0pO1xufVxuZnVuY3Rpb24gaHVlR3JhZGllbnQoZWxlbSkge1xuICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCAjZmYwMGZmIDE3JSwgIzAwMDBmZiAzNCUsICMwMGZmZmYgNTAlLCAjMDBmZjAwIDY3JSwgI2ZmZmYwMCA4NCUsICNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG59XG5cbnZhciBjc3MgPSB7XG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQodXJsLCBpbmRvYykge1xuICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcbiAgICB2YXIgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcbiAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gIH0sXG4gIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KGNzc0NvbnRlbnQsIGluZG9jKSB7XG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xuICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaW5qZWN0ZWQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzQ29udGVudDtcbiAgICB2YXIgaGVhZCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHRyeSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKGluamVjdGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2F2ZURpYWxvZ0NvbnRlbnRzID0gXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuXFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCI7XG5cbnZhciBDb250cm9sbGVyRmFjdG9yeSA9IGZ1bmN0aW9uIENvbnRyb2xsZXJGYWN0b3J5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gIGlmIChDb21tb24uaXNBcnJheShhcmd1bWVudHNbMl0pIHx8IENvbW1vbi5pc09iamVjdChhcmd1bWVudHNbMl0pKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbM10pKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICB9XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbNF0pKSB7XG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10sIHN0ZXA6IGFyZ3VtZW50c1s0XSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdIH0pO1xuICB9XG4gIGlmIChDb21tb24uaXNTdHJpbmcoaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzRnVuY3Rpb24oaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksICcnKTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzQm9vbGVhbihpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xufVxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxudmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZW50ZXJlZERpdigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50ZXJlZERpdik7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcicsXG4gICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcbiAgICBkb20ubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInLFxuICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZG9tLmJpbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENlbnRlcmVkRGl2LCBbe1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgICAgdGhpcy5sYXlvdXQoKTtcbiAgICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaWRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICB9O1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xheW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGggLyAyIC0gZG9tLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDZW50ZXJlZERpdjtcbn0oKTtcblxudmFyIHN0eWxlU2hlZXQgPSBfX18kaW5zZXJ0U3R5bGUoXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7Ym9yZGVyOjA7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS1ib3R0b217cG9zaXRpb246YWJzb2x1dGV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteTp2aXNpYmxlfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLXRvcHttYXJnaW4tdG9wOjB9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtYm90dG9te21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3t0b3A6MDt6LWluZGV4OjEwMDJ9LmRnLmEgLnNhdmUtcm93LmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtYm90dG9te3Bvc2l0aW9uOmZpeGVkfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy13ZWJraXQtdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXJ9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGk+KntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVufS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWV7d2lkdGg6MTAwJX0uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCU7cG9zaXRpb246cmVsYXRpdmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjdweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuY3IuY29sb3J7b3ZlcmZsb3c6dmlzaWJsZX0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmNvbG9ye2JvcmRlci1sZWZ0OjNweCBzb2xpZH0uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMkZBMUQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJGQTFENn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJGQTFENjttYXgtd2lkdGg6MTAwJX0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XFxuXCIpO1xuXG5jc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xudmFyIENTU19OQU1FU1BBQ0UgPSAnZGcnO1xudmFyIEhJREVfS0VZX0NPREUgPSA3MjtcbnZhciBDTE9TRV9CVVRUT05fSEVJR0hUID0gMjA7XG52YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xudmFyIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSgpO1xudmFyIFNBVkVfRElBTE9HVUUgPSB2b2lkIDA7XG52YXIgYXV0b1BsYWNlVmlyZ2luID0gdHJ1ZTtcbnZhciBhdXRvUGxhY2VDb250YWluZXIgPSB2b2lkIDA7XG52YXIgaGlkZSA9IGZhbHNlO1xudmFyIGhpZGVhYmxlR3VpcyA9IFtdO1xudmFyIEdVSSA9IGZ1bmN0aW9uIEdVSShwYXJzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBwYXJhbXMgPSBwYXJzIHx8IHt9O1xuICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5fX3VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCk7XG4gIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIENTU19OQU1FU1BBQ0UpO1xuICB0aGlzLl9fZm9sZGVycyA9IHt9O1xuICB0aGlzLl9fY29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzID0gW107XG4gIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX2xpc3RlbmluZyA9IFtdO1xuICBwYXJhbXMgPSBDb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgY2xvc2VPblRvcDogZmFsc2UsXG4gICAgYXV0b1BsYWNlOiB0cnVlLFxuICAgIHdpZHRoOiBHVUkuREVGQVVMVF9XSURUSFxuICB9KTtcbiAgcGFyYW1zID0gQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgIHJlc2l6YWJsZTogcGFyYW1zLmF1dG9QbGFjZSxcbiAgICBoaWRlYWJsZTogcGFyYW1zLmF1dG9QbGFjZVxuICB9KTtcbiAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLmxvYWQpKSB7XG4gICAgaWYgKHBhcmFtcy5wcmVzZXQpIHtcbiAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHBhcmFtcy5wcmVzZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmFtcy5sb2FkID0geyBwcmVzZXQ6IERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSB9O1xuICB9XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLmhpZGVhYmxlKSB7XG4gICAgaGlkZWFibGVHdWlzLnB1c2godGhpcyk7XG4gIH1cbiAgcGFyYW1zLnJlc2l6YWJsZSA9IENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMucmVzaXphYmxlO1xuICBpZiAocGFyYW1zLmF1dG9QbGFjZSAmJiBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnNjcm9sbGFibGUpKSB7XG4gICAgcGFyYW1zLnNjcm9sbGFibGUgPSB0cnVlO1xuICB9XG4gIHZhciB1c2VMb2NhbFN0b3JhZ2UgPSBTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJztcbiAgdmFyIHNhdmVUb0xvY2FsU3RvcmFnZSA9IHZvaWQgMDtcbiAgdmFyIHRpdGxlUm93ID0gdm9pZCAwO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxuICB7XG4gICAgcGFyZW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXJlbnQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBzY3JvbGxhYmxlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5zY3JvbGxhYmxlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXV0b1BsYWNlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5hdXRvUGxhY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZU9uVG9wOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZU9uVG9wO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlc2V0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSb290KCkucHJlc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgX3RoaXMuZ2V0Um9vdCgpLnByZXNldCA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcmVzZXRTZWxlY3RJbmRleCh0aGlzKTtcbiAgICAgICAgX3RoaXMucmV2ZXJ0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMud2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMud2lkdGggPSB2O1xuICAgICAgICBzZXRXaWR0aChfdGhpcywgdik7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5uYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLm5hbWUgPSB2O1xuICAgICAgICBpZiAodGl0bGVSb3cpIHtcbiAgICAgICAgICB0aXRsZVJvdy5pbm5lckhUTUwgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMuY2xvc2VkID0gdjtcbiAgICAgICAgaWYgKHBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgaWYgKF90aGlzLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICBfdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IHYgPyBHVUkuVEVYVF9PUEVOIDogR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2FkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlTG9jYWxTdG9yYWdlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShib29sKSB7XG4gICAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlID0gYm9vbDtcbiAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgZG9tLmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpLCBib29sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHBhcmFtcy5jbG9zZWQgfHwgZmFsc2U7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX01BSU4pO1xuICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgaWYgKHVzZUxvY2FsU3RvcmFnZSkge1xuICAgICAgICBfdGhpcy51c2VMb2NhbFN0b3JhZ2UgPSB0cnVlO1xuICAgICAgICB2YXIgc2F2ZWRHdWkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdndWknKSk7XG4gICAgICAgIGlmIChzYXZlZEd1aSkge1xuICAgICAgICAgIHBhcmFtcy5sb2FkID0gSlNPTi5wYXJzZShzYXZlZEd1aSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IEdVSS5URVhUX0NMT1NFRDtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OKTtcbiAgICBpZiAocGFyYW1zLmNsb3NlT25Ub3ApIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9UT1ApO1xuICAgICAgdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9fY2xvc2VCdXR0b24sIHRoaXMuZG9tRWxlbWVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JPVFRPTSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2Nsb3NlQnV0dG9uKTtcbiAgICB9XG4gICAgZG9tLmJpbmQodGhpcy5fX2Nsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbXMuY2xvc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgdGl0bGVSb3dOYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFyYW1zLm5hbWUpO1xuICAgIGRvbS5hZGRDbGFzcyh0aXRsZVJvd05hbWUsICdjb250cm9sbGVyLW5hbWUnKTtcbiAgICB0aXRsZVJvdyA9IGFkZFJvdyhfdGhpcywgdGl0bGVSb3dOYW1lKTtcbiAgICB2YXIgb25DbGlja1RpdGxlID0gZnVuY3Rpb24gb25DbGlja1RpdGxlKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICBkb20uYWRkQ2xhc3ModGl0bGVSb3csICd0aXRsZScpO1xuICAgIGRvbS5iaW5kKHRpdGxlUm93LCAnY2xpY2snLCBvbkNsaWNrVGl0bGUpO1xuICAgIGlmICghcGFyYW1zLmNsb3NlZCkge1xuICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmFtcy5hdXRvUGxhY2UpIHtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG4gICAgICBpZiAoYXV0b1BsYWNlVmlyZ2luKSB7XG4gICAgICAgIGF1dG9QbGFjZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9QbGFjZUNvbnRhaW5lciwgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdXRvUGxhY2VDb250YWluZXIpO1xuICAgICAgICBhdXRvUGxhY2VWaXJnaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX0FVVE9fUExBQ0UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBzZXRXaWR0aChfdGhpcywgcGFyYW1zLndpZHRoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMub25SZXNpemVEZWJvdW5jZWQoKTtcbiAgfTtcbiAgZG9tLmJpbmQod2luZG93LCAncmVzaXplJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd0cmFuc2l0aW9uZW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICdvVHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgdGhpcy5vblJlc2l6ZSgpO1xuICBpZiAocGFyYW1zLnJlc2l6YWJsZSkge1xuICAgIGFkZFJlc2l6ZUhhbmRsZSh0aGlzKTtcbiAgfVxuICBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiBzYXZlVG9Mb2NhbFN0b3JhZ2UoKSB7XG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2d1aScpLCBKU09OLnN0cmluZ2lmeShfdGhpcy5nZXRTYXZlT2JqZWN0KCkpKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSA9IHNhdmVUb0xvY2FsU3RvcmFnZTtcbiAgZnVuY3Rpb24gcmVzZXRXaWR0aCgpIHtcbiAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICByb290LndpZHRoICs9IDE7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3Qud2lkdGggLT0gMTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXBhcmFtcy5wYXJlbnQpIHtcbiAgICByZXNldFdpZHRoKCk7XG4gIH1cbn07XG5HVUkudG9nZ2xlSGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgaGlkZSA9ICFoaWRlO1xuICBDb21tb24uZWFjaChoaWRlYWJsZUd1aXMsIGZ1bmN0aW9uIChndWkpIHtcbiAgICBndWkuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaGlkZSA/ICdub25lJyA6ICcnO1xuICB9KTtcbn07XG5HVUkuQ0xBU1NfQVVUT19QTEFDRSA9ICdhJztcbkdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUiA9ICdhYyc7XG5HVUkuQ0xBU1NfTUFJTiA9ICdtYWluJztcbkdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyA9ICdjcic7XG5HVUkuQ0xBU1NfVE9PX1RBTEwgPSAndGFsbGVyLXRoYW4td2luZG93JztcbkdVSS5DTEFTU19DTE9TRUQgPSAnY2xvc2VkJztcbkdVSS5DTEFTU19DTE9TRV9CVVRUT04gPSAnY2xvc2UtYnV0dG9uJztcbkdVSS5DTEFTU19DTE9TRV9UT1AgPSAnY2xvc2UtdG9wJztcbkdVSS5DTEFTU19DTE9TRV9CT1RUT00gPSAnY2xvc2UtYm90dG9tJztcbkdVSS5DTEFTU19EUkFHID0gJ2RyYWcnO1xuR1VJLkRFRkFVTFRfV0lEVEggPSAyNDU7XG5HVUkuVEVYVF9DTE9TRUQgPSAnQ2xvc2UgQ29udHJvbHMnO1xuR1VJLlRFWFRfT1BFTiA9ICdPcGVuIENvbnRyb2xzJztcbkdVSS5fa2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSAndGV4dCcgJiYgKGUud2hpY2ggPT09IEhJREVfS0VZX0NPREUgfHwgZS5rZXlDb2RlID09PSBISURFX0tFWV9DT0RFKSkge1xuICAgIEdVSS50b2dnbGVIaWRlKCk7XG4gIH1cbn07XG5kb20uYmluZCh3aW5kb3csICdrZXlkb3duJywgR1VJLl9rZXlkb3duSGFuZGxlciwgZmFsc2UpO1xuQ29tbW9uLmV4dGVuZChHVUkucHJvdG90eXBlLFxue1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIF9hZGQodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgZmFjdG9yeUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICB9KTtcbiAgfSxcbiAgYWRkQ29sb3I6IGZ1bmN0aW9uIGFkZENvbG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gX2FkZCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICBjb2xvcjogdHJ1ZVxuICAgIH0pO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjb250cm9sbGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGNvbnRyb2xsZXIuX19saSk7XG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzLnNwbGljZSh0aGlzLl9fY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSwgMSk7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0aGUgcm9vdCBHVUkgc2hvdWxkIGJlIHJlbW92ZWQgd2l0aCAuZGVzdHJveSgpLiAnICsgJ0ZvciBzdWJmb2xkZXJzLCB1c2UgZ3VpLnJlbW92ZUZvbGRlcihmb2xkZXIpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgYXV0b1BsYWNlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIF90aGlzLnJlbW92ZUZvbGRlcihzdWJmb2xkZXIpO1xuICAgIH0pO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAna2V5ZG93bicsIEdVSS5fa2V5ZG93bkhhbmRsZXIsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcnModGhpcyk7XG4gIH0sXG4gIGFkZEZvbGRlcjogZnVuY3Rpb24gYWRkRm9sZGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fX2ZvbGRlcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYWxyZWFkeSBoYXZlIGEgZm9sZGVyIGluIHRoaXMgR1VJIGJ5IHRoZScgKyAnIG5hbWUgXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cbiAgICB2YXIgbmV3R3VpUGFyYW1zID0geyBuYW1lOiBuYW1lLCBwYXJlbnQ6IHRoaXMgfTtcbiAgICBuZXdHdWlQYXJhbXMuYXV0b1BsYWNlID0gdGhpcy5hdXRvUGxhY2U7XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0pIHtcbiAgICAgIG5ld0d1aVBhcmFtcy5jbG9zZWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXS5jbG9zZWQ7XG4gICAgICBuZXdHdWlQYXJhbXMubG9hZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdO1xuICAgIH1cbiAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdHdWlQYXJhbXMpO1xuICAgIHRoaXMuX19mb2xkZXJzW25hbWVdID0gZ3VpO1xuICAgIHZhciBsaSA9IGFkZFJvdyh0aGlzLCBndWkuZG9tRWxlbWVudCk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnZm9sZGVyJyk7XG4gICAgcmV0dXJuIGd1aTtcbiAgfSxcbiAgcmVtb3ZlRm9sZGVyOiBmdW5jdGlvbiByZW1vdmVGb2xkZXIoZm9sZGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGZvbGRlci5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLl9fZm9sZGVyc1tmb2xkZXIubmFtZV07XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcnMoZm9sZGVyKTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKGZvbGRlci5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIGZvbGRlci5yZW1vdmVGb2xkZXIoc3ViZm9sZGVyKTtcbiAgICB9KTtcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9LFxuICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH0sXG4gIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuICAgIGlmIChyb290LnNjcm9sbGFibGUpIHtcbiAgICAgIHZhciB0b3AgPSBkb20uZ2V0T2Zmc2V0KHJvb3QuX191bCkudG9wO1xuICAgICAgdmFyIGggPSAwO1xuICAgICAgQ29tbW9uLmVhY2gocm9vdC5fX3VsLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghKHJvb3QuYXV0b1BsYWNlICYmIG5vZGUgPT09IHJvb3QuX19zYXZlX3JvdykpIHtcbiAgICAgICAgICBoICs9IGRvbS5nZXRIZWlnaHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgPCBoKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290Ll9fcmVzaXplX2hhbmRsZSkge1xuICAgICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUuaGVpZ2h0ID0gcm9vdC5fX3VsLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJvb3QuX19jbG9zZUJ1dHRvbikge1xuICAgICAgcm9vdC5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gcm9vdC53aWR0aCArICdweCc7XG4gICAgfVxuICB9LFxuICBvblJlc2l6ZURlYm91bmNlZDogQ29tbW9uLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gIH0sIDUwKSxcbiAgcmVtZW1iZXI6IGZ1bmN0aW9uIHJlbWVtYmVyKCkge1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoU0FWRV9ESUFMT0dVRSkpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUgPSBuZXcgQ2VudGVyZWREaXYoKTtcbiAgICAgIFNBVkVfRElBTE9HVUUuZG9tRWxlbWVudC5pbm5lckhUTUwgPSBzYXZlRGlhbG9nQ29udGVudHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG9ubHkgY2FsbCByZW1lbWJlciBvbiBhIHRvcCBsZXZlbCBHVUkuJyk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFkZFNhdmVNZW51KF90aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICBzZXRXaWR0aCh0aGlzLCB0aGlzLndpZHRoKTtcbiAgICB9XG4gIH0sXG4gIGdldFJvb3Q6IGZ1bmN0aW9uIGdldFJvb3QoKSB7XG4gICAgdmFyIGd1aSA9IHRoaXM7XG4gICAgd2hpbGUgKGd1aS5wYXJlbnQpIHtcbiAgICAgIGd1aSA9IGd1aS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBndWk7XG4gIH0sXG4gIGdldFNhdmVPYmplY3Q6IGZ1bmN0aW9uIGdldFNhdmVPYmplY3QoKSB7XG4gICAgdmFyIHRvUmV0dXJuID0gdGhpcy5sb2FkO1xuICAgIHRvUmV0dXJuLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgdG9SZXR1cm4ucHJlc2V0ID0gdGhpcy5wcmVzZXQ7XG4gICAgICBpZiAoIXRvUmV0dXJuLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgfVxuICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIH1cbiAgICB0b1JldHVybi5mb2xkZXJzID0ge307XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChlbGVtZW50LCBrZXkpIHtcbiAgICAgIHRvUmV0dXJuLmZvbGRlcnNba2V5XSA9IGVsZW1lbnQuZ2V0U2F2ZU9iamVjdCgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0b1JldHVybjtcbiAgfSxcbiAgc2F2ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKCk7XG4gIH0sXG4gIHNhdmVBczogZnVuY3Rpb24gc2F2ZUFzKHByZXNldE5hbWUpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3ByZXNldE5hbWVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICB0aGlzLnByZXNldCA9IHByZXNldE5hbWU7XG4gICAgYWRkUHJlc2V0T3B0aW9uKHRoaXMsIHByZXNldE5hbWUsIHRydWUpO1xuICAgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpO1xuICB9LFxuICByZXZlcnQ6IGZ1bmN0aW9uIHJldmVydChndWkpIHtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250cm9sbGVyLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlLmNhbGwoY29udHJvbGxlciwgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xuICAgICAgZm9sZGVyLnJldmVydChmb2xkZXIpO1xuICAgIH0pO1xuICAgIGlmICghZ3VpKSB7XG4gICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcy5nZXRSb290KCksIGZhbHNlKTtcbiAgICB9XG4gIH0sXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGNvbnRyb2xsZXIpIHtcbiAgICB2YXIgaW5pdCA9IHRoaXMuX19saXN0ZW5pbmcubGVuZ3RoID09PSAwO1xuICAgIHRoaXMuX19saXN0ZW5pbmcucHVzaChjb250cm9sbGVyKTtcbiAgICBpZiAoaW5pdCkge1xuICAgICAgdXBkYXRlRGlzcGxheXModGhpcy5fX2xpc3RlbmluZyk7XG4gICAgfVxuICB9LFxuICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZm9sZGVyKSB7XG4gICAgICBmb2xkZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICB9XG59KTtcbmZ1bmN0aW9uIGFkZFJvdyhndWksIG5ld0RvbSwgbGlCZWZvcmUpIHtcbiAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgaWYgKG5ld0RvbSkge1xuICAgIGxpLmFwcGVuZENoaWxkKG5ld0RvbSk7XG4gIH1cbiAgaWYgKGxpQmVmb3JlKSB7XG4gICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGxpLCBsaUJlZm9yZSk7XG4gIH0gZWxzZSB7XG4gICAgZ3VpLl9fdWwuYXBwZW5kQ2hpbGQobGkpO1xuICB9XG4gIGd1aS5vblJlc2l6ZSgpO1xuICByZXR1cm4gbGk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZ3VpKSB7XG4gIGRvbS51bmJpbmQod2luZG93LCAncmVzaXplJywgZ3VpLl9fcmVzaXplSGFuZGxlcik7XG4gIGlmIChndWkuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSkge1xuICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLCBtb2RpZmllZCkge1xuICB2YXIgb3B0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuICBpZiAobW9kaWZpZWQpIHtcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlICsgJyonO1xuICB9IGVsc2Uge1xuICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fX2xpID0gbGk7XG4gIGNvbnRyb2xsZXIuX19ndWkgPSBndWk7XG4gIENvbW1vbi5leHRlbmQoY29udHJvbGxlciwge1xuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoX29wdGlvbnMpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBuZXh0U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW0NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKENvbW1vbi5pc0FycmF5KF9vcHRpb25zKSB8fCBDb21tb24uaXNPYmplY3QoX29wdGlvbnMpKSB7XG4gICAgICAgIHZhciBfbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBfbmV4dFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtfb3B0aW9uc11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKF9uYW1lKSB7XG4gICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gX25hbWU7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5saXN0ZW4oY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpIHtcbiAgICB2YXIgYm94ID0gbmV3IE51bWJlckNvbnRyb2xsZXJCb3goY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHsgbWluOiBjb250cm9sbGVyLl9fbWluLCBtYXg6IGNvbnRyb2xsZXIuX19tYXgsIHN0ZXA6IGNvbnRyb2xsZXIuX19zdGVwIH0pO1xuICAgIENvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZScsICdzdGVwJywgJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuICAgICAgdmFyIHBiID0gYm94W21ldGhvZF07XG4gICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBwYi5hcHBseShib3gsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcbiAgICBjb250cm9sbGVyLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJveC5kb21FbGVtZW50LCBjb250cm9sbGVyLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyQm94KSB7XG4gICAgdmFyIHIgPSBmdW5jdGlvbiByKHJldHVybmVkKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19taW4pICYmIENvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuICAgICAgICB2YXIgb2xkTmFtZSA9IGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUw7XG4gICAgICAgIHZhciB3YXNMaXN0ZW5pbmcgPSBjb250cm9sbGVyLl9fZ3VpLl9fbGlzdGVuaW5nLmluZGV4T2YoY29udHJvbGxlcikgPiAtMTtcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXIgPSBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb250cm9sbGVyLl9fbWluLCBjb250cm9sbGVyLl9fbWF4LCBjb250cm9sbGVyLl9fc3RlcF1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXIubmFtZShvbGROYW1lKTtcbiAgICAgICAgaWYgKHdhc0xpc3RlbmluZykgbmV3Q29udHJvbGxlci5saXN0ZW4oKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuZWQ7XG4gICAgfTtcbiAgICBjb250cm9sbGVyLm1pbiA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcbiAgICBjb250cm9sbGVyLm1heCA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWF4KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQm9vbGVhbkNvbnRyb2xsZXIpIHtcbiAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xuICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19idXR0b24sICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gQ29tbW9uLmNvbXBvc2UoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG4gIH1cbiAgY29udHJvbGxlci5zZXRWYWx1ZSA9IENvbW1vbi5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcbiAgICAgIG1hcmtQcmVzZXRNb2RpZmllZChndWkuZ2V0Um9vdCgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG59XG5mdW5jdGlvbiByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcikge1xuICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG4gIHZhciBtYXRjaGVkSW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XG4gIGlmIChtYXRjaGVkSW5kZXggIT09IC0xKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJNYXAgPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRJbmRleF07XG4gICAgaWYgKGNvbnRyb2xsZXJNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udHJvbGxlck1hcCA9IHt9O1xuICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkSW5kZXhdID0gY29udHJvbGxlck1hcDtcbiAgICB9XG4gICAgY29udHJvbGxlck1hcFtjb250cm9sbGVyLnByb3BlcnR5XSA9IGNvbnRyb2xsZXI7XG4gICAgaWYgKHJvb3QubG9hZCAmJiByb290LmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdmFyIHByZXNldE1hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuICAgICAgdmFyIHByZXNldCA9IHZvaWQgMDtcbiAgICAgIGlmIChwcmVzZXRNYXBbZ3VpLnByZXNldF0pIHtcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW2d1aS5wcmVzZXRdO1xuICAgICAgfSBlbHNlIGlmIChwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSkge1xuICAgICAgICBwcmVzZXQgPSBwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZEluZGV4XSAmJiBwcmVzZXRbbWF0Y2hlZEluZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkSW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuICAgICAgICBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGQoZ3VpLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IFwiJyArIG9iamVjdCArICdcIiBoYXMgbm8gcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCInKTtcbiAgfVxuICB2YXIgY29udHJvbGxlciA9IHZvaWQgMDtcbiAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgIGNvbnRyb2xsZXIgPSBuZXcgQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QsIHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcbiAgICBjb250cm9sbGVyID0gQ29udHJvbGxlckZhY3RvcnkuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5iZWZvcmUgaW5zdGFuY2VvZiBDb250cm9sbGVyKSB7XG4gICAgcGFyYW1zLmJlZm9yZSA9IHBhcmFtcy5iZWZvcmUuX19saTtcbiAgfVxuICByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcik7XG4gIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLmRvbUVsZW1lbnQsICdjJyk7XG4gIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBkb20uYWRkQ2xhc3MobmFtZSwgJ3Byb3BlcnR5LW5hbWUnKTtcbiAgbmFtZS5pbm5lckhUTUwgPSBjb250cm9sbGVyLnByb3BlcnR5O1xuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xsZXIuZG9tRWxlbWVudCk7XG4gIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XG4gIGRvbS5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcbiAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICB9IGVsc2Uge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgX3R5cGVvZihjb250cm9sbGVyLmdldFZhbHVlKCkpKTtcbiAgfVxuICBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKTtcbiAgZ3VpLl9fY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xufVxuZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICBvcHQuaW5uZXJIVE1MID0gbmFtZTtcbiAgb3B0LnZhbHVlID0gbmFtZTtcbiAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICBpZiAoc2V0U2VsZWN0ZWQpIHtcbiAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pIHtcbiAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG59XG5mdW5jdGlvbiBhZGRTYXZlTWVudShndWkpIHtcbiAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgZG9tLmFkZENsYXNzKGd1aS5kb21FbGVtZW50LCAnaGFzLXNhdmUnKTtcbiAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGRpdiwgZ3VpLl9fdWwuZmlyc3RDaGlsZCk7XG4gIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGdlYXJzLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcbiAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uLmlubmVySFRNTCA9ICdTYXZlJztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnc2F2ZScpO1xuICB2YXIgYnV0dG9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG4gIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24zLmlubmVySFRNTCA9ICdSZXZlcnQnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xuICB2YXIgc2VsZWN0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICBpZiAoZ3VpLmxvYWQgJiYgZ3VpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgIENvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBrZXksIGtleSA9PT0gZ3VpLnByZXNldCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FLCBmYWxzZSk7XG4gIH1cbiAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0uaW5uZXJIVE1MID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIGd1aS5wcmVzZXQgPSB0aGlzLnZhbHVlO1xuICB9KTtcbiAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG4gIGRpdi5hcHBlbmRDaGlsZChnZWFycyk7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24zKTtcbiAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XG4gICAgdmFyIGxvY2FsU3RvcmFnZUNoZWNrQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLXN0b3JhZ2UnKTtcbiAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG4gICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2VDaGVja0JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgIH1cbiAgICBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKTtcbiAgICBkb20uYmluZChsb2NhbFN0b3JhZ2VDaGVja0JveCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuICAgIH0pO1xuICB9XG4gIHZhciBuZXdDb25zdHJ1Y3RvclRleHRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLW5ldy1jb25zdHJ1Y3RvcicpO1xuICBkb20uYmluZChuZXdDb25zdHJ1Y3RvclRleHRBcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09PSA2NykpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuICAgIH1cbiAgfSk7XG4gIGRvbS5iaW5kKGdlYXJzLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShndWkuZ2V0U2F2ZU9iamVjdCgpLCB1bmRlZmluZWQsIDIpO1xuICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuZm9jdXMoKTtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLnNlbGVjdCgpO1xuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgZ3VpLnNhdmUoKTtcbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJlc2V0TmFtZSA9IHByb21wdCgnRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuJyk7XG4gICAgaWYgKHByZXNldE5hbWUpIHtcbiAgICAgIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG4gICAgfVxuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uMywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGd1aS5yZXZlcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRSZXNpemVIYW5kbGUoZ3VpKSB7XG4gIHZhciBwbW91c2VYID0gdm9pZCAwO1xuICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIENvbW1vbi5leHRlbmQoZ3VpLl9fcmVzaXplX2hhbmRsZS5zdHlsZSwge1xuICAgIHdpZHRoOiAnNnB4JyxcbiAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG4gICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgfSk7XG4gIGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBndWkud2lkdGggKz0gcG1vdXNlWCAtIGUuY2xpZW50WDtcbiAgICBndWkub25SZXNpemUoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RvcCgpIHtcbiAgICBkb20ucmVtb3ZlQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRvbS5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcbiAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgaWYgKGd1aS5fX3NhdmVfcm93ICYmIGd1aS5hdXRvUGxhY2UpIHtcbiAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICB9XG4gIGlmIChndWkuX19jbG9zZUJ1dHRvbikge1xuICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XG4gIHZhciB0b1JldHVybiA9IHt9O1xuICBDb21tb24uZWFjaChndWkuX19yZW1lbWJlcmVkT2JqZWN0cywgZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICB2YXIgc2F2ZWRWYWx1ZXMgPSB7fTtcbiAgICB2YXIgY29udHJvbGxlck1hcCA9IGd1aS5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tpbmRleF07XG4gICAgQ29tbW9uLmVhY2goY29udHJvbGxlck1hcCwgZnVuY3Rpb24gKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG4gICAgICBzYXZlZFZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XG4gICAgfSk7XG4gICAgdG9SZXR1cm5baW5kZXhdID0gc2F2ZWRWYWx1ZXM7XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59XG5mdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09PSBndWkucHJlc2V0KSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSkge1xuICBpZiAoY29udHJvbGxlckFycmF5Lmxlbmd0aCAhPT0gMCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpO1xuICAgIH0pO1xuICB9XG4gIENvbW1vbi5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24gKGMpIHtcbiAgICBjLnVwZGF0ZURpc3BsYXkoKTtcbiAgfSk7XG59XG5cbnZhciBjb2xvciA9IHtcbiAgQ29sb3I6IENvbG9yLFxuICBtYXRoOiBDb2xvck1hdGgsXG4gIGludGVycHJldDogaW50ZXJwcmV0XG59O1xudmFyIGNvbnRyb2xsZXJzID0ge1xuICBDb250cm9sbGVyOiBDb250cm9sbGVyLFxuICBCb29sZWFuQ29udHJvbGxlcjogQm9vbGVhbkNvbnRyb2xsZXIsXG4gIE9wdGlvbkNvbnRyb2xsZXI6IE9wdGlvbkNvbnRyb2xsZXIsXG4gIFN0cmluZ0NvbnRyb2xsZXI6IFN0cmluZ0NvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXI6IE51bWJlckNvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXJCb3g6IE51bWJlckNvbnRyb2xsZXJCb3gsXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXI6IE51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG4gIEZ1bmN0aW9uQ29udHJvbGxlcjogRnVuY3Rpb25Db250cm9sbGVyLFxuICBDb2xvckNvbnRyb2xsZXI6IENvbG9yQ29udHJvbGxlclxufTtcbnZhciBkb20kMSA9IHsgZG9tOiBkb20gfTtcbnZhciBndWkgPSB7IEdVSTogR1VJIH07XG52YXIgR1VJJDEgPSBHVUk7XG52YXIgaW5kZXggPSB7XG4gIGNvbG9yOiBjb2xvcixcbiAgY29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxuICBkb206IGRvbSQxLFxuICBndWk6IGd1aSxcbiAgR1VJOiBHVUkkMVxufTtcblxuZXhwb3J0IHsgY29sb3IsIGNvbnRyb2xsZXJzLCBkb20kMSBhcyBkb20sIGd1aSwgR1VJJDEgYXMgR1VJIH07XG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdC5ndWkubW9kdWxlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSBleHBvcnRzLnZhbGlkYXRlID0gZXhwb3J0cy52NyA9IGV4cG9ydHMudjZUb1YxID0gZXhwb3J0cy52NiA9IGV4cG9ydHMudjUgPSBleHBvcnRzLnY0ID0gZXhwb3J0cy52MyA9IGV4cG9ydHMudjFUb1Y2ID0gZXhwb3J0cy52MSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5wYXJzZSA9IGV4cG9ydHMuTklMID0gZXhwb3J0cy5NQVggPSB2b2lkIDA7XG52YXIgbWF4X2pzXzEgPSByZXF1aXJlKFwiLi9tYXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNQVhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heF9qc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgbmlsX2pzXzEgPSByZXF1aXJlKFwiLi9uaWwuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOSUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5pbF9qc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgcGFyc2VfanNfMSA9IHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlX2pzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBzdHJpbmdpZnlfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5X2pzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciB2MV9qc18xID0gcmVxdWlyZShcIi4vdjEuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2MVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdjFfanNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHYxVG9WNl9qc18xID0gcmVxdWlyZShcIi4vdjFUb1Y2LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjFUb1Y2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2MVRvVjZfanNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHYzX2pzXzEgPSByZXF1aXJlKFwiLi92My5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInYzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2M19qc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgdjRfanNfMSA9IHJlcXVpcmUoXCIuL3Y0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY0X2pzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciB2NV9qc18xID0gcmVxdWlyZShcIi4vdjUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdjVfanNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHY2X2pzXzEgPSByZXF1aXJlKFwiLi92Ni5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2Nl9qc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgdjZUb1YxX2pzXzEgPSByZXF1aXJlKFwiLi92NlRvVjEuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NlRvVjFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY2VG9WMV9qc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgdjdfanNfMSA9IHJlcXVpcmUoXCIuL3Y3LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY3X2pzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciB2YWxpZGF0ZV9qc18xID0gcmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfanNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb24uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2ZXJzaW9uX2pzXzEuZGVmYXVsdDsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gJ2ZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZic7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICAgIGNvbnN0IHdvcmRzID0gdWludDhUb1VpbnQzMihieXRlcyk7XG4gICAgY29uc3QgbWQ1Qnl0ZXMgPSB3b3Jkc1RvTWQ1KHdvcmRzLCBieXRlcy5sZW5ndGggKiA4KTtcbiAgICByZXR1cm4gdWludDMyVG9VaW50OChtZDVCeXRlcyk7XG59XG5mdW5jdGlvbiB1aW50MzJUb1VpbnQ4KGlucHV0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKiA0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDQ7IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IChpbnB1dFtpID4+IDJdID4+PiAoKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGdldE91dHB1dExlbmd0aChpbnB1dExlbmd0aDgpIHtcbiAgICByZXR1cm4gKCgoaW5wdXRMZW5ndGg4ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0ICsgMTtcbn1cbmZ1bmN0aW9uIHdvcmRzVG9NZDUoeCwgbGVuKSB7XG4gICAgY29uc3QgeHBhZCA9IG5ldyBVaW50MzJBcnJheShnZXRPdXRwdXRMZW5ndGgobGVuKSkuZmlsbCgwKTtcbiAgICB4cGFkLnNldCh4KTtcbiAgICB4cGFkW2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICAgIHhwYWRbeHBhZC5sZW5ndGggLSAxXSA9IGxlbjtcbiAgICB4ID0geHBhZDtcbiAgICBsZXQgYSA9IDE3MzI1ODQxOTM7XG4gICAgbGV0IGIgPSAtMjcxNzMzODc5O1xuICAgIGxldCBjID0gLTE3MzI1ODQxOTQ7XG4gICAgbGV0IGQgPSAyNzE3MzM4Nzg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICBjb25zdCBvbGRhID0gYTtcbiAgICAgICAgY29uc3Qgb2xkYiA9IGI7XG4gICAgICAgIGNvbnN0IG9sZGMgPSBjO1xuICAgICAgICBjb25zdCBvbGRkID0gZDtcbiAgICAgICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KTtcbiAgICAgICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgNF0sIDcsIC0xNzY0MTg4OTcpO1xuICAgICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KTtcbiAgICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgICAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpO1xuICAgICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpO1xuICAgICAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICAgICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICAgICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA1LCAtMTY1Nzk2NTEwKTtcbiAgICAgICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgICAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgICAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgICAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICAgICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICAgICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDE0XSwgOSwgLTEwMTk4MDM2OTApO1xuICAgICAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICAgICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICAgICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgICAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICAgICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcbiAgICAgICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgICAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgICAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgICAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgICAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICAgICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgICAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgICAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcbiAgICAgICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgICAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgN10sIDEwLCAxMTI2ODkxNDE1KTtcbiAgICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICAgICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICAgICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNiwgMTcwMDQ4NTU3MSk7XG4gICAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICAgICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgICAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpO1xuICAgICAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgICAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSk7XG4gICAgICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSk7XG4gICAgICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgICAgICBhID0gc2FmZUFkZChhLCBvbGRhKTtcbiAgICAgICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgICAgICBkID0gc2FmZUFkZChkLCBvbGRkKTtcbiAgICB9XG4gICAgcmV0dXJuIFVpbnQzMkFycmF5Lm9mKGEsIGIsIGMsIGQpO1xufVxuZnVuY3Rpb24gdWludDhUb1VpbnQzMihpbnB1dCkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSgpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDMyQXJyYXkoZ2V0T3V0cHV0TGVuZ3RoKGlucHV0Lmxlbmd0aCAqIDgpKS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0W2kgPj4gMl0gfD0gKGlucHV0W2ldICYgMHhmZikgPDwgKChpICUgNCkgKiA4KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIHNhZmVBZGQoeCwgeSkge1xuICAgIGNvbnN0IGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgICBjb25zdCBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhmZmZmKTtcbn1cbmZ1bmN0aW9uIGJpdFJvdGF0ZUxlZnQobnVtLCBjbnQpIHtcbiAgICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICAgIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuZnVuY3Rpb24gbWQ1ZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiBtZDVjbW4oKGIgJiBjKSB8ICh+YiAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNWdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICByZXR1cm4gbWQ1Y21uKChiICYgZCkgfCAoYyAmIH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiBtZDVjbW4oYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG1kNTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmFuZG9tVVVJRCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEICYmIGNyeXB0by5yYW5kb21VVUlELmJpbmQoY3J5cHRvKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHsgcmFuZG9tVVVJRCB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdmFsaWRhdGVfanNfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpO1xuZnVuY3Rpb24gcGFyc2UodXVpZCkge1xuICAgIGlmICghKDAsIHZhbGlkYXRlX2pzXzEuZGVmYXVsdCkodXVpZCkpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgICB9XG4gICAgbGV0IHY7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkub2YoKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNCwgKHYgPj4+IDE2KSAmIDB4ZmYsICh2ID4+PiA4KSAmIDB4ZmYsIHYgJiAweGZmLCAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4LCB2ICYgMHhmZiwgKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDgsIHYgJiAweGZmLCAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gOCwgdiAmIDB4ZmYsICgodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDApICYgMHhmZiwgKHYgLyAweDEwMDAwMDAwMCkgJiAweGZmLCAodiA+Pj4gMjQpICYgMHhmZiwgKHYgPj4+IDE2KSAmIDB4ZmYsICh2ID4+PiA4KSAmIDB4ZmYsIHYgJiAweGZmKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLThdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC9pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5sZXQgZ2V0UmFuZG9tVmFsdWVzO1xuY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5mdW5jdGlvbiBybmcoKSB7XG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8ICFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byk7XG4gICAgfVxuICAgIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcm5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBmKHMsIHgsIHksIHopIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuICh4ICYgeSkgXiAofnggJiB6KTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuICh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgICB9XG59XG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpO1xufVxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICAgIGNvbnN0IEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gICAgY29uc3QgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcbiAgICBjb25zdCBuZXdCeXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCArIDEpO1xuICAgIG5ld0J5dGVzLnNldChieXRlcyk7XG4gICAgbmV3Qnl0ZXNbYnl0ZXMubGVuZ3RoXSA9IDB4ODA7XG4gICAgYnl0ZXMgPSBuZXdCeXRlcztcbiAgICBjb25zdCBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gICAgY29uc3QgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICAgIGNvbnN0IE0gPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICAgICAgICBhcnJbal0gPVxuICAgICAgICAgICAgICAgIChieXRlc1tpICogNjQgKyBqICogNF0gPDwgMjQpIHxcbiAgICAgICAgICAgICAgICAgICAgKGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAgKGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMl0gPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICBieXRlc1tpICogNjQgKyBqICogNCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIE1baV0gPSBhcnI7XG4gICAgfVxuICAgIE1bTiAtIDFdWzE0XSA9ICgoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4KSAvIE1hdGgucG93KDIsIDMyKTtcbiAgICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gICAgTVtOIC0gMV1bMTVdID0gKChieXRlcy5sZW5ndGggLSAxKSAqIDgpICYgMHhmZmZmZmZmZjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICBjb25zdCBXID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAxNjsgKyt0KSB7XG4gICAgICAgICAgICBXW3RdID0gTVtpXVt0XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0ID0gMTY7IHQgPCA4MDsgKyt0KSB7XG4gICAgICAgICAgICBXW3RdID0gUk9UTChXW3QgLSAzXSBeIFdbdCAtIDhdIF4gV1t0IC0gMTRdIF4gV1t0IC0gMTZdLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYSA9IEhbMF07XG4gICAgICAgIGxldCBiID0gSFsxXTtcbiAgICAgICAgbGV0IGMgPSBIWzJdO1xuICAgICAgICBsZXQgZCA9IEhbM107XG4gICAgICAgIGxldCBlID0gSFs0XTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCA4MDsgKyt0KSB7XG4gICAgICAgICAgICBjb25zdCBzID0gTWF0aC5mbG9vcih0IC8gMjApO1xuICAgICAgICAgICAgY29uc3QgVCA9IChST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1t0XSkgPj4+IDA7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9IFJPVEwoYiwgMzApID4+PiAwO1xuICAgICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgICBhID0gVDtcbiAgICAgICAgfVxuICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSA+Pj4gMDtcbiAgICAgICAgSFsxXSA9IChIWzFdICsgYikgPj4+IDA7XG4gICAgICAgIEhbMl0gPSAoSFsyXSArIGMpID4+PiAwO1xuICAgICAgICBIWzNdID0gKEhbM10gKyBkKSA+Pj4gMDtcbiAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgPj4+IDA7XG4gICAgfVxuICAgIHJldHVybiBVaW50OEFycmF5Lm9mKEhbMF0gPj4gMjQsIEhbMF0gPj4gMTYsIEhbMF0gPj4gOCwgSFswXSwgSFsxXSA+PiAyNCwgSFsxXSA+PiAxNiwgSFsxXSA+PiA4LCBIWzFdLCBIWzJdID4+IDI0LCBIWzJdID4+IDE2LCBIWzJdID4+IDgsIEhbMl0sIEhbM10gPj4gMjQsIEhbM10gPj4gMTYsIEhbM10gPj4gOCwgSFszXSwgSFs0XSA+PiAyNCwgSFs0XSA+PiAxNiwgSFs0XSA+PiA4LCBIWzRdKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHNoYTE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5zYWZlU3RyaW5naWZ5ID0gdm9pZCAwO1xuY29uc3QgdmFsaWRhdGVfanNfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpO1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgICByZXR1cm4gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArXG4gICAgICAgICctJyArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gK1xuICAgICAgICAnLScgK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpO1xufVxuZXhwb3J0cy51bnNhZmVTdHJpbmdpZnkgPSB1bnNhZmVTdHJpbmdpZnk7XG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7XG4gICAgaWYgKCEoMCwgdmFsaWRhdGVfanNfMS5kZWZhdWx0KSh1dWlkKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdXVpZDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHN0cmluZ2lmeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51cGRhdGVWMVN0YXRlID0gdm9pZCAwO1xuY29uc3Qgcm5nX2pzXzEgPSByZXF1aXJlKFwiLi9ybmcuanNcIik7XG5jb25zdCBzdHJpbmdpZnlfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKTtcbmNvbnN0IF9zdGF0ZSA9IHt9O1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICBsZXQgYnl0ZXM7XG4gICAgY29uc3QgaXNWNiA9IG9wdGlvbnM/Ll92NiA/PyBmYWxzZTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb25zS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9uc0tleXMubGVuZ3RoID09PSAxICYmIG9wdGlvbnNLZXlzWzBdID09PSAnX3Y2Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBieXRlcyA9IHYxQnl0ZXMob3B0aW9ucy5yYW5kb20gPz8gb3B0aW9ucy5ybmc/LigpID8/ICgwLCBybmdfanNfMS5kZWZhdWx0KSgpLCBvcHRpb25zLm1zZWNzLCBvcHRpb25zLm5zZWNzLCBvcHRpb25zLmNsb2Nrc2VxLCBvcHRpb25zLm5vZGUsIGJ1Ziwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJuZHMgPSAoMCwgcm5nX2pzXzEuZGVmYXVsdCkoKTtcbiAgICAgICAgdXBkYXRlVjFTdGF0ZShfc3RhdGUsIG5vdywgcm5kcyk7XG4gICAgICAgIGJ5dGVzID0gdjFCeXRlcyhybmRzLCBfc3RhdGUubXNlY3MsIF9zdGF0ZS5uc2VjcywgaXNWNiA/IHVuZGVmaW5lZCA6IF9zdGF0ZS5jbG9ja3NlcSwgaXNWNiA/IHVuZGVmaW5lZCA6IF9zdGF0ZS5ub2RlLCBidWYsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBidWYgPz8gKDAsIHN0cmluZ2lmeV9qc18xLnVuc2FmZVN0cmluZ2lmeSkoYnl0ZXMpO1xufVxuZnVuY3Rpb24gdXBkYXRlVjFTdGF0ZShzdGF0ZSwgbm93LCBybmRzKSB7XG4gICAgc3RhdGUubXNlY3MgPz89IC1JbmZpbml0eTtcbiAgICBzdGF0ZS5uc2VjcyA/Pz0gMDtcbiAgICBpZiAobm93ID09PSBzdGF0ZS5tc2Vjcykge1xuICAgICAgICBzdGF0ZS5uc2VjcysrO1xuICAgICAgICBpZiAoc3RhdGUubnNlY3MgPj0gMTAwMDApIHtcbiAgICAgICAgICAgIHN0YXRlLm5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzdGF0ZS5uc2VjcyA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm93ID4gc3RhdGUubXNlY3MpIHtcbiAgICAgICAgc3RhdGUubnNlY3MgPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChub3cgPCBzdGF0ZS5tc2Vjcykge1xuICAgICAgICBzdGF0ZS5ub2RlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLm5vZGUpIHtcbiAgICAgICAgc3RhdGUubm9kZSA9IHJuZHMuc2xpY2UoMTAsIDE2KTtcbiAgICAgICAgc3RhdGUubm9kZVswXSB8PSAweDAxO1xuICAgICAgICBzdGF0ZS5jbG9ja3NlcSA9ICgocm5kc1s4XSA8PCA4KSB8IHJuZHNbOV0pICYgMHgzZmZmO1xuICAgIH1cbiAgICBzdGF0ZS5tc2VjcyA9IG5vdztcbiAgICByZXR1cm4gc3RhdGU7XG59XG5leHBvcnRzLnVwZGF0ZVYxU3RhdGUgPSB1cGRhdGVWMVN0YXRlO1xuZnVuY3Rpb24gdjFCeXRlcyhybmRzLCBtc2VjcywgbnNlY3MsIGNsb2Nrc2VxLCBub2RlLCBidWYsIG9mZnNldCA9IDApIHtcbiAgICBpZiAocm5kcy5sZW5ndGggPCAxNikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhbmRvbSBieXRlcyBsZW5ndGggbXVzdCBiZSA+PSAxNicpO1xuICAgIH1cbiAgICBpZiAoIWJ1Zikge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxNiA+IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVVUlEIGJ5dGUgcmFuZ2UgJHtvZmZzZXR9OiR7b2Zmc2V0ICsgMTV9IGlzIG91dCBvZiBidWZmZXIgYm91bmRzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbXNlY3MgPz89IERhdGUubm93KCk7XG4gICAgbnNlY3MgPz89IDA7XG4gICAgY2xvY2tzZXEgPz89ICgocm5kc1s4XSA8PCA4KSB8IHJuZHNbOV0pICYgMHgzZmZmO1xuICAgIG5vZGUgPz89IHJuZHMuc2xpY2UoMTAsIDE2KTtcbiAgICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcbiAgICBjb25zdCB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgICBidWZbb2Zmc2V0KytdID0gKHRsID4+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAodGwgPj4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9ICh0bCA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSB0bCAmIDB4ZmY7XG4gICAgY29uc3QgdG1oID0gKChtc2VjcyAvIDB4MTAwMDAwMDAwKSAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKHRtaCA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSB0bWggJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAoKHRtaCA+Pj4gMjQpICYgMHhmKSB8IDB4MTA7XG4gICAgYnVmW29mZnNldCsrXSA9ICh0bWggPj4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9IChjbG9ja3NlcSA+Pj4gOCkgfCAweDgwO1xuICAgIGJ1ZltvZmZzZXQrK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICAgICAgYnVmW29mZnNldCsrXSA9IG5vZGVbbl07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB2MTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcGFyc2VfanNfMSA9IHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpO1xuY29uc3Qgc3RyaW5naWZ5X2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG5mdW5jdGlvbiB2MVRvVjYodXVpZCkge1xuICAgIGNvbnN0IHYxQnl0ZXMgPSB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyAoMCwgcGFyc2VfanNfMS5kZWZhdWx0KSh1dWlkKSA6IHV1aWQ7XG4gICAgY29uc3QgdjZCeXRlcyA9IF92MVRvVjYodjFCeXRlcyk7XG4gICAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/ICgwLCBzdHJpbmdpZnlfanNfMS51bnNhZmVTdHJpbmdpZnkpKHY2Qnl0ZXMpIDogdjZCeXRlcztcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHYxVG9WNjtcbmZ1bmN0aW9uIF92MVRvVjYodjFCeXRlcykge1xuICAgIHJldHVybiBVaW50OEFycmF5Lm9mKCgodjFCeXRlc1s2XSAmIDB4MGYpIDw8IDQpIHwgKCh2MUJ5dGVzWzddID4+IDQpICYgMHgwZiksICgodjFCeXRlc1s3XSAmIDB4MGYpIDw8IDQpIHwgKCh2MUJ5dGVzWzRdICYgMHhmMCkgPj4gNCksICgodjFCeXRlc1s0XSAmIDB4MGYpIDw8IDQpIHwgKCh2MUJ5dGVzWzVdICYgMHhmMCkgPj4gNCksICgodjFCeXRlc1s1XSAmIDB4MGYpIDw8IDQpIHwgKCh2MUJ5dGVzWzBdICYgMHhmMCkgPj4gNCksICgodjFCeXRlc1swXSAmIDB4MGYpIDw8IDQpIHwgKCh2MUJ5dGVzWzFdICYgMHhmMCkgPj4gNCksICgodjFCeXRlc1sxXSAmIDB4MGYpIDw8IDQpIHwgKCh2MUJ5dGVzWzJdICYgMHhmMCkgPj4gNCksIDB4NjAgfCAodjFCeXRlc1syXSAmIDB4MGYpLCB2MUJ5dGVzWzNdLCB2MUJ5dGVzWzhdLCB2MUJ5dGVzWzldLCB2MUJ5dGVzWzEwXSwgdjFCeXRlc1sxMV0sIHYxQnl0ZXNbMTJdLCB2MUJ5dGVzWzEzXSwgdjFCeXRlc1sxNF0sIHYxQnl0ZXNbMTVdKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VUkwgPSBleHBvcnRzLkROUyA9IHZvaWQgMDtcbmNvbnN0IG1kNV9qc18xID0gcmVxdWlyZShcIi4vbWQ1LmpzXCIpO1xuY29uc3QgdjM1X2pzXzEgPSByZXF1aXJlKFwiLi92MzUuanNcIik7XG52YXIgdjM1X2pzXzIgPSByZXF1aXJlKFwiLi92MzUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJETlNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHYzNV9qc18yLkROUzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVSTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdjM1X2pzXzIuVVJMOyB9IH0pO1xuZnVuY3Rpb24gdjModmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKDAsIHYzNV9qc18xLmRlZmF1bHQpKDB4MzAsIG1kNV9qc18xLmRlZmF1bHQsIHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KTtcbn1cbnYzLkROUyA9IHYzNV9qc18xLkROUztcbnYzLlVSTCA9IHYzNV9qc18xLlVSTDtcbmV4cG9ydHMuZGVmYXVsdCA9IHYzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVSTCA9IGV4cG9ydHMuRE5TID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gdm9pZCAwO1xuY29uc3QgcGFyc2VfanNfMSA9IHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpO1xuY29uc3Qgc3RyaW5naWZ5X2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICAgIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG5leHBvcnRzLkROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0cy5VUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmZ1bmN0aW9uIHYzNSh2ZXJzaW9uLCBoYXNoLCB2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGNvbnN0IHZhbHVlQnl0ZXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3RyaW5nVG9CeXRlcyh2YWx1ZSkgOiB2YWx1ZTtcbiAgICBjb25zdCBuYW1lc3BhY2VCeXRlcyA9IHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnID8gKDAsIHBhcnNlX2pzXzEuZGVmYXVsdCkobmFtZXNwYWNlKSA6IG5hbWVzcGFjZTtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gKDAsIHBhcnNlX2pzXzEuZGVmYXVsdCkobmFtZXNwYWNlKTtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZT8ubGVuZ3RoICE9PSAxNikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZUJ5dGVzLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZUJ5dGVzKTtcbiAgICBieXRlcy5zZXQodmFsdWVCeXRlcywgbmFtZXNwYWNlQnl0ZXMubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2goYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuICAgIGlmIChidWYpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzdHJpbmdpZnlfanNfMS51bnNhZmVTdHJpbmdpZnkpKGJ5dGVzKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHYzNTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbmF0aXZlX2pzXzEgPSByZXF1aXJlKFwiLi9uYXRpdmUuanNcIik7XG5jb25zdCBybmdfanNfMSA9IHJlcXVpcmUoXCIuL3JuZy5qc1wiKTtcbmNvbnN0IHN0cmluZ2lmeV9qc18xID0gcmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpO1xuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAobmF0aXZlX2pzXzEuZGVmYXVsdC5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZV9qc18xLmRlZmF1bHQucmFuZG9tVVVJRCgpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gPz8gb3B0aW9ucy5ybmc/LigpID8/ICgwLCBybmdfanNfMS5kZWZhdWx0KSgpO1xuICAgIGlmIChybmRzLmxlbmd0aCA8IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmFuZG9tIGJ5dGVzIGxlbmd0aCBtdXN0IGJlID49IDE2Jyk7XG4gICAgfVxuICAgIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG4gICAgaWYgKGJ1Zikge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMTYgPiBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVVVJRCBieXRlIHJhbmdlICR7b2Zmc2V0fToke29mZnNldCArIDE1fSBpcyBvdXQgb2YgYnVmZmVyIGJvdW5kc2ApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN0cmluZ2lmeV9qc18xLnVuc2FmZVN0cmluZ2lmeSkocm5kcyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB2NDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VUkwgPSBleHBvcnRzLkROUyA9IHZvaWQgMDtcbmNvbnN0IHNoYTFfanNfMSA9IHJlcXVpcmUoXCIuL3NoYTEuanNcIik7XG5jb25zdCB2MzVfanNfMSA9IHJlcXVpcmUoXCIuL3YzNS5qc1wiKTtcbnZhciB2MzVfanNfMiA9IHJlcXVpcmUoXCIuL3YzNS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkROU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdjM1X2pzXzIuRE5TOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVVJMXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2MzVfanNfMi5VUkw7IH0gfSk7XG5mdW5jdGlvbiB2NSh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIHJldHVybiAoMCwgdjM1X2pzXzEuZGVmYXVsdCkoMHg1MCwgc2hhMV9qc18xLmRlZmF1bHQsIHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KTtcbn1cbnY1LkROUyA9IHYzNV9qc18xLkROUztcbnY1LlVSTCA9IHYzNV9qc18xLlVSTDtcbmV4cG9ydHMuZGVmYXVsdCA9IHY1O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzdHJpbmdpZnlfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKTtcbmNvbnN0IHYxX2pzXzEgPSByZXF1aXJlKFwiLi92MS5qc1wiKTtcbmNvbnN0IHYxVG9WNl9qc18xID0gcmVxdWlyZShcIi4vdjFUb1Y2LmpzXCIpO1xuZnVuY3Rpb24gdjYob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICBvcHRpb25zID8/PSB7fTtcbiAgICBvZmZzZXQgPz89IDA7XG4gICAgbGV0IGJ5dGVzID0gKDAsIHYxX2pzXzEuZGVmYXVsdCkoeyAuLi5vcHRpb25zLCBfdjY6IHRydWUgfSwgbmV3IFVpbnQ4QXJyYXkoMTYpKTtcbiAgICBieXRlcyA9ICgwLCB2MVRvVjZfanNfMS5kZWZhdWx0KShieXRlcyk7XG4gICAgaWYgKGJ1Zikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiAoMCwgc3RyaW5naWZ5X2pzXzEudW5zYWZlU3RyaW5naWZ5KShieXRlcyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB2NjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcGFyc2VfanNfMSA9IHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpO1xuY29uc3Qgc3RyaW5naWZ5X2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG5mdW5jdGlvbiB2NlRvVjEodXVpZCkge1xuICAgIGNvbnN0IHY2Qnl0ZXMgPSB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyAoMCwgcGFyc2VfanNfMS5kZWZhdWx0KSh1dWlkKSA6IHV1aWQ7XG4gICAgY29uc3QgdjFCeXRlcyA9IF92NlRvVjEodjZCeXRlcyk7XG4gICAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/ICgwLCBzdHJpbmdpZnlfanNfMS51bnNhZmVTdHJpbmdpZnkpKHYxQnl0ZXMpIDogdjFCeXRlcztcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHY2VG9WMTtcbmZ1bmN0aW9uIF92NlRvVjEodjZCeXRlcykge1xuICAgIHJldHVybiBVaW50OEFycmF5Lm9mKCgodjZCeXRlc1szXSAmIDB4MGYpIDw8IDQpIHwgKCh2NkJ5dGVzWzRdID4+IDQpICYgMHgwZiksICgodjZCeXRlc1s0XSAmIDB4MGYpIDw8IDQpIHwgKCh2NkJ5dGVzWzVdICYgMHhmMCkgPj4gNCksICgodjZCeXRlc1s1XSAmIDB4MGYpIDw8IDQpIHwgKHY2Qnl0ZXNbNl0gJiAweDBmKSwgdjZCeXRlc1s3XSwgKCh2NkJ5dGVzWzFdICYgMHgwZikgPDwgNCkgfCAoKHY2Qnl0ZXNbMl0gJiAweGYwKSA+PiA0KSwgKCh2NkJ5dGVzWzJdICYgMHgwZikgPDwgNCkgfCAoKHY2Qnl0ZXNbM10gJiAweGYwKSA+PiA0KSwgMHgxMCB8ICgodjZCeXRlc1swXSAmIDB4ZjApID4+IDQpLCAoKHY2Qnl0ZXNbMF0gJiAweDBmKSA8PCA0KSB8ICgodjZCeXRlc1sxXSAmIDB4ZjApID4+IDQpLCB2NkJ5dGVzWzhdLCB2NkJ5dGVzWzldLCB2NkJ5dGVzWzEwXSwgdjZCeXRlc1sxMV0sIHY2Qnl0ZXNbMTJdLCB2NkJ5dGVzWzEzXSwgdjZCeXRlc1sxNF0sIHY2Qnl0ZXNbMTVdKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51cGRhdGVWN1N0YXRlID0gdm9pZCAwO1xuY29uc3Qgcm5nX2pzXzEgPSByZXF1aXJlKFwiLi9ybmcuanNcIik7XG5jb25zdCBzdHJpbmdpZnlfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKTtcbmNvbnN0IF9zdGF0ZSA9IHt9O1xuZnVuY3Rpb24gdjcob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICBsZXQgYnl0ZXM7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgYnl0ZXMgPSB2N0J5dGVzKG9wdGlvbnMucmFuZG9tID8/IG9wdGlvbnMucm5nPy4oKSA/PyAoMCwgcm5nX2pzXzEuZGVmYXVsdCkoKSwgb3B0aW9ucy5tc2Vjcywgb3B0aW9ucy5zZXEsIGJ1Ziwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJuZHMgPSAoMCwgcm5nX2pzXzEuZGVmYXVsdCkoKTtcbiAgICAgICAgdXBkYXRlVjdTdGF0ZShfc3RhdGUsIG5vdywgcm5kcyk7XG4gICAgICAgIGJ5dGVzID0gdjdCeXRlcyhybmRzLCBfc3RhdGUubXNlY3MsIF9zdGF0ZS5zZXEsIGJ1Ziwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZiA/PyAoMCwgc3RyaW5naWZ5X2pzXzEudW5zYWZlU3RyaW5naWZ5KShieXRlcyk7XG59XG5mdW5jdGlvbiB1cGRhdGVWN1N0YXRlKHN0YXRlLCBub3csIHJuZHMpIHtcbiAgICBzdGF0ZS5tc2VjcyA/Pz0gLUluZmluaXR5O1xuICAgIHN0YXRlLnNlcSA/Pz0gMDtcbiAgICBpZiAobm93ID4gc3RhdGUubXNlY3MpIHtcbiAgICAgICAgc3RhdGUuc2VxID0gKHJuZHNbNl0gPDwgMjMpIHwgKHJuZHNbN10gPDwgMTYpIHwgKHJuZHNbOF0gPDwgOCkgfCBybmRzWzldO1xuICAgICAgICBzdGF0ZS5tc2VjcyA9IG5vdztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXRlLnNlcSA9IChzdGF0ZS5zZXEgKyAxKSB8IDA7XG4gICAgICAgIGlmIChzdGF0ZS5zZXEgPT09IDApIHtcbiAgICAgICAgICAgIHN0YXRlLm1zZWNzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuZXhwb3J0cy51cGRhdGVWN1N0YXRlID0gdXBkYXRlVjdTdGF0ZTtcbmZ1bmN0aW9uIHY3Qnl0ZXMocm5kcywgbXNlY3MsIHNlcSwgYnVmLCBvZmZzZXQgPSAwKSB7XG4gICAgaWYgKHJuZHMubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYW5kb20gYnl0ZXMgbGVuZ3RoIG11c3QgYmUgPj0gMTYnKTtcbiAgICB9XG4gICAgaWYgKCFidWYpIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMTYgPiBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVVVJRCBieXRlIHJhbmdlICR7b2Zmc2V0fToke29mZnNldCArIDE1fSBpcyBvdXQgb2YgYnVmZmVyIGJvdW5kc2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1zZWNzID8/PSBEYXRlLm5vdygpO1xuICAgIHNlcSA/Pz0gKChybmRzWzZdICogMHg3ZikgPDwgMjQpIHwgKHJuZHNbN10gPDwgMTYpIHwgKHJuZHNbOF0gPDwgOCkgfCBybmRzWzldO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAobXNlY3MgLyAweDEwMDAwMDAwMDAwKSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9IChtc2VjcyAvIDB4MTAwMDAwMDAwKSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9IChtc2VjcyAvIDB4MTAwMDAwMCkgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAobXNlY3MgLyAweDEwMDAwKSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9IChtc2VjcyAvIDB4MTAwKSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9IG1zZWNzICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gMHg3MCB8ICgoc2VxID4+PiAyOCkgJiAweDBmKTtcbiAgICBidWZbb2Zmc2V0KytdID0gKHNlcSA+Pj4gMjApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gMHg4MCB8ICgoc2VxID4+PiAxNCkgJiAweDNmKTtcbiAgICBidWZbb2Zmc2V0KytdID0gKHNlcSA+Pj4gNikgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAoKHNlcSA8PCAyKSAmIDB4ZmYpIHwgKHJuZHNbMTBdICYgMHgwMyk7XG4gICAgYnVmW29mZnNldCsrXSA9IHJuZHNbMTFdO1xuICAgIGJ1ZltvZmZzZXQrK10gPSBybmRzWzEyXTtcbiAgICBidWZbb2Zmc2V0KytdID0gcm5kc1sxM107XG4gICAgYnVmW29mZnNldCsrXSA9IHJuZHNbMTRdO1xuICAgIGJ1ZltvZmZzZXQrK10gPSBybmRzWzE1XTtcbiAgICByZXR1cm4gYnVmO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdjc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZ2V4X2pzXzEgPSByZXF1aXJlKFwiLi9yZWdleC5qc1wiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIHJlZ2V4X2pzXzEuZGVmYXVsdC50ZXN0KHV1aWQpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhbGlkYXRlX2pzXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKTtcbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICAgIGlmICghKDAsIHZhbGlkYXRlX2pzXzEuZGVmYXVsdCkodXVpZCkpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE1KSwgMTYpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdmVyc2lvbjtcbiIsImltcG9ydCBDYW1lcmEzZCBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEtM2QnO1xuaW1wb3J0IHtcbiAgbGluZSBhcyBfbGluZSxcbiAgU3R5bGVPcHRpb25zLFxuICB3aXRoQ29udGV4dCxcbn0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FudmFzLWhlbHBlcnMnO1xuaW1wb3J0IERlYnVnLCB7IERlYnVnTWFya2VyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvZGVidWcnO1xuaW1wb3J0IHsgdmVjMiwgdmVjMyB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3ZlYyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4ZXMge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBBWEVTX0xFTkdUSCA9IDMwO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBBWEVTX1dJRFRIID0gMjtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgWF9DT0xPUiA9ICcjZjQ0JztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgWV9DT0xPUiA9ICcjNGY0JztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgWl9DT0xPUiA9ICcjNDhmJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTUFSS0VSX0xFTkdUSCA9IDM1O1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBNQVJLRVJfT1BUSU9OUzogUGFydGlhbDxEZWJ1Z01hcmtlcj4gPSB7XG4gICAgc2hvd01hcmtlcjogZmFsc2UsXG4gICAgbGFiZWxPZmZzZXQ6IHZlYzIoLTQsIDApLFxuICAgIGJhY2tncm91bmRDb2xvdXI6ICd0cmFuc3BhcmVudCcsXG4gICAgdGFnczogWydwYW5lbC0zZCddLFxuICB9O1xuXG4gIHB1YmxpYyBzdGF0aWMgZHJhdyhcbiAgICBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgY2FtZXJhOiBDYW1lcmEzZCxcbiAgICBzY3JlZW5TaXplOiB2ZWMyXG4gICkge1xuICAgIGNvbnN0IG9yaWdpbjJkID0gY2FtZXJhLnByb2plY3QodmVjMygwLCAwLCAwKSwgc2NyZWVuU2l6ZSk7XG5cbiAgICAvLyBQcm9qZWN0IGVuZHBvaW50cyBhbG9uZyBlYWNoIGF4aXNcbiAgICBjb25zdCB4MiA9IGNhbWVyYS5wcm9qZWN0KHZlYzMoQXhlcy5BWEVTX0xFTkdUSCwgMCwgMCksIHNjcmVlblNpemUpO1xuICAgIGNvbnN0IHkyID0gY2FtZXJhLnByb2plY3QodmVjMygwLCBBeGVzLkFYRVNfTEVOR1RILCAwKSwgc2NyZWVuU2l6ZSk7XG4gICAgY29uc3QgejIgPSBjYW1lcmEucHJvamVjdCh2ZWMzKDAsIDAsIEF4ZXMuQVhFU19MRU5HVEgpLCBzY3JlZW5TaXplKTtcblxuICAgIGlmICghb3JpZ2luMmQgfHwgIXgyIHx8ICF5MiB8fCAhejIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsaW5lID0gd2l0aENvbnRleHQoY29udGV4dCwgX2xpbmUpIGFzIChcbiAgICAgIHN0YXJ0OiB2ZWMyLFxuICAgICAgZW5kOiB2ZWMyLFxuICAgICAgc3R5bGU6IFBhcnRpYWw8U3R5bGVPcHRpb25zPlxuICAgICkgPT4gdm9pZDtcbiAgICBjb25zdCBzdHlsZTogUGFydGlhbDxTdHlsZU9wdGlvbnM+ID0ge1xuICAgICAgbGluZVdpZHRoOiBBeGVzLkFYRVNfV0lEVEgsXG4gICAgfTtcbiAgICBsaW5lKG9yaWdpbjJkLCB4MiwgeyAuLi5zdHlsZSwgc3Ryb2tlQ29sb3I6IEF4ZXMuWF9DT0xPUiB9KTtcbiAgICBsaW5lKG9yaWdpbjJkLCB5MiwgeyAuLi5zdHlsZSwgc3Ryb2tlQ29sb3I6IEF4ZXMuWV9DT0xPUiB9KTtcbiAgICBsaW5lKG9yaWdpbjJkLCB6MiwgeyAuLi5zdHlsZSwgc3Ryb2tlQ29sb3I6IEF4ZXMuWl9DT0xPUiB9KTtcblxuICAgIC8vIFByb2plY3QgbWFya2VyIHBvc2l0aW9ucyBhbG9uZyBlYWNoIGF4aXNcbiAgICBjb25zdCBtYXJrZXJYMiA9IGNhbWVyYS5wcm9qZWN0KHZlYzMoQXhlcy5NQVJLRVJfTEVOR1RILCAwLCAwKSwgc2NyZWVuU2l6ZSk7XG4gICAgY29uc3QgbWFya2VyWTIgPSBjYW1lcmEucHJvamVjdCh2ZWMzKDAsIEF4ZXMuTUFSS0VSX0xFTkdUSCwgMCksIHNjcmVlblNpemUpO1xuICAgIGNvbnN0IG1hcmtlcloyID0gY2FtZXJhLnByb2plY3QodmVjMygwLCAwLCBBeGVzLk1BUktFUl9MRU5HVEgpLCBzY3JlZW5TaXplKTtcblxuICAgIGlmICghbWFya2VyWDIgfHwgIW1hcmtlclkyIHx8ICFtYXJrZXJaMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIERlYnVnLm1hcmtlcigneCcsICcnLCBtYXJrZXJYMiwge1xuICAgICAgZm9yZWdyb3VuZENvbG91cjogQXhlcy5YX0NPTE9SLFxuICAgICAgLi4uQXhlcy5NQVJLRVJfT1BUSU9OUyxcbiAgICB9KTtcbiAgICBEZWJ1Zy5tYXJrZXIoJ3knLCAnJywgbWFya2VyWTIsIHtcbiAgICAgIGZvcmVncm91bmRDb2xvdXI6IEF4ZXMuWV9DT0xPUixcbiAgICAgIC4uLkF4ZXMuTUFSS0VSX09QVElPTlMsXG4gICAgfSk7XG4gICAgRGVidWcubWFya2VyKCd6JywgJycsIG1hcmtlcloyLCB7XG4gICAgICBmb3JlZ3JvdW5kQ29sb3VyOiBBeGVzLlpfQ09MT1IsXG4gICAgICAuLi5BeGVzLk1BUktFUl9PUFRJT05TLFxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgQ2FtZXJhM2QgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhLTNkJztcbmltcG9ydCB7IGxpbmUgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycyc7XG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCB7IHY0IGFzIHV1aWQgfSBmcm9tICd1dWlkJztcbmltcG9ydCBNb2RlbEVkaXRvciBmcm9tICcuL21vZGVsLWVkaXRvcic7XG5pbXBvcnQgeyBwb2ludE5lYXJMaW5lLCB2MzIgfSBmcm9tICcuL3V0aWxpdGllcyc7XG5pbXBvcnQgVmVydGV4IGZyb20gJy4vdmVydGV4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRnZSB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENPTE9VUiA9ICcjZmZmJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTElORV9XSURUSCA9IDE7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEhPVkVSX0xJTkVfV0lEVEggPSAzO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTRUxFQ1RfTElORV9XSURUSCA9IDM7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEhPVkVSX1JBRElVUyA9IDY7XG5cbiAgcHVibGljIGlkOiBzdHJpbmcgPSAnJztcbiAgcHVibGljIGhvdmVyZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIHNlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBmb2xkZXI6IGRhdC5HVUkgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgYTogVmVydGV4LCBwdWJsaWMgYjogVmVydGV4LCBhZGRGb2xkZXI6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgdGhpcy5pZCA9IHV1aWQoKTtcblxuICAgIGlmIChNb2RlbEVkaXRvci5lZGdlc0ZvbGRlciAmJiBhZGRGb2xkZXIpIHtcbiAgICAgIHRoaXMuZm9sZGVyID0gTW9kZWxFZGl0b3IuZWRnZXNGb2xkZXIuYWRkRm9sZGVyKGBFZGdlICR7dGhpcy5pZH1gKTtcbiAgICAgIHRoaXMuZm9sZGVyLmFkZChcbiAgICAgICAgeyBzZWxlY3Q6ICgpID0+IE1vZGVsRWRpdG9yLmluc3RhbmNlPy5zZWxlY3RFZGdlKHRoaXMsIGZhbHNlKSB9LFxuICAgICAgICAnc2VsZWN0J1xuICAgICAgKTtcbiAgICAgIHRoaXMuZm9sZGVyLmFkZChcbiAgICAgICAgeyBkZWxldGU6ICgpID0+IE1vZGVsRWRpdG9yLmluc3RhbmNlPy5yZW1vdmVFZGdlKHRoaXMpIH0sXG4gICAgICAgICdkZWxldGUnXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmZvbGRlcikge1xuICAgICAgTW9kZWxFZGl0b3IuZWRnZXNGb2xkZXI/LnJlbW92ZUZvbGRlcih0aGlzLmZvbGRlcik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNlcmlhbGl6ZSgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBhOiB0aGlzLmEuaWQsXG4gICAgICBiOiB0aGlzLmIuaWQsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZGVzZXJpYWxpemUoXG4gICAgZGF0YTogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICB2ZXJ0aWNlczogTWFwPHN0cmluZywgVmVydGV4PlxuICApOiBFZGdlIHtcbiAgICBjb25zdCBhID0gdmVydGljZXMuZ2V0KGRhdGEuYSk7XG4gICAgY29uc3QgYiA9IHZlcnRpY2VzLmdldChkYXRhLmIpO1xuICAgIGlmICghYSB8fCAhYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFZGdlICR7ZGF0YS5pZH0gcmVmZXJlbmNlcyBub24tZXhpc3RlbnQgdmVydGljZXMuYCk7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2UgPSBuZXcgRWRnZShhLCBiKTtcbiAgICBpZiAoZGF0YS5pZCkge1xuICAgICAgZWRnZS5pZCA9IGRhdGEuaWQ7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyKSB7fVxuXG4gIHB1YmxpYyBkcmF3MmQoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjb21wb25lbnRzOiBzdHJpbmcpIHtcbiAgICBsaW5lKFxuICAgICAgY29udGV4dCxcbiAgICAgIHYzMih0aGlzLmEucG9zaXRpb24sIGNvbXBvbmVudHMpLFxuICAgICAgdjMyKHRoaXMuYi5wb3NpdGlvbiwgY29tcG9uZW50cyksXG4gICAgICB7XG4gICAgICAgIHN0cm9rZUNvbG9yOiBFZGdlLkNPTE9VUixcbiAgICAgICAgbGluZVdpZHRoOiB0aGlzLnNlbGVjdGVkXG4gICAgICAgICAgPyBFZGdlLlNFTEVDVF9MSU5FX1dJRFRIXG4gICAgICAgICAgOiB0aGlzLmhvdmVyZWRcbiAgICAgICAgICA/IEVkZ2UuSE9WRVJfTElORV9XSURUSFxuICAgICAgICAgIDogRWRnZS5MSU5FX1dJRFRILFxuICAgICAgICBsaW5lU3R5bGU6IHRoaXMuaG92ZXJlZCAmJiAhdGhpcy5zZWxlY3RlZCA/ICdkYXNoZWQnIDogJ3NvbGlkJyxcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgcHVibGljIGRyYXczZChcbiAgICBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgY2FtZXJhOiBDYW1lcmEzZCxcbiAgICBzY3JlZW46IHZlYzJcbiAgKSB7XG4gICAgY29uc3QgYTMgPSBjYW1lcmEucHJvamVjdCh0aGlzLmEucG9zaXRpb24sIHNjcmVlbik7XG4gICAgY29uc3QgYjMgPSBjYW1lcmEucHJvamVjdCh0aGlzLmIucG9zaXRpb24sIHNjcmVlbik7XG5cbiAgICBpZiAoIWEzIHx8ICFiMykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxpbmUoY29udGV4dCwgYTMsIGIzLCB7XG4gICAgICBzdHJva2VDb2xvcjogRWRnZS5DT0xPVVIsXG4gICAgICBsaW5lV2lkdGg6IHRoaXMuc2VsZWN0ZWRcbiAgICAgICAgPyBFZGdlLlNFTEVDVF9MSU5FX1dJRFRIXG4gICAgICAgIDogdGhpcy5ob3ZlcmVkXG4gICAgICAgID8gRWRnZS5IT1ZFUl9MSU5FX1dJRFRIXG4gICAgICAgIDogRWRnZS5MSU5FX1dJRFRILFxuICAgICAgbGluZVN0eWxlOiB0aGlzLmhvdmVyZWQgJiYgIXRoaXMuc2VsZWN0ZWQgPyAnZGFzaGVkJyA6ICdzb2xpZCcsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaXNQb2ludE5lYXIyZChcbiAgICBwb2ludDogdmVjMixcbiAgICBjb21wb25lbnRzOiBzdHJpbmcsXG4gICAgcmFuZ2U6IG51bWJlciA9IEVkZ2UuSE9WRVJfUkFESVVTXG4gICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwb2ludE5lYXJMaW5lKFxuICAgICAgcG9pbnQsXG4gICAgICB7XG4gICAgICAgIHN0YXJ0OiB2MzIodGhpcy5hLnBvc2l0aW9uLCBjb21wb25lbnRzKSxcbiAgICAgICAgZW5kOiB2MzIodGhpcy5iLnBvc2l0aW9uLCBjb21wb25lbnRzKSxcbiAgICAgIH0sXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgaXNQb2ludE5lYXIzZChcbiAgICBwb2ludDogdmVjMixcbiAgICBjYW1lcmE6IENhbWVyYTNkLFxuICAgIHNjcmVlbjogdmVjMixcbiAgICByYW5nZTogbnVtYmVyID0gRWRnZS5IT1ZFUl9SQURJVVNcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYTMgPSBjYW1lcmEucHJvamVjdCh0aGlzLmEucG9zaXRpb24sIHNjcmVlbik7XG4gICAgY29uc3QgYjMgPSBjYW1lcmEucHJvamVjdCh0aGlzLmIucG9zaXRpb24sIHNjcmVlbik7XG5cbiAgICBpZiAoIWEzIHx8ICFiMykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludE5lYXJMaW5lKHBvaW50LCB7IHN0YXJ0OiBhMywgZW5kOiBiMyB9LCByYW5nZSk7XG4gIH1cbn1cbiIsImltcG9ydCBDYW1lcmEgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhJztcbmltcG9ydCB7IGxpbmUgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycyc7XG5pbXBvcnQgRGVidWcsIHsgRGVidWdNYXJrZXIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9kZWJ1Zyc7XG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JpZCB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEdSSURfQ09MT1VSID0gJyNmZmYxJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgR1JJRF9MSU5FX1dJRFRIID0gMTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ0VOVEVSX0FYSVNfQ09MT1VSID0gJyNmZmYyJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ0VOVEVSX0FYSVNfTElORV9XSURUSCA9IDI7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE1BUktFUl9PUFRJT05TOiBQYXJ0aWFsPERlYnVnTWFya2VyPiA9IHtcbiAgICBzaG93TWFya2VyOiB0cnVlLFxuICAgIG1hcmtlclN0eWxlOiAnKycsXG4gICAgbGFiZWxPZmZzZXQ6IHZlYzIoMyksXG4gICAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3VyOiAndHJhbnNwYXJlbnQnLFxuICAgIGZvbnQ6ICcxMHB4IG1vbm9zcGFjZScsXG4gICAgZm9yZWdyb3VuZENvbG91cjogJyNmZmY1JyxcbiAgfTtcblxuICBwdWJsaWMgc3RhdGljIGRyYXcoXG4gICAgY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICAgIGNhbWVyYTogQ2FtZXJhLFxuICAgIGdyaWRTaXplOiBudW1iZXIsXG4gICAgc2hvd0xhYmVsczogYm9vbGVhbiA9IGZhbHNlLFxuICAgIGxhYmVsc0dhcDogbnVtYmVyID0gMCxcbiAgICBsYWJlbHNUYWc6IHN0cmluZyA9ICcnXG4gICkge1xuICAgIGNvbnN0IGJvdW5kcyA9IGNhbWVyYS5ib3VuZHM7XG5cbiAgICBjb25zdCB0b3BMZWZ0ID0gdmVjMi5tdWwoXG4gICAgICB2ZWMyLm1hcCh2ZWMyLmRpdih2ZWMyKGJvdW5kcy5sZWZ0LCBib3VuZHMudG9wKSwgZ3JpZFNpemUpLCBNYXRoLmZsb29yKSxcbiAgICAgIGdyaWRTaXplXG4gICAgKTtcbiAgICBjb25zdCBib3R0b21SaWdodCA9IHZlYzIubXVsKFxuICAgICAgdmVjMi5tYXAoXG4gICAgICAgIHZlYzIuZGl2KHZlYzIoYm91bmRzLnJpZ2h0LCBib3VuZHMuYm90dG9tKSwgZ3JpZFNpemUpLFxuICAgICAgICBNYXRoLmNlaWxcbiAgICAgICksXG4gICAgICBncmlkU2l6ZVxuICAgICk7XG5cbiAgICAvLyBWZXJ0aWNhbCBsaW5lc1xuICAgIGZvciAobGV0IHggPSB0b3BMZWZ0Lng7IHggPD0gYm90dG9tUmlnaHQueDsgeCArPSBncmlkU2l6ZSkge1xuICAgICAgY29uc3QgaXNDZW50ZXIgPSBNYXRoLmFicyh4KSA8IGdyaWRTaXplIC8gMjtcbiAgICAgIGxpbmUoY29udGV4dCwgdmVjMih4LCB0b3BMZWZ0LnkpLCB2ZWMyKHgsIGJvdHRvbVJpZ2h0LnkpLCB7XG4gICAgICAgIHN0cm9rZUNvbG9yOiBpc0NlbnRlciA/IEdyaWQuQ0VOVEVSX0FYSVNfQ09MT1VSIDogR3JpZC5HUklEX0NPTE9VUixcbiAgICAgICAgbGluZVdpZHRoOlxuICAgICAgICAgIChpc0NlbnRlciA/IEdyaWQuQ0VOVEVSX0FYSVNfTElORV9XSURUSCA6IEdyaWQuR1JJRF9MSU5FX1dJRFRIKSAvXG4gICAgICAgICAgY2FtZXJhLmFjdHVhbFNjYWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSG9yaXpvbnRhbCBsaW5lc1xuICAgIGZvciAobGV0IHkgPSB0b3BMZWZ0Lnk7IHkgPD0gYm90dG9tUmlnaHQueTsgeSArPSBncmlkU2l6ZSkge1xuICAgICAgY29uc3QgaXNDZW50ZXIgPSBNYXRoLmFicyh5KSA8IGdyaWRTaXplIC8gMjtcbiAgICAgIGxpbmUoY29udGV4dCwgdmVjMih0b3BMZWZ0LngsIHkpLCB2ZWMyKGJvdHRvbVJpZ2h0LngsIHkpLCB7XG4gICAgICAgIHN0cm9rZUNvbG9yOiBpc0NlbnRlciA/IEdyaWQuQ0VOVEVSX0FYSVNfQ09MT1VSIDogR3JpZC5HUklEX0NPTE9VUixcbiAgICAgICAgbGluZVdpZHRoOlxuICAgICAgICAgIChpc0NlbnRlciA/IEdyaWQuQ0VOVEVSX0FYSVNfTElORV9XSURUSCA6IEdyaWQuR1JJRF9MSU5FX1dJRFRIKSAvXG4gICAgICAgICAgY2FtZXJhLmFjdHVhbFNjYWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTGFiZWxzXG4gICAgaWYgKHNob3dMYWJlbHMpIHtcbiAgICAgIGNvbnN0IGxhYmVsc1N0YXJ0WCA9XG4gICAgICAgIE1hdGguZmxvb3IodG9wTGVmdC54IC8gKGdyaWRTaXplICogbGFiZWxzR2FwKSkgKiBncmlkU2l6ZSAqIGxhYmVsc0dhcDtcbiAgICAgIGNvbnN0IGxhYmVsc1N0YXJ0WSA9XG4gICAgICAgIE1hdGguZmxvb3IodG9wTGVmdC55IC8gKGdyaWRTaXplICogbGFiZWxzR2FwKSkgKiBncmlkU2l6ZSAqIGxhYmVsc0dhcDtcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCB4ID0gbGFiZWxzU3RhcnRYO1xuICAgICAgICB4IDw9IGJvdHRvbVJpZ2h0Lng7XG4gICAgICAgIHggKz0gZ3JpZFNpemUgKiBsYWJlbHNHYXBcbiAgICAgICkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGxldCB5ID0gbGFiZWxzU3RhcnRZO1xuICAgICAgICAgIHkgPD0gYm90dG9tUmlnaHQueTtcbiAgICAgICAgICB5ICs9IGdyaWRTaXplICogbGFiZWxzR2FwXG4gICAgICAgICkge1xuICAgICAgICAgIERlYnVnLm1hcmtlcihgZ3JpZC0ke2xhYmVsc1RhZ30tJHt4fS0ke3l9YCwgYCR7eH0sJHt5fWAsIHZlYzIoeCwgeSksIHtcbiAgICAgICAgICAgIHRhZ3M6IFtsYWJlbHNUYWddLFxuICAgICAgICAgICAgLi4uR3JpZC5NQVJLRVJfT1BUSU9OUyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IENhbWVyYTNkIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYS0zZCc7XG5pbXBvcnQgeyBsaW5lIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FudmFzLWhlbHBlcnMnO1xuaW1wb3J0IERlYnVnLCB7IERlYnVnTWFya2VyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvZGVidWcnO1xuaW1wb3J0IHsgaW50ZXJzZWN0aW9uMmQgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnRlcnNlY3Rpb24taGVscGVycyc7XG5pbXBvcnQgeyB2ZWMyLCB2ZWMzIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcblxuY29uc3QgeyBhYWJiVG9SZWN0YW5nbGUsIGxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlLCBwb2ludEluUmVjdGFuZ2xlIH0gPVxuICBpbnRlcnNlY3Rpb24yZDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JpZDNkIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgR1JJRF9DT0xPUiA9ICcjZmZmMSc7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEdSSURfTElORV9XSURUSCA9IDE7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENFTlRFUl9BWElTX0NPTE9SID0gJyNmZmYyJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ0VOVEVSX0FYSVNfTElORV9XSURUSCA9IDI7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE1BUktFUl9PUFRJT05TOiBQYXJ0aWFsPERlYnVnTWFya2VyPiA9IHtcbiAgICBzaG93TWFya2VyOiB0cnVlLFxuICAgIG1hcmtlclN0eWxlOiAnKycsXG4gICAgbGFiZWxPZmZzZXQ6IHZlYzIoMyksXG4gICAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3VyOiAndHJhbnNwYXJlbnQnLFxuICAgIGZvbnQ6ICcxMHB4IG1vbm9zcGFjZScsXG4gICAgZm9yZWdyb3VuZENvbG91cjogJyNmZmY1JyxcbiAgICB0YWdzOiBbJ3BhbmVsLTNkJ10sXG4gIH07XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY2xpcFRvU2NyZWVuKFxuICAgIGE6IHZlYzIsXG4gICAgYjogdmVjMixcbiAgICBzY3JlZW46IHZlYzJcbiAgKTogW3ZlYzIsIHZlYzJdIHwgW251bGwsIG51bGxdIHtcbiAgICBjb25zdCBhSW5TY3JlZW4gPSBwb2ludEluUmVjdGFuZ2xlKFxuICAgICAgYSxcbiAgICAgIGFhYmJUb1JlY3RhbmdsZSh7IHBvc2l0aW9uOiB2ZWMyKCksIHNpemU6IHNjcmVlbiB9KVxuICAgICk7XG4gICAgY29uc3QgYkluU2NyZWVuID0gcG9pbnRJblJlY3RhbmdsZShcbiAgICAgIGIsXG4gICAgICBhYWJiVG9SZWN0YW5nbGUoeyBwb3NpdGlvbjogdmVjMigpLCBzaXplOiBzY3JlZW4gfSlcbiAgICApO1xuXG4gICAgaWYgKGFJblNjcmVlbiAmJiBiSW5TY3JlZW4pIHtcbiAgICAgIHJldHVybiBbYSwgYl07XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IGxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlKFxuICAgICAgeyBzdGFydDogYSwgZW5kOiBiIH0sXG4gICAgICBhYWJiVG9SZWN0YW5nbGUoeyBwb3NpdGlvbjogdmVjMigpLCBzaXplOiBzY3JlZW4gfSlcbiAgICApO1xuXG4gICAgaWYgKCFpbnRlcnNlY3Rpb25zLmludGVyc2VjdHMpIHtcbiAgICAgIC8vIEJvdGggcG9pbnRzIGFyZSBvZmYgdGhlIHNjcmVlbiBhbmQgdGhlIGxpbmUgZG9lcyBub3QgaW50ZXJzZWN0IHRoZVxuICAgICAgLy8gc2NyZWVuLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlciB0aGlzIGxpbmVcbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgaW50ZXJzZWN0aW9ucy5pbnRlcnNlY3Rpb25Qb2ludHMgJiZcbiAgICAgIGludGVyc2VjdGlvbnMuaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMVxuICAgICkge1xuICAgICAgLy8gV2UgaGF2ZSBvbmUgaW50ZXJzZWN0aW9uIHBvaW50LCBzbyB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgICAgLy8gcG9pbnQgdG8ga2VlcCBiYXNlZCBvbiB3aGljaCBvbmUgaXMgaW4gdGhlIHNjcmVlblxuICAgICAgaWYgKGFJblNjcmVlbikge1xuICAgICAgICByZXR1cm4gW2EsIGludGVyc2VjdGlvbnMuaW50ZXJzZWN0aW9uUG9pbnRzWzBdXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbaW50ZXJzZWN0aW9ucy5pbnRlcnNlY3Rpb25Qb2ludHNbMF0sIGJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMsIHNvIHdlIGNhbiByZXR1cm4gdGhlbSBkaXJlY3RseVxuICAgIGlmIChcbiAgICAgIGludGVyc2VjdGlvbnMuaW50ZXJzZWN0aW9uUG9pbnRzICYmXG4gICAgICBpbnRlcnNlY3Rpb25zLmludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPT09IDJcbiAgICApIHtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb25zLmludGVyc2VjdGlvblBvaW50cyBhcyBbdmVjMiwgdmVjMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZHJhdyhcbiAgICBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgY2FtZXJhOiBDYW1lcmEzZCxcbiAgICBzY3JlZW46IHZlYzIsXG4gICAgZ3JpZFNpemU6IG51bWJlcixcbiAgICBncmlkQ291bnQ6IG51bWJlcixcbiAgICBzaG93TGFiZWxzOiBib29sZWFuID0gZmFsc2UsXG4gICAgbGFiZWxzR2FwOiBudW1iZXIgPSAwXG4gICkge1xuICAgIGNvbnN0IGhhbGZDb3VudCA9IGdyaWRDb3VudCAvIDI7XG4gICAgY29uc3QgaGFsZkdyaWQgPSBoYWxmQ291bnQgKiBncmlkU2l6ZTtcblxuICAgIC8vIERyYXcgbGluZXMgcGFyYWxsZWwgdG8gWCAodmFyeWluZyBaKVxuICAgIGZvciAobGV0IGkgPSAtaGFsZkNvdW50OyBpIDw9IGhhbGZDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB6ID0gaSAqIGdyaWRTaXplO1xuICAgICAgY29uc3QgYTMgPSB2ZWMzKC1oYWxmR3JpZCwgMCwgeik7XG4gICAgICBjb25zdCBiMyA9IHZlYzMoaGFsZkdyaWQsIDAsIHopO1xuICAgICAgbGV0IGEyID0gY2FtZXJhLnByb2plY3QoYTMsIHNjcmVlbik7XG4gICAgICBsZXQgYjIgPSBjYW1lcmEucHJvamVjdChiMywgc2NyZWVuKTtcblxuICAgICAgaWYgKCFhMiB8fCAhYjIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIFthMiwgYjJdID0gdGhpcy5jbGlwVG9TY3JlZW4oYTIsIGIyLCBzY3JlZW4pO1xuXG4gICAgICBpZiAoIWEyIHx8ICFiMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNDZW50ZXIgPSBNYXRoLmFicyh6KSA8IGdyaWRTaXplO1xuICAgICAgbGluZShjb250ZXh0LCB2ZWMyKGEyLngsIGEyLnkpLCB2ZWMyKGIyLngsIGIyLnkpLCB7XG4gICAgICAgIHN0cm9rZUNvbG9yOiBpc0NlbnRlciA/IEdyaWQzZC5DRU5URVJfQVhJU19DT0xPUiA6IEdyaWQzZC5HUklEX0NPTE9SLFxuICAgICAgICBsaW5lV2lkdGg6IGlzQ2VudGVyXG4gICAgICAgICAgPyBHcmlkM2QuQ0VOVEVSX0FYSVNfTElORV9XSURUSFxuICAgICAgICAgIDogR3JpZDNkLkdSSURfTElORV9XSURUSCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERyYXcgbGluZXMgcGFyYWxsZWwgdG8gWiAodmFyeWluZyBYKVxuICAgIGZvciAobGV0IGkgPSAtaGFsZkNvdW50OyBpIDw9IGhhbGZDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAqIGdyaWRTaXplO1xuICAgICAgY29uc3QgYTMgPSB2ZWMzKHgsIDAsIC1oYWxmR3JpZCk7XG4gICAgICBjb25zdCBiMyA9IHZlYzMoeCwgMCwgaGFsZkdyaWQpO1xuICAgICAgbGV0IGEyID0gY2FtZXJhLnByb2plY3QoYTMsIHNjcmVlbik7XG4gICAgICBsZXQgYjIgPSBjYW1lcmEucHJvamVjdChiMywgc2NyZWVuKTtcblxuICAgICAgaWYgKCFhMiB8fCAhYjIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIFthMiwgYjJdID0gdGhpcy5jbGlwVG9TY3JlZW4oYTIsIGIyLCBzY3JlZW4pO1xuXG4gICAgICBpZiAoIWEyIHx8ICFiMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNDZW50ZXIgPSBNYXRoLmFicyh4KSA8IGdyaWRTaXplO1xuICAgICAgbGluZShjb250ZXh0LCB2ZWMyKGEyLngsIGEyLnkpLCB2ZWMyKGIyLngsIGIyLnkpLCB7XG4gICAgICAgIHN0cm9rZUNvbG9yOiBpc0NlbnRlciA/IEdyaWQzZC5DRU5URVJfQVhJU19DT0xPUiA6IEdyaWQzZC5HUklEX0NPTE9SLFxuICAgICAgICBsaW5lV2lkdGg6IGlzQ2VudGVyXG4gICAgICAgICAgPyBHcmlkM2QuQ0VOVEVSX0FYSVNfTElORV9XSURUSFxuICAgICAgICAgIDogR3JpZDNkLkdSSURfTElORV9XSURUSCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIExhYmVsc1xuICAgIGlmIChzaG93TGFiZWxzKSB7XG4gICAgICBjb25zdCBsYWJlbHNTdGFydFggPVxuICAgICAgICBNYXRoLmZsb29yKC1oYWxmR3JpZCAvIChncmlkU2l6ZSAqIGxhYmVsc0dhcCkpICogZ3JpZFNpemUgKiBsYWJlbHNHYXA7XG4gICAgICBjb25zdCBsYWJlbHNTdGFydFogPVxuICAgICAgICBNYXRoLmZsb29yKC1oYWxmR3JpZCAvIChncmlkU2l6ZSAqIGxhYmVsc0dhcCkpICogZ3JpZFNpemUgKiBsYWJlbHNHYXA7XG4gICAgICBmb3IgKGxldCB4ID0gbGFiZWxzU3RhcnRYOyB4IDw9IGhhbGZHcmlkOyB4ICs9IGdyaWRTaXplICogbGFiZWxzR2FwKSB7XG4gICAgICAgIGZvciAobGV0IHogPSBsYWJlbHNTdGFydFo7IHogPD0gaGFsZkdyaWQ7IHogKz0gZ3JpZFNpemUgKiBsYWJlbHNHYXApIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGxhYmVsIGlzIG91dHNpZGUgb2YgdGhlIGdyaWQgYm91bmRzLCBza2lwIGl0XG4gICAgICAgICAgaWYgKE1hdGguYWJzKHgpID4gaGFsZkdyaWQgfHwgTWF0aC5hYnMoeikgPiBoYWxmR3JpZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcDIgPSBjYW1lcmEucHJvamVjdCh2ZWMzKHgsIDAsIHopLCBzY3JlZW4pO1xuICAgICAgICAgIGlmICghcDIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBEZWJ1Zy5tYXJrZXIoXG4gICAgICAgICAgICBgZ3JpZC0zZC0ke3h9LSR7en1gLFxuICAgICAgICAgICAgYCR7eH0sJHt6fWAsXG4gICAgICAgICAgICB2ZWMyKHAyLngsIHAyLnkpLFxuICAgICAgICAgICAgR3JpZDNkLk1BUktFUl9PUFRJT05TXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IENhbWVyYSwgeyBDYW1lcmFPcHRpb25zIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhJztcbmltcG9ydCBDYW1lcmEzZCwgeyBDYW1lcmEzZE9wdGlvbnMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEtM2QnO1xuaW1wb3J0IERlYnVnIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnJztcbmltcG9ydCBJbnB1dE1hbmFnZXIsIHsgTW91c2VCdXR0b24gfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyJztcbmltcG9ydCB7XG4gIGludGVyc2VjdGlvbjNkLFxuICBpbnRlcnNlY3Rpb25VdGlsaXRpZXMsXG59IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2ludGVyc2VjdGlvbi1oZWxwZXJzJztcbmltcG9ydCB7IGNsYW1wLCByYWRpYW5zLCByb3VuZCB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzJztcbmltcG9ydCB7IHZlYzIsIHZlYzMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0ICogYXMgZGF0IGZyb20gJ2RhdC5ndWknO1xuaW1wb3J0IEF4ZXMgZnJvbSAnLi9heGVzJztcbmltcG9ydCBFZGdlIGZyb20gJy4vZWRnZSc7XG5pbXBvcnQgR3JpZCBmcm9tICcuL2dyaWQnO1xuaW1wb3J0IEdyaWQzZCBmcm9tICcuL2dyaWQzZCc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi9tb2RlbCc7XG5pbXBvcnQgU3VyZmFjZSBmcm9tICcuL3N1cmZhY2UnO1xuaW1wb3J0IHsgSGlzdG9yeUVudHJ5LCBQYW5lbDJkSW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgc2V0c0VxdWFsIH0gZnJvbSAnLi91dGlsaXRpZXMnO1xuaW1wb3J0IFZlcnRleCBmcm9tICcuL3ZlcnRleCc7XG5cbmNvbnN0IHsgcmF5SW50ZXJzZWN0c1BsYW5lLCBtZXNoQ2VudHJvaWQgfSA9IGludGVyc2VjdGlvbjNkO1xuY29uc3QgeyB2ZWN0b3JBbG1vc3RaZXJvIH0gPSBpbnRlcnNlY3Rpb25VdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsRWRpdG9yIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9DQU1FUkEzRF9QT1NJVElPTiA9IHZlYzMoMzAwLCA0MDAsIDUwMCk7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfQ0FNRVJBM0RfVEFSR0VUID0gdmVjMygwLCAwLCAwKTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgUEFORUxfTUlOX1NJWkUgPSAwLjI7XG5cbiAgcHVibGljIHN0YXRpYyBpbnN0YW5jZTogTW9kZWxFZGl0b3IgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIGxhc3RGcmFtZVRpbWU6IG51bWJlcjtcbiAgcHJpdmF0ZSBsYXN0RnJhbWVDb3VudFRpbWU6IG51bWJlcjtcbiAgcHJpdmF0ZSBmcmFtZVJhdGU6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgZnJhbWVDb3VudDogbnVtYmVyID0gMDtcblxuICBwcml2YXRlIGNhbnZhc1RvcDogSFRNTENhbnZhc0VsZW1lbnQ7XG4gIHByaXZhdGUgY29udGV4dFRvcDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICBwcml2YXRlIGNhbWVyYVRvcDogQ2FtZXJhO1xuXG4gIHByaXZhdGUgY2FudmFzRnJvbnQ6IEhUTUxDYW52YXNFbGVtZW50O1xuICBwcml2YXRlIGNvbnRleHRGcm9udDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICBwcml2YXRlIGNhbWVyYUZyb250OiBDYW1lcmE7XG5cbiAgcHJpdmF0ZSBjYW52YXNTaWRlOiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgcHJpdmF0ZSBjb250ZXh0U2lkZTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICBwcml2YXRlIGNhbWVyYVNpZGU6IENhbWVyYTtcblxuICBwcml2YXRlIGNhbnZhczNkOiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgcHJpdmF0ZSBjb250ZXh0M2Q6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgcHJpdmF0ZSBjYW1lcmEzZDogQ2FtZXJhM2Q7XG5cbiAgcHVibGljIHRvb2w6IHN0cmluZyA9ICdzZWxlY3QnO1xuICBwdWJsaWMgb3B0aW9ucyA9IHtcbiAgICBtb2RlbE5hbWU6ICcnLFxuICAgIHNob3dWZXJ0ZXhMYWJlbHM6IHRydWUsXG4gICAgc2hvd0F4ZXM6IHRydWUsXG4gICAgc2hvd0dyaWQ6IHRydWUsXG4gICAgZ3JpZFNpemU6IDUwLFxuICAgIHNob3dHcmlkTGFiZWxzOiB0cnVlLFxuICAgIGdyaWRMYWJlbHNHYXA6IDUsXG4gICAgc2hvd0dyb3VuZFBsYW5lOiB0cnVlLFxuICAgIGdyb3VuZFBsYW5lU2l6ZTogMjAsXG4gICAgc2hvd0dyb3VuZFBsYW5lTGFiZWxzOiB0cnVlLFxuICAgIGdyb3VuZFBsYW5lTGFiZWxzR2FwOiA1LFxuICAgIHpvb21TcGVlZDogMC4yLFxuICAgIG1vdmVTcGVlZDogMC4zLFxuICAgIHJvdGF0ZVNwZWVkOiAwLjAwMyxcbiAgfTtcblxuICBwcml2YXRlIGNhbWVyYU9wdGlvbnM6IFBhcnRpYWw8Q2FtZXJhT3B0aW9ucz4gPSB7XG4gICAgbWF4U2NhbGU6IDEwLFxuICAgIG1pblNjYWxlOiAwLjEsXG4gICAgbW92ZUVhc2VBbW91bnQ6IDAuNzUsXG4gICAgc2NhbGVFYXNlQW1vdW50OiAwLjc1LFxuICB9O1xuXG4gIHByaXZhdGUgY2FtZXJhM2RPcHRpb25zOiBQYXJ0aWFsPENhbWVyYTNkT3B0aW9ucz4gPSB7XG4gICAgZm92OiBNYXRoLlBJIC8gNCxcbiAgICBwb3NpdGlvbkVhc2VBbW91bnQ6IDAuNzUsXG4gICAgdGFyZ2V0RWFzZUFtb3VudDogMC43NSxcbiAgfTtcblxuICBwdWJsaWMgc3RhdGljIGd1aTogZGF0LkdVSTtcbiAgcHVibGljIHN0YXRpYyB2ZXJ0aWNlc0ZvbGRlcjogZGF0LkdVSSB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgc3RhdGljIGVkZ2VzRm9sZGVyOiBkYXQuR1VJIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBzdGF0aWMgc3VyZmFjZXNGb2xkZXI6IGRhdC5HVUkgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIHN0YXRpYyBoaXN0b3J5Rm9sZGVyOiBkYXQuR1VJIHwgbnVsbCA9IG51bGw7XG5cbiAgcHVibGljIG1vZGVsOiBNb2RlbCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGhpc3Rvcnk6IEhpc3RvcnlFbnRyeVtdID0gW107XG4gIHByaXZhdGUgY3VycmVudEhpc3RvcnlJbmRleDogbnVtYmVyID0gLTE7XG5cbiAgcHJpdmF0ZSBwYW5uaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgbGFzdFBhblBvc2l0aW9uOiB2ZWMyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbGFzdE1vdXNlUG9zaXRpb246IHZlYzIgPSB2ZWMyKCk7XG5cbiAgcHJpdmF0ZSBjYW1lcmEzZFlhdzogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBjYW1lcmEzZFBpdGNoOiBudW1iZXIgPSAwO1xuXG4gIHByaXZhdGUgaG92ZXJlZFZlcnRleDogVmVydGV4IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaG92ZXJlZEVkZ2U6IEVkZ2UgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBob3ZlcmVkU3VyZmFjZTogU3VyZmFjZSB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgY2xpY2tlZFZlcnRleDogVmVydGV4IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc2VsZWN0ZWRWZXJ0aWNlczogVmVydGV4W10gPSBbXTtcbiAgcHJpdmF0ZSBzZWxlY3RlZEVkZ2VzOiBFZGdlW10gPSBbXTtcbiAgcHJpdmF0ZSBzZWxlY3RlZFN1cmZhY2VzOiBTdXJmYWNlW10gPSBbXTtcblxuICBwcml2YXRlIGRyYWdnaW5nVmVydGV4OiBWZXJ0ZXggfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBkcmFnU3RhcnRNb3VzZTogdmVjMiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGRyYWdTdGFydFZlcnRleFBvc2l0aW9uczogTWFwPHN0cmluZywgdmVjMz4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB2ZXJ0aWNlc01vdmVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBjcmVhdGluZ0VkZ2U6IEVkZ2UgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjcmVhdGluZ1N1cmZhY2U6IFN1cmZhY2UgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIHByZXZpb3VzVG9vbDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3BhY2ViYXJQYW5BY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIG1vdmVtZW50Q29uc3RyYWludFhBY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBtb3ZlbWVudENvbnN0cmFpbnRZQWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgbW92ZW1lbnRDb25zdHJhaW50WkFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgcGFuZWxDb250YWluZXI6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcGFuZWxSZXNpemVNb2RlOiAndmVydGljYWwnIHwgJ2hvcml6b250YWwnIHwgJ2NlbnRlcicgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwYW5lbFZlcnRpY2FsU2l6ZTogbnVtYmVyID0gMC41O1xuICBwcml2YXRlIHBhbmVsSG9yaXpvbnRhbFNpemU6IG51bWJlciA9IDAuNTtcbiAgcHJpdmF0ZSBwYW5lbFJlc2l6ZUhhbmRsZVZlcnRpY2FsOiBIVE1MRGl2RWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHBhbmVsUmVzaXplSGFuZGxlSG9yaXpvbnRhbDogSFRNTERpdkVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwYW5lbFJlc2l6ZUhhbmRsZUNlbnRlcjogSFRNTERpdkVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIHVuZG9CdXR0b246IEhUTUxCdXR0b25FbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVkb0J1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIGhlbHBNb2RhbDogSFRNTERpYWxvZ0VsZW1lbnQ7XG5cbiAgcHJpdmF0ZSBsYXN0R3VpU3RhdGUgPSB7XG4gICAgdmVydGljZXM6IG5ldyBTZXQ8c3RyaW5nPigpLFxuICAgIGVkZ2VzOiBuZXcgU2V0PHN0cmluZz4oKSxcbiAgICBzdXJmYWNlczogbmV3IFNldDxzdHJpbmc+KCksXG4gICAgaGlzdG9yeUluZGV4OiAtMSxcbiAgfTtcblxuICBwcml2YXRlIHRvb2xzID0ge1xuICAgIC8qKlxuICAgICAqIFNjYWxlIHZlcnRpY2VzIGZyb20gdGhlaXIgY29tbW9uIGNlbnRyb2lkIGJ5IGEgZ2l2ZW4gYW1vdW50XG4gICAgICovXG4gICAgc2NhbGU6ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5tb2RlbCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyBtb2RlbCBsb2FkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdObyB2ZXJ0aWNlcyBzZWxlY3RlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzY2FsZVN0cmluZyA9IHByb21wdCgnQW1vdW50IHRvIHNjYWxlIGJ5OicsICcxJyk7XG4gICAgICBpZiAoc2NhbGVTdHJpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2NhbGUgPSBwYXJzZUZsb2F0KHNjYWxlU3RyaW5nKTtcbiAgICAgIGlmIChzY2FsZSA9PT0gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1NjYWxlIGZhY3RvciAxIGRvZXMgbm90aGluZycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjZW50cm9pZCA9IG1lc2hDZW50cm9pZCh7XG4gICAgICAgIHZlcnRpY2VzOiB0aGlzLnNlbGVjdGVkVmVydGljZXMubWFwKHYgPT4gdi5wb3NpdGlvbiksXG4gICAgICAgIGluZGljZXM6IFtdLFxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IHZlcnRleCBvZiB0aGlzLnNlbGVjdGVkVmVydGljZXMpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB2ZWMzLnN1Yih2ZXJ0ZXgucG9zaXRpb24sIGNlbnRyb2lkKTtcbiAgICAgICAgdmVydGV4LnBvc2l0aW9uID0gdmVjMy5hZGQoY2VudHJvaWQsIHZlYzMubXVsKGRlbHRhLCBzY2FsZSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RlbC5lbWl0Q2hhbmdlRXZlbnQoJ1ZlcnRpY2VzIHNjYWxlZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgdmVydGljZXMgYXJvdW5kIHRoZWlyIGNvbW1vbiBjZW50cm9pZCBieSBhIGdpdmVuIGFtb3VudCBpbiB0aGVcbiAgICAgKiBYIGRpbWVuc2lvblxuICAgICAqL1xuICAgIHJvdGF0ZVg6ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5tb2RlbCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyBtb2RlbCBsb2FkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdObyB2ZXJ0aWNlcyBzZWxlY3RlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0aGV0YVN0cmluZyA9IHByb21wdCgnQW1vdW50IHRvIHJvdGF0ZSBieSAoaW4gZGVncmVlcyk6JywgJzAnKTtcbiAgICAgIGlmICh0aGV0YVN0cmluZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0aGV0YSA9IHBhcnNlRmxvYXQodGhldGFTdHJpbmcpO1xuICAgICAgaWYgKHRoZXRhID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUm90YXRpbmcgYnkgMCBkZWdyZWVzIGRvZXMgbm90aGluZycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjZW50cm9pZCA9IG1lc2hDZW50cm9pZCh7XG4gICAgICAgIHZlcnRpY2VzOiB0aGlzLnNlbGVjdGVkVmVydGljZXMubWFwKHYgPT4gdi5wb3NpdGlvbiksXG4gICAgICAgIGluZGljZXM6IFtdLFxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IHZlcnRleCBvZiB0aGlzLnNlbGVjdGVkVmVydGljZXMpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB2ZWMzLnN1Yih2ZXJ0ZXgucG9zaXRpb24sIGNlbnRyb2lkKTtcbiAgICAgICAgdmVydGV4LnBvc2l0aW9uID0gdmVjMy5hZGQoY2VudHJvaWQsIHZlYzMucm90eChkZWx0YSwgcmFkaWFucyh0aGV0YSkpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kZWwuZW1pdENoYW5nZUV2ZW50KCdWZXJ0aWNlcyByb3RhdGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSB2ZXJ0aWNlcyBhcm91bmQgdGhlaXIgY29tbW9uIGNlbnRyb2lkIGJ5IGEgZ2l2ZW4gYW1vdW50IGluIHRoZVxuICAgICAqIFkgZGltZW5zaW9uXG4gICAgICovXG4gICAgcm90YXRlWTogKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm1vZGVsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIG1vZGVsIGxvYWRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZFZlcnRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ05vIHZlcnRpY2VzIHNlbGVjdGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRoZXRhU3RyaW5nID0gcHJvbXB0KCdBbW91bnQgdG8gcm90YXRlIGJ5IChpbiBkZWdyZWVzKTonLCAnMCcpO1xuICAgICAgaWYgKHRoZXRhU3RyaW5nID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRoZXRhID0gcGFyc2VGbG9hdCh0aGV0YVN0cmluZyk7XG4gICAgICBpZiAodGhldGEgPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdSb3RhdGluZyBieSAwIGRlZ3JlZXMgZG9lcyBub3RoaW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbnRyb2lkID0gbWVzaENlbnRyb2lkKHtcbiAgICAgICAgdmVydGljZXM6IHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5tYXAodiA9PiB2LnBvc2l0aW9uKSxcbiAgICAgICAgaW5kaWNlczogW10sXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgdmVydGV4IG9mIHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcykge1xuICAgICAgICBjb25zdCBkZWx0YSA9IHZlYzMuc3ViKHZlcnRleC5wb3NpdGlvbiwgY2VudHJvaWQpO1xuICAgICAgICB2ZXJ0ZXgucG9zaXRpb24gPSB2ZWMzLmFkZChjZW50cm9pZCwgdmVjMy5yb3R5KGRlbHRhLCByYWRpYW5zKHRoZXRhKSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RlbC5lbWl0Q2hhbmdlRXZlbnQoJ1ZlcnRpY2VzIHJvdGF0ZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlIHZlcnRpY2VzIGFyb3VuZCB0aGVpciBjb21tb24gY2VudHJvaWQgYnkgYSBnaXZlbiBhbW91bnQgaW4gdGhlXG4gICAgICogWiBkaW1lbnNpb25cbiAgICAgKi9cbiAgICByb3RhdGVaOiAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubW9kZWwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTm8gbW9kZWwgbG9hZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkVmVydGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gdmVydGljZXMgc2VsZWN0ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGhldGFTdHJpbmcgPSBwcm9tcHQoJ0Ftb3VudCB0byByb3RhdGUgYnkgKGluIGRlZ3JlZXMpOicsICcwJyk7XG4gICAgICBpZiAodGhldGFTdHJpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGhldGEgPSBwYXJzZUZsb2F0KHRoZXRhU3RyaW5nKTtcbiAgICAgIGlmICh0aGV0YSA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1JvdGF0aW5nIGJ5IDAgZGVncmVlcyBkb2VzIG5vdGhpbmcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2VudHJvaWQgPSBtZXNoQ2VudHJvaWQoe1xuICAgICAgICB2ZXJ0aWNlczogdGhpcy5zZWxlY3RlZFZlcnRpY2VzLm1hcCh2ID0+IHYucG9zaXRpb24pLFxuICAgICAgICBpbmRpY2VzOiBbXSxcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgdGhpcy5zZWxlY3RlZFZlcnRpY2VzKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdmVjMy5zdWIodmVydGV4LnBvc2l0aW9uLCBjZW50cm9pZCk7XG4gICAgICAgIHZlcnRleC5wb3NpdGlvbiA9IHZlYzMuYWRkKGNlbnRyb2lkLCB2ZWMzLnJvdHooZGVsdGEsIHJhZGlhbnModGhldGEpKSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1vZGVsLmVtaXRDaGFuZ2VFdmVudCgnVmVydGljZXMgcm90YXRlZCcpO1xuICAgIH0sXG4gIH07XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIE1vZGVsRWRpdG9yLmluc3RhbmNlID0gdGhpcztcblxuICAgIC8vIEluaXRpYWxpc2UgY2FudmFzZXNcbiAgICB0aGlzLmNhbnZhc1RvcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtdG9wJykgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgdGhpcy5jb250ZXh0VG9wID0gdGhpcy5jYW52YXNUb3AuZ2V0Q29udGV4dChcbiAgICAgICcyZCdcbiAgICApIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICB0aGlzLmNhbnZhc0Zyb250ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAnY2FudmFzLWZyb250J1xuICAgICkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgdGhpcy5jb250ZXh0RnJvbnQgPSB0aGlzLmNhbnZhc0Zyb250LmdldENvbnRleHQoXG4gICAgICAnMmQnXG4gICAgKSBhcyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgdGhpcy5jYW52YXNTaWRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAnY2FudmFzLXNpZGUnXG4gICAgKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICB0aGlzLmNvbnRleHRTaWRlID0gdGhpcy5jYW52YXNTaWRlLmdldENvbnRleHQoXG4gICAgICAnMmQnXG4gICAgKSBhcyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgdGhpcy5jYW52YXMzZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtM2QnKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICB0aGlzLmNvbnRleHQzZCA9IHRoaXMuY2FudmFzM2QuZ2V0Q29udGV4dCgnMmQnKSBhcyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cbiAgICAvLyBIYW5kbGUgd2luZG93IHJlc2l6ZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlc2l6ZVBhbmVscygpO1xuICAgICAgdGhpcy5yZXNpemVDYW52YXNlcygpO1xuICAgIH0pO1xuICAgIHRoaXMucmVzaXplQ2FudmFzZXMoKTtcblxuICAgIC8vIEluaXRpYWxpc2UgdG9vbGJhciBldmVudCBoYW5kbGVyc1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50b29sYmFyIGJ1dHRvbicpLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICAgICAgaWYgKHRhcmdldC5kYXRhc2V0LnNlbGVjdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIHRoaXMuc2V0VG9vbCh0YXJnZXQuZGF0YXNldC50b29sISk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoICh0YXJnZXQuZGF0YXNldC50b29sKSB7XG4gICAgICAgICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgICAgICAgICB0aGlzLmltcG9ydCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICAgICAgICAgIHRoaXMuZXhwb3J0KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndW5kbyc6XG4gICAgICAgICAgICAgIHRoaXMudW5kbygpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlZG8nOlxuICAgICAgICAgICAgICB0aGlzLnJlZG8oKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnVuZG9CdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYnRuLXVuZG8nKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICB0aGlzLnJlZG9CdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYnRuLXJlZG8nKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcblxuICAgIC8vIFJlc2V0IGNhbWVyYSBidXR0b24gZXZlbnQgaGFuZGxlcnNcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucmVzZXQtY2FtZXJhLWJ0bicpLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgcGFuZWwgPSAoZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQnV0dG9uRWxlbWVudCkuZGF0YXNldC5wYW5lbDtcbiAgICAgICAgdGhpcy5yZXNldENhbWVyYShwYW5lbCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIE1vdmVtZW50IGNvbnN0cmFpbnQgYnV0dG9uIGV2ZW50IGhhbmRsZXJzXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1vdmVtZW50LWNvbnN0cmFpbnQtYnRuJykuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZU1vdmVtZW50Q29uc3RyYWludHMoXG4gICAgICAgICAgKGJ1dHRvbiBhcyBIVE1MQnV0dG9uRWxlbWVudCkuZGF0YXNldC5heGlzIGFzICd4JyB8ICd5JyB8ICd6J1xuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBQYW5lbCByZXNpemUgaGFuZGxlIGV2ZW50IGhhbmRsZXJzXG4gICAgdGhpcy5wYW5lbENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYW5lbC1jb250YWluZXInKTtcbiAgICB0aGlzLnBhbmVsUmVzaXplSGFuZGxlVmVydGljYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgJy5yZXNpemUtaGFuZGxlLXZlcnRpY2FsJ1xuICAgICkgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgdGhpcy5wYW5lbFJlc2l6ZUhhbmRsZUhvcml6b250YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgJy5yZXNpemUtaGFuZGxlLWhvcml6b250YWwnXG4gICAgKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICB0aGlzLnBhbmVsUmVzaXplSGFuZGxlQ2VudGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICcucmVzaXplLWhhbmRsZS1jZW50ZXInXG4gICAgKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucmVzaXplLWhhbmRsZScpLmZvckVhY2goaGFuZGxlID0+IHtcbiAgICAgIC8vIFN0YXJ0IHJlc2l6aW5nIHBhbmVscyBvbiBtb3VzZSBkb3duXG4gICAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKChoYW5kbGUgYXMgSFRNTERpdkVsZW1lbnQpLmRhdGFzZXQubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICAgIHRoaXMucGFuZWxSZXNpemVNb2RlID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgIHRoaXMucGFuZWxSZXNpemVIYW5kbGVWZXJ0aWNhbD8uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICAgIHRoaXMucGFuZWxSZXNpemVNb2RlID0gJ2hvcml6b250YWwnO1xuICAgICAgICAgICAgdGhpcy5wYW5lbFJlc2l6ZUhhbmRsZUhvcml6b250YWw/LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHRoaXMucGFuZWxSZXNpemVNb2RlID0gJ2NlbnRlcic7XG4gICAgICAgICAgICB0aGlzLnBhbmVsUmVzaXplSGFuZGxlQ2VudGVyPy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVzZXQgcGFuZWwgc2l6ZXMgb24gZG91YmxlLWNsaWNrXG4gICAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucGFuZWxSZXNpemVNb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYW5lbFJlc2l6ZUhhbmRsZVZlcnRpY2FsPy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy5wYW5lbFJlc2l6ZUhhbmRsZUhvcml6b250YWw/LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLnBhbmVsUmVzaXplSGFuZGxlQ2VudGVyPy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy5wYW5lbFZlcnRpY2FsU2l6ZSA9IDAuNTtcbiAgICAgICAgdGhpcy5wYW5lbEhvcml6b250YWxTaXplID0gMC41O1xuICAgICAgICB0aGlzLnJlc2l6ZVBhbmVscygpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgcGFuZWwgcmVzaXplIHdoZW4gZHJhZ2dpbmcgd2l0aCB0aGUgbW91c2VcbiAgICB0aGlzLnBhbmVsQ29udGFpbmVyPy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgc3dpdGNoICh0aGlzLnBhbmVsUmVzaXplTW9kZSkge1xuICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgdGhpcy5jYWxjdWxhdGVQYW5lbFNpemVzKGUuY2xpZW50WCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICAgIHRoaXMuY2FsY3VsYXRlUGFuZWxTaXplcyhudWxsLCBlLmNsaWVudFkgLSA0MCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgdGhpcy5jYWxjdWxhdGVQYW5lbFNpemVzKGUuY2xpZW50WCwgZS5jbGllbnRZIC0gNDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2l6ZVBhbmVscygpO1xuICAgICAgdGhpcy5yZXNpemVDYW52YXNlcygpO1xuICAgIH0pO1xuXG4gICAgLy8gRmluaXNoIHJlc2l6aW5nIHBhbmVscyBvbiBtb3VzZSB1cFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgICAgdGhpcy5wYW5lbFJlc2l6ZU1vZGUgPSBudWxsO1xuICAgICAgdGhpcy5wYW5lbFJlc2l6ZUhhbmRsZVZlcnRpY2FsPy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIHRoaXMucGFuZWxSZXNpemVIYW5kbGVIb3Jpem9udGFsPy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIHRoaXMucGFuZWxSZXNpemVIYW5kbGVDZW50ZXI/LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGlzZSBzdWJzeXN0ZW1zXG4gICAgRGVidWcuaW5pdGlhbGlzZSgpO1xuICAgIElucHV0TWFuYWdlci5pbml0aWFsaXNlKCk7XG4gICAgdGhpcy5jYW1lcmFUb3AgPSBuZXcgQ2FtZXJhKHZlYzIoKSwgdGhpcy5jYW1lcmFPcHRpb25zKTtcbiAgICB0aGlzLmNhbWVyYUZyb250ID0gbmV3IENhbWVyYSh2ZWMyKCksIHRoaXMuY2FtZXJhT3B0aW9ucyk7XG4gICAgdGhpcy5jYW1lcmFTaWRlID0gbmV3IENhbWVyYSh2ZWMyKCksIHRoaXMuY2FtZXJhT3B0aW9ucyk7XG4gICAgdGhpcy5jYW1lcmEzZCA9IG5ldyBDYW1lcmEzZChcbiAgICAgIE1vZGVsRWRpdG9yLkRFRkFVTFRfQ0FNRVJBM0RfUE9TSVRJT04sXG4gICAgICBNb2RlbEVkaXRvci5ERUZBVUxUX0NBTUVSQTNEX1RBUkdFVCxcbiAgICAgIHRoaXMuY2FtZXJhM2RPcHRpb25zXG4gICAgKTtcbiAgICB0aGlzLmluaXRpYWxpc2VDYW1lcmFZYXdBbmRQaXRjaCgpO1xuXG4gICAgLy8gSW5pdGlhbGlzZSBHVUlcbiAgICBNb2RlbEVkaXRvci5ndWkgPSBuZXcgZGF0LkdVSSh7IHdpZHRoOiA0MDAsIGNsb3NlZDogdHJ1ZSB9KTtcbiAgICBNb2RlbEVkaXRvci5ndWlcbiAgICAgIC5hZGQodGhpcy5vcHRpb25zLCAnbW9kZWxOYW1lJylcbiAgICAgIC5uYW1lKCdNb2RlbCBuYW1lJylcbiAgICAgIC5vbkZpbmlzaENoYW5nZSgobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgICAgdGhpcy5tb2RlbC5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLm1vZGVsLmVtaXRDaGFuZ2VFdmVudCgnTW9kZWwgbmFtZSBjaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAubGlzdGVuKCk7XG4gICAgTW9kZWxFZGl0b3IuZ3VpXG4gICAgICAuYWRkKHRoaXMub3B0aW9ucywgJ3Nob3dWZXJ0ZXhMYWJlbHMnKVxuICAgICAgLm5hbWUoJ1Nob3cgdmVydGV4IGxhYmVscycpO1xuICAgIE1vZGVsRWRpdG9yLmd1aS5hZGQodGhpcy5vcHRpb25zLCAnc2hvd0F4ZXMnKS5uYW1lKCdTaG93IDNkIGF4ZXMnKTtcblxuICAgIGNvbnN0IHRvb2xzRm9sZGVyID0gTW9kZWxFZGl0b3IuZ3VpLmFkZEZvbGRlcignVG9vbHMnKTtcbiAgICB0b29sc0ZvbGRlci5hZGQodGhpcy50b29scywgJ3NjYWxlJykubmFtZSgnU2NhbGUnKTtcbiAgICB0b29sc0ZvbGRlci5hZGQodGhpcy50b29scywgJ3JvdGF0ZVgnKS5uYW1lKCdSb3RhdGUgWCcpO1xuICAgIHRvb2xzRm9sZGVyLmFkZCh0aGlzLnRvb2xzLCAncm90YXRlWScpLm5hbWUoJ1JvdGF0ZSBZJyk7XG4gICAgdG9vbHNGb2xkZXIuYWRkKHRoaXMudG9vbHMsICdyb3RhdGVaJykubmFtZSgnUm90YXRlIFonKTtcblxuICAgIGNvbnN0IGdyaWRGb2xkZXIgPSBNb2RlbEVkaXRvci5ndWkuYWRkRm9sZGVyKCcyRCBHcmlkcycpO1xuICAgIGdyaWRGb2xkZXIuYWRkKHRoaXMub3B0aW9ucywgJ3Nob3dHcmlkJykubmFtZSgnU2hvdyAyZCBncmlkcycpO1xuICAgIGdyaWRGb2xkZXIuYWRkKHRoaXMub3B0aW9ucywgJ2dyaWRTaXplJywgMSwgMTAwLCAxKS5uYW1lKCdHcmlkIHNpemUnKTtcbiAgICBncmlkRm9sZGVyLmFkZCh0aGlzLm9wdGlvbnMsICdzaG93R3JpZExhYmVscycpLm5hbWUoJ1Nob3cgZ3JpZCBsYWJlbHMnKTtcbiAgICBncmlkRm9sZGVyXG4gICAgICAuYWRkKHRoaXMub3B0aW9ucywgJ2dyaWRMYWJlbHNHYXAnLCAxLCAxMCwgMSlcbiAgICAgIC5uYW1lKCdHcmlkIGxhYmVscyBnYXAnKTtcblxuICAgIGNvbnN0IGdyb3VuZFBsYW5lRm9sZGVyID0gTW9kZWxFZGl0b3IuZ3VpLmFkZEZvbGRlcignM0QgR3JvdW5kIFBsYW5lJyk7XG4gICAgZ3JvdW5kUGxhbmVGb2xkZXJcbiAgICAgIC5hZGQodGhpcy5vcHRpb25zLCAnc2hvd0dyb3VuZFBsYW5lJylcbiAgICAgIC5uYW1lKCdTaG93IDNkIGdyb3VuZCBwbGFuZScpO1xuICAgIGdyb3VuZFBsYW5lRm9sZGVyXG4gICAgICAuYWRkKHRoaXMub3B0aW9ucywgJ2dyb3VuZFBsYW5lU2l6ZScsIDIsIDEwMCwgMilcbiAgICAgIC5uYW1lKCdHcm91bmQgcGxhbmUgc2l6ZScpO1xuICAgIGdyb3VuZFBsYW5lRm9sZGVyXG4gICAgICAuYWRkKHRoaXMub3B0aW9ucywgJ3Nob3dHcm91bmRQbGFuZUxhYmVscycpXG4gICAgICAubmFtZSgnU2hvdyBncm91bmQgcGxhbmUgbGFiZWxzJyk7XG4gICAgZ3JvdW5kUGxhbmVGb2xkZXJcbiAgICAgIC5hZGQodGhpcy5vcHRpb25zLCAnZ3JvdW5kUGxhbmVMYWJlbHNHYXAnLCAxLCAxMCwgMSlcbiAgICAgIC5uYW1lKCdHcm91bmQgcGxhbmUgbGFiZWxzIGdhcCcpO1xuXG4gICAgY29uc3QgY2FtZXJhRm9sZGVyID0gTW9kZWxFZGl0b3IuZ3VpLmFkZEZvbGRlcignQ2FtZXJhJyk7XG4gICAgY2FtZXJhRm9sZGVyXG4gICAgICAuYWRkKHRoaXMuY2FtZXJhM2QsICdmb3YnLCBNYXRoLlBJIC8gOCwgTWF0aC5QSSAvIDIsIDAuMDEpXG4gICAgICAubmFtZSgnM0QgY2FtZXJhIEZPVicpO1xuICAgIGNhbWVyYUZvbGRlclxuICAgICAgLmFkZCh0aGlzLm9wdGlvbnMsICd6b29tU3BlZWQnLCAwLjEsIDEwLCAwLjAxKVxuICAgICAgLm5hbWUoJ1pvb20gc3BlZWQnKTtcbiAgICBjYW1lcmFGb2xkZXJcbiAgICAgIC5hZGQodGhpcy5vcHRpb25zLCAnbW92ZVNwZWVkJywgMC4xLCAxMCwgMC4wMSlcbiAgICAgIC5uYW1lKCdNb3ZlIHNwZWVkJyk7XG4gICAgY2FtZXJhRm9sZGVyXG4gICAgICAuYWRkKHRoaXMub3B0aW9ucywgJ3JvdGF0ZVNwZWVkJywgMC4wMDAxLCAwLjAxKVxuICAgICAgLm5hbWUoJ1JvdGF0ZSBzcGVlZCcpO1xuXG4gICAgTW9kZWxFZGl0b3IudmVydGljZXNGb2xkZXIgPSBNb2RlbEVkaXRvci5ndWkuYWRkRm9sZGVyKCdWZXJ0aWNlcycpO1xuICAgIE1vZGVsRWRpdG9yLmVkZ2VzRm9sZGVyID0gTW9kZWxFZGl0b3IuZ3VpLmFkZEZvbGRlcignRWRnZXMnKTtcbiAgICBNb2RlbEVkaXRvci5zdXJmYWNlc0ZvbGRlciA9IE1vZGVsRWRpdG9yLmd1aS5hZGRGb2xkZXIoJ1N1cmZhY2VzJyk7XG4gICAgTW9kZWxFZGl0b3IuaGlzdG9yeUZvbGRlciA9IE1vZGVsRWRpdG9yLmd1aS5hZGRGb2xkZXIoJ0hpc3RvcnknKTtcblxuICAgIC8vIEluaXRpYWxpc2UgdGhlIG1vZGVsIGFuZCBVSVxuICAgIHRoaXMucmVzZXQoKTtcblxuICAgIC8vIEluaXRpYWxpc2UgaGVscCBtb2RhbFxuICAgIHRoaXMuaGVscE1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hlbHAtbW9kYWwnKSBhcyBIVE1MRGlhbG9nRWxlbWVudDtcbiAgICBjb25zdCBoZWxwQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bi1oZWxwJyk7XG4gICAgY29uc3QgY2xvc2VCdXR0b24gPSB0aGlzLmhlbHBNb2RhbC5xdWVyeVNlbGVjdG9yKCcuY2xvc2UtYnRuJyk7XG5cbiAgICBoZWxwQnV0dG9uPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuaGVscE1vZGFsLnNob3dNb2RhbCgpO1xuICAgIH0pO1xuXG4gICAgY2xvc2VCdXR0b24/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5oZWxwTW9kYWwuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuaGVscE1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IHRoaXMuaGVscE1vZGFsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgaXNJbkRpYWxvZyA9XG4gICAgICAgIHJlY3QudG9wIDw9IGV2ZW50LmNsaWVudFkgJiZcbiAgICAgICAgZXZlbnQuY2xpZW50WSA8PSByZWN0LmJvdHRvbSAmJlxuICAgICAgICByZWN0LmxlZnQgPD0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICBldmVudC5jbGllbnRYIDw9IHJlY3QucmlnaHQ7XG4gICAgICBpZiAoIWlzSW5EaWFsb2cpIHtcbiAgICAgICAgdGhpcy5oZWxwTW9kYWwuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFN0YXJ0IHJlbmRlciBsb29wXG4gICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gdGhpcy5sYXN0RnJhbWVDb3VudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLmxvb3AoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzaXplQ2FudmFzZXMoKSB7XG4gICAgdGhpcy5jYW52YXNUb3Aud2lkdGggPSB0aGlzLmNhbnZhc1RvcC5jbGllbnRXaWR0aDtcbiAgICB0aGlzLmNhbnZhc1RvcC5oZWlnaHQgPSB0aGlzLmNhbnZhc1RvcC5jbGllbnRIZWlnaHQ7XG4gICAgdGhpcy5jYW52YXNGcm9udC53aWR0aCA9IHRoaXMuY2FudmFzRnJvbnQuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5jYW52YXNGcm9udC5oZWlnaHQgPSB0aGlzLmNhbnZhc0Zyb250LmNsaWVudEhlaWdodDtcbiAgICB0aGlzLmNhbnZhc1NpZGUud2lkdGggPSB0aGlzLmNhbnZhc1NpZGUuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5jYW52YXNTaWRlLmhlaWdodCA9IHRoaXMuY2FudmFzU2lkZS5jbGllbnRIZWlnaHQ7XG4gICAgdGhpcy5jYW52YXMzZC53aWR0aCA9IHRoaXMuY2FudmFzM2QuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5jYW52YXMzZC5oZWlnaHQgPSB0aGlzLmNhbnZhczNkLmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlUGFuZWxTaXplcyh4OiBudW1iZXIgfCBudWxsLCB5OiBudW1iZXIgfCBudWxsKSB7XG4gICAgaWYgKCF0aGlzLnBhbmVsQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjbGFtcGVkWCA9IGNsYW1wKFxuICAgICAgICB4IC0gMixcbiAgICAgICAgdGhpcy5wYW5lbENvbnRhaW5lci5jbGllbnRXaWR0aCAqIE1vZGVsRWRpdG9yLlBBTkVMX01JTl9TSVpFLFxuICAgICAgICB0aGlzLnBhbmVsQ29udGFpbmVyLmNsaWVudFdpZHRoICogKDEgLSBNb2RlbEVkaXRvci5QQU5FTF9NSU5fU0laRSlcbiAgICAgICk7XG4gICAgICB0aGlzLnBhbmVsSG9yaXpvbnRhbFNpemUgPSByb3VuZChcbiAgICAgICAgY2xhbXBlZFggLyB0aGlzLnBhbmVsQ29udGFpbmVyLmNsaWVudFdpZHRoLFxuICAgICAgICAyXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY2xhbXBlZFkgPSBjbGFtcChcbiAgICAgICAgeSAtIDIsXG4gICAgICAgIHRoaXMucGFuZWxDb250YWluZXIuY2xpZW50SGVpZ2h0ICogTW9kZWxFZGl0b3IuUEFORUxfTUlOX1NJWkUsXG4gICAgICAgIHRoaXMucGFuZWxDb250YWluZXIuY2xpZW50SGVpZ2h0ICogKDEgLSBNb2RlbEVkaXRvci5QQU5FTF9NSU5fU0laRSlcbiAgICAgICk7XG4gICAgICB0aGlzLnBhbmVsVmVydGljYWxTaXplID0gcm91bmQoXG4gICAgICAgIGNsYW1wZWRZIC8gdGhpcy5wYW5lbENvbnRhaW5lci5jbGllbnRIZWlnaHQsXG4gICAgICAgIDJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZXNpemVQYW5lbHMoKSB7XG4gICAgaWYgKCF0aGlzLnBhbmVsQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2V0IHBhbmVsIGNvbnRhaW5lciBncmlkIHRlbXBsYXRlIHN0eWxlcyB0byByZXNpemUgcGFuZWxzXG4gICAgdGhpcy5wYW5lbENvbnRhaW5lci5zdHlsZS5ncmlkVGVtcGxhdGVDb2x1bW5zID0gYCR7XG4gICAgICB0aGlzLnBhbmVsSG9yaXpvbnRhbFNpemVcbiAgICB9ZnIgJHsxIC0gdGhpcy5wYW5lbEhvcml6b250YWxTaXplfWZyYDtcbiAgICB0aGlzLnBhbmVsQ29udGFpbmVyLnN0eWxlLmdyaWRUZW1wbGF0ZVJvd3MgPSBgJHt0aGlzLnBhbmVsVmVydGljYWxTaXplfWZyICR7XG4gICAgICAxIC0gdGhpcy5wYW5lbFZlcnRpY2FsU2l6ZVxuICAgIH1mcmA7XG5cbiAgICAvLyBSZS1wb3NpdGlvbiB0aGUgcGFuZWwgcmVzaXplIGhhbmRsZXNcbiAgICBjb25zdCByZXNpemVIYW5kbGVYID1cbiAgICAgIHRoaXMucGFuZWxIb3Jpem9udGFsU2l6ZSAqIHRoaXMucGFuZWxDb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgY29uc3QgcmVzaXplSGFuZGxlWSA9XG4gICAgICB0aGlzLnBhbmVsVmVydGljYWxTaXplICogdGhpcy5wYW5lbENvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKHRoaXMucGFuZWxSZXNpemVIYW5kbGVWZXJ0aWNhbCkge1xuICAgICAgdGhpcy5wYW5lbFJlc2l6ZUhhbmRsZVZlcnRpY2FsLnN0eWxlLmxlZnQgPSBgJHtyZXNpemVIYW5kbGVYIC0gMn1weGA7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhbmVsUmVzaXplSGFuZGxlSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy5wYW5lbFJlc2l6ZUhhbmRsZUhvcml6b250YWwuc3R5bGUudG9wID0gYCR7cmVzaXplSGFuZGxlWSAtIDJ9cHhgO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYW5lbFJlc2l6ZUhhbmRsZUNlbnRlcikge1xuICAgICAgdGhpcy5wYW5lbFJlc2l6ZUhhbmRsZUNlbnRlci5zdHlsZS5sZWZ0ID0gYCR7cmVzaXplSGFuZGxlWCAtIDZ9cHhgO1xuICAgICAgdGhpcy5wYW5lbFJlc2l6ZUhhbmRsZUNlbnRlci5zdHlsZS50b3AgPSBgJHtyZXNpemVIYW5kbGVZIC0gNn1weGA7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZXNldCgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLm1vZGVsICYmXG4gICAgICAhY29uZmlybSgnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHJlc2V0PyBUaGlzIHdpbGwgY2xlYXIgdW5kbyBoaXN0b3J5LicpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2FtZXJhcyB0byBkZWZhdWx0IHBvc2l0aW9ucyBhbmQgc2NhbGVzXG4gICAgdGhpcy5yZXNldENhbWVyYSgndG9wJyk7XG4gICAgdGhpcy5yZXNldENhbWVyYSgnZnJvbnQnKTtcbiAgICB0aGlzLnJlc2V0Q2FtZXJhKCdzaWRlJyk7XG4gICAgdGhpcy5yZXNldENhbWVyYSgnM2QnKTtcblxuICAgIC8vIENsZWFyIHRoZSBjdXJyZW50IG1vZGVsIGFuZCBjcmVhdGUgYSBuZXcgb25lXG4gICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgIHRoaXMubW9kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5tb2RlbENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLm1vZGVsLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1vZGVsID0gbmV3IE1vZGVsKCk7XG4gICAgdGhpcy5vcHRpb25zLm1vZGVsTmFtZSA9ICcnO1xuICAgIHRoaXMubW9kZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5tb2RlbENoYW5nZWQuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBSZXNldCB0b29sLCBob3ZlciwgYW5kIHNlbGVjdGlvbiBzdGF0ZXNcbiAgICB0aGlzLnRvb2wgPSAnc2VsZWN0JztcbiAgICB0aGlzLmhvdmVyZWRWZXJ0ZXggPSBudWxsO1xuICAgIGlmICh0aGlzLnNlbGVjdGVkVmVydGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZWxlY3RlZFZlcnRpY2VzLmZvckVhY2godiA9PiAodi5zZWxlY3RlZCA9IGZhbHNlKSk7XG4gICAgICB0aGlzLnNlbGVjdGVkVmVydGljZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkRWRnZXMuZm9yRWFjaChlID0+IChlLnNlbGVjdGVkID0gZmFsc2UpKTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRFZGdlcyA9IFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZWxlY3RlZFN1cmZhY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRTdXJmYWNlcy5mb3JFYWNoKHMgPT4gKHMuc2VsZWN0ZWQgPSBmYWxzZSkpO1xuICAgICAgdGhpcy5zZWxlY3RlZFN1cmZhY2VzID0gW107XG4gICAgfVxuICAgIHRoaXMuZHJhZ2dpbmdWZXJ0ZXggPSBudWxsO1xuICAgIHRoaXMuZHJhZ1N0YXJ0TW91c2UgPSBudWxsO1xuICAgIHRoaXMuZHJhZ1N0YXJ0VmVydGV4UG9zaXRpb25zID0gbnVsbDtcbiAgICB0aGlzLnBhbm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RQYW5Qb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5sYXN0TW91c2VQb3NpdGlvbiA9IHZlYzIoKTtcblxuICAgIC8vIFJlc2V0IGVkZ2VzIGFuZCBzdXJmYWNlcyBiZWluZyBjcmVhdGVkXG4gICAgaWYgKHRoaXMuY3JlYXRpbmdFZGdlKSB7XG4gICAgICB0aGlzLmNyZWF0aW5nRWRnZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmNyZWF0aW5nRWRnZSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmNyZWF0aW5nU3VyZmFjZSkge1xuICAgICAgdGhpcy5jcmVhdGluZ1N1cmZhY2UuZGVzdHJveSgpO1xuICAgICAgdGhpcy5jcmVhdGluZ1N1cmZhY2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGhpc3RvcnlcbiAgICBpZiAoTW9kZWxFZGl0b3IuaGlzdG9yeUZvbGRlcikge1xuICAgICAgTW9kZWxFZGl0b3IuaGlzdG9yeUZvbGRlci5fX2NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PlxuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmhpc3RvcnkgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRIaXN0b3J5SW5kZXggPSAtMTtcbiAgICB0aGlzLnVwZGF0ZVVuZG9SZWRvQnV0dG9ucygpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRUb29sKHRvb2w6IHN0cmluZykge1xuICAgIHRoaXMudG9vbCA9IHRvb2w7XG4gICAgY29uc3QgdG9vbGJhckJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudG9vbGJhciBidXR0b24nKTtcbiAgICB0b29sYmFyQnV0dG9ucy5mb3JFYWNoKChidXR0b246IEhUTUxCdXR0b25FbGVtZW50KSA9PiB7XG4gICAgICBpZiAoYnV0dG9uLmRhdGFzZXQudG9vbCA9PT0gdG9vbCkge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHBhbmVsIGNvbnRhaW5lciBjbGFzcyBiYXNlZCBvbiBzZWxlY3RlZCB0b29sXG4gICAgaWYgKHRoaXMucGFuZWxDb250YWluZXIpIHtcbiAgICAgIHRoaXMucGFuZWxDb250YWluZXIuY2xhc3NMaXN0LmZvckVhY2goYyA9PiB7XG4gICAgICAgIGlmIChjLnN0YXJ0c1dpdGgoJ3Rvb2wtJykpIHtcbiAgICAgICAgICB0aGlzLnBhbmVsQ29udGFpbmVyIS5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGFuZWxDb250YWluZXIuY2xhc3NMaXN0LmFkZChgdG9vbC0ke3RoaXMudG9vbH1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGltcG9ydCgpIHtcbiAgICAvLyBDcmVhdGUgYSBmaWxlIGlucHV0IGVsZW1lbnRcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgaW5wdXQudHlwZSA9ICdmaWxlJztcbiAgICBpbnB1dC5hY2NlcHQgPSAnLmpzb24nO1xuXG4gICAgLy8gSGFuZGxlIGZpbGUgc2VsZWN0aW9uXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IGlucHV0LmZpbGVzPy5bMF07XG4gICAgICBpZiAoIWZpbGUpIHJldHVybjtcblxuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBlID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShlLnRhcmdldD8ucmVzdWx0IGFzIHN0cmluZyk7XG5cbiAgICAgICAgICAvLyBDbGVhciB0aGUgZXhpc3RpbmcgbW9kZWwgaWYgb25lIGV4aXN0c1xuICAgICAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICdjaGFuZ2UnLFxuICAgICAgICAgICAgICB0aGlzLm1vZGVsQ2hhbmdlZC5iaW5kKHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tb2RlbCA9IE1vZGVsLmRlc2VyaWFsaXplKGRhdGEpO1xuXG4gICAgICAgICAgLy8gSWYgYSBtb2RlbCBzdWNjZXNzZnVsbHkgaW1wb3J0ZWQsIHNldCB1cCB0aGUgbW9kZWxcbiAgICAgICAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm1vZGVsQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tb2RlbE5hbWUgPSB0aGlzLm1vZGVsLm5hbWUgfHwgJyc7XG4gICAgICAgICAgICB0aGlzLmNsZWFySGlzdG9yeUVudHJpZXMoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkSGlzdG9yeUVudHJ5KCdNb2RlbCBpbXBvcnRlZCcsIHRoaXMubW9kZWwuc2VyaWFsaXplKCkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ01vZGVsIGltcG9ydGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW1wb3J0aW5nIG1vZGVsOicsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICB9KTtcblxuICAgIC8vIFRyaWdnZXIgZmlsZSBzZWxlY3Rpb24gZGlhbG9nXG4gICAgaW5wdXQuY2xpY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgZXhwb3J0KCkge1xuICAgIGlmICghdGhpcy5tb2RlbCkge1xuICAgICAgY29uc29sZS5lcnJvcignTm8gbW9kZWwgdG8gZXhwb3J0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIG1vZGVsIG5hbWUgaXMgdXAgdG8gZGF0ZSBiZWZvcmUgZXhwb3J0XG4gICAgdGhpcy5tb2RlbC5uYW1lID0gdGhpcy5vcHRpb25zLm1vZGVsTmFtZTtcblxuICAgIC8vIFNlcmlhbGl6ZSB0aGUgbW9kZWwgYW5kIGNyZWF0ZSBhIEJsb2JcbiAgICBjb25zdCBkYXRhID0gSlNPTi5zdHJpbmdpZnkodGhpcy5tb2RlbC5zZXJpYWxpemUoKSwgbnVsbCwgMik7XG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSk7XG5cbiAgICAvLyBDcmVhdGUgYSBkb3dubG9hZCBVUkwgYW5kIGxpbmtcbiAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGluay5ocmVmID0gdXJsO1xuICAgIGxpbmsuZG93bmxvYWQgPSBgJHt0aGlzLm1vZGVsLm5hbWUgfHwgJ21vZGVsJ30uanNvbmA7XG5cbiAgICAvLyBUcmlnZ2VyIGRvd25sb2FkIGFuZCBjbGVhbnVwXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICBsaW5rLmNsaWNrKCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gIH1cblxuICBwcml2YXRlIHVuZG8oKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudEhpc3RvcnlJbmRleCA8PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIG1vcmUgaGlzdG9yeSB0byB1bmRvJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSnVtcCB0byB0aGUgcHJldmlvdXMgaGlzdG9yeSBlbnRyeVxuICAgIHRoaXMuY3VycmVudEhpc3RvcnlJbmRleC0tO1xuICAgIHRoaXMuanVtcFRvSGlzdG9yeUVudHJ5KHRoaXMuY3VycmVudEhpc3RvcnlJbmRleCk7XG4gICAgdGhpcy51cGRhdGVVbmRvUmVkb0J1dHRvbnMoKTtcbiAgICBjb25zb2xlLmxvZygnVW5kbyBsYXN0IGFjdGlvbjonLCB0aGlzLmhpc3RvcnlbdGhpcy5jdXJyZW50SGlzdG9yeUluZGV4XSk7XG4gIH1cblxuICBwcml2YXRlIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudEhpc3RvcnlJbmRleCA+PSB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSkge1xuICAgICAgY29uc29sZS53YXJuKCdObyBtb3JlIGhpc3RvcnkgdG8gcmVkbycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEp1bXAgdG8gdGhlIG5leHQgaGlzdG9yeSBlbnRyeVxuICAgIHRoaXMuY3VycmVudEhpc3RvcnlJbmRleCsrO1xuICAgIHRoaXMuanVtcFRvSGlzdG9yeUVudHJ5KHRoaXMuY3VycmVudEhpc3RvcnlJbmRleCk7XG4gICAgdGhpcy51cGRhdGVVbmRvUmVkb0J1dHRvbnMoKTtcbiAgICBjb25zb2xlLmxvZygnUmVkbyBsYXN0IGFjdGlvbjonLCB0aGlzLmhpc3RvcnlbdGhpcy5jdXJyZW50SGlzdG9yeUluZGV4XSk7XG4gIH1cblxuICBwcml2YXRlIG1vZGVsQ2hhbmdlZChlOiBDdXN0b21FdmVudCkge1xuICAgIGNvbnN0IHsgYWN0aW9uLCBtb2RlbCB9ID0gZS5kZXRhaWw7XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgdGhpcy5hZGRIaXN0b3J5RW50cnkoYWN0aW9uLCBtb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBqdW1wVG9IaXN0b3J5RW50cnkoaW5kZXg6IG51bWJlcikge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5oaXN0b3J5Lmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGhpc3RvcnkgaW5kZXg6JywgaW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGN1cnJlbnQgbW9kZWwgYW5kIGxvYWQgdGhlIG1vZGVsIGZyb20gdGhlIGhpc3RvcnkgZW50cnlcbiAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgdGhpcy5tb2RlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm1vZGVsQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMubW9kZWwuZGVzdHJveSgpO1xuICAgICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5oaXN0b3J5W2luZGV4XTtcbiAgICB0aGlzLm1vZGVsID0gTW9kZWwuZGVzZXJpYWxpemUoZW50cnkubW9kZWwpO1xuICAgIHRoaXMub3B0aW9ucy5tb2RlbE5hbWUgPSB0aGlzLm1vZGVsLm5hbWUgfHwgJyc7XG4gICAgdGhpcy5tb2RlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm1vZGVsQ2hhbmdlZC5iaW5kKHRoaXMpKTtcblxuICAgIC8vIFVwZGF0ZSBjdXJyZW50IGhpc3RvcnkgaW5kZXhcbiAgICB0aGlzLmN1cnJlbnRIaXN0b3J5SW5kZXggPSBpbmRleDtcblxuICAgIC8vIFVwZGF0ZSBidXR0b24gc3RhdGVzXG4gICAgdGhpcy51cGRhdGVVbmRvUmVkb0J1dHRvbnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkSGlzdG9yeUVudHJ5KGFjdGlvbjogc3RyaW5nLCBtb2RlbDogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGxldCBpbmRleDogbnVtYmVyID0gLTE7XG5cbiAgICAvLyBJZiB3ZSdyZSBub3QgYXQgdGhlIGVuZCBvZiB0aGUgaGlzdG9yeSwgY2xlYXIgZnV0dXJlIGVudHJpZXNcbiAgICBpZiAodGhpcy5jdXJyZW50SGlzdG9yeUluZGV4IDwgdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY2xlYXJIaXN0b3J5RW50cmllcyh0aGlzLmN1cnJlbnRIaXN0b3J5SW5kZXggKyAxKTtcbiAgICB9XG4gICAgaW5kZXggPSB0aGlzLmhpc3RvcnkubGVuZ3RoO1xuXG4gICAgLy8gQ3JlYXRlIEdVSSBidXR0b25cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIGxldCBjb250cm9sbGVyOiBkYXQuR1VJQ29udHJvbGxlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoTW9kZWxFZGl0b3IuaGlzdG9yeUZvbGRlcikge1xuICAgICAgY29udHJvbGxlciA9IE1vZGVsRWRpdG9yLmhpc3RvcnlGb2xkZXJcbiAgICAgICAgLmFkZCh7IGp1bXA6ICgpID0+IHRoaXMuanVtcFRvSGlzdG9yeUVudHJ5KGluZGV4KSB9LCAnanVtcCcpXG4gICAgICAgIC5uYW1lKGAke2RhdGV9IC0gJHthY3Rpb259YCk7XG4gICAgfVxuICAgIGNvbnN0IGVudHJ5OiBIaXN0b3J5RW50cnkgPSB7XG4gICAgICBhY3Rpb24sXG4gICAgICBtb2RlbCxcbiAgICAgIGRhdGUsXG4gICAgICBjb250cm9sbGVyLFxuICAgIH07XG4gICAgdGhpcy5oaXN0b3J5LnB1c2goZW50cnkpO1xuICAgIHRoaXMuY3VycmVudEhpc3RvcnlJbmRleCA9IGluZGV4O1xuICAgIHRoaXMudXBkYXRlVW5kb1JlZG9CdXR0b25zKCk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFySGlzdG9yeUVudHJpZXMoZnJvbT86IG51bWJlcikge1xuICAgIGZyb20gPSBmcm9tID8/IDA7XG4gICAgaWYgKGZyb20gPCAwIHx8IGZyb20gPj0gdGhpcy5oaXN0b3J5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgaGlzdG9yeSBlbnRyaWVzIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleFxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdGhpcy5oaXN0b3J5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMuaGlzdG9yeVtpXTtcbiAgICAgIGlmIChlbnRyeS5jb250cm9sbGVyICYmIE1vZGVsRWRpdG9yLmhpc3RvcnlGb2xkZXIpIHtcbiAgICAgICAgTW9kZWxFZGl0b3IuaGlzdG9yeUZvbGRlci5yZW1vdmUoZW50cnkuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaGlzdG9yeS5zcGxpY2UoZnJvbSwgdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIGZyb20pO1xuICAgIHRoaXMudXBkYXRlVW5kb1JlZG9CdXR0b25zKCk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVVuZG9SZWRvQnV0dG9ucygpIHtcbiAgICBpZiAodGhpcy51bmRvQnV0dG9uKSB7XG4gICAgICB0aGlzLnVuZG9CdXR0b24uZGlzYWJsZWQgPSB0aGlzLmN1cnJlbnRIaXN0b3J5SW5kZXggPD0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVkb0J1dHRvbikge1xuICAgICAgdGhpcy5yZWRvQnV0dG9uLmRpc2FibGVkID1cbiAgICAgICAgdGhpcy5jdXJyZW50SGlzdG9yeUluZGV4ID49IHRoaXMuaGlzdG9yeS5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRDYW1lcmEocGFuZWw6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHN3aXRjaCAocGFuZWwpIHtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHRoaXMuY2FtZXJhVG9wLnBvc2l0aW9uID0gdmVjMigwLCAwKTtcbiAgICAgICAgdGhpcy5jYW1lcmFUb3Auc2NhbGUgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Zyb250JzpcbiAgICAgICAgdGhpcy5jYW1lcmFGcm9udC5wb3NpdGlvbiA9IHZlYzIoMCwgMCk7XG4gICAgICAgIHRoaXMuY2FtZXJhRnJvbnQuc2NhbGUgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NpZGUnOlxuICAgICAgICB0aGlzLmNhbWVyYVNpZGUucG9zaXRpb24gPSB2ZWMyKDAsIDApO1xuICAgICAgICB0aGlzLmNhbWVyYVNpZGUuc2NhbGUgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzNkJzpcbiAgICAgICAgdGhpcy5jYW1lcmEzZC5wb3NpdGlvbiA9IE1vZGVsRWRpdG9yLkRFRkFVTFRfQ0FNRVJBM0RfUE9TSVRJT047XG4gICAgICAgIHRoaXMuY2FtZXJhM2QudGFyZ2V0ID0gTW9kZWxFZGl0b3IuREVGQVVMVF9DQU1FUkEzRF9UQVJHRVQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbGlzZUNhbWVyYVlhd0FuZFBpdGNoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlTW92ZW1lbnRDb25zdHJhaW50cyhheGlzOiAneCcgfCAneScgfCAneicgfCBudWxsKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1vdmVtZW50LWNvbnN0cmFpbnQtYnRuJykuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgKGJ1dHRvbiBhcyBIVE1MQnV0dG9uRWxlbWVudCkuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgY29uc3QgbW92ZW1lbnRDb25zdHJhaW50QnV0dG9uWCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAnLm1vdmVtZW50LWNvbnN0cmFpbnQtYnRuLXgnXG4gICAgKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICBjb25zdCBtb3ZlbWVudENvbnN0cmFpbnRCdXR0b25ZID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICcubW92ZW1lbnQtY29uc3RyYWludC1idG4teSdcbiAgICApIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgIGNvbnN0IG1vdmVtZW50Q29uc3RyYWludEJ1dHRvblogPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgJy5tb3ZlbWVudC1jb25zdHJhaW50LWJ0bi16J1xuICAgICkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG5cbiAgICBzd2l0Y2ggKGF4aXMpIHtcbiAgICAgIGNhc2UgJ3gnOlxuICAgICAgICB0aGlzLm1vdmVtZW50Q29uc3RyYWludFhBY3RpdmUgPSAhdGhpcy5tb3ZlbWVudENvbnN0cmFpbnRYQWN0aXZlO1xuICAgICAgICB0aGlzLm1vdmVtZW50Q29uc3RyYWludFlBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3ZlbWVudENvbnN0cmFpbnRaQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIG1vdmVtZW50Q29uc3RyYWludEJ1dHRvblguY2xhc3NMaXN0LnRvZ2dsZShcbiAgICAgICAgICAnYWN0aXZlJyxcbiAgICAgICAgICB0aGlzLm1vdmVtZW50Q29uc3RyYWludFhBY3RpdmVcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd5JzpcbiAgICAgICAgdGhpcy5tb3ZlbWVudENvbnN0cmFpbnRYQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW92ZW1lbnRDb25zdHJhaW50WUFjdGl2ZSA9ICF0aGlzLm1vdmVtZW50Q29uc3RyYWludFlBY3RpdmU7XG4gICAgICAgIHRoaXMubW92ZW1lbnRDb25zdHJhaW50WkFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBtb3ZlbWVudENvbnN0cmFpbnRCdXR0b25ZLmNsYXNzTGlzdC50b2dnbGUoXG4gICAgICAgICAgJ2FjdGl2ZScsXG4gICAgICAgICAgdGhpcy5tb3ZlbWVudENvbnN0cmFpbnRZQWN0aXZlXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAneic6XG4gICAgICAgIHRoaXMubW92ZW1lbnRDb25zdHJhaW50WEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdmVtZW50Q29uc3RyYWludFlBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3ZlbWVudENvbnN0cmFpbnRaQWN0aXZlID0gIXRoaXMubW92ZW1lbnRDb25zdHJhaW50WkFjdGl2ZTtcbiAgICAgICAgbW92ZW1lbnRDb25zdHJhaW50QnV0dG9uWi5jbGFzc0xpc3QudG9nZ2xlKFxuICAgICAgICAgICdhY3RpdmUnLFxuICAgICAgICAgIHRoaXMubW92ZW1lbnRDb25zdHJhaW50WkFjdGl2ZVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMubW92ZW1lbnRDb25zdHJhaW50WEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdmVtZW50Q29uc3RyYWludFlBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3ZlbWVudENvbnN0cmFpbnRaQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGlzZUNhbWVyYVlhd0FuZFBpdGNoKCkge1xuICAgIGNvbnN0IGZvcndhcmQgPSB2ZWMzLm5vcihcbiAgICAgIHZlYzMuc3ViKHRoaXMuY2FtZXJhM2QudGFyZ2V0LCB0aGlzLmNhbWVyYTNkLnBvc2l0aW9uKVxuICAgICk7XG5cbiAgICBjb25zdCBwb2xhciA9IHZlYzMucG9sYXIoZm9yd2FyZCk7XG4gICAgdGhpcy5jYW1lcmEzZFlhdyA9IHBvbGFyLnBoaTtcbiAgICB0aGlzLmNhbWVyYTNkUGl0Y2ggPSBNYXRoLlBJIC8gMiAtIHBvbGFyLnRoZXRhO1xuICB9XG5cbiAgcHJpdmF0ZSBsb29wKCkge1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gbm93IC0gdGhpcy5sYXN0RnJhbWVUaW1lO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGZyYW1lcmF0ZVxuICAgIGlmIChub3cgLSB0aGlzLmxhc3RGcmFtZUNvdW50VGltZSA+PSAxMDAwKSB7XG4gICAgICB0aGlzLmxhc3RGcmFtZUNvdW50VGltZSA9IG5vdztcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gdGhpcy5mcmFtZUNvdW50O1xuICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICB9XG4gICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gbm93O1xuICAgIERlYnVnLnZhbHVlKCdGUFMnLCB0aGlzLmZyYW1lUmF0ZSwgeyBhbGlnbjogJ3JpZ2h0JywgdGFnczogWydwYW5lbC0zZCddIH0pO1xuXG4gICAgLy8gRG8gZ2FtZSBsb29wXG4gICAgdGhpcy51cGRhdGUoZWxhcHNlZFRpbWUpO1xuICAgIHRoaXMuZHJhdygpO1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5sb29wLmJpbmQodGhpcykpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIGNvbnN0IGhvdmVyZWRFbGVtZW50ID0gSW5wdXRNYW5hZ2VyLmhvdmVyZWRFbGVtZW50Py5pZCA/PyAnJztcblxuICAgIC8vIEF1dG8tcGFuIHRvb2w6IHdoZW4gaG9sZGluZyB0aGUgc3BhY2ViYXIsIHN3aXRjaCB0byBwYW4gdG9vbFxuICAgIGlmIChJbnB1dE1hbmFnZXIua2V5UHJlc3NlZCgnU3BhY2UnKSAmJiB0aGlzLnRvb2wgIT09ICdwYW4nKSB7XG4gICAgICB0aGlzLnByZXZpb3VzVG9vbCA9IHRoaXMudG9vbDtcbiAgICAgIHRoaXMuc2V0VG9vbCgncGFuJyk7XG4gICAgICB0aGlzLnNwYWNlYmFyUGFuQWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKElucHV0TWFuYWdlci5rZXlSZWxlYXNlZCgnU3BhY2UnKSAmJiB0aGlzLnNwYWNlYmFyUGFuQWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5wcmV2aW91c1Rvb2wgJiYgdGhpcy50b29sID09PSAncGFuJykge1xuICAgICAgICB0aGlzLnNldFRvb2wodGhpcy5wcmV2aW91c1Rvb2wpO1xuICAgICAgfVxuICAgICAgdGhpcy5zcGFjZWJhclBhbkFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5wcmV2aW91c1Rvb2wgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIE1vdmVtZW50IGNvbnN0cmFpbnQga2V5c1xuICAgIGlmIChJbnB1dE1hbmFnZXIua2V5UHJlc3NlZCgnS2V5WCcpKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1vdmVtZW50Q29uc3RyYWludHMoJ3gnKTtcbiAgICB9XG4gICAgaWYgKElucHV0TWFuYWdlci5rZXlQcmVzc2VkKCdLZXlZJykpIHtcbiAgICAgIHRoaXMudXBkYXRlTW92ZW1lbnRDb25zdHJhaW50cygneScpO1xuICAgIH1cbiAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleVByZXNzZWQoJ0tleVonKSkge1xuICAgICAgdGhpcy51cGRhdGVNb3ZlbWVudENvbnN0cmFpbnRzKCd6Jyk7XG4gICAgfVxuICAgIGlmIChJbnB1dE1hbmFnZXIua2V5UmVsZWFzZWQoJ0tleVgnKSkge1xuICAgICAgdGhpcy51cGRhdGVNb3ZlbWVudENvbnN0cmFpbnRzKG51bGwpO1xuICAgIH1cbiAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleVJlbGVhc2VkKCdLZXlZJykpIHtcbiAgICAgIHRoaXMudXBkYXRlTW92ZW1lbnRDb25zdHJhaW50cyhudWxsKTtcbiAgICB9XG4gICAgaWYgKElucHV0TWFuYWdlci5rZXlSZWxlYXNlZCgnS2V5WicpKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1vdmVtZW50Q29uc3RyYWludHMobnVsbCk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgYWxsIGhvdmVyZWQgc3RhdGVzXG4gICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgIHRoaXMubW9kZWwudmVydGljZXMuZm9yRWFjaCh2ID0+ICh2LmhvdmVyZWQgPSBmYWxzZSkpO1xuICAgICAgdGhpcy5tb2RlbC5lZGdlcy5mb3JFYWNoKGUgPT4gKGUuaG92ZXJlZCA9IGZhbHNlKSk7XG4gICAgICB0aGlzLm1vZGVsLnN1cmZhY2VzLmZvckVhY2gocyA9PiAocy5ob3ZlcmVkID0gZmFsc2UpKTtcbiAgICB9XG4gICAgdGhpcy5ob3ZlcmVkVmVydGV4ID0gbnVsbDtcbiAgICB0aGlzLmhvdmVyZWRFZGdlID0gbnVsbDtcbiAgICB0aGlzLmhvdmVyZWRTdXJmYWNlID0gbnVsbDtcblxuICAgIC8vIEhvdmVyIGxvZ2ljIDJkOiBmaW5kIHRvcG1vc3Qgb2JqZWN0IHVuZGVyIG1vdXNlIGluIGFjdGl2ZSAyZCBwYW5lbFxuICAgIGlmIChcbiAgICAgIHRoaXMubW9kZWwgJiZcbiAgICAgIFsnc2VsZWN0JywgJ2NyZWF0ZS1lZGdlJywgJ2NyZWF0ZS1zdXJmYWNlJ10uaW5jbHVkZXModGhpcy50b29sKSAmJlxuICAgICAgWydjYW52YXMtdG9wJywgJ2NhbnZhcy1mcm9udCcsICdjYW52YXMtc2lkZSddLmluY2x1ZGVzKGhvdmVyZWRFbGVtZW50KVxuICAgICkge1xuICAgICAgLy8gQ29udmVydCBtb3VzZSB0byB3b3JsZCBzcGFjZSBmb3IgdGhlIHBhbmVsXG4gICAgICBjb25zdCB7IGNhbWVyYSwgY29tcG9uZW50cyB9ID0gdGhpcy5nZXRQYW5lbDJkSW5mbyhob3ZlcmVkRWxlbWVudCkgPz8ge307XG4gICAgICBjb25zdCBtb3VzZVdvcmxkID0gY2FtZXJhIS5zY3JlZW5Ub1dvcmxkKElucHV0TWFuYWdlci5tb3VzZVBvc2l0aW9uKTtcblxuICAgICAgLy8gRmluZCBhbGwgdmVydGljZXMgdW5kZXIgbW91c2VcbiAgICAgIGNvbnN0IGhvdmVyZWRWZXJ0aWNlcyA9IHRoaXMubW9kZWwudmVydGljZXMuZmlsdGVyKHYgPT5cbiAgICAgICAgdi5pc1BvaW50TmVhcjJkKG1vdXNlV29ybGQsIGNvbXBvbmVudHMhKVxuICAgICAgKTtcbiAgICAgIGlmIChob3ZlcmVkVmVydGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2Ugb25seSBob3ZlciB0aGUgdG9wbW9zdCB2ZXJ0ZXhcbiAgICAgICAgc3dpdGNoIChob3ZlcmVkRWxlbWVudCkge1xuICAgICAgICAgIGNhc2UgJ2NhbnZhcy10b3AnOlxuICAgICAgICAgICAgaG92ZXJlZFZlcnRpY2VzLnNvcnQoKGEsIGIpID0+IGEucG9zaXRpb24ueSAtIGIucG9zaXRpb24ueSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjYW52YXMtZnJvbnQnOlxuICAgICAgICAgICAgaG92ZXJlZFZlcnRpY2VzLnNvcnQoKGEsIGIpID0+IGEucG9zaXRpb24ueiAtIGIucG9zaXRpb24ueik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjYW52YXMtc2lkZSc6XG4gICAgICAgICAgICBob3ZlcmVkVmVydGljZXMuc29ydCgoYSwgYikgPT4gYS5wb3NpdGlvbi54IC0gYi5wb3NpdGlvbi54KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRleCA9IGhvdmVyZWRWZXJ0aWNlc1tob3ZlcmVkVmVydGljZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRleC5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gdmVydGV4IGlzIGhvdmVyZWQsIGZpbmQgYWxsIGVkZ2VzIHVuZGVyIG1vdXNlXG4gICAgICAvLyAoZWRnZXMgY2FuIG9ubHkgYmUgaG92ZXJlZCBpbiBcInNlbGVjdFwiIG1vZGUpXG4gICAgICBpZiAodGhpcy50b29sID09PSAnc2VsZWN0JyAmJiAhdGhpcy5ob3ZlcmVkVmVydGV4KSB7XG4gICAgICAgIGNvbnN0IGhvdmVyZWRFZGdlcyA9IHRoaXMubW9kZWwuZWRnZXNcbiAgICAgICAgICAuZmlsdGVyKGUgPT4gZS5pc1BvaW50TmVhcjJkKG1vdXNlV29ybGQsIGNvbXBvbmVudHMhKSlcbiAgICAgICAgICAubWFwKGUgPT4gKHtcbiAgICAgICAgICAgIGVkZ2U6IGUsXG5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBza2lwIGRpdmlkaW5nIGJ5IDIgaGVyZSBzaW5jZSB3ZSdyZSBvbmx5IGludGVyZXN0ZWQgaW5cbiAgICAgICAgICAgIC8vIHRoZSByZWxhdGl2ZSB2YWx1ZXMgZm9yIHNvcnRpbmdcbiAgICAgICAgICAgIGF2ZzogdmVjMyhcbiAgICAgICAgICAgICAgZS5hLnBvc2l0aW9uLnggKyBlLmIucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgZS5hLnBvc2l0aW9uLnkgKyBlLmIucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgZS5hLnBvc2l0aW9uLnogKyBlLmIucG9zaXRpb24uelxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9KSk7XG4gICAgICAgIGlmIChob3ZlcmVkRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGhvdmVyIHRoZSB0b3Btb3N0IGVkZ2VcbiAgICAgICAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIHRoZSBhdmVyYWdlIG9mIHRoZSBzdGFydCBhbmQgZW5kIHZlcnRleCBwb3NpdGlvbnNcbiAgICAgICAgICBzd2l0Y2ggKGhvdmVyZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBjYXNlICdjYW52YXMtdG9wJzpcbiAgICAgICAgICAgICAgaG92ZXJlZEVkZ2VzLnNvcnQoKGEsIGIpID0+IGEuYXZnLnkgLSBiLmF2Zy55KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjYW52YXMtZnJvbnQnOlxuICAgICAgICAgICAgICBob3ZlcmVkRWRnZXMuc29ydCgoYSwgYikgPT4gYS5hdmcueiAtIGIuYXZnLnopO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NhbnZhcy1zaWRlJzpcbiAgICAgICAgICAgICAgaG92ZXJlZEVkZ2VzLnNvcnQoKGEsIGIpID0+IGEuYXZnLnggLSBiLmF2Zy54KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaG92ZXJlZEVkZ2UgPSBob3ZlcmVkRWRnZXNbaG92ZXJlZEVkZ2VzLmxlbmd0aCAtIDFdLmVkZ2U7XG4gICAgICAgICAgdGhpcy5ob3ZlcmVkRWRnZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyB2ZXJ0ZXggb3IgZWRnZSBpcyBob3ZlcmVkLCBmaW5kIGFsbCBzdXJmYWNlcyB1bmRlciBtb3VzZVxuICAgICAgLy8gKHN1cmZhY2VzIGNhbiBvbmx5IGJlIGhvdmVyZWQgaW4gXCJzZWxlY3RcIiBtb2RlKVxuICAgICAgaWYgKHRoaXMudG9vbCA9PT0gJ3NlbGVjdCcgJiYgIXRoaXMuaG92ZXJlZFZlcnRleCAmJiAhdGhpcy5ob3ZlcmVkRWRnZSkge1xuICAgICAgICBjb25zdCBob3ZlcmVkU3VyZmFjZXMgPSB0aGlzLm1vZGVsLnN1cmZhY2VzXG4gICAgICAgICAgLmZpbHRlcihzID0+IHMuaXNQb2ludE5lYXIyZChtb3VzZVdvcmxkLCBjb21wb25lbnRzISkpXG4gICAgICAgICAgLm1hcChzID0+ICh7XG4gICAgICAgICAgICBzdXJmYWNlOiBzLFxuXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBza2lwIGRpdmlkaW5nIGJ5IHRoZSBudW1iZXIgb2YgdmVydGljZXMgaGVyZSBzaW5jZSBlYWNoXG4gICAgICAgICAgICAvLyBzdXJmYWNlIG1pZ2h0IGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIHZlcnRpY2VzXG4gICAgICAgICAgICBhdmc6IHZlYzMoXG4gICAgICAgICAgICAgIHMudmVydGljZXMucmVkdWNlKChzdW0sIHYpID0+IHN1bSArIHYucG9zaXRpb24ueCwgMCkgL1xuICAgICAgICAgICAgICAgIHMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgICBzLnZlcnRpY2VzLnJlZHVjZSgoc3VtLCB2KSA9PiBzdW0gKyB2LnBvc2l0aW9uLnksIDApIC9cbiAgICAgICAgICAgICAgICBzLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgICAgICAgcy52ZXJ0aWNlcy5yZWR1Y2UoKHN1bSwgdikgPT4gc3VtICsgdi5wb3NpdGlvbi56LCAwKSAvXG4gICAgICAgICAgICAgICAgcy52ZXJ0aWNlcy5sZW5ndGhcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfSkpO1xuICAgICAgICBpZiAoaG92ZXJlZFN1cmZhY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgd2Ugb25seSBob3ZlciB0aGUgdG9wbW9zdCBzdXJmYWNlXG4gICAgICAgICAgLy8gVGhpcyBpcyBiYXNlZCBvbiB0aGUgYXZlcmFnZSBvZiB0aGUgc3VyZmFjZSB2ZXJ0aWNlcyBwb3NpdGlvbnNcbiAgICAgICAgICBzd2l0Y2ggKGhvdmVyZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBjYXNlICdjYW52YXMtdG9wJzpcbiAgICAgICAgICAgICAgaG92ZXJlZFN1cmZhY2VzLnNvcnQoKGEsIGIpID0+IGEuYXZnLnkgLSBiLmF2Zy55KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjYW52YXMtZnJvbnQnOlxuICAgICAgICAgICAgICBob3ZlcmVkU3VyZmFjZXMuc29ydCgoYSwgYikgPT4gYS5hdmcueiAtIGIuYXZnLnopO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NhbnZhcy1zaWRlJzpcbiAgICAgICAgICAgICAgaG92ZXJlZFN1cmZhY2VzLnNvcnQoKGEsIGIpID0+IGEuYXZnLnggLSBiLmF2Zy54KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaG92ZXJlZFN1cmZhY2UgPVxuICAgICAgICAgICAgaG92ZXJlZFN1cmZhY2VzW2hvdmVyZWRTdXJmYWNlcy5sZW5ndGggLSAxXS5zdXJmYWNlO1xuICAgICAgICAgIHRoaXMuaG92ZXJlZFN1cmZhY2UuaG92ZXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIb3ZlciBsb2dpYyAzZDogZmluZCBjbG9zZXN0IG9iamVjdCB1bmRlciBtb3VzZSBpbiAzZCBjYW52YXNcbiAgICBpZiAoXG4gICAgICB0aGlzLm1vZGVsICYmXG4gICAgICBbJ3NlbGVjdCcsICdjcmVhdGUtZWRnZScsICdjcmVhdGUtc3VyZmFjZSddLmluY2x1ZGVzKHRoaXMudG9vbCkgJiZcbiAgICAgIGhvdmVyZWRFbGVtZW50ID09PSAnY2FudmFzLTNkJ1xuICAgICkge1xuICAgICAgLy8gRmluZCBhbGwgdmVydGljZXMgdW5kZXIgbW91c2VcbiAgICAgIGxldCBjbG9zZXN0VmVydGV4OiBWZXJ0ZXggfCBudWxsID0gbnVsbDtcbiAgICAgIGNvbnN0IGludGVyc2VjdGluZ1ZlcnRpY2VzID0gdGhpcy5tb2RlbC52ZXJ0aWNlcy5maWx0ZXIodiA9PlxuICAgICAgICB2LmlzUG9pbnROZWFyM2QoXG4gICAgICAgICAgSW5wdXRNYW5hZ2VyLm1vdXNlUG9zaXRpb24sXG4gICAgICAgICAgdGhpcy5jYW1lcmEzZCxcbiAgICAgICAgICB2ZWMyKHRoaXMuY2FudmFzM2Qud2lkdGgsIHRoaXMuY2FudmFzM2QuaGVpZ2h0KVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICAvLyBHZXQgdGhlIGNsb3Nlc3QgdmVydGV4IHRvIHRoZSBjYW1lcmFcbiAgICAgIGlmIChpbnRlcnNlY3RpbmdWZXJ0aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNsb3Nlc3RWZXJ0ZXggPSBpbnRlcnNlY3RpbmdWZXJ0aWNlc1xuICAgICAgICAgIC5tYXAodiA9PiAoe1xuICAgICAgICAgICAgdmVydGV4OiB2LFxuICAgICAgICAgICAgZGlzdGFuY2U6IHZlYzMubGVuKHZlYzMuc3ViKHYucG9zaXRpb24sIHRoaXMuY2FtZXJhM2QucG9zaXRpb24pKSxcbiAgICAgICAgICB9KSlcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2UpWzBdLnZlcnRleDtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZm91bmQgYSBjbG9zZXN0IHZlcnRleCwgc2V0IGl0IGFzIGhvdmVyZWRcbiAgICAgIGlmIChjbG9zZXN0VmVydGV4KSB7XG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRleCA9IGNsb3Nlc3RWZXJ0ZXg7XG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRleC5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gdmVydGV4IGlzIGhvdmVyZWQsIGZpbmQgYWxsIGVkZ2VzIHVuZGVyIG1vdXNlXG4gICAgICAvLyAoZWRnZXMgY2FuIG9ubHkgYmUgaG92ZXJlZCBpbiBcInNlbGVjdFwiIG1vZGUpXG4gICAgICBpZiAodGhpcy50b29sID09PSAnc2VsZWN0JyAmJiAhdGhpcy5ob3ZlcmVkVmVydGV4KSB7XG4gICAgICAgIGxldCBjbG9zZXN0RWRnZTogRWRnZSB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBpbnRlcnNlY3RpbmdFZGdlcyA9IHRoaXMubW9kZWwuZWRnZXMuZmlsdGVyKGUgPT5cbiAgICAgICAgICBlLmlzUG9pbnROZWFyM2QoXG4gICAgICAgICAgICBJbnB1dE1hbmFnZXIubW91c2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhM2QsXG4gICAgICAgICAgICB2ZWMyKHRoaXMuY2FudmFzM2Qud2lkdGgsIHRoaXMuY2FudmFzM2QuaGVpZ2h0KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBHZXQgdGhlIGNsb3Nlc3QgZWRnZSB0byB0aGUgY2FtZXJhXG4gICAgICAgIC8vIFRoaXMgaXMgYmFzZWQgb24gdGhlIGF2ZXJhZ2Ugb2YgdGhlIHN0YXJ0IGFuZCBlbmQgdmVydGV4IHBvc2l0aW9uc1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW5nRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNsb3Nlc3RFZGdlID0gaW50ZXJzZWN0aW5nRWRnZXNcbiAgICAgICAgICAgIC5tYXAoZSA9PiAoe1xuICAgICAgICAgICAgICBlZGdlOiBlLFxuICAgICAgICAgICAgICBkaXN0YW5jZTogdmVjMy5sZW4oXG4gICAgICAgICAgICAgICAgdmVjMy5zdWIoXG4gICAgICAgICAgICAgICAgICB2ZWMzLmRpdih2ZWMzLmFkZChlLmEucG9zaXRpb24sIGUuYi5wb3NpdGlvbiksIDIpLFxuICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEzZC5wb3NpdGlvblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlKVswXS5lZGdlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBjbG9zZXN0IGVkZ2UsIHNldCBpdCBhcyBob3ZlcmVkXG4gICAgICAgIGlmIChjbG9zZXN0RWRnZSkge1xuICAgICAgICAgIHRoaXMuaG92ZXJlZEVkZ2UgPSBjbG9zZXN0RWRnZTtcbiAgICAgICAgICB0aGlzLmhvdmVyZWRFZGdlLmhvdmVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIHZlcnRleCBvciBlZGdlIGlzIGhvdmVyZWQsIGZpbmQgYWxsIHN1cmZhY2VzIHVuZGVyIG1vdXNlXG4gICAgICAvLyAoc3VyZmFjZXMgY2FuIG9ubHkgYmUgaG92ZXJlZCBpbiBcInNlbGVjdFwiIG1vZGUpXG4gICAgICBpZiAodGhpcy50b29sID09PSAnc2VsZWN0JyAmJiAhdGhpcy5ob3ZlcmVkVmVydGV4ICYmICF0aGlzLmhvdmVyZWRFZGdlKSB7XG4gICAgICAgIGxldCBjbG9zZXN0U3VyZmFjZTogU3VyZmFjZSB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBpbnRlcnNlY3RpbmdTdXJmYWNlcyA9IHRoaXMubW9kZWwuc3VyZmFjZXMuZmlsdGVyKHMgPT5cbiAgICAgICAgICBzLmlzUG9pbnROZWFyM2QoXG4gICAgICAgICAgICBJbnB1dE1hbmFnZXIubW91c2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhM2QsXG4gICAgICAgICAgICB2ZWMyKHRoaXMuY2FudmFzM2Qud2lkdGgsIHRoaXMuY2FudmFzM2QuaGVpZ2h0KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBHZXQgdGhlIGNsb3Nlc3Qgc3VyZmFjZSB0byB0aGUgY2FtZXJhXG4gICAgICAgIGlmIChpbnRlcnNlY3RpbmdTdXJmYWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2xvc2VzdFN1cmZhY2UgPSBpbnRlcnNlY3RpbmdTdXJmYWNlc1xuICAgICAgICAgICAgLm1hcChzID0+ICh7XG4gICAgICAgICAgICAgIHN1cmZhY2U6IHMsXG4gICAgICAgICAgICAgIGRpc3RhbmNlOiB2ZWMzLmxlbihcbiAgICAgICAgICAgICAgICB2ZWMzLnN1YihcbiAgICAgICAgICAgICAgICAgIHZlYzMuZGl2KFxuICAgICAgICAgICAgICAgICAgICBzLnZlcnRpY2VzLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgICAoc3VtLCB2KSA9PiB2ZWMzLmFkZChzdW0sIHYucG9zaXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgIHZlYzMoKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBzLnZlcnRpY2VzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhM2QucG9zaXRpb25cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZSlbMF0uc3VyZmFjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGEgY2xvc2VzdCBzdXJmYWNlLCBzZXQgaXQgYXMgaG92ZXJlZFxuICAgICAgICBpZiAoY2xvc2VzdFN1cmZhY2UpIHtcbiAgICAgICAgICB0aGlzLmhvdmVyZWRTdXJmYWNlID0gY2xvc2VzdFN1cmZhY2U7XG4gICAgICAgICAgdGhpcy5ob3ZlcmVkU3VyZmFjZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNrIHRoZSBtb3N0IHJlY2VudGx5IGNsaWNrZWQgYW5kIHNlbGVjdGVkIHZlcnRleFxuICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHRvIGhhbmRsZSBhbiBlZGdlIGNhc2Ugd2hlbiB0b2dnbGluZyBzZWxlY3Rpb24gc3RhdGVcbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIGRlc2VsZWN0IGEgdmVydGV4IG9uIG1vdXNlIHJlbGVhc2UgaWYgaXQgd2FzIG9ubHkganVzdFxuICAgIC8vIHNlbGVjdGVkIG9uIHRoZSBjb3JyZXNwb25kaW5nIG1vdXNlIHByZXNzXG4gICAgaWYgKFxuICAgICAgdGhpcy5ob3ZlcmVkVmVydGV4ICYmXG4gICAgICB0aGlzLmhvdmVyZWRWZXJ0ZXguc2VsZWN0ZWQgJiZcbiAgICAgIElucHV0TWFuYWdlci5tb3VzZVByZXNzZWQoTW91c2VCdXR0b24uTGVmdClcbiAgICApIHtcbiAgICAgIHRoaXMuY2xpY2tlZFZlcnRleCA9IHRoaXMuaG92ZXJlZFZlcnRleDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhvdmVyZWRWZXJ0ZXgpIHtcbiAgICAgIHRoaXMuY2xpY2tlZFZlcnRleCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VsZWN0aW9uIGxvZ2ljIDJkIGFuZCAzZDogb24gbW91c2UgcHJlc3MsIHNlbGVjdCBob3ZlcmVkIG9iamVjdFxuICAgIGlmICh0aGlzLnRvb2wgPT09ICdzZWxlY3QnICYmIElucHV0TWFuYWdlci5tb3VzZVByZXNzZWQoTW91c2VCdXR0b24uTGVmdCkpIHtcbiAgICAgIC8vIEEgdmVydGV4IGlzIGhvdmVyZWRcbiAgICAgIGlmICh0aGlzLmhvdmVyZWRWZXJ0ZXgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIElucHV0TWFuYWdlci5rZXlEb3duKCdDb250cm9sTGVmdCcpIHx8XG4gICAgICAgICAgSW5wdXRNYW5hZ2VyLmtleURvd24oJ0NvbnRyb2xSaWdodCcpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIE11bHRpLXNlbGVjdDogYWRkIHRoZSBob3ZlcmVkIHZlcnRleCB0byB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgdGhpcy5zZWxlY3RWZXJ0ZXgodGhpcy5ob3ZlcmVkVmVydGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW5nbGUtc2VsZWN0OiBkZXNlbGVjdCBvdGhlciB2ZXJ0aWNlcyBiZWZvcmUgc2VsZWN0aW5nIHRoaXMgb25lXG4gICAgICAgICAgdGhpcy5kZXNlbGVjdFZlcnRleCgpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0VmVydGV4KHRoaXMuaG92ZXJlZFZlcnRleCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgZHJhZ2dpbmcgc3RhcnRcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5kcmFnZ2luZ1ZlcnRleCA9IHRoaXMuaG92ZXJlZFZlcnRleDtcbiAgICAgICAgICB0aGlzLmRyYWdTdGFydE1vdXNlID0gdmVjMi5jcHkoSW5wdXRNYW5hZ2VyLm1vdXNlUG9zaXRpb24pO1xuICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0VmVydGV4UG9zaXRpb25zID0gbmV3IE1hcChcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5tYXAodiA9PiBbdi5pZCwgdmVjMy5jcHkodi5wb3NpdGlvbildKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQW4gZWRnZSBpcyBob3ZlcmVkXG4gICAgICBpZiAodGhpcy5ob3ZlcmVkRWRnZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgSW5wdXRNYW5hZ2VyLmtleURvd24oJ0NvbnRyb2xMZWZ0JykgfHxcbiAgICAgICAgICBJbnB1dE1hbmFnZXIua2V5RG93bignQ29udHJvbFJpZ2h0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gTXVsdGktc2VsZWN0OiBhZGQgdGhlIGhvdmVyZWQgZWRnZSB0byB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgdGhpcy5zZWxlY3RFZGdlKHRoaXMuaG92ZXJlZEVkZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmdsZS1zZWxlY3Q6IGRlc2VsZWN0IGFsbCBvdGhlciBlZGdlcyBiZWZvcmUgc2VsZWN0aW5nIHRoaXMgb25lXG4gICAgICAgICAgdGhpcy5kZXNlbGVjdEVkZ2UoKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdEVkZ2UodGhpcy5ob3ZlcmVkRWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQSBzdXJmYWNlIGlzIGhvdmVyZWRcbiAgICAgIGlmICh0aGlzLmhvdmVyZWRTdXJmYWNlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBJbnB1dE1hbmFnZXIua2V5RG93bignQ29udHJvbExlZnQnKSB8fFxuICAgICAgICAgIElucHV0TWFuYWdlci5rZXlEb3duKCdDb250cm9sUmlnaHQnKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBNdWx0aS1zZWxlY3Q6IGFkZCB0aGUgaG92ZXJlZCBzdXJmYWNlIHRvIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICB0aGlzLnNlbGVjdFN1cmZhY2UodGhpcy5ob3ZlcmVkU3VyZmFjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luZ2xlLXNlbGVjdDogZGVzZWxlY3QgYWxsIG90aGVyIHN1cmZhY2VzIGJlZm9yZSBzZWxlY3RpbmcgdGhpcyBvbmVcbiAgICAgICAgICB0aGlzLmRlc2VsZWN0U3VyZmFjZSgpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0U3VyZmFjZSh0aGlzLmhvdmVyZWRTdXJmYWNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERyYWcgbG9naWMgMmQ6IG1vdmUgc2VsZWN0ZWQgdmVydGljZXMgd2hpbGUgZHJhZ2dpbmdcbiAgICBpZiAoXG4gICAgICB0aGlzLnRvb2wgPT09ICdzZWxlY3QnICYmXG4gICAgICB0aGlzLmRyYWdnaW5nVmVydGV4ICYmXG4gICAgICB0aGlzLnNlbGVjdGVkVmVydGljZXMubGVuZ3RoID4gMCAmJlxuICAgICAgWydjYW52YXMtdG9wJywgJ2NhbnZhcy1mcm9udCcsICdjYW52YXMtc2lkZSddLmluY2x1ZGVzKGhvdmVyZWRFbGVtZW50KSAmJlxuICAgICAgSW5wdXRNYW5hZ2VyLm1vdXNlRG93bihNb3VzZUJ1dHRvbi5MZWZ0KVxuICAgICkge1xuICAgICAgY29uc3QgbW91c2VOb3cgPSB2ZWMyLmNweShJbnB1dE1hbmFnZXIubW91c2VQb3NpdGlvbik7XG4gICAgICBjb25zdCB7IGNhbWVyYSB9ID0gdGhpcy5nZXRQYW5lbDJkSW5mbyhob3ZlcmVkRWxlbWVudCkgPz8ge307XG4gICAgICBjb25zdCB3b3JsZFN0YXJ0ID0gY2FtZXJhIS5zY3JlZW5Ub1dvcmxkKHRoaXMuZHJhZ1N0YXJ0TW91c2UhKTtcbiAgICAgIGNvbnN0IHdvcmxkTm93ID0gY2FtZXJhIS5zY3JlZW5Ub1dvcmxkKG1vdXNlTm93KTtcbiAgICAgIGNvbnN0IGRlbHRhTW91c2UgPSB2ZWMyLnN1Yih3b3JsZE5vdywgd29ybGRTdGFydCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB1bnNuYXBwZWQgZGVsdGEgcG9zaXRpb24gYmFzZWQgb24gcGFuZWxcbiAgICAgIGNvbnN0IGRlbHRhVmVydGV4UG9zaXRpb24gPSB2ZWMzKCk7XG4gICAgICBzd2l0Y2ggKGhvdmVyZWRFbGVtZW50KSB7XG4gICAgICAgIGNhc2UgJ2NhbnZhcy10b3AnOlxuICAgICAgICAgIGRlbHRhVmVydGV4UG9zaXRpb24ueCA9IGRlbHRhTW91c2UueDtcbiAgICAgICAgICBkZWx0YVZlcnRleFBvc2l0aW9uLnogPSBkZWx0YU1vdXNlLnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NhbnZhcy1mcm9udCc6XG4gICAgICAgICAgZGVsdGFWZXJ0ZXhQb3NpdGlvbi54ID0gZGVsdGFNb3VzZS54O1xuICAgICAgICAgIGRlbHRhVmVydGV4UG9zaXRpb24ueSA9IC1kZWx0YU1vdXNlLnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NhbnZhcy1zaWRlJzpcbiAgICAgICAgICBkZWx0YVZlcnRleFBvc2l0aW9uLnogPSAtZGVsdGFNb3VzZS54O1xuICAgICAgICAgIGRlbHRhVmVydGV4UG9zaXRpb24ueSA9IC1kZWx0YU1vdXNlLnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBkcmFnZ2luZyB2ZXJ0ZXgncyBpbml0aWFsIHBvc2l0aW9uXG4gICAgICBjb25zdCBkcmFnZ2luZ0luaXRpYWxQb3NpdGlvbiA9IHRoaXMuZHJhZ1N0YXJ0VmVydGV4UG9zaXRpb25zIS5nZXQoXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdWZXJ0ZXguaWRcbiAgICAgICkhO1xuICAgICAgY29uc3QgZHJhZ2dpbmdOZXdQb3NpdGlvbiA9IHZlYzMuYWRkKFxuICAgICAgICBkcmFnZ2luZ0luaXRpYWxQb3NpdGlvbixcbiAgICAgICAgZGVsdGFWZXJ0ZXhQb3NpdGlvblxuICAgICAgKTtcblxuICAgICAgLy8gSWYgc2hpZnQgaXMgaGVsZCwgc25hcCB0aGUgZHJhZ2dpbmcgdmVydGV4J3MgcG9zaXRpb24gdG8gZ3JpZFxuICAgICAgaWYgKFxuICAgICAgICBJbnB1dE1hbmFnZXIua2V5RG93bignU2hpZnRMZWZ0JykgfHxcbiAgICAgICAgSW5wdXRNYW5hZ2VyLmtleURvd24oJ1NoaWZ0UmlnaHQnKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZFNpemU7XG4gICAgICAgIGRyYWdnaW5nTmV3UG9zaXRpb24ueCA9IE1hdGgucm91bmQoZHJhZ2dpbmdOZXdQb3NpdGlvbi54IC8gZ3JpZCkgKiBncmlkO1xuICAgICAgICBkcmFnZ2luZ05ld1Bvc2l0aW9uLnkgPSBNYXRoLnJvdW5kKGRyYWdnaW5nTmV3UG9zaXRpb24ueSAvIGdyaWQpICogZ3JpZDtcbiAgICAgICAgZHJhZ2dpbmdOZXdQb3NpdGlvbi56ID0gTWF0aC5yb3VuZChkcmFnZ2luZ05ld1Bvc2l0aW9uLnogLyBncmlkKSAqIGdyaWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBmaW5hbCBkZWx0YSBiYXNlZCBvbiBkcmFnZ2luZyB2ZXJ0ZXgncyBuZXcgcG9zaXRpb25cbiAgICAgIGNvbnN0IGZpbmFsRGVsdGEgPSB2ZWMzLnN1YihkcmFnZ2luZ05ld1Bvc2l0aW9uLCBkcmFnZ2luZ0luaXRpYWxQb3NpdGlvbik7XG5cbiAgICAgIC8vIFVwZGF0ZSBhbGwgc2VsZWN0ZWQgdmVydGV4IHBvc2l0aW9ucyB1c2luZyB0aGUgZmluYWwgZGVsdGFcbiAgICAgIHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBjb25zdCBpbml0aWFsUG9zaXRpb24gPSB0aGlzLmRyYWdTdGFydFZlcnRleFBvc2l0aW9ucyEuZ2V0KHYuaWQpO1xuICAgICAgICBpZiAoaW5pdGlhbFBvc2l0aW9uKSB7XG4gICAgICAgICAgdi5wb3NpdGlvbiA9IHZlYzMuYWRkKGluaXRpYWxQb3NpdGlvbiwgZmluYWxEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCF2ZWN0b3JBbG1vc3RaZXJvKGZpbmFsRGVsdGEpKSB7XG4gICAgICAgIHRoaXMudmVydGljZXNNb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHJhZyBsb2dpYyAzZDogbW92ZSBzZWxlY3RlZCB2ZXJ0aWNlcyB3aGlsZSBkcmFnZ2luZ1xuICAgIGlmIChcbiAgICAgIHRoaXMudG9vbCA9PT0gJ3NlbGVjdCcgJiZcbiAgICAgIHRoaXMuZHJhZ2dpbmdWZXJ0ZXggJiZcbiAgICAgIHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5sZW5ndGggPiAwICYmXG4gICAgICBob3ZlcmVkRWxlbWVudCA9PT0gJ2NhbnZhcy0zZCcgJiZcbiAgICAgIElucHV0TWFuYWdlci5tb3VzZURvd24oTW91c2VCdXR0b24uTGVmdClcbiAgICApIHtcbiAgICAgIGNvbnN0IG1vdXNlID0gdmVjMi5jcHkoSW5wdXRNYW5hZ2VyLm1vdXNlUG9zaXRpb24pO1xuICAgICAgY29uc3QgcmF5ID0gdGhpcy5jYW1lcmEzZC5yYXljYXN0KFxuICAgICAgICBtb3VzZSxcbiAgICAgICAgdmVjMih0aGlzLmNhbnZhczNkLndpZHRoLCB0aGlzLmNhbnZhczNkLmhlaWdodClcbiAgICAgICk7XG5cbiAgICAgIGlmIChyYXkpIHtcbiAgICAgICAgbGV0IGRlbHRhVmVydGV4UG9zaXRpb24gPSB2ZWMzKCk7XG4gICAgICAgIGNvbnN0IGRyYWdnaW5nSW5pdGlhbFBvc2l0aW9uID0gdGhpcy5kcmFnU3RhcnRWZXJ0ZXhQb3NpdGlvbnMhLmdldChcbiAgICAgICAgICB0aGlzLmRyYWdnaW5nVmVydGV4LmlkXG4gICAgICAgICkhO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1vdmVtZW50Q29uc3RyYWludFhBY3RpdmUgfHxcbiAgICAgICAgICB0aGlzLm1vdmVtZW50Q29uc3RyYWludFlBY3RpdmUgfHxcbiAgICAgICAgICB0aGlzLm1vdmVtZW50Q29uc3RyYWludFpBY3RpdmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbW91c2VTdGFydFRvTm93ID0gbW91c2UueSAtIHRoaXMuZHJhZ1N0YXJ0TW91c2UhLnk7XG4gICAgICAgICAgY29uc3QgbW92ZW1lbnRBbW91bnQgPSAtbW91c2VTdGFydFRvTm93O1xuXG4gICAgICAgICAgLy8gQXBwbHkgbW92ZW1lbnQgdG8gdGhlIGNvbnN0cmFpbmVkIGRpbWVuc2lvblxuICAgICAgICAgIGlmICh0aGlzLm1vdmVtZW50Q29uc3RyYWludFhBY3RpdmUpIHtcbiAgICAgICAgICAgIGRlbHRhVmVydGV4UG9zaXRpb24ueCArPSBtb3ZlbWVudEFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMubW92ZW1lbnRDb25zdHJhaW50WUFjdGl2ZSkge1xuICAgICAgICAgICAgZGVsdGFWZXJ0ZXhQb3NpdGlvbi55ICs9IG1vdmVtZW50QW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5tb3ZlbWVudENvbnN0cmFpbnRaQWN0aXZlKSB7XG4gICAgICAgICAgICBkZWx0YVZlcnRleFBvc2l0aW9uLnogKz0gbW92ZW1lbnRBbW91bnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBkcmFnZ2luZyB2ZXJ0ZXggcG9zaXRpb25cbiAgICAgICAgICBjb25zdCBkcmFnZ2luZ05ld1Bvc2l0aW9uID0gdmVjMy5hZGQoXG4gICAgICAgICAgICBkcmFnZ2luZ0luaXRpYWxQb3NpdGlvbixcbiAgICAgICAgICAgIGRlbHRhVmVydGV4UG9zaXRpb25cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gQXBwbHkgZ3JpZCBzbmFwcGluZyBpZiBzaGlmdCBpcyBoZWxkXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgSW5wdXRNYW5hZ2VyLmtleURvd24oJ1NoaWZ0TGVmdCcpIHx8XG4gICAgICAgICAgICBJbnB1dE1hbmFnZXIua2V5RG93bignU2hpZnRSaWdodCcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWRTaXplO1xuICAgICAgICAgICAgZHJhZ2dpbmdOZXdQb3NpdGlvbi54ID1cbiAgICAgICAgICAgICAgTWF0aC5yb3VuZChkcmFnZ2luZ05ld1Bvc2l0aW9uLnggLyBncmlkKSAqIGdyaWQ7XG4gICAgICAgICAgICBkcmFnZ2luZ05ld1Bvc2l0aW9uLnkgPVxuICAgICAgICAgICAgICBNYXRoLnJvdW5kKGRyYWdnaW5nTmV3UG9zaXRpb24ueSAvIGdyaWQpICogZ3JpZDtcbiAgICAgICAgICAgIGRyYWdnaW5nTmV3UG9zaXRpb24ueiA9XG4gICAgICAgICAgICAgIE1hdGgucm91bmQoZHJhZ2dpbmdOZXdQb3NpdGlvbi56IC8gZ3JpZCkgKiBncmlkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBmaW5hbCBkZWx0YSBiYXNlZCBvbiBkcmFnZ2luZyB2ZXJ0ZXgncyBuZXcgcG9zaXRpb25cbiAgICAgICAgICBkZWx0YVZlcnRleFBvc2l0aW9uID0gdmVjMy5zdWIoXG4gICAgICAgICAgICBkcmFnZ2luZ05ld1Bvc2l0aW9uLFxuICAgICAgICAgICAgZHJhZ2dpbmdJbml0aWFsUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgLSBtb3ZlIGluIFhaIHBsYW5lXG4gICAgICAgICAgY29uc3QgcGxhbmVQb2ludCA9IHZlYzMoMCwgdGhpcy5kcmFnZ2luZ1ZlcnRleC5wb3NpdGlvbi55LCAwKTtcbiAgICAgICAgICBjb25zdCBwbGFuZU5vcm1hbCA9IHZlYzMoMCwgMSwgMCk7XG4gICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gcmF5SW50ZXJzZWN0c1BsYW5lKHJheSwge1xuICAgICAgICAgICAgcG9pbnQ6IHBsYW5lUG9pbnQsXG4gICAgICAgICAgICBub3JtYWw6IHBsYW5lTm9ybWFsLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGRyYWdnaW5nIHZlcnRleCBwb3NpdGlvblxuICAgICAgICAgICAgbGV0IGRyYWdnaW5nTmV3UG9zaXRpb24gPSB2ZWMzLmNweShpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQhKTtcblxuICAgICAgICAgICAgLy8gQXBwbHkgZ3JpZCBzbmFwcGluZyBpZiBzaGlmdCBpcyBoZWxkXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIElucHV0TWFuYWdlci5rZXlEb3duKCdTaGlmdExlZnQnKSB8fFxuICAgICAgICAgICAgICBJbnB1dE1hbmFnZXIua2V5RG93bignU2hpZnRSaWdodCcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkU2l6ZTtcbiAgICAgICAgICAgICAgZHJhZ2dpbmdOZXdQb3NpdGlvbi54ID1cbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKGRyYWdnaW5nTmV3UG9zaXRpb24ueCAvIGdyaWQpICogZ3JpZDtcbiAgICAgICAgICAgICAgZHJhZ2dpbmdOZXdQb3NpdGlvbi56ID1cbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKGRyYWdnaW5nTmV3UG9zaXRpb24ueiAvIGdyaWQpICogZ3JpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGZpbmFsIGRlbHRhIGJhc2VkIG9uIGRyYWdnaW5nIHZlcnRleCdzIG5ldyBwb3NpdGlvblxuICAgICAgICAgICAgZGVsdGFWZXJ0ZXhQb3NpdGlvbiA9IHZlYzMuc3ViKFxuICAgICAgICAgICAgICBkcmFnZ2luZ05ld1Bvc2l0aW9uLFxuICAgICAgICAgICAgICBkcmFnZ2luZ0luaXRpYWxQb3NpdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgYWxsIHNlbGVjdGVkIHZlcnRleCBwb3NpdGlvbnMgdXNpbmcgdGhlIGZpbmFsIGRlbHRhXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgIGNvbnN0IGluaXRpYWxQb3NpdGlvbiA9IHRoaXMuZHJhZ1N0YXJ0VmVydGV4UG9zaXRpb25zIS5nZXQodi5pZCk7XG4gICAgICAgICAgaWYgKGluaXRpYWxQb3NpdGlvbikge1xuICAgICAgICAgICAgdi5wb3NpdGlvbiA9IHZlYzMuYWRkKGluaXRpYWxQb3NpdGlvbiwgZGVsdGFWZXJ0ZXhQb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF2ZWN0b3JBbG1vc3RaZXJvKGRlbHRhVmVydGV4UG9zaXRpb24pKSB7XG4gICAgICAgICAgdGhpcy52ZXJ0aWNlc01vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlc2VsZWN0aW9uIGxvZ2ljIDJkIGFuZCAzZDogZGVzZWxlY3QgdGhlIGhvdmVyZWQgdmVydGV4IG9uIG1vdXNlIHJlbGVhc2VcbiAgICBpZiAoXG4gICAgICB0aGlzLnRvb2wgPT09ICdzZWxlY3QnICYmXG4gICAgICB0aGlzLmhvdmVyZWRWZXJ0ZXggJiZcbiAgICAgIElucHV0TWFuYWdlci5tb3VzZVJlbGVhc2VkKE1vdXNlQnV0dG9uLkxlZnQpICYmXG4gICAgICB0aGlzLmNsaWNrZWRWZXJ0ZXggPT09IHRoaXMuaG92ZXJlZFZlcnRleCAmJlxuICAgICAgKCF0aGlzLmRyYWdTdGFydE1vdXNlIHx8XG4gICAgICAgIHZlYzIuZXEodGhpcy5kcmFnU3RhcnRNb3VzZSwgSW5wdXRNYW5hZ2VyLm1vdXNlUG9zaXRpb24pKSAmJlxuICAgICAgWydjYW52YXMtdG9wJywgJ2NhbnZhcy1mcm9udCcsICdjYW52YXMtc2lkZScsICdjYW52YXMtM2QnXS5pbmNsdWRlcyhcbiAgICAgICAgaG92ZXJlZEVsZW1lbnRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRoaXMuZGVzZWxlY3RWZXJ0ZXgodGhpcy5ob3ZlcmVkVmVydGV4KTtcbiAgICAgIHRoaXMuY2xpY2tlZFZlcnRleCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gRW5kIGRyYWcgb24gbW91c2UgcmVsZWFzZVxuICAgIGlmICh0aGlzLmRyYWdnaW5nVmVydGV4ICYmIElucHV0TWFuYWdlci5tb3VzZVJlbGVhc2VkKE1vdXNlQnV0dG9uLkxlZnQpKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nVmVydGV4ID0gbnVsbDtcbiAgICAgIHRoaXMuZHJhZ1N0YXJ0TW91c2UgPSBudWxsO1xuICAgICAgdGhpcy5kcmFnU3RhcnRWZXJ0ZXhQb3NpdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkLCBjaGVjayBpZiB3ZSBtb3ZlZCBhbnkgdmVydGljZXMgYW5kIGlmIHNvLFxuICAgIC8vIGZpcmUgdGhlIG1vZGVsIGNoYW5nZWQgZXZlbnRcbiAgICBpZiAodGhpcy52ZXJ0aWNlc01vdmVkICYmIElucHV0TWFuYWdlci5tb3VzZVJlbGVhc2VkKE1vdXNlQnV0dG9uLkxlZnQpKSB7XG4gICAgICB0aGlzLnZlcnRpY2VzTW92ZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwuZW1pdENoYW5nZUV2ZW50KCdWZXJ0aWNlcyBtb3ZlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlc2VsZWN0IGFsbCB2ZXJ0aWNlcyBpZiBjbGlja2luZyBlbXB0eSBzcGFjZSAob3Igc29tZXRoaW5nIHRoYXQgaXNuJ3QgYVxuICAgIC8vIHZlcnRleCkgaW4gMkQgcGFuZWxcbiAgICBpZiAoXG4gICAgICB0aGlzLnRvb2wgPT09ICdzZWxlY3QnICYmXG4gICAgICAhdGhpcy5ob3ZlcmVkVmVydGV4ICYmXG4gICAgICBJbnB1dE1hbmFnZXIubW91c2VQcmVzc2VkKE1vdXNlQnV0dG9uLkxlZnQpICYmXG4gICAgICBbJ2NhbnZhcy10b3AnLCAnY2FudmFzLWZyb250JywgJ2NhbnZhcy1zaWRlJywgJ2NhbnZhcy0zZCddLmluY2x1ZGVzKFxuICAgICAgICBob3ZlcmVkRWxlbWVudFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5kZXNlbGVjdFZlcnRleCgpO1xuICAgIH1cblxuICAgIC8vIERlc2VsZWN0IGFsbCBlZGdlcyBpZiBjbGlja2luZyBlbXB0eSBzcGFjZSAob3Igc29tZXRoaW5nIHRoYXQgaXNuJ3QgYW5cbiAgICAvLyBlZGdlKSBpbiAyRCBwYW5lbFxuICAgIGlmIChcbiAgICAgIHRoaXMudG9vbCA9PT0gJ3NlbGVjdCcgJiZcbiAgICAgICF0aGlzLmhvdmVyZWRFZGdlICYmXG4gICAgICBJbnB1dE1hbmFnZXIubW91c2VQcmVzc2VkKE1vdXNlQnV0dG9uLkxlZnQpICYmXG4gICAgICBbJ2NhbnZhcy10b3AnLCAnY2FudmFzLWZyb250JywgJ2NhbnZhcy1zaWRlJywgJ2NhbnZhcy0zZCddLmluY2x1ZGVzKFxuICAgICAgICBob3ZlcmVkRWxlbWVudFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5kZXNlbGVjdEVkZ2UoKTtcbiAgICB9XG5cbiAgICAvLyBEZXNlbGVjdCBhbGwgc3VyZmFjZXMgaWYgY2xpY2tpbmcgZW1wdHkgc3BhY2UgKG9yIHNvbWV0aGluZyB0aGF0IGlzbid0IGFcbiAgICAvLyBzdXJmYWNlKSBpbiAyRCBwYW5lbFxuICAgIGlmIChcbiAgICAgIHRoaXMudG9vbCA9PT0gJ3NlbGVjdCcgJiZcbiAgICAgICF0aGlzLmhvdmVyZWRTdXJmYWNlICYmXG4gICAgICBJbnB1dE1hbmFnZXIubW91c2VQcmVzc2VkKE1vdXNlQnV0dG9uLkxlZnQpICYmXG4gICAgICBbJ2NhbnZhcy10b3AnLCAnY2FudmFzLWZyb250JywgJ2NhbnZhcy1zaWRlJywgJ2NhbnZhcy0zZCddLmluY2x1ZGVzKFxuICAgICAgICBob3ZlcmVkRWxlbWVudFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5kZXNlbGVjdFN1cmZhY2UoKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IHZlcnRpY2VzXG4gICAgaWYgKFxuICAgICAgdGhpcy50b29sID09PSAnY3JlYXRlLXZlcnRleCcgJiZcbiAgICAgIElucHV0TWFuYWdlci5tb3VzZVByZXNzZWQoTW91c2VCdXR0b24uTGVmdCkgJiZcbiAgICAgIHRoaXMubW9kZWxcbiAgICApIHtcbiAgICAgIC8vIDJEIHBhbmVsc1xuICAgICAgaWYgKFxuICAgICAgICBbJ2NhbnZhcy10b3AnLCAnY2FudmFzLWZyb250JywgJ2NhbnZhcy1zaWRlJ10uaW5jbHVkZXMoaG92ZXJlZEVsZW1lbnQpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgcGFuZWxJbmZvID0gdGhpcy5nZXRQYW5lbDJkSW5mbyhob3ZlcmVkRWxlbWVudCk7XG4gICAgICAgIGlmIChwYW5lbEluZm8pIHtcbiAgICAgICAgICBjb25zdCB7IGNhbWVyYSwgY29tcG9uZW50cyB9ID0gcGFuZWxJbmZvO1xuICAgICAgICAgIGNvbnN0IG1vdXNlV29ybGQgPSBjYW1lcmEuc2NyZWVuVG9Xb3JsZChJbnB1dE1hbmFnZXIubW91c2VQb3NpdGlvbik7XG4gICAgICAgICAgbGV0IHBvc2l0aW9uID0gdmVjMygpO1xuICAgICAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xuICAgICAgICAgICAgY2FzZSAneHonOlxuICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZlYzMobW91c2VXb3JsZC54LCAwLCBtb3VzZVdvcmxkLnkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3hZJzpcbiAgICAgICAgICAgICAgcG9zaXRpb24gPSB2ZWMzKG1vdXNlV29ybGQueCwgLW1vdXNlV29ybGQueSwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnWlknOlxuICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZlYzMoMCwgLW1vdXNlV29ybGQueSwgLW1vdXNlV29ybGQueCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNuYXAgdG8gZ3JpZCBpZiBTaGlmdCBpcyBoZWxkXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgSW5wdXRNYW5hZ2VyLmtleURvd24oJ1NoaWZ0TGVmdCcpIHx8XG4gICAgICAgICAgICBJbnB1dE1hbmFnZXIua2V5RG93bignU2hpZnRSaWdodCcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWRTaXplO1xuICAgICAgICAgICAgcG9zaXRpb24ueCA9IE1hdGgucm91bmQocG9zaXRpb24ueCAvIGdyaWQpICogZ3JpZDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnkgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnkgLyBncmlkKSAqIGdyaWQ7XG4gICAgICAgICAgICBwb3NpdGlvbi56ID0gTWF0aC5yb3VuZChwb3NpdGlvbi56IC8gZ3JpZCkgKiBncmlkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkZCB2ZXJ0ZXggdG8gbW9kZWxcbiAgICAgICAgICB0aGlzLm1vZGVsLmFkZFZlcnRleChwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gM0QgcGFuZWxcbiAgICAgIGlmIChob3ZlcmVkRWxlbWVudCA9PT0gJ2NhbnZhcy0zZCcpIHtcbiAgICAgICAgY29uc3QgbW91c2UgPSB2ZWMyLmNweShJbnB1dE1hbmFnZXIubW91c2VQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHJheSA9IHRoaXMuY2FtZXJhM2QucmF5Y2FzdChcbiAgICAgICAgICBtb3VzZSxcbiAgICAgICAgICB2ZWMyKHRoaXMuY2FudmFzM2Qud2lkdGgsIHRoaXMuY2FudmFzM2QuaGVpZ2h0KVxuICAgICAgICApO1xuICAgICAgICBpZiAocmF5KSB7XG4gICAgICAgICAgLy8gSW50ZXJzZWN0IHdpdGggZ3JvdW5kIHBsYW5lIHk9MFxuICAgICAgICAgIGNvbnN0IHBsYW5lUG9pbnQgPSB2ZWMzKDAsIDAsIDApO1xuICAgICAgICAgIGNvbnN0IHBsYW5lTm9ybWFsID0gdmVjMygwLCAxLCAwKTtcbiAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSByYXlJbnRlcnNlY3RzUGxhbmUocmF5LCB7XG4gICAgICAgICAgICBwb2ludDogcGxhbmVQb2ludCxcbiAgICAgICAgICAgIG5vcm1hbDogcGxhbmVOb3JtYWwsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLmludGVyc2VjdHMgJiYgaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQhO1xuXG4gICAgICAgICAgICAvLyBTbmFwIHRvIGdyaWQgaWYgU2hpZnQgaXMgaGVsZFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBJbnB1dE1hbmFnZXIua2V5RG93bignU2hpZnRMZWZ0JykgfHxcbiAgICAgICAgICAgICAgSW5wdXRNYW5hZ2VyLmtleURvd24oJ1NoaWZ0UmlnaHQnKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZFNpemU7XG4gICAgICAgICAgICAgIHBvc2l0aW9uLnggPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnggLyBncmlkKSAqIGdyaWQ7XG4gICAgICAgICAgICAgIHBvc2l0aW9uLnkgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnkgLyBncmlkKSAqIGdyaWQ7XG4gICAgICAgICAgICAgIHBvc2l0aW9uLnogPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnogLyBncmlkKSAqIGdyaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB2ZXJ0ZXggdG8gbW9kZWxcbiAgICAgICAgICAgIHRoaXMubW9kZWwuYWRkVmVydGV4KHBvc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IGVkZ2VzXG4gICAgaWYgKFxuICAgICAgdGhpcy5tb2RlbCAmJlxuICAgICAgdGhpcy50b29sID09PSAnY3JlYXRlLWVkZ2UnICYmXG4gICAgICB0aGlzLmhvdmVyZWRWZXJ0ZXggJiZcbiAgICAgIElucHV0TWFuYWdlci5tb3VzZVByZXNzZWQoTW91c2VCdXR0b24uTGVmdClcbiAgICApIHtcbiAgICAgIGlmICh0aGlzLmNyZWF0aW5nRWRnZSkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBjcmVhdGluZyBhbiBlZGdlLCBhZGQgdGhlIGhvdmVyZWQgdmVydGV4IHRvIGl0XG4gICAgICAgIHRoaXMuY3JlYXRpbmdFZGdlLmIgPSB0aGlzLmhvdmVyZWRWZXJ0ZXg7XG4gICAgICAgIHRoaXMubW9kZWwuYWRkRWRnZShuZXcgRWRnZSh0aGlzLmNyZWF0aW5nRWRnZS5hLCB0aGlzLmNyZWF0aW5nRWRnZS5iKSk7XG4gICAgICAgIHRoaXMuY3JlYXRpbmdFZGdlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jcmVhdGluZ0VkZ2UgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCB5ZXQgY3JlYXRpbmcgYW4gZWRnZSwgc3RhcnQgY3JlYXRpbmcgb25lIHdpdGggdGhlXG4gICAgICAgIC8vIGhvdmVyZWQgdmVydGV4XG4gICAgICAgIHRoaXMuY3JlYXRpbmdFZGdlID0gbmV3IEVkZ2UoXG4gICAgICAgICAgdGhpcy5ob3ZlcmVkVmVydGV4LFxuICAgICAgICAgIG5ldyBWZXJ0ZXgodmVjMygpLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNyZWF0aW5nRWRnZSkge1xuICAgICAgdGhpcy5jcmVhdGluZ0VkZ2UuYS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3JlYXRpbmdFZGdlLmhvdmVyZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuaG92ZXJlZFZlcnRleCkge1xuICAgICAgICAvLyBTbmFwIHRoZSBlbmQgdmVydGV4IG9mIHRoZSBlZGdlIHRvIHRoZSBob3ZlcmVkIHZlcnRleCBwb3NpdGlvblxuICAgICAgICB0aGlzLmNyZWF0aW5nRWRnZS5iLnBvc2l0aW9uID0gdmVjMy5jcHkodGhpcy5ob3ZlcmVkVmVydGV4LnBvc2l0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIFsnY2FudmFzLXRvcCcsICdjYW52YXMtZnJvbnQnLCAnY2FudmFzLXNpZGUnXS5pbmNsdWRlcyhob3ZlcmVkRWxlbWVudClcbiAgICAgICkge1xuICAgICAgICAvLyBDb252ZXJ0IG1vdXNlIHRvIHdvcmxkIHNwYWNlIGZvciB0aGUgcGFuZWxcbiAgICAgICAgY29uc3QgeyBjYW1lcmEgfSA9IHRoaXMuZ2V0UGFuZWwyZEluZm8oaG92ZXJlZEVsZW1lbnQpID8/IHt9O1xuICAgICAgICBjb25zdCBtb3VzZVdvcmxkID0gY2FtZXJhIS5zY3JlZW5Ub1dvcmxkKElucHV0TWFuYWdlci5tb3VzZVBvc2l0aW9uKTtcblxuICAgICAgICAvLyBUaGUgZW5kIHZlcnRleCBvZiB0aGUgZWRnZSBzaG91bGQgZm9sbG93IHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAgICBzd2l0Y2ggKGhvdmVyZWRFbGVtZW50KSB7XG4gICAgICAgICAgY2FzZSAnY2FudmFzLXRvcCc6XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW5nRWRnZS5iLnBvc2l0aW9uID0gdmVjMyhcbiAgICAgICAgICAgICAgbW91c2VXb3JsZC54LFxuICAgICAgICAgICAgICB0aGlzLmNyZWF0aW5nRWRnZS5hLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgIG1vdXNlV29ybGQueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NhbnZhcy1mcm9udCc6XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW5nRWRnZS5iLnBvc2l0aW9uID0gdmVjMyhcbiAgICAgICAgICAgICAgbW91c2VXb3JsZC54LFxuICAgICAgICAgICAgICAtbW91c2VXb3JsZC55LFxuICAgICAgICAgICAgICB0aGlzLmNyZWF0aW5nRWRnZS5hLnBvc2l0aW9uLnpcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjYW52YXMtc2lkZSc6XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW5nRWRnZS5iLnBvc2l0aW9uID0gdmVjMyhcbiAgICAgICAgICAgICAgdGhpcy5jcmVhdGluZ0VkZ2UuYS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAtbW91c2VXb3JsZC55LFxuICAgICAgICAgICAgICAtbW91c2VXb3JsZC54XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoWydjYW52YXMtM2QnXS5pbmNsdWRlcyhob3ZlcmVkRWxlbWVudCkpIHtcbiAgICAgICAgLy8gSW4gM0QgcGFuZWwsIHRoZSBlbmQgdmVydGV4IG9mIHRoZSBlZGdlIHNob3VsZCBmb2xsb3cgdGhlIG1vdXNlXG4gICAgICAgIGNvbnN0IG1vdXNlID0gdmVjMi5jcHkoSW5wdXRNYW5hZ2VyLm1vdXNlUG9zaXRpb24pO1xuICAgICAgICBjb25zdCByYXkgPSB0aGlzLmNhbWVyYTNkLnJheWNhc3QoXG4gICAgICAgICAgbW91c2UsXG4gICAgICAgICAgdmVjMih0aGlzLmNhbnZhczNkLndpZHRoLCB0aGlzLmNhbnZhczNkLmhlaWdodClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJheSkge1xuICAgICAgICAgIC8vIEludGVyc2VjdCB3aXRoIGdyb3VuZCBwbGFuZSAoeSA9IGVkZ2Ugc3RhcnQgdmVydGV4IHkpXG4gICAgICAgICAgY29uc3QgcGxhbmVQb2ludCA9IHZlYzMoMCwgdGhpcy5jcmVhdGluZ0VkZ2UuYS5wb3NpdGlvbi55LCAwKTtcbiAgICAgICAgICBjb25zdCBwbGFuZU5vcm1hbCA9IHZlYzMoMCwgMSwgMCk7XG4gICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gcmF5SW50ZXJzZWN0c1BsYW5lKHJheSwge1xuICAgICAgICAgICAgcG9pbnQ6IHBsYW5lUG9pbnQsXG4gICAgICAgICAgICBub3JtYWw6IHBsYW5lTm9ybWFsLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3RzICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGluZ0VkZ2UuYi5wb3NpdGlvbiA9IHZlYzMuY3B5KFxuICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQhXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGNyZWF0aW5nIGFuIGVkZ2UsIHdlIGNhbiBjYW5jZWwgaXQgYnkgcHJlc3NpbmcgRXNjYXBlXG4gICAgaWYgKFxuICAgICAgdGhpcy50b29sID09PSAnY3JlYXRlLWVkZ2UnICYmXG4gICAgICB0aGlzLmNyZWF0aW5nRWRnZSAmJlxuICAgICAgSW5wdXRNYW5hZ2VyLmtleVByZXNzZWQoJ0VzY2FwZScpXG4gICAgKSB7XG4gICAgICB0aGlzLmNyZWF0aW5nRWRnZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmNyZWF0aW5nRWRnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gSWYgd2Ugc3dpdGNoIHRvb2xzIHdoaWxlIGNyZWF0aW5nIGFuIGVkZ2UsIGNhbmNlbCB0aGUgY3JlYXRpb25cbiAgICAvLyAodW5sZXNzIHdlIGFyZSBzd2l0Y2hpbmcgdG8gdGhlIHBhbiB0b29sKVxuICAgIGlmICghWydjcmVhdGUtZWRnZScsICdwYW4nXS5pbmNsdWRlcyh0aGlzLnRvb2wpICYmIHRoaXMuY3JlYXRpbmdFZGdlKSB7XG4gICAgICB0aGlzLmNyZWF0aW5nRWRnZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmNyZWF0aW5nRWRnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5ldyBzdXJmYWNlc1xuICAgIGlmIChcbiAgICAgIHRoaXMubW9kZWwgJiZcbiAgICAgIHRoaXMudG9vbCA9PT0gJ2NyZWF0ZS1zdXJmYWNlJyAmJlxuICAgICAgdGhpcy5ob3ZlcmVkVmVydGV4ICYmXG4gICAgICBJbnB1dE1hbmFnZXIubW91c2VQcmVzc2VkKE1vdXNlQnV0dG9uLkxlZnQpXG4gICAgKSB7XG4gICAgICBpZiAodGhpcy5jcmVhdGluZ1N1cmZhY2UpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgY3JlYXRpbmcgYSBzdXJmYWNlLi4uXG4gICAgICAgIGlmICghdGhpcy5jcmVhdGluZ1N1cmZhY2UudmVydGljZXMuaW5jbHVkZXModGhpcy5ob3ZlcmVkVmVydGV4KSkge1xuICAgICAgICAgIC8vIElmIHRoZSB2ZXJ0ZXggaXMgbm90IGFscmVhZHkgaW4gdGhlIHN1cmZhY2UsIGFkZCBpdFxuICAgICAgICAgIHRoaXMuY3JlYXRpbmdTdXJmYWNlLnZlcnRpY2VzLnB1c2godGhpcy5ob3ZlcmVkVmVydGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZS52ZXJ0aWNlcy5sZW5ndGggPj0gMyAmJlxuICAgICAgICAgIHRoaXMuY3JlYXRpbmdTdXJmYWNlLnZlcnRpY2VzWzBdID09PSB0aGlzLmhvdmVyZWRWZXJ0ZXhcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHZlcnRleCBpcyB0aGUgZmlyc3Qgb25lIGluIHRoZSBzdXJmYWNlLCB3ZSBoYXZlIGNsb3NlZCB0aGVcbiAgICAgICAgICAvLyBzdXJmYWNlIHBvbHlnb24gYW5kIGNhbiBhZGQgaXQgdG8gdGhlIG1vZGVsXG4gICAgICAgICAgdGhpcy5tb2RlbC5hZGRTdXJmYWNlKFxuICAgICAgICAgICAgbmV3IFN1cmZhY2UoWy4uLnRoaXMuY3JlYXRpbmdTdXJmYWNlLnZlcnRpY2VzXSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuY3JlYXRpbmdTdXJmYWNlLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmVydGV4IGlzIGFscmVhZHkgaW4gdGhlIHN1cmZhY2UsIHNvIHJlbW92ZSBpdFxuICAgICAgICAgIHRoaXMuY3JlYXRpbmdTdXJmYWNlLnZlcnRpY2VzID0gdGhpcy5jcmVhdGluZ1N1cmZhY2UudmVydGljZXMuZmlsdGVyKFxuICAgICAgICAgICAgdiA9PiB2ICE9PSB0aGlzLmhvdmVyZWRWZXJ0ZXhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IHlldCBjcmVhdGluZyBhIHN1cmZhY2UsIHN0YXJ0IGNyZWF0aW5nIG9uZSB3aXRoIHRoZVxuICAgICAgICAvLyBob3ZlcmVkIHZlcnRleFxuICAgICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZSA9IG5ldyBTdXJmYWNlKFt0aGlzLmhvdmVyZWRWZXJ0ZXhdLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNyZWF0aW5nU3VyZmFjZSkge1xuICAgICAgdGhpcy5jcmVhdGluZ1N1cmZhY2UudmVydGljZXMuZm9yRWFjaCh2ID0+ICh2LmhvdmVyZWQgPSB0cnVlKSk7XG4gICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBjcmVhdGluZyBhIHN1cmZhY2UsIHdlIGNhbiBjYW5jZWwgaXQgYnkgcHJlc3NpbmcgRXNjYXBlXG4gICAgaWYgKFxuICAgICAgdGhpcy50b29sID09PSAnY3JlYXRlLXN1cmZhY2UnICYmXG4gICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZSAmJlxuICAgICAgSW5wdXRNYW5hZ2VyLmtleVByZXNzZWQoJ0VzY2FwZScpXG4gICAgKSB7XG4gICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gSWYgd2Ugc3dpdGNoIHRvb2xzIHdoaWxlIGNyZWF0aW5nIGFuIGVkZ2UsIGNhbmNlbCB0aGUgY3JlYXRpb25cbiAgICAvLyAodW5sZXNzIHdlIGFyZSBzd2l0Y2hpbmcgdG8gdGhlIHBhbiB0b29sKVxuICAgIGlmIChcbiAgICAgICFbJ2NyZWF0ZS1zdXJmYWNlJywgJ3BhbiddLmluY2x1ZGVzKHRoaXMudG9vbCkgJiZcbiAgICAgIHRoaXMuY3JlYXRpbmdTdXJmYWNlXG4gICAgKSB7XG4gICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIHNlbGVjdGVkIG9iamVjdHMgd2l0aCBEZWxldGUga2V5XG4gICAgaWYgKFxuICAgICAgdGhpcy50b29sID09PSAnc2VsZWN0JyAmJlxuICAgICAgSW5wdXRNYW5hZ2VyLmtleVByZXNzZWQoJ0RlbGV0ZScpICYmXG4gICAgICB0aGlzLm1vZGVsXG4gICAgKSB7XG4gICAgICAvLyBEZWxldGUgdmVydGljZXNcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkVmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5mb3JFYWNoKHYgPT4gdGhpcy5tb2RlbCEucmVtb3ZlVmVydGV4KHYpKTtcbiAgICAgICAgdGhpcy5kZXNlbGVjdFZlcnRleCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWxldGUgZWRnZXNcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkRWRnZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRFZGdlcy5mb3JFYWNoKGUgPT4gdGhpcy5tb2RlbCEucmVtb3ZlRWRnZShlKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRFZGdlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWxldGUgc3VyZmFjZXNcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkU3VyZmFjZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRTdXJmYWNlcy5mb3JFYWNoKHMgPT4gdGhpcy5tb2RlbCEucmVtb3ZlU3VyZmFjZShzKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRTdXJmYWNlcyA9IFtdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDNkIGNhbWVyYSBtb3ZlbWVudCAoV0FTRCArIFpYKVxuICAgIGlmIChob3ZlcmVkRWxlbWVudCA9PT0gJ2NhbnZhcy0zZCcpIHtcbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgbGV0IG1vdmVEaXIgPSB2ZWMzKCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBmb3J3YXJkLCByaWdodCwgYW5kIHVwIHZlY3RvcnNcbiAgICAgIGNvbnN0IGZvcndhcmQgPSB2ZWMzLm5vcihcbiAgICAgICAgdmVjMy5zdWIodGhpcy5jYW1lcmEzZC50YXJnZXQsIHRoaXMuY2FtZXJhM2QucG9zaXRpb24pXG4gICAgICApO1xuICAgICAgY29uc3QgcmlnaHQgPSB2ZWMzLm5vcih2ZWMzLmNyb3NzKGZvcndhcmQsIHZlYzMoMCwgMSwgMCkpKTtcbiAgICAgIGNvbnN0IHVwID0gdmVjMygwLCAxLCAwKTtcblxuICAgICAgLy8gS2V5Ym9hcmQgbW92ZW1lbnRcbiAgICAgIGlmIChJbnB1dE1hbmFnZXIua2V5RG93bignS2V5VycpKSB7XG4gICAgICAgIG1vdmVEaXIgPSB2ZWMzLmFkZChtb3ZlRGlyLCBmb3J3YXJkKTtcbiAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKElucHV0TWFuYWdlci5rZXlEb3duKCdLZXlTJykpIHtcbiAgICAgICAgbW92ZURpciA9IHZlYzMuc3ViKG1vdmVEaXIsIGZvcndhcmQpO1xuICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleURvd24oJ0tleUEnKSkge1xuICAgICAgICBtb3ZlRGlyID0gdmVjMy5zdWIobW92ZURpciwgcmlnaHQpO1xuICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleURvd24oJ0tleUQnKSkge1xuICAgICAgICBtb3ZlRGlyID0gdmVjMy5hZGQobW92ZURpciwgcmlnaHQpO1xuICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleURvd24oJ0tleVEnKSkge1xuICAgICAgICBtb3ZlRGlyID0gdmVjMy5hZGQobW92ZURpciwgdXApO1xuICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleURvd24oJ0tleUUnKSkge1xuICAgICAgICBtb3ZlRGlyID0gdmVjMy5zdWIobW92ZURpciwgdXApO1xuICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICBtb3ZlRGlyID0gdmVjMy5ub3IobW92ZURpcik7XG4gICAgICAgIGNvbnN0IG1vdmVTdGVwID0gdmVjMy5zY2FsZShtb3ZlRGlyLCB0aGlzLm9wdGlvbnMubW92ZVNwZWVkICogZHQpO1xuICAgICAgICB0aGlzLmNhbWVyYTNkLnBvc2l0aW9uID0gdmVjMy5hZGQodGhpcy5jYW1lcmEzZC5wb3NpdGlvbiwgbW92ZVN0ZXApO1xuICAgICAgICB0aGlzLmNhbWVyYTNkLnRhcmdldCA9IHZlYzMuYWRkKHRoaXMuY2FtZXJhM2QudGFyZ2V0LCBtb3ZlU3RlcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gM2QgY2FtZXJhIHJvdGF0aW9uXG4gICAgaWYgKFxuICAgICAgdGhpcy50b29sID09PSAncGFuJyAmJlxuICAgICAgaG92ZXJlZEVsZW1lbnQgPT09ICdjYW52YXMtM2QnICYmXG4gICAgICBJbnB1dE1hbmFnZXIubW91c2VEb3duKE1vdXNlQnV0dG9uLkxlZnQpXG4gICAgKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IHZlYzIuc3ViKFxuICAgICAgICBJbnB1dE1hbmFnZXIubW91c2VQb3NpdGlvbixcbiAgICAgICAgdGhpcy5sYXN0TW91c2VQb3NpdGlvblxuICAgICAgKTtcbiAgICAgIHRoaXMuY2FtZXJhM2RZYXcgKz0gZGVsdGEueCAqIHRoaXMub3B0aW9ucy5yb3RhdGVTcGVlZDtcbiAgICAgIHRoaXMuY2FtZXJhM2RQaXRjaCAtPSBkZWx0YS55ICogdGhpcy5vcHRpb25zLnJvdGF0ZVNwZWVkO1xuXG4gICAgICAvLyBDbGFtcCBwaXRjaCB0byBhdm9pZCBmbGlwcGluZ1xuICAgICAgY29uc3QgbWF4UGl0Y2ggPSBNYXRoLlBJIC8gMiAtIDAuMDE7XG4gICAgICB0aGlzLmNhbWVyYTNkUGl0Y2ggPSBNYXRoLm1heChcbiAgICAgICAgLW1heFBpdGNoLFxuICAgICAgICBNYXRoLm1pbihtYXhQaXRjaCwgdGhpcy5jYW1lcmEzZFBpdGNoKVxuICAgICAgKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBmb3J3YXJkIHZlY3RvclxuICAgICAgY29uc3QgciA9IHZlYzMubGVuKFxuICAgICAgICB2ZWMzLnN1Yih0aGlzLmNhbWVyYTNkLnBvc2l0aW9uLCB0aGlzLmNhbWVyYTNkLnRhcmdldClcbiAgICAgICk7XG4gICAgICBjb25zdCBvZmZzZXQgPSB2ZWMzLmZyb21Qb2xhcihcbiAgICAgICAgcixcbiAgICAgICAgTWF0aC5QSSAvIDIgLSB0aGlzLmNhbWVyYTNkUGl0Y2gsXG4gICAgICAgIHRoaXMuY2FtZXJhM2RZYXdcbiAgICAgICk7XG5cbiAgICAgIC8vIE1vdmUgdGhlIHRhcmdldCBwb3NpdGlvblxuICAgICAgdGhpcy5jYW1lcmEzZC50YXJnZXQgPSB2ZWMzLmFkZCh0aGlzLmNhbWVyYTNkLnBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIDJkIGNhbWVyYSB6b29taW5nXG4gICAgaWYgKFxuICAgICAgWydjYW52YXMtdG9wJywgJ2NhbnZhcy1mcm9udCcsICdjYW52YXMtc2lkZSddLmluY2x1ZGVzKGhvdmVyZWRFbGVtZW50KVxuICAgICkge1xuICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5nZXRQYW5lbDJkSW5mbyhob3ZlcmVkRWxlbWVudCkhLmNhbWVyYTtcbiAgICAgIGlmIChJbnB1dE1hbmFnZXIubW91c2VXaGVlbFVwKCkpIHtcbiAgICAgICAgY2FtZXJhLnNjYWxlICo9IDEgKyB0aGlzLm9wdGlvbnMuem9vbVNwZWVkO1xuICAgICAgfVxuICAgICAgaWYgKElucHV0TWFuYWdlci5tb3VzZVdoZWVsRG93bigpKSB7XG4gICAgICAgIGNhbWVyYS5zY2FsZSAqPSAxIC0gdGhpcy5vcHRpb25zLnpvb21TcGVlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyZCBjYW1lcmEgcGFubmluZ1xuICAgIGlmICh0aGlzLnRvb2wgPT09ICdwYW4nKSB7XG4gICAgICAvLyBTdGFydCBwYW5uaW5nXG4gICAgICBpZiAoXG4gICAgICAgIFsnY2FudmFzLXRvcCcsICdjYW52YXMtZnJvbnQnLCAnY2FudmFzLXNpZGUnXS5pbmNsdWRlcyhcbiAgICAgICAgICBob3ZlcmVkRWxlbWVudFxuICAgICAgICApICYmXG4gICAgICAgIElucHV0TWFuYWdlci5tb3VzZVByZXNzZWQoTW91c2VCdXR0b24uTGVmdClcbiAgICAgICkge1xuICAgICAgICB0aGlzLnBhbm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RQYW5Qb3NpdGlvbiA9IHZlYzIuY3B5KElucHV0TWFuYWdlci5tb3VzZVBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGFuIHRoZSBjYW1lcmFcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5wYW5uaW5nICYmXG4gICAgICAgIFsnY2FudmFzLXRvcCcsICdjYW52YXMtZnJvbnQnLCAnY2FudmFzLXNpZGUnXS5pbmNsdWRlcyhcbiAgICAgICAgICBob3ZlcmVkRWxlbWVudFxuICAgICAgICApICYmXG4gICAgICAgIElucHV0TWFuYWdlci5tb3VzZURvd24oTW91c2VCdXR0b24uTGVmdCkgJiZcbiAgICAgICAgdGhpcy5sYXN0UGFuUG9zaXRpb25cbiAgICAgICkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IHZlYzIuc3ViKFxuICAgICAgICAgIElucHV0TWFuYWdlci5tb3VzZVBvc2l0aW9uLFxuICAgICAgICAgIHRoaXMubGFzdFBhblBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuZ2V0UGFuZWwyZEluZm8oaG92ZXJlZEVsZW1lbnQpIS5jYW1lcmE7XG4gICAgICAgIGlmIChjYW1lcmEpIHtcbiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueCAtPSBkZWx0YS54IC8gY2FtZXJhLmFjdHVhbFNjYWxlO1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi55IC09IGRlbHRhLnkgLyBjYW1lcmEuYWN0dWFsU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0UGFuUG9zaXRpb24gPSB2ZWMyLmNweShJbnB1dE1hbmFnZXIubW91c2VQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3AgcGFubmluZ1xuICAgICAgaWYgKHRoaXMucGFubmluZyAmJiBJbnB1dE1hbmFnZXIubW91c2VSZWxlYXNlZChNb3VzZUJ1dHRvbi5MZWZ0KSkge1xuICAgICAgICB0aGlzLnBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0UGFuUG9zaXRpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCBwYW5uaW5nIHN0YXRlIGlmIG5vdCBpbiBwYW4gdG9vbFxuICAgICAgdGhpcy5wYW5uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmxhc3RQYW5Qb3NpdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVHdWlTdGF0ZXMoKTtcblxuICAgIC8vIFVwZGF0ZSBtb2RlbFxuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICB0aGlzLm1vZGVsLnVwZGF0ZShkdCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGNhbWVyYXNcbiAgICB0aGlzLmNhbWVyYVRvcC51cGRhdGUoe1xuICAgICAgeDogdGhpcy5jYW52YXNUb3Aud2lkdGgsXG4gICAgICB5OiB0aGlzLmNhbnZhc1RvcC5oZWlnaHQsXG4gICAgfSk7XG4gICAgdGhpcy5jYW1lcmFGcm9udC51cGRhdGUoe1xuICAgICAgeDogdGhpcy5jYW52YXNGcm9udC53aWR0aCxcbiAgICAgIHk6IHRoaXMuY2FudmFzRnJvbnQuaGVpZ2h0LFxuICAgIH0pO1xuICAgIHRoaXMuY2FtZXJhU2lkZS51cGRhdGUoe1xuICAgICAgeDogdGhpcy5jYW52YXNTaWRlLndpZHRoLFxuICAgICAgeTogdGhpcy5jYW52YXNTaWRlLmhlaWdodCxcbiAgICB9KTtcbiAgICB0aGlzLmNhbWVyYTNkLnVwZGF0ZSgpO1xuXG4gICAgRGVidWcudmFsdWUoXG4gICAgICAnY2FtZXJhLXRvcCcsXG4gICAgICBgKCR7dmVjMi5zdHIodmVjMi5tYXAodGhpcy5jYW1lcmFUb3AucG9zaXRpb24sIE1hdGguZmxvb3IpKX0pIHgke3JvdW5kKFxuICAgICAgICB0aGlzLmNhbWVyYVRvcC5zY2FsZSxcbiAgICAgICAgMlxuICAgICAgKX1gLFxuICAgICAge1xuICAgICAgICBzaG93TGFiZWw6IGZhbHNlLFxuICAgICAgICBhbGlnbjogJ3JpZ2h0JyxcbiAgICAgICAgdGFnczogWydwYW5lbC10b3AnXSxcbiAgICAgIH1cbiAgICApO1xuICAgIERlYnVnLnZhbHVlKFxuICAgICAgJ2NhbWVyYS1mcm9udCcsXG4gICAgICBgKCR7dmVjMi5zdHIodmVjMi5tYXAodGhpcy5jYW1lcmFGcm9udC5wb3NpdGlvbiwgTWF0aC5mbG9vcikpfSkgeCR7cm91bmQoXG4gICAgICAgIHRoaXMuY2FtZXJhRnJvbnQuc2NhbGUsXG4gICAgICAgIDJcbiAgICAgICl9YCxcbiAgICAgIHtcbiAgICAgICAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgICAgICAgYWxpZ246ICdyaWdodCcsXG4gICAgICAgIHRhZ3M6IFsncGFuZWwtZnJvbnQnXSxcbiAgICAgIH1cbiAgICApO1xuICAgIERlYnVnLnZhbHVlKFxuICAgICAgJ2NhbWVyYS1zaWRlJyxcbiAgICAgIGAoJHt2ZWMyLnN0cih2ZWMyLm1hcCh0aGlzLmNhbWVyYVNpZGUucG9zaXRpb24sIE1hdGguZmxvb3IpKX0pIHgke3JvdW5kKFxuICAgICAgICB0aGlzLmNhbWVyYVNpZGUuc2NhbGUsXG4gICAgICAgIDJcbiAgICAgICl9YCxcbiAgICAgIHtcbiAgICAgICAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgICAgICAgYWxpZ246ICdyaWdodCcsXG4gICAgICAgIHRhZ3M6IFsncGFuZWwtc2lkZSddLFxuICAgICAgfVxuICAgICk7XG4gICAgRGVidWcudmFsdWUoXG4gICAgICAnY2FtZXJhLTNkJyxcbiAgICAgIGAoJHt2ZWMzLnN0cihcbiAgICAgICAgdmVjMy5tYXAodGhpcy5jYW1lcmEzZC5wb3NpdGlvbiwgTWF0aC5mbG9vcilcbiAgICAgICl9KSA+ICgke3ZlYzMuc3RyKFxuICAgICAgICB2ZWMzLm1hcCh0aGlzLmNhbWVyYTNkLnRhcmdldCwgTWF0aC5mbG9vcilcbiAgICAgICl9KSB5YXc9JHtyb3VuZCh0aGlzLmNhbWVyYTNkWWF3LCAyKX0gcGl0Y2g9JHtyb3VuZChcbiAgICAgICAgdGhpcy5jYW1lcmEzZFBpdGNoLFxuICAgICAgICAyXG4gICAgICApfWAsXG4gICAgICB7XG4gICAgICAgIHNob3dMYWJlbDogZmFsc2UsXG4gICAgICAgIGFsaWduOiAncmlnaHQnLFxuICAgICAgICB0YWdzOiBbJ3BhbmVsLTNkJ10sXG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMubGFzdE1vdXNlUG9zaXRpb24gPSB2ZWMyLmNweShJbnB1dE1hbmFnZXIubW91c2VQb3NpdGlvbik7XG4gICAgSW5wdXRNYW5hZ2VyLnVwZGF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVHdWlTdGF0ZXMoKSB7XG4gICAgLy8gQ2hlY2sgaWYgdmVydGljZXMgc2VsZWN0aW9uIGNoYW5nZWRcbiAgICBjb25zdCBjdXJyZW50VmVydGljZXMgPSBuZXcgU2V0KHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5tYXAodiA9PiB2LmlkKSk7XG4gICAgaWYgKCFzZXRzRXF1YWwodGhpcy5sYXN0R3VpU3RhdGUudmVydGljZXMsIGN1cnJlbnRWZXJ0aWNlcykpIHtcbiAgICAgIGlmIChNb2RlbEVkaXRvci52ZXJ0aWNlc0ZvbGRlcikge1xuICAgICAgICBPYmplY3QudmFsdWVzKE1vZGVsRWRpdG9yLnZlcnRpY2VzRm9sZGVyLl9fZm9sZGVycykuZm9yRWFjaChmb2xkZXIgPT4ge1xuICAgICAgICAgIGZvbGRlci5kb21FbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmVydGljZXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICBpZiAodi5mb2xkZXIpIHtcbiAgICAgICAgICAgIHYuZm9sZGVyLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0R3VpU3RhdGUudmVydGljZXMgPSBjdXJyZW50VmVydGljZXM7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgZWRnZXMgc2VsZWN0aW9uIGNoYW5nZWRcbiAgICBjb25zdCBjdXJyZW50RWRnZXMgPSBuZXcgU2V0KHRoaXMuc2VsZWN0ZWRFZGdlcy5tYXAoZSA9PiBlLmlkKSk7XG4gICAgaWYgKCFzZXRzRXF1YWwodGhpcy5sYXN0R3VpU3RhdGUuZWRnZXMsIGN1cnJlbnRFZGdlcykpIHtcbiAgICAgIGlmIChNb2RlbEVkaXRvci5lZGdlc0ZvbGRlcikge1xuICAgICAgICBPYmplY3QudmFsdWVzKE1vZGVsRWRpdG9yLmVkZ2VzRm9sZGVyLl9fZm9sZGVycykuZm9yRWFjaChmb2xkZXIgPT4ge1xuICAgICAgICAgIGZvbGRlci5kb21FbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRWRnZXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICBpZiAoZS5mb2xkZXIpIHtcbiAgICAgICAgICAgIGUuZm9sZGVyLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0R3VpU3RhdGUuZWRnZXMgPSBjdXJyZW50RWRnZXM7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgc3VyZmFjZXMgc2VsZWN0aW9uIGNoYW5nZWRcbiAgICBjb25zdCBjdXJyZW50U3VyZmFjZXMgPSBuZXcgU2V0KHRoaXMuc2VsZWN0ZWRTdXJmYWNlcy5tYXAocyA9PiBzLmlkKSk7XG4gICAgaWYgKCFzZXRzRXF1YWwodGhpcy5sYXN0R3VpU3RhdGUuc3VyZmFjZXMsIGN1cnJlbnRTdXJmYWNlcykpIHtcbiAgICAgIGlmIChNb2RlbEVkaXRvci5zdXJmYWNlc0ZvbGRlcikge1xuICAgICAgICBPYmplY3QudmFsdWVzKE1vZGVsRWRpdG9yLnN1cmZhY2VzRm9sZGVyLl9fZm9sZGVycykuZm9yRWFjaChmb2xkZXIgPT4ge1xuICAgICAgICAgIGZvbGRlci5kb21FbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGVkU3VyZmFjZXMuZm9yRWFjaChzID0+IHtcbiAgICAgICAgICBpZiAocy5mb2xkZXIpIHtcbiAgICAgICAgICAgIHMuZm9sZGVyLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0R3VpU3RhdGUuc3VyZmFjZXMgPSBjdXJyZW50U3VyZmFjZXM7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgaGlzdG9yeSBpbmRleCBjaGFuZ2VkXG4gICAgaWYgKHRoaXMuY3VycmVudEhpc3RvcnlJbmRleCAhPT0gdGhpcy5sYXN0R3VpU3RhdGUuaGlzdG9yeUluZGV4KSB7XG4gICAgICBpZiAoTW9kZWxFZGl0b3IuaGlzdG9yeUZvbGRlcikge1xuICAgICAgICBPYmplY3QudmFsdWVzKE1vZGVsRWRpdG9yLmhpc3RvcnlGb2xkZXIuX19jb250cm9sbGVycykuZm9yRWFjaChcbiAgICAgICAgICBjb250cm9sbGVyID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5wYXJlbnROb2RlXG4gICAgICAgICAgICAgID8ucXVlcnlTZWxlY3Rvcignc3Bhbi5wcm9wZXJ0eS1uYW1lJylcbiAgICAgICAgICAgICAgPy5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeS5sZW5ndGggPiAwICYmIHRoaXMuY3VycmVudEhpc3RvcnlJbmRleCA+PSAwKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudENvbnRyb2xsZXIgPVxuICAgICAgICAgICAgTW9kZWxFZGl0b3IuaGlzdG9yeUZvbGRlci5fX2NvbnRyb2xsZXJzW3RoaXMuY3VycmVudEhpc3RvcnlJbmRleF07XG4gICAgICAgICAgaWYgKGN1cnJlbnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5kb21FbGVtZW50LnBhcmVudE5vZGVcbiAgICAgICAgICAgICAgPy5xdWVyeVNlbGVjdG9yKCdzcGFuLnByb3BlcnR5LW5hbWUnKVxuICAgICAgICAgICAgICA/LmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RHdWlTdGF0ZS5oaXN0b3J5SW5kZXggPSB0aGlzLmN1cnJlbnRIaXN0b3J5SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNlbGVjdFZlcnRleCh2ZXJ0ZXg6IFZlcnRleCwgYWRkVG9TZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgaWYgKCFhZGRUb1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5kZXNlbGVjdFZlcnRleCgpO1xuICAgIH1cbiAgICB2ZXJ0ZXguc2VsZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuc2VsZWN0ZWRWZXJ0aWNlcy5wdXNoKHZlcnRleCk7XG4gICAgdGhpcy5kcmFnZ2luZ1ZlcnRleCA9IG51bGw7XG4gICAgdGhpcy5kcmFnU3RhcnRNb3VzZSA9IG51bGw7XG4gICAgdGhpcy5kcmFnU3RhcnRWZXJ0ZXhQb3NpdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIHNlbGVjdEVkZ2UoZWRnZTogRWRnZSwgYWRkVG9TZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgaWYgKCFhZGRUb1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5kZXNlbGVjdEVkZ2UoKTtcbiAgICB9XG4gICAgZWRnZS5zZWxlY3RlZCA9IHRydWU7XG4gICAgdGhpcy5zZWxlY3RlZEVkZ2VzLnB1c2goZWRnZSk7XG4gIH1cblxuICBwdWJsaWMgc2VsZWN0U3VyZmFjZShzdXJmYWNlOiBTdXJmYWNlLCBhZGRUb1NlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBpZiAoIWFkZFRvU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmRlc2VsZWN0U3VyZmFjZSgpO1xuICAgIH1cbiAgICBzdXJmYWNlLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNlbGVjdGVkU3VyZmFjZXMucHVzaChzdXJmYWNlKTtcbiAgfVxuXG4gIHByaXZhdGUgZGVzZWxlY3RWZXJ0ZXgodmVydGV4PzogVmVydGV4KSB7XG4gICAgaWYgKHZlcnRleCkge1xuICAgICAgdmVydGV4LnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbGVjdGVkVmVydGljZXMgPSB0aGlzLnNlbGVjdGVkVmVydGljZXMuZmlsdGVyKHYgPT4gdiAhPT0gdmVydGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3RlZFZlcnRpY2VzLmZvckVhY2godiA9PiAodi5zZWxlY3RlZCA9IGZhbHNlKSk7XG4gICAgICB0aGlzLnNlbGVjdGVkVmVydGljZXMgPSBbXTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRlc2VsZWN0RWRnZShlZGdlPzogRWRnZSkge1xuICAgIGlmIChlZGdlKSB7XG4gICAgICBlZGdlLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbGVjdGVkRWRnZXMgPSB0aGlzLnNlbGVjdGVkRWRnZXMuZmlsdGVyKGUgPT4gZSAhPT0gZWRnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRFZGdlcy5mb3JFYWNoKGUgPT4gKGUuc2VsZWN0ZWQgPSBmYWxzZSkpO1xuICAgICAgdGhpcy5zZWxlY3RlZEVkZ2VzID0gW107XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZXNlbGVjdFN1cmZhY2Uoc3VyZmFjZT86IFN1cmZhY2UpIHtcbiAgICBpZiAoc3VyZmFjZSkge1xuICAgICAgc3VyZmFjZS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zZWxlY3RlZFN1cmZhY2VzID0gdGhpcy5zZWxlY3RlZFN1cmZhY2VzLmZpbHRlcihzID0+IHMgIT09IHN1cmZhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGVkU3VyZmFjZXMuZm9yRWFjaChzID0+IChzLnNlbGVjdGVkID0gZmFsc2UpKTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRTdXJmYWNlcyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVWZXJ0ZXgodmVydGV4OiBWZXJ0ZXgpIHtcbiAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgdGhpcy5tb2RlbC5yZW1vdmVWZXJ0ZXgodmVydGV4KTtcbiAgICB9XG4gICAgdGhpcy5kZXNlbGVjdFZlcnRleCh2ZXJ0ZXgpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUVkZ2UoZWRnZTogRWRnZSkge1xuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICB0aGlzLm1vZGVsLnJlbW92ZUVkZ2UoZWRnZSk7XG4gICAgfVxuICAgIHRoaXMuZGVzZWxlY3RFZGdlKGVkZ2UpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZVN1cmZhY2Uoc3VyZmFjZTogU3VyZmFjZSkge1xuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICB0aGlzLm1vZGVsLnJlbW92ZVN1cmZhY2Uoc3VyZmFjZSk7XG4gICAgfVxuICAgIHRoaXMuZGVzZWxlY3RTdXJmYWNlKHN1cmZhY2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRQYW5lbDJkSW5mbyhwYW5lbElkOiBzdHJpbmcpOiBQYW5lbDJkSW5mbyB8IG51bGwge1xuICAgIHN3aXRjaCAocGFuZWxJZCkge1xuICAgICAgY2FzZSAnY2FudmFzLXRvcCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FtZXJhOiB0aGlzLmNhbWVyYVRvcCxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHRUb3AsXG4gICAgICAgICAgY29tcG9uZW50czogJ3h6JyxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ2NhbnZhcy1mcm9udCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FtZXJhOiB0aGlzLmNhbWVyYUZyb250LFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dEZyb250LFxuICAgICAgICAgIGNvbXBvbmVudHM6ICd4WScsXG4gICAgICAgIH07XG4gICAgICBjYXNlICdjYW52YXMtc2lkZSc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FtZXJhOiB0aGlzLmNhbWVyYVNpZGUsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0U2lkZSxcbiAgICAgICAgICBjb21wb25lbnRzOiAnWlknLFxuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkcmF3KCkge1xuICAgIC8vIENsZWFyIGNhbnZhc2VzXG4gICAgdGhpcy5jb250ZXh0VG9wLmNsZWFyUmVjdChcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgdGhpcy5jYW52YXNUb3Aud2lkdGgsXG4gICAgICB0aGlzLmNhbnZhc1RvcC5oZWlnaHRcbiAgICApO1xuICAgIHRoaXMuY29udGV4dEZyb250LmNsZWFyUmVjdChcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgdGhpcy5jYW52YXNGcm9udC53aWR0aCxcbiAgICAgIHRoaXMuY2FudmFzRnJvbnQuaGVpZ2h0XG4gICAgKTtcbiAgICB0aGlzLmNvbnRleHRTaWRlLmNsZWFyUmVjdChcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgdGhpcy5jYW52YXNTaWRlLndpZHRoLFxuICAgICAgdGhpcy5jYW52YXNTaWRlLmhlaWdodFxuICAgICk7XG4gICAgdGhpcy5jb250ZXh0M2QuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzM2Qud2lkdGgsIHRoaXMuY2FudmFzM2QuaGVpZ2h0KTtcblxuICAgIC8vIFNhdmUgY29udGV4dHNcbiAgICB0aGlzLmNvbnRleHRUb3Auc2F2ZSgpO1xuICAgIHRoaXMuY29udGV4dEZyb250LnNhdmUoKTtcbiAgICB0aGlzLmNvbnRleHRTaWRlLnNhdmUoKTtcbiAgICB0aGlzLmNvbnRleHQzZC5zYXZlKCk7XG5cbiAgICAvLyBBcHBseSBjYW1lcmEgdHJhbnNmb3Jtc1xuICAgIHRoaXMuY2FtZXJhVG9wLnNldFRyYW5zZm9ybXModGhpcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLmNhbWVyYUZyb250LnNldFRyYW5zZm9ybXModGhpcy5jb250ZXh0RnJvbnQpO1xuICAgIHRoaXMuY2FtZXJhU2lkZS5zZXRUcmFuc2Zvcm1zKHRoaXMuY29udGV4dFNpZGUpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSAzZCBjYW1lcmEgYXNwZWN0IHJhdGlvXG4gICAgdGhpcy5jYW1lcmEzZC5hc3BlY3QgPSB0aGlzLmNhbnZhczNkLndpZHRoIC8gdGhpcy5jYW52YXMzZC5oZWlnaHQ7XG5cbiAgICAvLyBEcmF3IGdyaWRzXG4gICAgY29uc3QgcGFuZWwzZFNpemUgPSB2ZWMyKHRoaXMuY2FudmFzM2Qud2lkdGgsIHRoaXMuY2FudmFzM2QuaGVpZ2h0KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dHcmlkKSB7XG4gICAgICBHcmlkLmRyYXcoXG4gICAgICAgIHRoaXMuY29udGV4dFRvcCxcbiAgICAgICAgdGhpcy5jYW1lcmFUb3AsXG4gICAgICAgIHRoaXMub3B0aW9ucy5ncmlkU2l6ZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLnNob3dHcmlkTGFiZWxzLFxuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JpZExhYmVsc0dhcCxcbiAgICAgICAgJ3BhbmVsLXRvcCdcbiAgICAgICk7XG4gICAgICBHcmlkLmRyYXcoXG4gICAgICAgIHRoaXMuY29udGV4dEZyb250LFxuICAgICAgICB0aGlzLmNhbWVyYUZyb250LFxuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JpZFNpemUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5zaG93R3JpZExhYmVscyxcbiAgICAgICAgdGhpcy5vcHRpb25zLmdyaWRMYWJlbHNHYXAsXG4gICAgICAgICdwYW5lbC1mcm9udCdcbiAgICAgICk7XG4gICAgICBHcmlkLmRyYXcoXG4gICAgICAgIHRoaXMuY29udGV4dFNpZGUsXG4gICAgICAgIHRoaXMuY2FtZXJhU2lkZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLmdyaWRTaXplLFxuICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd0dyaWRMYWJlbHMsXG4gICAgICAgIHRoaXMub3B0aW9ucy5ncmlkTGFiZWxzR2FwLFxuICAgICAgICAncGFuZWwtc2lkZSdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0dyb3VuZFBsYW5lKSB7XG4gICAgICBHcmlkM2QuZHJhdyhcbiAgICAgICAgdGhpcy5jb250ZXh0M2QsXG4gICAgICAgIHRoaXMuY2FtZXJhM2QsXG4gICAgICAgIHBhbmVsM2RTaXplLFxuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JpZFNpemUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5ncm91bmRQbGFuZVNpemUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5zaG93R3JvdW5kUGxhbmVMYWJlbHMsXG4gICAgICAgIHRoaXMub3B0aW9ucy5ncm91bmRQbGFuZUxhYmVsc0dhcFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IHRoZSBtb2RlbFxuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICB0aGlzLm1vZGVsLmRyYXdUb3AodGhpcy5jb250ZXh0VG9wLCB0aGlzLm9wdGlvbnMuc2hvd1ZlcnRleExhYmVscyk7XG4gICAgICB0aGlzLm1vZGVsLmRyYXdGcm9udCh0aGlzLmNvbnRleHRGcm9udCwgdGhpcy5vcHRpb25zLnNob3dWZXJ0ZXhMYWJlbHMpO1xuICAgICAgdGhpcy5tb2RlbC5kcmF3U2lkZSh0aGlzLmNvbnRleHRTaWRlLCB0aGlzLm9wdGlvbnMuc2hvd1ZlcnRleExhYmVscyk7XG4gICAgICB0aGlzLm1vZGVsLmRyYXczZChcbiAgICAgICAgdGhpcy5jb250ZXh0M2QsXG4gICAgICAgIHRoaXMuY2FtZXJhM2QsXG4gICAgICAgIHBhbmVsM2RTaXplLFxuICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd1ZlcnRleExhYmVsc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBjcmVhdGluZyBhbiBlZGdlLCBkcmF3IHRoZSB0ZW1wb3JhcnkgZWRnZVxuICAgIGlmICh0aGlzLmNyZWF0aW5nRWRnZSkge1xuICAgICAgdGhpcy5jcmVhdGluZ0VkZ2UuZHJhdzJkKHRoaXMuY29udGV4dFRvcCwgJ3h6Jyk7XG4gICAgICB0aGlzLmNyZWF0aW5nRWRnZS5kcmF3MmQodGhpcy5jb250ZXh0RnJvbnQsICd4WScpO1xuICAgICAgdGhpcy5jcmVhdGluZ0VkZ2UuZHJhdzJkKHRoaXMuY29udGV4dFNpZGUsICdaWScpO1xuICAgICAgdGhpcy5jcmVhdGluZ0VkZ2UuZHJhdzNkKHRoaXMuY29udGV4dDNkLCB0aGlzLmNhbWVyYTNkLCBwYW5lbDNkU2l6ZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgY3JlYXRpbmcgYSBzdXJmYWNlLCBkcmF3IHRoZSB0ZW1wb3Jhcnkgc3VyZmFjZVxuICAgIGlmICh0aGlzLmNyZWF0aW5nU3VyZmFjZSkge1xuICAgICAgdGhpcy5jcmVhdGluZ1N1cmZhY2UuZHJhdzJkKHRoaXMuY29udGV4dFRvcCwgJ3h6Jyk7XG4gICAgICB0aGlzLmNyZWF0aW5nU3VyZmFjZS5kcmF3MmQodGhpcy5jb250ZXh0RnJvbnQsICd4WScpO1xuICAgICAgdGhpcy5jcmVhdGluZ1N1cmZhY2UuZHJhdzJkKHRoaXMuY29udGV4dFNpZGUsICdaWScpO1xuICAgICAgdGhpcy5jcmVhdGluZ1N1cmZhY2UuZHJhdzNkKHRoaXMuY29udGV4dDNkLCB0aGlzLmNhbWVyYTNkLCBwYW5lbDNkU2l6ZSk7XG4gICAgfVxuXG4gICAgLy8gRHJhdyBheGlzIGluZGljYXRvcnNcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dBeGVzKSB7XG4gICAgICBBeGVzLmRyYXcodGhpcy5jb250ZXh0M2QsIHRoaXMuY2FtZXJhM2QsIHBhbmVsM2RTaXplKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgZGVidWcgaW5mb3JtYXRpb25cbiAgICBEZWJ1Zy5kcmF3KHRoaXMuY29udGV4dFRvcCwgWydwYW5lbC10b3AnXSwgZmFsc2UpO1xuICAgIERlYnVnLmRyYXcodGhpcy5jb250ZXh0RnJvbnQsIFsncGFuZWwtZnJvbnQnXSwgZmFsc2UpO1xuICAgIERlYnVnLmRyYXcodGhpcy5jb250ZXh0U2lkZSwgWydwYW5lbC1zaWRlJ10sIGZhbHNlKTtcbiAgICBEZWJ1Zy5kcmF3KHRoaXMuY29udGV4dDNkLCBbJ3BhbmVsLTNkJ10sIGZhbHNlKTtcbiAgICBEZWJ1Zy5jbGVhcigpO1xuXG4gICAgLy8gUmVzdG9yZSBjb250ZXh0c1xuICAgIHRoaXMuY29udGV4dFRvcC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb250ZXh0RnJvbnQucmVzdG9yZSgpO1xuICAgIHRoaXMuY29udGV4dFNpZGUucmVzdG9yZSgpO1xuICAgIHRoaXMuY29udGV4dDNkLnJlc3RvcmUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IENhbWVyYTNkIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYS0zZCc7XG5pbXBvcnQgeyB2ZWMyLCB2ZWMzIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCBFZGdlIGZyb20gJy4vZWRnZSc7XG5pbXBvcnQgU3VyZmFjZSBmcm9tICcuL3N1cmZhY2UnO1xuaW1wb3J0IFZlcnRleCBmcm9tICcuL3ZlcnRleCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICBwdWJsaWMgdmVydGljZXM6IFZlcnRleFtdID0gW107XG4gIHB1YmxpYyBlZGdlczogRWRnZVtdID0gW107XG4gIHB1YmxpYyBzdXJmYWNlczogU3VyZmFjZVtdID0gW107XG5cbiAgY29uc3RydWN0b3IocHVibGljIG5hbWU6IHN0cmluZyA9ICcnKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMudmVydGljZXMuZm9yRWFjaCh2ID0+IHYuZGVzdHJveSgpKTtcbiAgICB0aGlzLmVkZ2VzLmZvckVhY2goZSA9PiBlLmRlc3Ryb3koKSk7XG4gICAgdGhpcy5zdXJmYWNlcy5mb3JFYWNoKHMgPT4gcy5kZXN0cm95KCkpO1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgIHRoaXMuZWRnZXMgPSBbXTtcbiAgICB0aGlzLnN1cmZhY2VzID0gW107XG4gIH1cblxuICBwdWJsaWMgc2VyaWFsaXplKCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB2ZXJ0aWNlczogdGhpcy52ZXJ0aWNlcy5tYXAodiA9PiB2LnNlcmlhbGl6ZSgpKSxcbiAgICAgIGVkZ2VzOiB0aGlzLmVkZ2VzLm1hcChlID0+IGUuc2VyaWFsaXplKCkpLFxuICAgICAgc3VyZmFjZXM6IHRoaXMuc3VyZmFjZXMubWFwKHMgPT4gcy5zZXJpYWxpemUoKSksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IE1vZGVsIHtcbiAgICBjb25zdCBtb2RlbCA9IG5ldyBNb2RlbChkYXRhLm5hbWUpO1xuICAgIG1vZGVsLnZlcnRpY2VzID0gZGF0YS52ZXJ0aWNlcy5tYXAoKHY6IFJlY29yZDxzdHJpbmcsIGFueT4pID0+XG4gICAgICBWZXJ0ZXguZGVzZXJpYWxpemUodilcbiAgICApO1xuICAgIGNvbnN0IHZlcnRpY2VzTWFwID0gbW9kZWwudmVydGljZXMucmVkdWNlKChtYXAsIHYpID0+IHtcbiAgICAgIG1hcC5zZXQodi5pZCwgdik7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sIG5ldyBNYXA8c3RyaW5nLCBWZXJ0ZXg+KCkpO1xuICAgIG1vZGVsLmVkZ2VzID0gZGF0YS5lZGdlcy5tYXAoKGU6IFJlY29yZDxzdHJpbmcsIGFueT4pID0+XG4gICAgICBFZGdlLmRlc2VyaWFsaXplKGUsIHZlcnRpY2VzTWFwKVxuICAgICk7XG4gICAgbW9kZWwuc3VyZmFjZXMgPSBkYXRhLnN1cmZhY2VzLm1hcCgoczogUmVjb3JkPHN0cmluZywgYW55PikgPT5cbiAgICAgIFN1cmZhY2UuZGVzZXJpYWxpemUocywgdmVydGljZXNNYXApXG4gICAgKTtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICBwdWJsaWMgZW1pdENoYW5nZUV2ZW50KGFjdGlvbjogc3RyaW5nID0gJycpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ3VzdG9tRXZlbnQoJ2NoYW5nZScsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgbW9kZWw6IHRoaXMuc2VyaWFsaXplKCksXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFkZFZlcnRleChwb3NpdGlvbjogdmVjMyk6IFZlcnRleCB7XG4gICAgY29uc3QgdmVydGV4ID0gbmV3IFZlcnRleChwb3NpdGlvbiwgZmFsc2UpO1xuICAgIHRoaXMudmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xuXG4gICAgLy8gVGhlIG1vZGVsIGhhcyBjaGFuZ2VkLCBzbyB3ZSBlbWl0IGEgY2hhbmdlIGV2ZW50XG4gICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoJ1ZlcnRleCBhZGRlZCcpO1xuICAgIHJldHVybiB2ZXJ0ZXg7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlVmVydGV4KHZlcnRleDogVmVydGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnZlcnRpY2VzLmluZGV4T2YodmVydGV4KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnZlcnRpY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB2ZXJ0ZXguZGVzdHJveSgpO1xuXG4gICAgICAvLyBSZW1vdmUgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgdmVydGV4XG4gICAgICB0aGlzLmVkZ2VzID0gdGhpcy5lZGdlcy5maWx0ZXIoZSA9PiBlLmEgIT09IHZlcnRleCAmJiBlLmIgIT09IHZlcnRleCk7XG5cbiAgICAgIC8vIFJlbW92ZSBzdXJmYWNlcyB0aGF0IGNvbnRhaW4gdGhpcyB2ZXJ0ZXhcbiAgICAgIHRoaXMuc3VyZmFjZXMgPSB0aGlzLnN1cmZhY2VzLmZpbHRlcihzID0+ICFzLnZlcnRpY2VzLmluY2x1ZGVzKHZlcnRleCkpO1xuXG4gICAgICAvLyBUaGUgbW9kZWwgaGFzIGNoYW5nZWQsIHNvIHdlIGVtaXQgYSBjaGFuZ2UgZXZlbnRcbiAgICAgIHRoaXMuZW1pdENoYW5nZUV2ZW50KCdWZXJ0ZXggcmVtb3ZlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhZGRFZGdlKGVkZ2U6IEVkZ2UpOiBFZGdlO1xuICBwdWJsaWMgYWRkRWRnZShhOiBWZXJ0ZXgsIGI6IFZlcnRleCk6IEVkZ2U7XG4gIHB1YmxpYyBhZGRFZGdlKGE6IFZlcnRleCB8IEVkZ2UsIGI/OiBWZXJ0ZXgpOiBFZGdlIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgRWRnZSkpIHtcbiAgICAgIGEgPSBuZXcgRWRnZShhLCBiISk7XG4gICAgfVxuICAgIHRoaXMuZWRnZXMucHVzaChhKTtcblxuICAgIC8vIFRoZSBtb2RlbCBoYXMgY2hhbmdlZCwgc28gd2UgZW1pdCBhIGNoYW5nZSBldmVudFxuICAgIHRoaXMuZW1pdENoYW5nZUV2ZW50KCdFZGdlIGFkZGVkJyk7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlRWRnZShlZGdlOiBFZGdlKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgZWRnZS5kZXN0cm95KCk7XG5cbiAgICAgIC8vIFRoZSBtb2RlbCBoYXMgY2hhbmdlZCwgc28gd2UgZW1pdCBhIGNoYW5nZSBldmVudFxuICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoJ0VkZ2UgcmVtb3ZlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhZGRTdXJmYWNlKHN1cmZhY2U6IFN1cmZhY2UpOiBTdXJmYWNlO1xuICBwdWJsaWMgYWRkU3VyZmFjZSh2ZXJ0aWNlczogVmVydGV4W10pOiBTdXJmYWNlO1xuICBwdWJsaWMgYWRkU3VyZmFjZShhOiBTdXJmYWNlIHwgVmVydGV4W10pOiBTdXJmYWNlIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgU3VyZmFjZSkpIHtcbiAgICAgIGEgPSBuZXcgU3VyZmFjZShhKTtcbiAgICB9XG4gICAgdGhpcy5zdXJmYWNlcy5wdXNoKGEpO1xuXG4gICAgLy8gVGhlIG1vZGVsIGhhcyBjaGFuZ2VkLCBzbyB3ZSBlbWl0IGEgY2hhbmdlIGV2ZW50XG4gICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoJ1N1cmZhY2UgYWRkZWQnKTtcbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVTdXJmYWNlKHN1cmZhY2U6IFN1cmZhY2UpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3VyZmFjZXMuaW5kZXhPZihzdXJmYWNlKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnN1cmZhY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBzdXJmYWNlLmRlc3Ryb3koKTtcblxuICAgICAgLy8gVGhlIG1vZGVsIGhhcyBjaGFuZ2VkLCBzbyB3ZSBlbWl0IGEgY2hhbmdlIGV2ZW50XG4gICAgICB0aGlzLmVtaXRDaGFuZ2VFdmVudCgnU3VyZmFjZSByZW1vdmVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyKSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKHYgPT4gdi51cGRhdGUoZHQpKTtcbiAgICB0aGlzLmVkZ2VzLmZvckVhY2goZSA9PiBlLnVwZGF0ZShkdCkpO1xuICAgIHRoaXMuc3VyZmFjZXMuZm9yRWFjaChzID0+IHMudXBkYXRlKGR0KSk7XG4gIH1cblxuICBwdWJsaWMgZHJhd1RvcChjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHNob3dWZXJ0ZXhMYWJlbHMgPSBmYWxzZSkge1xuICAgIHRoaXMudmVydGljZXMuZm9yRWFjaCh2ID0+IHYuZHJhdzJkKGNvbnRleHQsICd4eicsIHNob3dWZXJ0ZXhMYWJlbHMpKTtcbiAgICB0aGlzLmVkZ2VzLmZvckVhY2goZSA9PiBlLmRyYXcyZChjb250ZXh0LCAneHonKSk7XG4gICAgdGhpcy5zdXJmYWNlcy5mb3JFYWNoKHMgPT4gcy5kcmF3MmQoY29udGV4dCwgJ3h6JykpO1xuICB9XG5cbiAgcHVibGljIGRyYXdGcm9udChcbiAgICBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgc2hvd1ZlcnRleExhYmVscyA9IGZhbHNlXG4gICkge1xuICAgIHRoaXMudmVydGljZXMuZm9yRWFjaCh2ID0+IHYuZHJhdzJkKGNvbnRleHQsICd4WScsIHNob3dWZXJ0ZXhMYWJlbHMpKTtcbiAgICB0aGlzLmVkZ2VzLmZvckVhY2goZSA9PiBlLmRyYXcyZChjb250ZXh0LCAneFknKSk7XG4gICAgdGhpcy5zdXJmYWNlcy5mb3JFYWNoKHMgPT4gcy5kcmF3MmQoY29udGV4dCwgJ3hZJykpO1xuICB9XG5cbiAgcHVibGljIGRyYXdTaWRlKGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgc2hvd1ZlcnRleExhYmVscyA9IGZhbHNlKSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKHYgPT4gdi5kcmF3MmQoY29udGV4dCwgJ1pZJywgc2hvd1ZlcnRleExhYmVscykpO1xuICAgIHRoaXMuZWRnZXMuZm9yRWFjaChlID0+IGUuZHJhdzJkKGNvbnRleHQsICdaWScpKTtcbiAgICB0aGlzLnN1cmZhY2VzLmZvckVhY2gocyA9PiBzLmRyYXcyZChjb250ZXh0LCAnWlknKSk7XG4gIH1cblxuICBwdWJsaWMgZHJhdzNkKFxuICAgIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgICBjYW1lcmE6IENhbWVyYTNkLFxuICAgIHNjcmVlbjogdmVjMixcbiAgICBzaG93VmVydGV4TGFiZWxzID0gZmFsc2VcbiAgKSB7XG4gICAgdGhpcy52ZXJ0aWNlcy5mb3JFYWNoKHYgPT5cbiAgICAgIHYuZHJhdzNkKGNvbnRleHQsIGNhbWVyYSwgc2NyZWVuLCBzaG93VmVydGV4TGFiZWxzKVxuICAgICk7XG4gICAgdGhpcy5lZGdlcy5mb3JFYWNoKGUgPT4gZS5kcmF3M2QoY29udGV4dCwgY2FtZXJhLCBzY3JlZW4pKTtcbiAgICB0aGlzLnN1cmZhY2VzLmZvckVhY2gocyA9PiBzLmRyYXczZChjb250ZXh0LCBjYW1lcmEsIHNjcmVlbikpO1xuICB9XG59XG4iLCJpbXBvcnQgQ2FtZXJhM2QgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhLTNkJztcbmltcG9ydCB7IHBvbHlnb24gfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycyc7XG5pbXBvcnQgeyBpbnRlcnNlY3Rpb24yZCB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2ludGVyc2VjdGlvbi1oZWxwZXJzJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IHsgdjQgYXMgdXVpZCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IE1vZGVsRWRpdG9yIGZyb20gJy4vbW9kZWwtZWRpdG9yJztcbmltcG9ydCB7IHYzMiB9IGZyb20gJy4vdXRpbGl0aWVzJztcbmltcG9ydCBWZXJ0ZXggZnJvbSAnLi92ZXJ0ZXgnO1xuXG5jb25zdCB7IHBvaW50SW5Qb2x5Z29uIH0gPSBpbnRlcnNlY3Rpb24yZDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3VyZmFjZSB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENPTE9VUiA9ICcjZmZmMic7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEhPVkVSX0NPTE9VUiA9ICcjZmZmNCc7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEhPVkVSX1BBVFRFUk5fU0laRSA9IDY7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNFTEVDVF9DT0xPVVIgPSAnI2ZmZjYnO1xuXG4gIHB1YmxpYyBpZDogc3RyaW5nID0gJyc7XG4gIHB1YmxpYyBob3ZlcmVkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBzZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgZm9sZGVyOiBkYXQuR1VJIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgaG92ZXJQYXR0ZXJuQ2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN0YXRpYyBob3ZlclBhdHRlcm5Db250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmVydGljZXM6IFZlcnRleFtdLCBhZGRGb2xkZXI6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgdGhpcy5pZCA9IHV1aWQoKTtcblxuICAgIGlmIChNb2RlbEVkaXRvci5zdXJmYWNlc0ZvbGRlciAmJiBhZGRGb2xkZXIpIHtcbiAgICAgIHRoaXMuZm9sZGVyID0gTW9kZWxFZGl0b3Iuc3VyZmFjZXNGb2xkZXIuYWRkRm9sZGVyKGBTdXJmYWNlICR7dGhpcy5pZH1gKTtcbiAgICAgIHRoaXMuZm9sZGVyLmFkZChcbiAgICAgICAgeyBzZWxlY3Q6ICgpID0+IE1vZGVsRWRpdG9yLmluc3RhbmNlPy5zZWxlY3RTdXJmYWNlKHRoaXMsIGZhbHNlKSB9LFxuICAgICAgICAnc2VsZWN0J1xuICAgICAgKTtcbiAgICAgIHRoaXMuZm9sZGVyLmFkZChcbiAgICAgICAgeyBkZWxldGU6ICgpID0+IE1vZGVsRWRpdG9yLmluc3RhbmNlPy5yZW1vdmVTdXJmYWNlKHRoaXMpIH0sXG4gICAgICAgICdkZWxldGUnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgaG92ZXIgcGF0dGVybiBjYW52YXMgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmICghU3VyZmFjZS5ob3ZlclBhdHRlcm5DYW52YXMpIHtcbiAgICAgIFN1cmZhY2UuaG92ZXJQYXR0ZXJuQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBTdXJmYWNlLmhvdmVyUGF0dGVybkNhbnZhcy53aWR0aCA9IFN1cmZhY2UuSE9WRVJfUEFUVEVSTl9TSVpFO1xuICAgICAgU3VyZmFjZS5ob3ZlclBhdHRlcm5DYW52YXMuaGVpZ2h0ID0gU3VyZmFjZS5IT1ZFUl9QQVRURVJOX1NJWkU7XG4gICAgICBTdXJmYWNlLmhvdmVyUGF0dGVybkNvbnRleHQgPSBTdXJmYWNlLmhvdmVyUGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKFN1cmZhY2UuaG92ZXJQYXR0ZXJuQ29udGV4dCkge1xuICAgICAgICBjb25zdCBoYWxmSG92ZXJQYXR0ZXJuU2l6ZSA9IFN1cmZhY2UuSE9WRVJfUEFUVEVSTl9TSVpFIC8gMjtcbiAgICAgICAgU3VyZmFjZS5ob3ZlclBhdHRlcm5Db250ZXh0LmZpbGxTdHlsZSA9IFN1cmZhY2UuSE9WRVJfQ09MT1VSO1xuICAgICAgICBTdXJmYWNlLmhvdmVyUGF0dGVybkNvbnRleHQuZmlsbFJlY3QoXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGhhbGZIb3ZlclBhdHRlcm5TaXplLFxuICAgICAgICAgIGhhbGZIb3ZlclBhdHRlcm5TaXplXG4gICAgICAgICk7XG4gICAgICAgIFN1cmZhY2UuaG92ZXJQYXR0ZXJuQ29udGV4dC5maWxsUmVjdChcbiAgICAgICAgICBoYWxmSG92ZXJQYXR0ZXJuU2l6ZSxcbiAgICAgICAgICBoYWxmSG92ZXJQYXR0ZXJuU2l6ZSxcbiAgICAgICAgICBoYWxmSG92ZXJQYXR0ZXJuU2l6ZSxcbiAgICAgICAgICBoYWxmSG92ZXJQYXR0ZXJuU2l6ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmZvbGRlcikge1xuICAgICAgTW9kZWxFZGl0b3Iuc3VyZmFjZXNGb2xkZXI/LnJlbW92ZUZvbGRlcih0aGlzLmZvbGRlcik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNlcmlhbGl6ZSgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICB2ZXJ0aWNlczogdGhpcy52ZXJ0aWNlcy5tYXAodiA9PiB2LmlkKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkZXNlcmlhbGl6ZShcbiAgICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIHZlcnRpY2VzOiBNYXA8c3RyaW5nLCBWZXJ0ZXg+XG4gICk6IFN1cmZhY2Uge1xuICAgIGNvbnN0IHN1cmZhY2VWZXJ0aWNlcyA9IGRhdGEudmVydGljZXMubWFwKChpZDogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCB2ZXJ0ZXggPSB2ZXJ0aWNlcy5nZXQoaWQpO1xuICAgICAgaWYgKCF2ZXJ0ZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBTdXJmYWNlICR7ZGF0YS5pZH0gcmVmZXJlbmNlcyBub24tZXhpc3RlbnQgdmVydGV4ICR7aWR9LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2ZXJ0ZXg7XG4gICAgfSk7XG5cbiAgICBjb25zdCBzdXJmYWNlID0gbmV3IFN1cmZhY2Uoc3VyZmFjZVZlcnRpY2VzKTtcbiAgICBpZiAoZGF0YS5pZCkge1xuICAgICAgc3VyZmFjZS5pZCA9IGRhdGEuaWQ7XG4gICAgfVxuICAgIHJldHVybiBzdXJmYWNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyKSB7fVxuXG4gIHB1YmxpYyBkcmF3MmQoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjb21wb25lbnRzOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5ob3ZlcmVkICYmICF0aGlzLnNlbGVjdGVkICYmIFN1cmZhY2UuaG92ZXJQYXR0ZXJuQ2FudmFzKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgcG9seWdvbihcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5tYXAodiA9PiB2MzIodi5wb3NpdGlvbiwgY29tcG9uZW50cykpLFxuICAgICAgICB7XG4gICAgICAgICAgYmF0Y2g6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihcbiAgICAgICAgU3VyZmFjZS5ob3ZlclBhdHRlcm5DYW52YXMsXG4gICAgICAgICdyZXBlYXQnXG4gICAgICApITtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2x5Z29uKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICB0aGlzLnZlcnRpY2VzLm1hcCh2ID0+IHYzMih2LnBvc2l0aW9uLCBjb21wb25lbnRzKSksXG4gICAgICAgIHtcbiAgICAgICAgICBzdHJva2U6IGZhbHNlLFxuICAgICAgICAgIGZpbGw6IHRydWUsXG4gICAgICAgICAgZmlsbENvbG9yOiB0aGlzLnNlbGVjdGVkID8gU3VyZmFjZS5TRUxFQ1RfQ09MT1VSIDogU3VyZmFjZS5DT0xPVVIsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRyYXczZChcbiAgICBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgY2FtZXJhOiBDYW1lcmEzZCxcbiAgICBzY3JlZW46IHZlYzJcbiAgKSB7XG4gICAgY29uc3QgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzXG4gICAgICAubWFwKHYgPT4gY2FtZXJhLnByb2plY3Qodi5wb3NpdGlvbiwgc2NyZWVuKSlcbiAgICAgIC5maWx0ZXIoKHYpOiB2IGlzIHZlYzIgPT4gISF2KTtcblxuICAgIGlmICh0aGlzLmhvdmVyZWQgJiYgIXRoaXMuc2VsZWN0ZWQgJiYgU3VyZmFjZS5ob3ZlclBhdHRlcm5DYW52YXMpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBwb2x5Z29uKGNvbnRleHQsIHZlcnRpY2VzLCB7XG4gICAgICAgIGJhdGNoOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihcbiAgICAgICAgU3VyZmFjZS5ob3ZlclBhdHRlcm5DYW52YXMsXG4gICAgICAgICdyZXBlYXQnXG4gICAgICApITtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2x5Z29uKGNvbnRleHQsIHZlcnRpY2VzLCB7XG4gICAgICAgIHN0cm9rZTogZmFsc2UsXG4gICAgICAgIGZpbGw6IHRydWUsXG4gICAgICAgIGZpbGxDb2xvcjogdGhpcy5zZWxlY3RlZCA/IFN1cmZhY2UuU0VMRUNUX0NPTE9VUiA6IFN1cmZhY2UuQ09MT1VSLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGlzUG9pbnROZWFyMmQocG9pbnQ6IHZlYzIsIGNvbXBvbmVudHM6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBwb2ludEluUG9seWdvbihwb2ludCwge1xuICAgICAgICB2ZXJ0aWNlczogdGhpcy52ZXJ0aWNlcy5tYXAodiA9PiB2MzIodi5wb3NpdGlvbiwgY29tcG9uZW50cykpLFxuICAgICAgfSk/LmludGVyc2VjdHMgfHwgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGlzUG9pbnROZWFyM2QocG9pbnQ6IHZlYzIsIGNhbWVyYTogQ2FtZXJhM2QsIHNjcmVlbjogdmVjMik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHByb2plY3RlZFZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlc1xuICAgICAgLm1hcCh2ID0+IGNhbWVyYS5wcm9qZWN0KHYucG9zaXRpb24sIHNjcmVlbikpXG4gICAgICAuZmlsdGVyKCh2KTogdiBpcyB2ZWMyID0+ICEhdik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgcG9pbnRJblBvbHlnb24ocG9pbnQsIHtcbiAgICAgICAgdmVydGljZXM6IHByb2plY3RlZFZlcnRpY2VzLFxuICAgICAgfSk/LmludGVyc2VjdHMgfHwgZmFsc2VcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjaXJjbGUgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycyc7XG5pbXBvcnQgeyBpbnRlcnNlY3Rpb24yZCB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2ludGVyc2VjdGlvbi1oZWxwZXJzJztcbmltcG9ydCB7IHZlYzIsIHZlYzMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuXG50eXBlIExpbmUgPSBpbnRlcnNlY3Rpb24yZC5MaW5lO1xudHlwZSBQb2ludCA9IGludGVyc2VjdGlvbjJkLlBvaW50O1xuXG5leHBvcnQgZnVuY3Rpb24gdjMyKHY6IHZlYzMsIGNvbXBvbmVudHM6IHN0cmluZyk6IHZlYzIge1xuICByZXR1cm4gdmVjMi5mcm9tQ29tcG9uZW50cyh2ZWMzLnN3aXoodiwgY29tcG9uZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnROZWFyTGluZShcbiAgcG9pbnQ6IFBvaW50LFxuICBsaW5lOiBMaW5lLFxuICByYW5nZTogbnVtYmVyID0gNVxuKTogYm9vbGVhbiB7XG4gIHJldHVybiBpbnRlcnNlY3Rpb24yZC5wb2ludE9uTGluZShwb2ludCwgbGluZSkuZGlzdGFuY2UgPD0gcmFuZ2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoXG4gIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcG9zaXRpb246IHZlYzIsXG4gIHJhZGl1czogbnVtYmVyID0gNSxcbiAgY29sb3VyOiBzdHJpbmcgPSAnI2ZmZidcbikge1xuICBjaXJjbGUoY29udGV4dCwgcG9zaXRpb24sIHJhZGl1cywge1xuICAgIGZpbGw6IHRydWUsXG4gICAgZmlsbENvbG9yOiBjb2xvdXIsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0c0VxdWFsKGE6IFNldDxzdHJpbmc+LCBiOiBTZXQ8c3RyaW5nPik6IGJvb2xlYW4ge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQgQ2FtZXJhM2QgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhLTNkJztcbmltcG9ydCB7IGNpcmNsZSB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NhbnZhcy1oZWxwZXJzJztcbmltcG9ydCBEZWJ1ZywgeyBEZWJ1Z01hcmtlciB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnJztcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMnO1xuaW1wb3J0IHsgdmVjMiwgdmVjMyB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3ZlYyc7XG5pbXBvcnQgeyB2NCBhcyB1dWlkIH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgTW9kZWxFZGl0b3IgZnJvbSAnLi9tb2RlbC1lZGl0b3InO1xuaW1wb3J0IHsgZG90LCB2MzIgfSBmcm9tICcuL3V0aWxpdGllcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRleCB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENPTE9VUiA9ICcjZmZmJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgSElEREVOX0NPTE9VUiA9ICcjZmZmNic7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFJBRElVUyA9IDM7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEhPVkVSX1JBRElVUyA9IDEwO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBIT1ZFUl9MSU5FX1dJRFRIID0gMjtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTUFSS0VSX09QVElPTlM6IFBhcnRpYWw8RGVidWdNYXJrZXI+ID0ge1xuICAgIHNob3dNYXJrZXI6IGZhbHNlLFxuICAgIHNob3dMYWJlbDogZmFsc2UsXG4gICAgYmFja2dyb3VuZENvbG91cjogJyNmZmYyJyxcbiAgfTtcblxuICBwdWJsaWMgaWQ6IHN0cmluZyA9ICcnO1xuICBwdWJsaWMgaG92ZXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgc2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIGZvbGRlcjogZGF0LkdVSSB8IG51bGwgPSBudWxsO1xuXG4gIC8vIFdlIGtlZXAgYW4gaW50ZXJuYWwgcG9zaXRpb24gc28gd2UgaGF2ZSBhIGNvbnNpc3RlbnQgb2JqZWN0IHJlZmVyZW5jZVxuICAvLyBmb3IgZGlzcGxheWluZyBpbiBkYXQuR1VJIChvdGhlcndpc2UsIGlmL3doZW4gdGhlIHBvc2l0aW9uIG9iamVjdCBpc1xuICAvLyByZXBsYWNlZCwgdGhlIEdVSSBsaXN0ZW5lciB3aWxsIHN0b3Agd29ya2luZylcbiAgcHJpdmF0ZSByZWFkb25seSBpbnRlcm5hbFBvc2l0aW9uOiB2ZWMzID0gdmVjMygpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBwb3NpdGlvbjogdmVjMyxcbiAgICBwdWJsaWMgaGlkZGVuOiBib29sZWFuID0gZmFsc2UsXG4gICAgYWRkRm9sZGVyOiBib29sZWFuID0gdHJ1ZVxuICApIHtcbiAgICB0aGlzLmlkID0gdXVpZCgpO1xuXG4gICAgaWYgKE1vZGVsRWRpdG9yLnZlcnRpY2VzRm9sZGVyICYmIGFkZEZvbGRlcikge1xuICAgICAgdGhpcy5mb2xkZXIgPSBNb2RlbEVkaXRvci52ZXJ0aWNlc0ZvbGRlci5hZGRGb2xkZXIoYFZlcnRleCAke3RoaXMuaWR9YCk7XG4gICAgICB0aGlzLmZvbGRlci5hZGQoXG4gICAgICAgIHsgc2VsZWN0OiAoKSA9PiBNb2RlbEVkaXRvci5pbnN0YW5jZT8uc2VsZWN0VmVydGV4KHRoaXMsIGZhbHNlKSB9LFxuICAgICAgICAnc2VsZWN0J1xuICAgICAgKTtcbiAgICAgIHRoaXMuZm9sZGVyLmFkZChcbiAgICAgICAgeyBkZWxldGU6ICgpID0+IE1vZGVsRWRpdG9yLmluc3RhbmNlPy5yZW1vdmVWZXJ0ZXgodGhpcykgfSxcbiAgICAgICAgJ2RlbGV0ZSdcbiAgICAgICk7XG4gICAgICB0aGlzLmZvbGRlclxuICAgICAgICAuYWRkKHRoaXMuaW50ZXJuYWxQb3NpdGlvbiwgJ3gnKVxuICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAubGlzdGVuKCk7XG4gICAgICB0aGlzLmZvbGRlclxuICAgICAgICAuYWRkKHRoaXMuaW50ZXJuYWxQb3NpdGlvbiwgJ3knKVxuICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAubGlzdGVuKCk7XG4gICAgICB0aGlzLmZvbGRlclxuICAgICAgICAuYWRkKHRoaXMuaW50ZXJuYWxQb3NpdGlvbiwgJ3onKVxuICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgIHRoaXMucG9zaXRpb24ueiA9IHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAubGlzdGVuKCk7XG4gICAgICB0aGlzLmZvbGRlclxuICAgICAgICAuYWRkKHRoaXMsICdoaWRkZW4nKVxuICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgIHRoaXMuaGlkZGVuID0gdmFsdWU7XG4gICAgICAgICAgTW9kZWxFZGl0b3IuaW5zdGFuY2U/Lm1vZGVsPy5lbWl0Q2hhbmdlRXZlbnQoXG4gICAgICAgICAgICAnVmVydGV4IHZpc2liaWxpdHkgY2hhbmdlZCdcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgICAubGlzdGVuKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZm9sZGVyKSB7XG4gICAgICBNb2RlbEVkaXRvci52ZXJ0aWNlc0ZvbGRlcj8ucmVtb3ZlRm9sZGVyKHRoaXMuZm9sZGVyKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2VyaWFsaXplKCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHBvc2l0aW9uOiB2ZWMzLmNvbXBvbmVudHModGhpcy5wb3NpdGlvbiksXG4gICAgICBoaWRkZW46IHRoaXMuaGlkZGVuLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGRlc2VyaWFsaXplKGRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBWZXJ0ZXgge1xuICAgIGNvbnN0IHZlcnRleCA9IG5ldyBWZXJ0ZXgoXG4gICAgICB2ZWMzLmZyb21Db21wb25lbnRzKGRhdGEucG9zaXRpb24pLFxuICAgICAgISFkYXRhLmhpZGRlblxuICAgICk7XG4gICAgaWYgKGRhdGEuaWQpIHtcbiAgICAgIHZlcnRleC5pZCA9IGRhdGEuaWQ7XG4gICAgfVxuICAgIHJldHVybiB2ZXJ0ZXg7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGR0OiBudW1iZXIpIHtcbiAgICBpZiAoIXZlYzMuZXEodGhpcy5pbnRlcm5hbFBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uKSkge1xuICAgICAgdGhpcy5pbnRlcm5hbFBvc2l0aW9uLnggPSB0aGlzLnBvc2l0aW9uLng7XG4gICAgICB0aGlzLmludGVybmFsUG9zaXRpb24ueSA9IHRoaXMucG9zaXRpb24ueTtcbiAgICAgIHRoaXMuaW50ZXJuYWxQb3NpdGlvbi56ID0gdGhpcy5wb3NpdGlvbi56O1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkcmF3MmQoXG4gICAgY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICAgIGNvbXBvbmVudHM6IHN0cmluZyxcbiAgICBzaG93VmVydGV4TGFiZWxzID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgcDIgPSB2MzIodGhpcy5wb3NpdGlvbiwgY29tcG9uZW50cyk7XG4gICAgZG90KFxuICAgICAgY29udGV4dCxcbiAgICAgIHAyLFxuICAgICAgVmVydGV4LlJBRElVUyxcbiAgICAgIHRoaXMuaGlkZGVuID8gVmVydGV4LkhJRERFTl9DT0xPVVIgOiBWZXJ0ZXguQ09MT1VSXG4gICAgKTtcblxuICAgIGlmIChzaG93VmVydGV4TGFiZWxzKSB7XG4gICAgICBjb25zdCB0YWdzID0geyB4ejogJ3BhbmVsLXRvcCcsIHhZOiAncGFuZWwtZnJvbnQnLCBaWTogJ3BhbmVsLXNpZGUnIH07XG4gICAgICBEZWJ1Zy5tYXJrZXIoXG4gICAgICAgIGAke3RoaXMuaWR9LSR7Y29tcG9uZW50c31gLFxuICAgICAgICB0aGlzLmhvdmVyZWQgfHwgdGhpcy5zZWxlY3RlZFxuICAgICAgICAgID8gYCR7dGhpcy5pZH1cXG4ke3ZlYzMuc3RyKHZlYzMubWFwKHRoaXMucG9zaXRpb24sIHYgPT4gcm91bmQodiwgMikpKX1gXG4gICAgICAgICAgOiB0aGlzLmlkLnN1YnN0cmluZygwLCA1KSxcbiAgICAgICAgcDIsXG4gICAgICAgIHtcbiAgICAgICAgICB0YWdzOiBbdGFnc1tjb21wb25lbnRzIGFzIGtleW9mIHR5cGVvZiB0YWdzXV0sXG4gICAgICAgICAgLi4uVmVydGV4Lk1BUktFUl9PUFRJT05TLFxuICAgICAgICAgIGZvcmVncm91bmRDb2xvdXI6IHRoaXMuaGlkZGVuID8gVmVydGV4LkhJRERFTl9DT0xPVVIgOiBWZXJ0ZXguQ09MT1VSLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhvdmVyZWQgfHwgdGhpcy5zZWxlY3RlZCkge1xuICAgICAgY2lyY2xlKGNvbnRleHQsIHAyLCBWZXJ0ZXguSE9WRVJfUkFESVVTLCB7XG4gICAgICAgIHN0cm9rZUNvbG9yOiBWZXJ0ZXguQ09MT1VSLFxuICAgICAgICBsaW5lV2lkdGg6IFZlcnRleC5IT1ZFUl9MSU5FX1dJRFRILFxuICAgICAgICBsaW5lU3R5bGU6IHRoaXMuc2VsZWN0ZWQgPyAnc29saWQnIDogJ2Rhc2hlZCcsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZHJhdzNkKFxuICAgIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgICBjYW1lcmE6IENhbWVyYTNkLFxuICAgIHNjcmVlbjogdmVjMixcbiAgICBzaG93VmVydGV4TGFiZWxzID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgcHJvamVjdGVkID0gY2FtZXJhLnByb2plY3QodGhpcy5wb3NpdGlvbiwgc2NyZWVuKTtcblxuICAgIGlmICghcHJvamVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG90KFxuICAgICAgY29udGV4dCxcbiAgICAgIHByb2plY3RlZCxcbiAgICAgIFZlcnRleC5SQURJVVMsXG4gICAgICB0aGlzLmhpZGRlbiA/IFZlcnRleC5ISURERU5fQ09MT1VSIDogVmVydGV4LkNPTE9VUlxuICAgICk7XG5cbiAgICBpZiAoc2hvd1ZlcnRleExhYmVscykge1xuICAgICAgRGVidWcubWFya2VyKFxuICAgICAgICBgJHt0aGlzLmlkfS0zZGAsXG4gICAgICAgIHRoaXMuaG92ZXJlZCB8fCB0aGlzLnNlbGVjdGVkXG4gICAgICAgICAgPyBgJHt0aGlzLmlkfVxcbiR7dmVjMy5zdHIodmVjMy5tYXAodGhpcy5wb3NpdGlvbiwgdiA9PiByb3VuZCh2LCAyKSkpfWBcbiAgICAgICAgICA6IHRoaXMuaWQuc3Vic3RyaW5nKDAsIDUpLFxuICAgICAgICBwcm9qZWN0ZWQsXG4gICAgICAgIHtcbiAgICAgICAgICB0YWdzOiBbJ3BhbmVsLTNkJ10sXG4gICAgICAgICAgLi4uVmVydGV4Lk1BUktFUl9PUFRJT05TLFxuICAgICAgICAgIGZvcmVncm91bmRDb2xvdXI6IHRoaXMuaGlkZGVuID8gVmVydGV4LkhJRERFTl9DT0xPVVIgOiBWZXJ0ZXguQ09MT1VSLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhvdmVyZWQgfHwgdGhpcy5zZWxlY3RlZCkge1xuICAgICAgY2lyY2xlKGNvbnRleHQsIHByb2plY3RlZCwgVmVydGV4LkhPVkVSX1JBRElVUywge1xuICAgICAgICBzdHJva2VDb2xvcjogVmVydGV4LkNPTE9VUixcbiAgICAgICAgbGluZVdpZHRoOiBWZXJ0ZXguSE9WRVJfTElORV9XSURUSCxcbiAgICAgICAgbGluZVN0eWxlOiB0aGlzLnNlbGVjdGVkID8gJ3NvbGlkJyA6ICdkYXNoZWQnLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGlzUG9pbnROZWFyMmQoXG4gICAgcG9pbnQ6IHZlYzIsXG4gICAgY29tcG9uZW50czogc3RyaW5nLFxuICAgIHJhZGl1czogbnVtYmVyID0gVmVydGV4LkhPVkVSX1JBRElVU1xuICApOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmVjMi5sZW4odmVjMi5zdWIocG9pbnQsIHYzMih0aGlzLnBvc2l0aW9uLCBjb21wb25lbnRzKSkpIDw9IHJhZGl1cztcbiAgfVxuXG4gIHB1YmxpYyBpc1BvaW50TmVhcjNkKFxuICAgIHBvaW50OiB2ZWMyLFxuICAgIGNhbWVyYTogQ2FtZXJhM2QsXG4gICAgc2NyZWVuOiB2ZWMyLFxuICAgIHJhZGl1czogbnVtYmVyID0gVmVydGV4LkhPVkVSX1JBRElVU1xuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBwcm9qZWN0ZWQgPSBjYW1lcmEucHJvamVjdCh0aGlzLnBvc2l0aW9uLCBzY3JlZW4pO1xuXG4gICAgaWYgKCFwcm9qZWN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVjMi5sZW4odmVjMi5zdWIocG9pbnQsIHByb2plY3RlZCkpIDw9IHJhZGl1cztcbiAgfVxufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgTW9kZWxFZGl0b3IgZnJvbSAnLi9tb2RlbC1lZGl0b3InO1xuXG53aW5kb3cub25sb2FkID0gKCkgPT4ge1xuICAod2luZG93IGFzIGFueSkuZWRpdG9yID0gbmV3IE1vZGVsRWRpdG9yKCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9